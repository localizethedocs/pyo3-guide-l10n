msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:42:12Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/migration.md:1
msgid "Migrating from older PyO3 versions"
msgstr "從舊版 PyO3 遷移"

#: src/migration.md:3
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see the [CHANGELOG]"
"(changelog.md)."
msgstr ""
"本指南可協助你跨越 PyO3 版本間的破壞性變更來升級程式碼。完整變更清單請見 "
"[CHANGELOG](changelog.md)。"

#: src/migration.md:6
msgid "from 0.18.\\* to 0.19"
msgstr ""

#: src/migration.md:8
msgid ""
"Access to `Python` inside `__traverse__` implementations are now forbidden"
msgstr ""

#: src/migration.md:10
msgid ""
"During `__traverse__` implementations for Python's Garbage Collection it is "
"forbidden to do anything other than visit the members of the `#[pyclass]` "
"being traversed. This means making Python function calls or other API calls "
"are forbidden."
msgstr ""

#: src/migration.md:12
msgid ""
"Previous versions of PyO3 would allow access to `Python` (e.g. via `Python::"
"with_gil`), which could cause the Python interpreter to crash or otherwise "
"confuse the garbage collection algorithm."
msgstr ""

#: src/migration.md:14
msgid ""
"Attempts to acquire the GIL will now panic. See [\\#3165](https://github.com/"
"PyO3/pyo3/issues/3165) for more detail."
msgstr ""

#: src/migration.md:24
msgid "/*...*/"
msgstr ""

#: src/migration.md:24
msgid "// ERROR: this will panic\n"
msgstr ""

#: src/migration.md:29
msgid ""
"Smarter `anyhow::Error` / `eyre::Report` conversion when inner error is "
"\"simple\" `PyErr`"
msgstr ""

#: src/migration.md:31
msgid ""
"When converting from `anyhow::Error` or `eyre::Report` to `PyErr`, if the "
"inner error is a \"simple\" `PyErr` (with no source error), then the inner "
"error will be used directly as the `PyErr` instead of wrapping it in a new "
"`PyRuntimeError` with the original information converted into a string."
msgstr ""

#: src/migration.md:34
msgid "\"anyhow\""
msgstr ""

#: src/migration.md:41
msgid "\"original error message\""
msgstr ""

#: src/migration.md:47
msgid ""
"r\"\n"
"        try:\n"
"            rs_func()\n"
"        except Exception as e:\n"
"            print(repr(e))\n"
"        \""
msgstr ""

#: src/migration.md:58
msgid ""
"Before, the above code would have printed `RuntimeError('ValueError: "
"original error message')`, which might be confusing."
msgstr ""

#: src/migration.md:60
msgid ""
"After, the same code will print `ValueError: original error message`, which "
"is more straightforward."
msgstr ""

#: src/migration.md:62
msgid ""
"However, if the `anyhow::Error` or `eyre::Report` has a source, then the "
"original exception will still be wrapped in a `PyRuntimeError`."
msgstr ""

#: src/migration.md:64
msgid ""
"The deprecated `Python::acquire_gil` was removed and `Python::with_gil` must "
"be used instead"
msgstr ""

#: src/migration.md:66
msgid ""
"While the API provided by [`Python::acquire_gil`](https://docs.rs/"
"pyo3/0.18.3/pyo3/marker/struct.Python.html#method.acquire_gil) seems "
"convenient, it is somewhat brittle as the design of the GIL token [`Python`]"
"(https://docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html) relies on "
"proper nesting and panics if not used correctly, e.g."
msgstr ""

#: src/migration.md:90
msgid "// Panics because the guard within `second` is still alive.\n"
msgstr ""

#: src/migration.md:96
msgid ""
"The replacement is [`Python::with_gil`]() which is more cumbersome but "
"enforces the proper nesting by design, e.g."
msgstr ""

#: src/migration.md:116
msgid "// It either forces us to release the GIL before aquiring it again.\n"
msgstr ""

#: src/migration.md:122
msgid "// Or it ensure releasing the inner lock before the outer one.\n"
msgstr ""

#: src/migration.md:134
msgid ""
"Furthermore, `Python::acquire_gil` provides ownership of a `GILGuard` which "
"can be freely stored and passed around. This is usually not helpful as it "
"may keep the lock held for a long time thereby blocking progress in other "
"parts of the program. Due to the generative lifetime attached to the GIL "
"token supplied by `Python::with_gil`, the problem is avoided as the GIL "
"token can only be passed down the call chain. Often, this issue can also be "
"avoided entirely as any GIL-bound reference `&'py PyAny` implies access to a "
"GIL token `Python<'py>` via the [`PyAny::py`](https://docs.rs/pyo3/latest/"
"pyo3/types/struct.PyAny.html#method.py) method."
msgstr ""

#: src/migration.md:136
msgid "from 0.17.\\* to 0.18"
msgstr ""

#: src/migration.md:138
msgid ""
"Required arguments after `Option<_>` arguments will no longer be "
"automatically inferred"
msgstr ""

#: src/migration.md:140
msgid ""
"In `#[pyfunction]` and `#[pymethods]`, if a \"required\" function input such "
"as `i32` came after an `Option<_>` input, then the `Option<_>` would be "
"implicitly treated as required. (All trailing `Option<_>` arguments were "
"treated as optional with a default value of `None`)."
msgstr ""

#: src/migration.md:142
msgid ""
"Starting with PyO3 0.18, this is deprecated and a future PyO3 version will "
"require a [`#[pyo3(signature = (...))]` option](./function/signature.md) to "
"explicitly declare the programmer's intention."
msgstr ""

#: src/migration.md:144
msgid ""
"Before, x in the below example would be required to be passed from Python "
"code:"
msgstr ""

#: src/migration.md:154
msgid "After, specify the intended Python signature explicitly:"
msgstr ""

#: src/migration.md:159
msgid "// If x really was intended to be required\n"
msgstr ""

#: src/migration.md:163
msgid "// If x was intended to be optional, y needs a default too\n"
msgstr ""

#: src/migration.md:169
msgid ""
"`__text_signature__` is now automatically generated for `#[pyfunction]` and "
"`#[pymethods]`"
msgstr ""

#: src/migration.md:171
msgid ""
"The [`#[pyo3(text_signature = \"...\")]` option](./function/signature."
"md#making-the-function-signature-available-to-python) was previously the "
"only supported way to set the `__text_signature__` attribute on generated "
"Python functions."
msgstr ""

#: src/migration.md:173
msgid ""
"PyO3 is now able to automatically populate `__text_signature__` for all "
"functions automatically based on their Rust signature (or the [new "
"`#[pyo3(signature = (...))]` option](./function/signature.md)). These "
"automatically-generated `__text_signature__` values will currently only "
"render `...` for all default values. Many `#[pyo3(text_signature = \"..."
"\")]` options can be removed from functions when updating to PyO3 0.18, "
"however in cases with default values a manual implementation may still be "
"preferred for now."
msgstr ""

#: src/migration.md:175
msgid "As examples:"
msgstr ""

#: src/migration.md:179
msgid ""
"// The `text_signature` option here is no longer necessary, as PyO3 will "
"automatically\n"
"// generate exactly the same value.\n"
msgstr ""

#: src/migration.md:182 src/migration.md:193
msgid "\"(a, b, c)\""
msgstr ""

#: src/migration.md:184
msgid ""
"// The `text_signature` still provides value here as of PyO3 0.18, because "
"the automatically\n"
"// generated signature would be \"(a, b=..., c=...)\".\n"
msgstr ""

#: src/migration.md:187 src/migration.md:195
msgid "\"(a, b=1, c=2)\""
msgstr ""

#: src/migration.md:193 src/migration.md:195
msgid "\"__text_signature__\""
msgstr ""

#: src/migration.md:200
msgid "from 0.16.\\* to 0.17"
msgstr ""

#: src/migration.md:202
msgid "Type checks have been changed for `PyMapping` and `PySequence` types"
msgstr ""

#: src/migration.md:204
msgid ""
"Previously the type checks for `PyMapping` and `PySequence` (implemented in "
"`PyTryFrom`) used the Python C-API functions `PyMapping_Check` and "
"`PySequence_Check`. Unfortunately these functions are not sufficient for "
"distinguishing such types, leading to inconsistent behavior (see [pyo3/"
"pyo3#2072](https://github.com/PyO3/pyo3/issues/2072))."
msgstr ""

#: src/migration.md:210
msgid ""
"PyO3 0.17 changes these downcast checks to explicitly test if the type is a "
"subclass of the corresponding abstract base class `collections.abc.Mapping` "
"or `collections.abc.Sequence`. Note this requires calling into Python, which "
"may incur a performance penalty over the previous method. If this "
"performance penalty is a problem, you may be able to perform your own checks "
"and use `try_from_unchecked` (unsafe)."
msgstr ""

#: src/migration.md:217
msgid ""
"Another side-effect is that a pyclass defined in Rust with PyO3 will need to "
"be _registered_ with the corresponding Python abstract base class for "
"downcasting to succeed. `PySequence::register` and `PyMapping:register` have "
"been added to make it easy to do this from Rust code. These are equivalent "
"to calling `collections.abc.Mapping.register(MappingPyClass)` or "
"`collections.abc.Sequence.register(SequencePyClass)` from Python."
msgstr ""

#: src/migration.md:224
msgid "For example, for a mapping class defined in Rust:"
msgstr ""

#: src/migration.md:238
msgid ""
"// ...\n"
"    // truncated implementation of this mapping pyclass - basically a "
"wrapper around a HashMap\n"
msgstr ""

#: src/migration.md:243
msgid ""
"You must register the class with `collections.abc.Mapping` before the "
"downcast will work:"
msgstr ""

#: src/migration.md:251
msgid ""
"Note that this requirement may go away in the future when a pyclass is able "
"to inherit from the abstract base class directly (see [pyo3/pyo3#991]"
"(https://github.com/PyO3/pyo3/issues/991))."
msgstr ""

#: src/migration.md:253
msgid "The `multiple-pymethods` feature now requires Rust 1.62"
msgstr ""

#: src/migration.md:255
msgid ""
"Due to limitations in the `inventory` crate which the `multiple-pymethods` "
"feature depends on, this feature now requires Rust 1.62. For more "
"information see [dtolnay/inventory#32](https://github.com/dtolnay/inventory/"
"issues/32)."
msgstr ""

#: src/migration.md:258
msgid "Added `impl IntoPy<Py<PyString>> for &str`"
msgstr ""

#: src/migration.md:260
msgid "This may cause inference errors."
msgstr ""

#: src/migration.md:262 src/migration.md:296 src/migration.md:343
#: src/migration.md:532 src/migration.md:617 src/migration.md:669
#: src/migration.md:695 src/migration.md:723 src/migration.md:758
#: src/migration.md:793 src/migration.md:819 src/migration.md:841
#: src/migration.md:871 src/migration.md:957 src/migration.md:984
#: src/migration.md:1019
msgid "Before:"
msgstr "之前："

#: src/migration.md:268
msgid "// Cannot infer either `Py<PyAny>` or `Py<PyString>`\n"
msgstr ""

#: src/migration.md:269 src/migration.md:281
msgid "\"test\""
msgstr ""

#: src/migration.md:274
msgid "After, some type annotations may be necessary:"
msgstr ""

#: src/migration.md:286
msgid "The `pyproto` feature is now disabled by default"
msgstr ""

#: src/migration.md:288
msgid ""
"In preparation for removing the deprecated `#[pyproto]` attribute macro in a "
"future PyO3 version, it is now gated behind an opt-in feature flag. This "
"also gives a slight saving to compile times for code which does not use the "
"deprecated macro."
msgstr ""

#: src/migration.md:290
msgid "`PyTypeObject` trait has been deprecated"
msgstr ""

#: src/migration.md:292
msgid ""
"The `PyTypeObject` trait already was near-useless; almost all functionality "
"was already on the `PyTypeInfo` trait, which `PyTypeObject` had a blanket "
"implementation based upon. In PyO3 0.17 the final method, `PyTypeObject::"
"type_object` was moved to `PyTypeInfo::type_object`."
msgstr ""

#: src/migration.md:294
msgid ""
"To migrate, update trait bounds and imports from `PyTypeObject` to "
"`PyTypeInfo`."
msgstr ""

#: src/migration.md:308 src/migration.md:368 src/migration.md:681
msgid "After"
msgstr ""

#: src/migration.md:321
msgid ""
"`impl<T, const N: usize> IntoPy<PyObject> for [T; N]` now requires `T: "
"IntoPy` rather than `T: ToPyObject`"
msgstr ""

#: src/migration.md:323
msgid ""
"If this leads to errors, simply implement `IntoPy`. Because pyclasses "
"already implement `IntoPy`, you probably don't need to worry about this."
msgstr ""

#: src/migration.md:325
msgid "Each `#[pymodule]` can now only be initialized once per process"
msgstr ""

#: src/migration.md:327
msgid ""
"To make PyO3 modules sound in the presence of Python sub-interpreters, for "
"now it has been necessary to explicitly disable the ability to initialize a "
"`#[pymodule]` more than once in the same process. Attempting to do this will "
"now raise an `ImportError`."
msgstr ""

#: src/migration.md:329
msgid "from 0.15.\\* to 0.16"
msgstr ""

#: src/migration.md:331
msgid "Drop support for older technologies"
msgstr ""

#: src/migration.md:333
msgid ""
"PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python "
"version to 3.7. This enables use of newer language features (enabling some "
"of the other additions in 0.16) and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:335
msgid "`#[pyproto]` has been deprecated"
msgstr ""

#: src/migration.md:337
msgid ""
"In PyO3 0.15, the `#[pymethods]` attribute macro gained support for "
"implementing \"magic methods\" such as `__str__` (aka \"dunder\" methods). "
"This implementation was not quite finalized at the time, with a few edge "
"cases to be decided upon. The existing `#[pyproto]` attribute macro was left "
"untouched, because it covered these edge cases."
msgstr ""

#: src/migration.md:339
msgid ""
"In PyO3 0.16, the `#[pymethods]` implementation has been completed and is "
"now the preferred way to implement magic methods. To allow the PyO3 project "
"to move forward, `#[pyproto]` has been deprecated (with expected removal in "
"PyO3 0.18)."
msgstr ""

#: src/migration.md:341
msgid ""
"Migration from `#[pyproto]` to `#[pymethods]` is straightforward; copying "
"the existing methods directly from the `#[pyproto]` trait implementation is "
"all that is needed in most cases."
msgstr ""

#: src/migration.md:356 src/migration.md:380 src/migration.md:544
#: src/migration.md:560
msgid "b\"hello, world\""
msgstr ""

#: src/migration.md:363 src/migration.md:384
msgid "\"hello, world\""
msgstr ""

#: src/migration.md:389
msgid "Removed `PartialEq` for object wrappers"
msgstr ""

#: src/migration.md:391
msgid ""
"The Python object wrappers `Py` and `PyAny` had implementations of "
"`PartialEq` so that `object_a == object_b` would compare the Python objects "
"for pointer equality, which corresponds to the `is` operator, not the `==` "
"operator in Python.  This has been removed in favor of a new method: use "
"`object_a.is(object_b)`.  This also has the advantage of not requiring the "
"same wrapper type for `object_a` and `object_b`; you can now directly "
"compare a `Py<T>` with a `&PyAny` without having to convert."
msgstr ""

#: src/migration.md:399
msgid ""
"To check for Python object equality (the Python `==` operator), use the new "
"method `eq()`."
msgstr ""

#: src/migration.md:402
msgid "Container magic methods now match Python behavior"
msgstr ""

#: src/migration.md:404
msgid ""
"In PyO3 0.15, `__getitem__`, `__setitem__` and `__delitem__` in "
"`#[pymethods]` would generate only the _mapping_ implementation for a "
"`#[pyclass]`. To match the Python behavior, these methods now generate both "
"the _mapping_ **and** _sequence_ implementations."
msgstr ""

#: src/migration.md:406
msgid ""
"This means that classes implementing these `#[pymethods]` will now also be "
"treated as sequences, same as a Python `class` would be. Small differences "
"in behavior may result:"
msgstr ""

#: src/migration.md:407
msgid ""
"PyO3 will allow instances of these classes to be cast to `PySequence` as "
"well as `PyMapping`."
msgstr ""

#: src/migration.md:408
msgid ""
"Python will provide a default implementation of `__iter__` (if the class did "
"not have one) which repeatedly calls `__getitem__` with integers (starting "
"at 0) until an `IndexError` is raised."
msgstr ""

#: src/migration.md:410
msgid "To explain this in detail, consider the following Python class:"
msgstr ""

#: src/migration.md:424
msgid ""
"This class implements a Python [sequence](https://docs.python.org/3/glossary."
"html#term-sequence)."
msgstr ""

#: src/migration.md:426
msgid ""
"The `__len__` and `__getitem__` methods are also used to implement a Python "
"[mapping](https://docs.python.org/3/glossary.html#term-mapping). In the "
"Python C-API, these methods are not shared: the sequence `__len__` and "
"`__getitem__` are defined by the `sq_length` and `sq_item` slots, and the "
"mapping equivalents are `mp_length` and `mp_subscript`. There are similar "
"distinctions for `__setitem__` and `__delitem__`."
msgstr ""

#: src/migration.md:428
msgid ""
"Because there is no such distinction from Python, implementing these methods "
"will fill the mapping and sequence slots simultaneously. A Python class with "
"`__len__` implemented, for example, will have both the `sq_length` and "
"`mp_length` slots filled."
msgstr ""

#: src/migration.md:430
msgid ""
"The PyO3 behavior in 0.16 has been changed to be closer to this Python "
"behavior by default."
msgstr ""

#: src/migration.md:432
msgid "`wrap_pymodule!` and `wrap_pyfunction!` now respect privacy correctly"
msgstr ""

#: src/migration.md:434
msgid ""
"Prior to PyO3 0.16 the `wrap_pymodule!` and `wrap_pyfunction!` macros could "
"use modules and functions whose defining `fn` was not reachable according "
"Rust privacy rules."
msgstr ""

#: src/migration.md:436
msgid ""
"For example, the following code was legal before 0.16, but in 0.16 is "
"rejected because the `wrap_pymodule!` macro cannot access the "
"`private_submodule` function:"
msgstr ""

#: src/migration.md:458
msgid ""
"To fix it, make the private submodule visible, e.g. with `pub` or "
"`pub(crate)`."
msgstr ""

#: src/migration.md:481
msgid "from 0.14.\\* to 0.15"
msgstr ""

#: src/migration.md:483
msgid "Changes in sequence indexing"
msgstr ""

#: src/migration.md:485
msgid ""
"For all types that take sequence indices (`PyList`, `PyTuple` and "
"`PySequence`), the API has been made consistent to only take `usize` "
"indices, for consistency with Rust's indexing conventions.  Negative "
"indices, which were only sporadically supported even in APIs that took "
"`isize`, now aren't supported anywhere."
msgstr ""

#: src/migration.md:491
msgid ""
"Further, the `get_item` methods now always return a `PyResult` instead of "
"panicking on invalid indices.  The `Index` trait has been implemented "
"instead, and provides the same panic behavior as on Rust vectors."
msgstr ""

#: src/migration.md:495
msgid ""
"Note that _slice_ indices (accepted by `PySequence::get_slice` and other) "
"still inherit the Python behavior of clamping the indices to the actual "
"length, and not panicking/returning an error on out of range indices."
msgstr ""

#: src/migration.md:499
msgid ""
"An additional advantage of using Rust's indexing conventions for these types "
"is that these types can now also support Rust's indexing operators as part "
"of a consistent API:"
msgstr ""

#: src/migration.md:508
msgid "\"[1, 2]\""
msgstr ""

#: src/migration.md:512
msgid "from 0.13.\\* to 0.14"
msgstr ""

#: src/migration.md:514
msgid "`auto-initialize` feature is now opt-in"
msgstr ""

#: src/migration.md:516
msgid ""
"For projects embedding Python in Rust, PyO3 no longer automatically "
"initializes a Python interpreter on the first call to `Python::with_gil` (or "
"`Python::acquire_gil`) unless the [`auto-initialize` feature](features."
"md#auto-initialize) is enabled."
msgstr ""

#: src/migration.md:518
msgid "New `multiple-pymethods` feature"
msgstr ""

#: src/migration.md:520
msgid ""
"`#[pymethods]` have been reworked with a simpler default implementation "
"which removes the dependency on the `inventory` crate. This reduces "
"dependencies and compile times for the majority of users."
msgstr ""

#: src/migration.md:522
msgid ""
"The limitation of the new default implementation is that it cannot support "
"multiple `#[pymethods]` blocks for the same `#[pyclass]`. If you need this "
"functionality, you must enable the `multiple-pymethods` feature which will "
"switch `#[pymethods]` to the inventory-based implementation."
msgstr ""

#: src/migration.md:524
msgid "Deprecated `#[pyproto]` methods"
msgstr ""

#: src/migration.md:526
msgid ""
"Some protocol (aka `__dunder__`) methods such as `__bytes__` and "
"`__format__` have been possible to implement two ways in PyO3 for some time: "
"via a `#[pyproto]` (e.g. `PyObjectProtocol` for the methods listed here), or "
"by writing them directly in `#[pymethods]`. This is only true for a handful "
"of the `#[pyproto]` methods (for technical reasons to do with the way PyO3 "
"currently interacts with the Python C-API)."
msgstr ""

#: src/migration.md:528
msgid ""
"In the interest of having only one way to do things, the `#[pyproto]` forms "
"of these methods have been deprecated."
msgstr ""

#: src/migration.md:530
msgid ""
"To migrate just move the affected methods from a `#[pyproto]` to a "
"`#[pymethods]` block."
msgstr ""

#: src/migration.md:549 src/migration.md:640 src/migration.md:703
#: src/migration.md:732 src/migration.md:771 src/migration.md:803
#: src/migration.md:826 src/migration.md:852 src/migration.md:885
#: src/migration.md:967 src/migration.md:991 src/migration.md:1037
msgid "After:"
msgstr ""

#: src/migration.md:565
msgid "from 0.12.\\* to 0.13"
msgstr ""

#: src/migration.md:567
msgid "Minimum Rust version increased to Rust 1.45"
msgstr ""

#: src/migration.md:569
msgid ""
"PyO3 `0.13` makes use of new Rust language features stabilized between Rust "
"1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, "
"you will need to update your toolchain to be able to continue using PyO3."
msgstr ""

#: src/migration.md:571
msgid "Runtime changes to support the CPython limited API"
msgstr ""

#: src/migration.md:573
msgid ""
"In PyO3 `0.13` support was added for compiling against the CPython limited "
"API. This had a number of implications for _all_ PyO3 users, described here."
msgstr ""

#: src/migration.md:575
msgid ""
"The largest of these is that all types created from PyO3 are what CPython "
"calls \"heap\" types. The specific implications of this are:"
msgstr ""

#: src/migration.md:577
msgid ""
"If you wish to subclass one of these types _from Rust_ you must mark it "
"`#[pyclass(subclass)]`, as you would if you wished to allow subclassing it "
"from Python code."
msgstr ""

#: src/migration.md:578
msgid "Type objects are now mutable - Python code can set attributes on them."
msgstr ""

#: src/migration.md:579
msgid ""
"`__module__` on types without `#[pyclass(module=\"mymodule\")]` no longer "
"returns `builtins`, it now raises `AttributeError`."
msgstr ""

#: src/migration.md:581
msgid "from 0.11.\\* to 0.12"
msgstr ""

#: src/migration.md:583
msgid "`PyErr` has been reworked"
msgstr ""

#: src/migration.md:585
msgid ""
"In PyO3 `0.12` the `PyErr` type has been re-implemented to be significantly "
"more compatible with the standard Rust error handling ecosystem. "
"Specifically `PyErr` now implements `Error + Send + Sync`, which are the "
"standard traits used for error types."
msgstr ""

#: src/migration.md:589
msgid ""
"While this has necessitated the removal of a number of APIs, the resulting "
"`PyErr` type should now be much more easier to work with. The following "
"sections list the changes in detail and how to migrate to the new APIs."
msgstr ""

#: src/migration.md:593
msgid ""
"`PyErr::new` and `PyErr::from_type` now require `Send + Sync` for their "
"argument"
msgstr ""

#: src/migration.md:595
msgid ""
"For most uses no change will be needed. If you are trying to construct "
"`PyErr` from a value that is not `Send + Sync`, you will need to first "
"create the Python object and then use `PyErr::from_instance`."
msgstr ""

#: src/migration.md:599
msgid ""
"Similarly, any types which implemented `PyErrArguments` will now need to be "
"`Send + Sync`."
msgstr ""

#: src/migration.md:601
msgid "`PyErr`'s contents are now private"
msgstr ""

#: src/migration.md:603
msgid ""
"It is no longer possible to access the fields `.ptype`, `.pvalue` and `."
"ptraceback` of a `PyErr`. You should instead now use the new methods `PyErr::"
"ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/migration.md:606
msgid "`PyErrValue` and `PyErr::from_value` have been removed"
msgstr ""

#: src/migration.md:608
msgid ""
"As these were part the internals of `PyErr` which have been reworked, these "
"APIs no longer exist."
msgstr ""

#: src/migration.md:610
msgid ""
"If you used this API, it is recommended to use `PyException::new_err` (see "
"[the section on Exception types](#exception-types-have-been-reworked))."
msgstr ""

#: src/migration.md:613
msgid "`Into<PyResult<T>>` for `PyErr` has been removed"
msgstr ""

#: src/migration.md:615
msgid ""
"This implementation was redundant. Just construct the `Result::Err` variant "
"directly."
msgstr ""

#: src/migration.md:619 src/migration.md:625 src/migration.md:637
#: src/migration.md:646
msgid "\"error message\""
msgstr ""

#: src/migration.md:622
msgid ""
"After (also using the new reworked exception types; see the following "
"section):"
msgstr ""

#: src/migration.md:628
msgid "Exception types have been reworked"
msgstr ""

#: src/migration.md:630
msgid ""
"Previously exception types were zero-sized marker types purely used to "
"construct `PyErr`. In PyO3 0.12, these types have been replaced with full "
"definitions and are usable in the same way as `PyAny`, `PyDict` etc. This "
"makes it possible to interact with Python exception objects."
msgstr ""

#: src/migration.md:634
msgid ""
"The new types also have names starting with the \"Py\" prefix. For example, "
"before:"
msgstr ""

#: src/migration.md:647
msgid "// Uses Display for PyErr, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:649
msgid "\"TypeError: error message\""
msgstr ""

#: src/migration.md:650
msgid ""
"// Now possible to interact with exception instances, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:654
msgid "\"__class__\""
msgstr ""

#: src/migration.md:661
msgid "`FromPy` has been removed"
msgstr ""

#: src/migration.md:662
msgid ""
"To simplify the PyO3 conversion traits, the `FromPy` trait has been removed. "
"Previously there were two ways to define the to-Python conversion for a "
"type: `FromPy<T> for PyObject` and `IntoPy<PyObject> for T`."
msgstr ""

#: src/migration.md:666
msgid ""
"Now there is only one way to define the conversion, `IntoPy`, so downstream "
"crates may need to adjust accordingly."
msgstr ""

#: src/migration.md:693
msgid ""
"Similarly, code which was using the `FromPy` trait can be trivially "
"rewritten to use `IntoPy`."
msgstr ""

#: src/migration.md:711
msgid "`PyObject` is now a type alias of `Py<PyAny>`"
msgstr ""

#: src/migration.md:712
msgid ""
"This should change very little from a usage perspective. If you implemented "
"traits for both `PyObject` and `Py<T>`, you may find you can just remove the "
"`PyObject` implementation."
msgstr ""

#: src/migration.md:715
msgid "`AsPyRef` has been removed"
msgstr ""

#: src/migration.md:716
msgid ""
"As `PyObject` has been changed to be just a type alias, the only remaining "
"implementor of `AsPyRef` was `Py<T>`. This removed the need for a trait, so "
"the `AsPyRef::as_ref` method has been moved to `Py::as_ref`."
msgstr ""

#: src/migration.md:720
msgid ""
"This should require no code changes except removing `use pyo3::AsPyRef` for "
"code which did not use `pyo3::prelude::*`."
msgstr ""

#: src/migration.md:741
msgid "from 0.10.\\* to 0.11"
msgstr ""

#: src/migration.md:743
msgid "Stable Rust"
msgstr ""

#: src/migration.md:744
msgid ""
"PyO3 now supports the stable Rust toolchain. The minimum required version is "
"1.39.0."
msgstr ""

#: src/migration.md:746
msgid "`#[pyclass]` structs must now be `Send` or `unsendable`"
msgstr ""

#: src/migration.md:747
msgid ""
"Because `#[pyclass]` structs can be sent between threads by the Python "
"interpreter, they must implement `Send` or declared as `unsendable` (by "
"`#[pyclass(unsendable)]`). Note that `unsendable` is added in PyO3 `0.11.1` "
"and `Send` is always required in PyO3 `0.11.0`."
msgstr ""

#: src/migration.md:751
msgid ""
"This may \"break\" some code which previously was accepted, even though it "
"could be unsound. There can be two fixes:"
msgstr ""

#: src/migration.md:754
msgid ""
"If you think that your `#[pyclass]` actually must be `Send`able, then let's "
"implement `Send`. A common, safer way is using thread-safe types. E.g., "
"`Arc` instead of `Rc`, `Mutex` instead of `RefCell`, and `Box<dyn Send + T>` "
"instead of `Box<dyn T>`."
msgstr ""

#: src/migration.md:784
msgid ""
"In situations where you cannot change your `#[pyclass]` to automatically "
"implement `Send` (e.g., when it contains a raw pointer), you can use `unsafe "
"impl Send`. In such cases, care should be taken to ensure the struct is "
"actually thread safe. See [the Rustonomicon](https://doc.rust-lang.org/"
"nomicon/send-and-sync.html) for more."
msgstr ""

#: src/migration.md:789
msgid ""
"If you think that your `#[pyclass]` should not be accessed by another "
"thread, you can use `unsendable` flag. A class marked with `unsendable` "
"panics when accessed by another thread, making it thread-safe to expose an "
"unsendable object to the Python interpreter."
msgstr ""

#: src/migration.md:814
msgid "All `PyObject` and `Py<T>` methods now take `Python` as an argument"
msgstr ""

#: src/migration.md:815
msgid ""
"Previously, a few methods such as `Object::get_refcnt` did not take `Python` "
"as an argument (to ensure that the Python GIL was held by the current "
"thread). Technically, this was not sound. To migrate, just pass a `py` "
"argument to any calls to these methods."
msgstr ""

#: src/migration.md:833
msgid "from 0.9.\\* to 0.10"
msgstr ""

#: src/migration.md:835
msgid "`ObjectProtocol` is removed"
msgstr ""

#: src/migration.md:836
msgid ""
"All methods are moved to [`PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html). And since now all native types (e.g., `PyList`) "
"implements `Deref<Target=PyAny>`, all you need to do is remove "
"`ObjectProtocol` from your code. Or if you use `ObjectProtocol` by `use "
"pyo3::prelude::*`, you have to do nothing."
msgstr ""

#: src/migration.md:846 src/migration.md:855
msgid "\"lambda: 'Hi :)'\""
msgstr ""

#: src/migration.md:861
msgid "No `#![feature(specialization)]` in user code"
msgstr ""

#: src/migration.md:862
msgid ""
"While PyO3 itself still requires specialization and nightly Rust, now you "
"don't have to use `#![feature(specialization)]` in your crate."
msgstr ""

#: src/migration.md:865
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:867
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:868
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:900
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](class.html#constructor) of this guide."
msgstr ""

#: src/migration.md:903
msgid "PyCell"
msgstr ""

#: src/migration.md:904
msgid ""
"PyO3 0.9 introduces [`PyCell`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyCell.html), which is a [`RefCell`](https://doc.rust-lang.org/std/cell/"
"struct.RefCell.html)\\-like object wrapper for ensuring Rust's rules "
"regarding aliasing of references are upheld. For more detail, see the [Rust "
"Book's section on Rust's rules of references](https://doc.rust-lang.org/book/"
"ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:909
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:913
msgid "Here is an example."
msgstr ""

#: src/migration.md:934
msgid ""
"r\"\n"
"#     try:\n"
"#        names.merge(names)\n"
"#        assert False, 'Unreachable'\n"
"#     except RuntimeError as e:\n"
"#        assert str(e) == 'Already borrowed'\n"
"#     \""
msgstr ""

#: src/migration.md:943
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/main/doc/pyo3/pycell/"
"struct.PyBorrowMutError.html) exception, since it requires two mutable "
"borrows of `names`."
msgstr ""

#: src/migration.md:947
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:949
msgid "Object creation"
msgstr ""

#: src/migration.md:950
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use [`PyCell::new`]"
"(https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html#method.new) "
"instead. If you need [`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html), just call `.borrow()` or `.borrow_mut()` on the newly-created "
"`PyCell`."
msgstr ""

#: src/migration.md:978
msgid "Object extraction"
msgstr ""

#: src/migration.md:979
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:999
msgid "\"c\""
msgstr ""

#: src/migration.md:1000
msgid "\"c()\""
msgstr ""

#: src/migration.md:1003
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:1006
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:1013
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:1014
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) implementation. So if your protocol methods take `&T` or `&mut T` "
"(where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) instead."
msgstr ""
