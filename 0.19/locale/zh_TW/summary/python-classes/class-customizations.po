msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:42:12Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class/protocols.md:1
msgid "Magic methods and slots"
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. You may be "
"familiar with implementing these protocols in Python classes by \"magic\" "
"methods, such as `__str__` or `__repr__`. Because of the double-underscores "
"surrounding their name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"In the Python C-API which PyO3 is implemented upon, many of these magic "
"methods have to be placed into special \"slots\" on the class type object, "
"as covered in the previous section."
msgstr ""

#: src/class/protocols.md:7
msgid ""
"If a function name in `#[pymethods]` is a recognised magic method, it will "
"be automatically placed into the correct slot in the Python type object. The "
"function name is taken from the usual rules for naming `#[pymethods]`: the "
"`#[pyo3(name = \"...\")]` attribute is used if present, otherwise the Rust "
"function name is used."
msgstr ""

#: src/class/protocols.md:9
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the the subset which "
"have slots as [defined here](https://docs.python.org/3/c-api/typeobj.html). "
"Some of the slots do not have a magic method in Python, which leads to a few "
"additional magic methods defined only in PyO3:"
msgstr ""

#: src/class/protocols.md:10
msgid "Magic methods for garbage collection"
msgstr ""

#: src/class/protocols.md:11
msgid "Magic methods for the buffer protocol"
msgstr ""

#: src/class/protocols.md:13
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:14
msgid "The Rust function signature is restricted to match the magic method."
msgstr ""

#: src/class/protocols.md:15
msgid ""
"The `#[pyo3(signature = (...)]` and `#[pyo3(text_signature = \"...\")]` "
"attributes are not allowed."
msgstr ""

#: src/class/protocols.md:17
msgid ""
"The following sections list of all magic methods PyO3 currently handles.  "
"The given signatures should be interpreted as follows:"
msgstr ""

#: src/class/protocols.md:19
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `PyCell` reference like `self_: PyRef<'_, Self>` "
"and `self_: PyRefMut<'_, Self>`, as described [here](../class."
"md#inheritance)."
msgstr ""

#: src/class/protocols.md:22
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:23
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:24
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:26
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:28
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:30
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:35
msgid "Basic object customization"
msgstr ""

#: src/class/protocols.md:37
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:38
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:40
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:42
msgid ""
"Objects that compare equal must have the same hash value. Any type up to 64 "
"bits may be returned instead of `isize`, PyO3 will convert to an isize "
"automatically (wrapping unsigned types like `u64` and `usize`)."
msgstr ""

#: src/class/protocols.md:61
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:63
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `CompareOp` argument indicates the comparison operation being "
"performed."
msgstr ""

#: src/class/protocols.md:66
msgid ""
"_Note that implementing `__richcmp__` will cause Python not to generate a "
"default `__hash__` implementation, so consider implementing `__hash__` when "
"implementing `__richcmp__`._"
msgstr ""

#: src/class/protocols.md:73
msgid ""
"You can use [`CompareOp::matches`](https://pyo3.rs/main/doc/pyo3/pyclass/"
"enum.CompareOp.html#method.matches) to adapt a Rust `std::cmp::Ordering` "
"result to the requested comparison."
msgstr ""

#: src/class/protocols.md:77
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:78
msgid "`__getattribute__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:88
msgid "`__setattr__(<self>, value: object) -> ()`"
msgstr ""

#: src/class/protocols.md:89
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:91
msgid "Overrides attribute access."
msgstr ""

#: src/class/protocols.md:93
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:95
msgid "Determines the \"truthyness\" of an object."
msgstr ""

#: src/class/protocols.md:97
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:100
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:102
msgid "Iterators can be defined using these methods:"
msgstr ""

#: src/class/protocols.md:104
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:105
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:107
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items."
msgstr ""

#: src/class/protocols.md:109 src/class/protocols.md:382
msgid "Example:"
msgstr ""

#: src/class/protocols.md:130
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, the "
"iterable only needs to implement `__iter__()` while the iterator must "
"implement both `__iter__()` and `__next__()`. For example:"
msgstr ""

#: src/class/protocols.md:172
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:173
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:177
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:180
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:182
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration.  In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://pyo3.rs/"
"main/doc/pyo3/pyclass/enum.IterNextOutput.html) enum to both `Yield` values "
"and `Return` a final value - see its docs for further details and an example."
msgstr ""

#: src/class/protocols.md:187
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:189
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:190
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:191
msgid "`__anext__(<self>) -> Option<object> or IterANextOutput`"
msgstr ""

#: src/class/protocols.md:193
msgid "Mapping & Sequence types"
msgstr ""

#: src/class/protocols.md:195
msgid ""
"The magic methods in this section can be used to implement Python container "
"types. They are two main categories of container in Python: \"mappings\" "
"such as `dict`, with arbitrary keys, and \"sequences\" such as `list` and "
"`tuple`, with integer keys."
msgstr ""

#: src/class/protocols.md:197
msgid ""
"The Python C-API which PyO3 is built upon has separate \"slots\" for "
"sequences and mappings. When writing a `class` in pure Python, there is no "
"such distinction in the implementation - a `__getitem__` implementation will "
"fill the slots for both the mapping and sequence forms, for example."
msgstr ""

#: src/class/protocols.md:199
msgid ""
"By default PyO3 reproduces the Python behaviour of filling both mapping and "
"sequence slots. This makes sense for the \"simple\" case which matches "
"Python, and also for sequences, where the mapping slot is used anyway to "
"implement slice indexing."
msgstr ""

#: src/class/protocols.md:201
msgid ""
"Mapping types usually will not want the sequence slots filled. Having them "
"filled will lead to outcomes which may be unwanted, such as:"
msgstr ""

#: src/class/protocols.md:202
msgid ""
"The mapping type will successfully cast to [`PySequence`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PySequence.html). This may lead to consumers of "
"the type handling it incorrectly."
msgstr ""

#: src/class/protocols.md:203
msgid ""
"Python provides a default implementation of `__iter__` for sequences, which "
"calls `__getitem__` with consecutive positive integers starting from 0 until "
"an `IndexError` is returned. Unless the mapping only contains consecutive "
"positive integer keys, this `__iter__` implementation will likely not be the "
"intended behavior."
msgstr ""

#: src/class/protocols.md:205
msgid ""
"Use the `#[pyclass(mapping)]` annotation to instruct PyO3 to only fill the "
"mapping slots, leaving the sequence ones empty. This will apply to "
"`__getitem__`, `__setitem__`, and `__delitem__`."
msgstr ""

#: src/class/protocols.md:207
msgid ""
"Use the `#[pyclass(sequence)]` annotation to instruct PyO3 to fill the "
"`sq_length` slot instead of the `mp_length` slot for `__len__`. This will "
"help libraries such as `numpy` recognise the class as a sequence, however "
"will also cause CPython to automatically add the sequence length to any "
"negative indices before passing them to `__getitem__`. (`__getitem__`, "
"`__setitem__` and `__delitem__` mapping slots are still used for sequences, "
"for slice operations.)"
msgstr ""

#: src/class/protocols.md:209
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:211
msgid "Implements the built-in function `len()`."
msgstr ""

#: src/class/protocols.md:213
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:215
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that donâ€™t define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:223
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:242
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:244
msgid "Implements retrieval of the `self[a]` element."
msgstr ""

#: src/class/protocols.md:246
msgid ""
"_Note:_ Negative integer indexes are not handled specially by PyO3. However, "
"for classes with `#[pyclass(sequence)]`, when a negative index is accessed "
"via `PySequence::get_item`, the underlying C API already adjusts the index "
"to be positive."
msgstr ""

#: src/class/protocols.md:251
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:253
msgid ""
"Implements assignment to the `self[a]` element. Should only be implemented "
"if elements can be replaced."
msgstr ""

#: src/class/protocols.md:256 src/class/protocols.md:263
msgid "Same behavior regarding negative indices as for `__getitem__`."
msgstr ""

#: src/class/protocols.md:258
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:260
msgid ""
"Implements deletion of the `self[a]` element. Should only be implemented if "
"elements can be deleted."
msgstr ""

#: src/class/protocols.md:265
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:267
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `__add__` and `__radd__` methods."
msgstr ""

#: src/class/protocols.md:271
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:273
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `__mul__` and `__rmul__` methods."
msgstr ""

#: src/class/protocols.md:277
msgid ""
"`fn __inplace_concat__(&self, other: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:279
msgid ""
"Concatenates two sequences. Used by the `+=` operator, after trying the "
"numeric addition via the `__iadd__` method."
msgstr ""

#: src/class/protocols.md:283
msgid ""
"`fn __inplace_repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:285
msgid ""
"Concatenates two sequences. Used by the `*=` operator, after trying the "
"numeric multiplication via the `__imul__` method."
msgstr ""

#: src/class/protocols.md:289
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:291
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:292
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:293
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:295
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:297
msgid ""
"Binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, "
"`divmod()`, `pow()` and `**`, `<<`, `>>`, `&`, `^`, and `|`) and their "
"reflected versions:"
msgstr ""

#: src/class/protocols.md:300
msgid ""
"(If the `object` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`.)"
msgstr ""

#: src/class/protocols.md:303
msgid "`__add__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:304
msgid "`__radd__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:305
msgid "`__sub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:306
msgid "`__rsub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:307
msgid "`__mul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:308
msgid "`__rmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:309
msgid "`__matmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:310
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:311
msgid "`__floordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:312
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:313
msgid "`__truediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:314
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:315
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:316
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:317
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:318
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:319
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:320
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:321
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:322
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:323
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:324
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:325
msgid "`__xor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:326
msgid "`__rxor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:327
msgid "`__or__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:328
msgid "`__ror__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:329
msgid "`__pow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:330
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:332
msgid ""
"In-place assignment operations (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, "
"`**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:335
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:336
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:337
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:338
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:339
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:340
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:341
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:342
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:343
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:344
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:345
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:346
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:347
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:349
msgid "Unary operations (`-`, `+`, `abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:351
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:352
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:353
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:354
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:356
msgid "Coercions:"
msgstr ""

#: src/class/protocols.md:358
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:359
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:360
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:362
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:364
msgid "`__getbuffer__(<self>, *mut ffi::Py_buffer, flags) -> ()`"
msgstr ""

#: src/class/protocols.md:365
msgid ""
"`__releasebuffer__(<self>, *mut ffi::Py_buffer) -> ()` Errors returned from "
"`__releasebuffer__` will be sent to `sys.unraiseablehook`. It is strongly "
"advised to never return an error from `__releasebuffer__`, and if it really "
"is necessary, to make best effort to perform any required freeing operations "
"before returning. `__releasebuffer__` will not be called a second time; "
"anything not freed will be leaked."
msgstr ""

#: src/class/protocols.md:368
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:370
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references.  To do this, implement the two methods `__traverse__` and "
"`__clear__`.  These correspond to the slots `tp_traverse` and `tp_clear` in "
"the Python C API. `__traverse__` must call `visit.call()` for each reference "
"to another Python object.  `__clear__` must clear out any mutable references "
"to other Python objects (thus breaking reference cycles). Immutable "
"references do not have to be cleared, as every cycle must contain at least "
"one mutable reference."
msgstr ""

#: src/class/protocols.md:379
msgid ""
"`__traverse__(<self>, pyo3::class::gc::PyVisit<'_>) -> Result<(), pyo3::"
"class::gc::PyTraverseError>`"
msgstr ""

#: src/class/protocols.md:380
msgid "`__clear__(<self>) -> ()`"
msgstr ""

#: src/class/protocols.md:404
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:410
msgid ""
"Usually, an implementation of `__traverse__` should do nothing but calls to "
"`visit.call`. Most importantly, safe access to the GIL is prohibited inside "
"implementations of `__traverse__`, i.e. `Python::with_gil` will panic."
msgstr ""

#: src/class/protocols.md:414
msgid ""
"Note: these methods are part of the C API, PyPy does not necessarily honor "
"them. If you are building for PyPy you should measure memory consumption to "
"make sure you do not have runaway memory growth. See [this issue on the PyPy "
"bug tracker](https://foss.heptapod.net/pypy/pypy/-/issues/3899)."
msgstr ""
