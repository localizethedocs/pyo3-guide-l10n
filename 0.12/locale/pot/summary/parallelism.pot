msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:56Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"CPython has the infamous [Global Interpreter Lock](https://docs.python.org/3/"
"glossary.html#term-global-interpreter-lock), which prevents several threads "
"from executing Python bytecode in parallel. This makes threading in Python a "
"bad fit for [CPU-bound](https://stackoverflow.com/questions/868568/) tasks "
"and often forces developers to accept the overhead of multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a "
"look at our [word-count](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs) example, where we have a `search` function that "
"utilizes the [rayon](https://github.com/nikomatsakis/rayon) crate to count "
"words in parallel."
msgstr ""

#: src/parallelism.md:16
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""

#: src/parallelism.md:23
msgid ""
"To enable parallel execution of this function, the [`Python::allow_threads`]"
"(https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.allow_threads) "
"method can be used to temporarily release the GIL, thus allowing other "
"Python threads to run. We then have a function exposed to the Python runtime "
"which calls `search_sequential` inside a closure passed to [`Python::"
"allow_threads`](https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method."
"allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:31
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""

#: src/parallelism.md:48
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:50
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr ""

#: src/parallelism.md:52
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr ""

#: src/parallelism.md:54
msgid "Pure Python version"
msgstr ""

#: src/parallelism.md:55
msgid "Rust parallel version"
msgstr ""

#: src/parallelism.md:56
msgid "Rust sequential version"
msgstr ""

#: src/parallelism.md:57
msgid "Rust sequential version executed twice with two Python threads"
msgstr ""

#: src/parallelism.md:59
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/tests/test_word_count.py), and we can run `tox` "
"in the `word-count` folder to benchmark these functions."
msgstr ""

#: src/parallelism.md:61
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr ""

#: src/parallelism.md:73
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""
