msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:41Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class/object.md:1
msgid "Basic object customization"
msgstr ""

#: src/class/object.md:3
msgid "Recall the `Number` class from the previous chapter:"
msgstr ""

#: src/class/object.md:27
msgid ""
"At this point Python code can import the module, access the class and create "
"class instances - but nothing else."
msgstr ""

#: src/class/object.md:41
msgid "String representations"
msgstr ""

#: src/class/object.md:43
msgid ""
"It can't even print an user-readable representation of itself! We can fix "
"that by defining the `__repr__` and `__str__` methods inside a "
"`#[pymethods]` block. We do this by accessing the value contained inside "
"`Number`."
msgstr ""

#: src/class/object.md:55
msgid ""
"// For `__repr__` we want to return a string that Python code could use to "
"recreate\n"
"    // the `Number`, like `Number(5)` for example.\n"
msgstr ""

#: src/class/object.md:58
msgid ""
"// We use the `format!` macro to create a string. Its first argument is a\n"
"        // format string, followed by any number of parameters which replace "
"the\n"
"        // `{}`'s in the format string.\n"
"        //\n"
"        //                       ðŸ‘‡ Tuple field access in Rust uses a dot\n"
msgstr ""

#: src/class/object.md:63
msgid "\"Number({})\""
msgstr ""

#: src/class/object.md:65
msgid ""
"// `__str__` is generally used to create an \"informal\" representation, so "
"we\n"
"    // just forward to `i32`'s `ToString` trait implementation to print a "
"bare number.\n"
msgstr ""

#: src/class/object.md:73
msgid ""
"To automatically generate the `__str__` implementation using a `Display` "
"trait implementation, pass the `str` argument to `pyclass`."
msgstr ""

#: src/class/object.md:89
msgid "\"({}, {}, {})\""
msgstr ""

#: src/class/object.md:94
msgid ""
"For convenience, a shorthand format string can be passed to `str` as "
"`str=\"<format string>\"` for **structs only**.  It expands and is passed "
"into the `format!` macro in the following ways:"
msgstr ""

#: src/class/object.md:96
msgid "`\"{x}\"` -> `\"{}\", self.x`"
msgstr ""

#: src/class/object.md:97
msgid "`\"{0}\"` -> `\"{}\", self.0`"
msgstr ""

#: src/class/object.md:98
msgid "`\"{x:?}\"` -> `\"{:?}\", self.x`"
msgstr ""

#: src/class/object.md:100
msgid ""
"_Note: Depending upon the format string you use, this may require "
"implementation of the `Display` or `Debug` traits for the given Rust types."
"_  \n"
"_Note: the pyclass args `name` and `rename_all` are incompatible with the "
"shorthand format string and will raise a compile time error._"
msgstr ""

#: src/class/object.md:107
msgid "\"({x}, {y}, {z})\""
msgstr ""

#: src/class/object.md:115
msgid "Accessing the class name"
msgstr ""

#: src/class/object.md:117
msgid ""
"In the `__repr__`, we used a hard-coded class name. This is sometimes not "
"ideal, because if the class is subclassed in Python, we would like the repr "
"to reflect the subclass name. This is typically done in Python code by "
"accessing `self.__class__.__name__`. In order to be able to access the "
"Python type information _and_ the Rust struct, we need to use a `Bound` as "
"the `self` argument."
msgstr ""

#: src/class/object.md:134
msgid "// This is the equivalent of `self.__class__.__name__` in Python.\n"
msgstr ""

#: src/class/object.md:136
msgid ""
"// To access fields of the Rust struct, we need to borrow the `PyCell`.\n"
msgstr ""

#: src/class/object.md:137 src/class/object.md:353
msgid "\"{}({})\""
msgstr ""

#: src/class/object.md:142
msgid "Hashing"
msgstr ""

#: src/class/object.md:145
msgid ""
"Let's also implement hashing. We'll just hash the `i32`. For that we need a "
"[`Hasher`](https://doc.rust-lang.org/std/hash/trait.Hasher.html). The one "
"provided by `std` is [`DefaultHasher`](https://doc.rust-lang.org/std/"
"collections/hash_map/struct.DefaultHasher.html), which uses the [SipHash]"
"(https://en.wikipedia.org/wiki/SipHash) algorithm."
msgstr ""

#: src/class/object.md:150
msgid ""
"// Required to call the `.hash` and `.finish` methods, which are defined on "
"traits.\n"
msgstr ""

#: src/class/object.md:169
msgid ""
"To implement `__hash__` using the Rust [`Hash`](https://doc.rust-lang.org/"
"std/hash/trait.Hash.html) trait implementation, the `hash` option can be "
"used. This option is only available for `frozen` classes to prevent "
"accidental hash changes from mutating the object. If you need an `__hash__` "
"implementation for a mutable class, use the manual method from above. This "
"option also requires `eq`: According to the [Python docs](https://docs."
"python.org/3/reference/datamodel.html#object.__hash__) \"If a class does not "
"define an `__eq__()` method it should not define a `__hash__()` operation "
"either\""
msgstr ""

#: src/class/object.md:184
msgid ""
"**Note**: When implementing `__hash__` and comparisons, it is important that "
"the following property holds:"
msgstr ""

#: src/class/object.md:190
msgid ""
"In other words, if two keys are equal, their hashes must also be equal. In "
"addition you must take care that your classes' hash doesn't change during "
"its lifetime. In this tutorial we do that by not letting Python code change "
"our `Number` class. In other words, it is immutable."
msgstr ""

#: src/class/object.md:194
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to None. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/object.md:210
msgid "Comparisons"
msgstr ""

#: src/class/object.md:212
msgid ""
"PyO3 supports the usual magic comparison methods available in Python such as "
"`__eq__`, `__lt__` and so on. It is also possible to support all six "
"operations at once with `__richcmp__`. This method will be called with a "
"value of `CompareOp` depending on the operation."
msgstr ""

#: src/class/object.md:240
msgid ""
"If you obtain the result by comparing two Rust values, as in this example, "
"you can take a shortcut using `CompareOp::matches`:"
msgstr ""

#: src/class/object.md:260
msgid ""
"It checks that the `std::cmp::Ordering` obtained from Rust's `Ord` matches "
"the given `CompareOp`."
msgstr ""

#: src/class/object.md:263
msgid "Alternatively, you can implement just equality using `__eq__`:"
msgstr ""

#: src/class/object.md:290
msgid ""
"To implement `__eq__` using the Rust [`PartialEq`](https://doc.rust-lang.org/"
"stable/std/cmp/trait.PartialEq.html) trait implementation, the `eq` option "
"can be used."
msgstr ""

#: src/class/object.md:301
msgid ""
"To implement `__lt__`, `__le__`, `__gt__`, & `__ge__` using the Rust "
"`PartialOrd` trait implementation, the `ord` option can be used. _Note: "
"Requires `eq`._"
msgstr ""

#: src/class/object.md:312
msgid "Truthyness"
msgstr ""

#: src/class/object.md:314
msgid "We'll consider `Number` to be `True` if it is nonzero:"
msgstr ""

#: src/class/object.md:331
msgid "Final code"
msgstr ""
