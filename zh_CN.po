msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr ""

#: src/advanced.md:3
msgid "FFI"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of Python's C API through the `ffi` module."
msgstr ""

#: src/advanced.md:7
msgid ""
"The C API is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that API."
msgstr ""

#: src/migration.md:1
msgid "Migrating from older PyO3 versions"
msgstr ""

#: src/migration.md:3
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see the [CHANGELOG]"
"(changelog.md)."
msgstr ""

#: src/migration.md:6
msgid "from 0.21.\\* to 0.22"
msgstr ""

#: src/migration.md:8
msgid "Deprecation of `gil-refs` feature continues"
msgstr ""

#: src/migration.md:12
msgid ""
"Following the introduction of the \"Bound\" API in PyO3 0.21 and the planned "
"removal of the \"GIL Refs\" API, all functionality related to GIL Refs is "
"now gated behind the `gil-refs` feature and emits a deprecation warning on "
"use."
msgstr ""

#: src/migration.md:14
msgid ""
"See <a href=\"#from-021-to-022\">the 0.21 migration entry</a> for help "
"upgrading."
msgstr ""

#: src/migration.md:17
msgid "Deprecation of implicit default for trailing optional arguments"
msgstr ""

#: src/migration.md:21
msgid ""
"With `pyo3` 0.22 the implicit `None` default for trailing `Option<T>` type "
"argument is deprecated. To migrate, place a `#[pyo3(signature = (...))]` "
"attribute on affected functions or methods and specify the desired behavior. "
"The migration warning specifies the corresponding signature to keep the "
"current behavior. With 0.23 the signature will be required for any function "
"containing `Option<T>` type parameters to prevent accidental and unnoticed "
"changes in behavior. With 0.24 this restriction will be lifted again and "
"`Option<T>` type arguments will be treated as any other argument _without_ "
"special handling."
msgstr ""

#: src/migration.md:25 src/migration.md:67 src/migration.md:105
#: src/migration.md:179 src/migration.md:206 src/migration.md:441
#: src/migration.md:489 src/migration.md:561 src/migration.md:618
#: src/migration.md:647 src/migration.md:967 src/migration.md:1007
#: src/migration.md:1066 src/migration.md:1277 src/migration.md:1383
#: src/migration.md:1442 src/migration.md:1469 src/migration.md:1505
#: src/migration.md:1548 src/migration.md:1583 src/migration.md:1613
#: src/migration.md:1639 src/migration.md:1677 src/migration.md:1767
#: src/migration.md:1794 src/migration.md:1829
msgid "Before:"
msgstr ""

#: src/migration.md:36 src/migration.md:79 src/migration.md:126
#: src/migration.md:187 src/migration.md:221 src/migration.md:451
#: src/migration.md:506 src/migration.md:585 src/migration.md:627
#: src/migration.md:657 src/migration.md:1294 src/migration.md:1409
#: src/migration.md:1477 src/migration.md:1514 src/migration.md:1561
#: src/migration.md:1593 src/migration.md:1620 src/migration.md:1650
#: src/migration.md:1691 src/migration.md:1777 src/migration.md:1801
#: src/migration.md:1847
msgid "After:"
msgstr ""

#: src/migration.md:49
msgid "`Py::clone` is now gated behind the `py-clone` feature"
msgstr ""

#: src/migration.md:54
msgid ""
"However, take care to note that the behaviour is different from previous "
"versions. If `Clone` was called without the GIL being held, we tried to "
"delay the application of these reference count increments until PyO3-based "
"code would re-acquire it. This turned out to be impossible to implement in a "
"sound manner and hence was removed. Now, if `Clone` is called without the "
"GIL being held, we panic instead for which calling code might not be "
"prepared."
msgstr ""

#: src/migration.md:56
msgid ""
"Related to this, we also added a `pyo3_disable_reference_pool` conditional "
"compilation flag which removes the infrastructure necessary to apply delayed "
"reference count decrements implied by `impl<T> Drop for Py<T>`. They do not "
"appear to be a soundness hazard as they should lead to memory leaks in the "
"worst case. However, the global synchronization adds significant overhead to "
"cross the Python-Rust boundary. Enabling this feature will remove these "
"costs and make the `Drop` implementation abort the process if called without "
"the GIL being held instead."
msgstr ""

#: src/migration.md:59
msgid "Require explicit opt-in for comparison for simple enums"
msgstr ""

#: src/migration.md:63
msgid ""
"With `pyo3` 0.22 the new `#[pyo3(eq)]` options allows automatic "
"implementation of Python equality using Rust's `PartialEq`. Previously "
"simple enums automatically implemented equality in terms of their "
"discriminants. To make PyO3 more consistent, this automatic equality "
"implementation is deprecated in favour of having opt-ins for all "
"`#[pyclass]` types. Similarly, simple enums supported comparison with "
"integers, which is not covered by Rust's `PartialEq` derive, so has been "
"split out into the `#[pyo3(eq_int)]` attribute."
msgstr ""

#: src/migration.md:65
msgid ""
"To migrate, place a `#[pyo3(eq, eq_int)]` attribute on simple enum classes."
msgstr ""

#: src/migration.md:93
msgid "`PyType::name` reworked to better match Python `__name__`"
msgstr ""

#: src/migration.md:97
msgid ""
"This function previously would try to read directly from Python type "
"objects' C API field (`tp_name`), in which case it would return a `Cow::"
"Borrowed`. However the contents of `tp_name` don't have well-defined "
"semantics."
msgstr ""

#: src/migration.md:100
msgid ""
"Instead `PyType::name()` now returns the equivalent of Python `__name__` and "
"returns `PyResult<Bound<'py, PyString>>`."
msgstr ""

#: src/migration.md:102
msgid ""
"The closest equivalent to PyO3 0.21's version of `PyType::name()` has been "
"introduced as a new function `PyType::fully_qualified_name()`, which is "
"equivalent to `__module__` and `__qualname__` joined as `module.qualname`."
msgstr ""

#: src/migration.md:115 src/migration.md:119 src/migration.md:136
#: src/migration.md:141
msgid "\"Hello, {}\""
msgstr ""

#: src/migration.md:138
msgid ""
"// (if the full dotted path was desired, switch from `name()` to "
"`fully_qualified_name()`)\n"
msgstr ""

#: src/migration.md:151
msgid "from 0.20.\\* to 0.21"
msgstr ""

#: src/migration.md:155
msgid ""
"PyO3 0.21 introduces a new `Bound<'py, T>` smart pointer which replaces the "
"existing \"GIL Refs\" API to interact with Python objects. For example, in "
"PyO3 0.20 the reference `&'py PyAny` would be used to interact with Python "
"objects. In PyO3 0.21 the updated type is `Bound<'py, PyAny>`. Making this "
"change moves Rust ownership semantics out of PyO3's internals and into user "
"code. This change fixes [a known soundness edge case of interaction with "
"gevent](https://github.com/PyO3/pyo3/issues/3668) as well as improves CPU "
"and [memory performance](https://github.com/PyO3/pyo3/issues/1056). For a "
"full history of discussion see https://github.com/PyO3/pyo3/issues/3382."
msgstr ""

#: src/migration.md:157
msgid ""
"The \"GIL Ref\" `&'py PyAny` and similar types such as `&'py PyDict` "
"continue to be available as a deprecated API. Due to the advantages of the "
"new API it is advised that all users make the effort to upgrade as soon as "
"possible."
msgstr ""

#: src/migration.md:159
msgid ""
"In addition to the major API type overhaul, PyO3 has needed to make a few "
"small breaking adjustments to other APIs to close correctness and soundness "
"gaps."
msgstr ""

#: src/migration.md:161
msgid "The recommended steps to update to PyO3 0.21 is as follows:"
msgstr ""

#: src/migration.md:162
msgid ""
"Enable the `gil-refs` feature to silence deprecations related to the API "
"change"
msgstr ""

#: src/migration.md:163
msgid "Fix all other PyO3 0.21 migration steps"
msgstr ""

#: src/migration.md:164
msgid "Disable the `gil-refs` feature and migrate off the deprecated APIs"
msgstr ""

#: src/migration.md:166
msgid "The following sections are laid out in this order."
msgstr ""

#: src/migration.md:169
msgid "Enable the `gil-refs` feature"
msgstr ""

#: src/migration.md:173
msgid ""
"To make the transition for the PyO3 ecosystem away from the GIL Refs API as "
"smooth as possible, in PyO3 0.21 no APIs consuming or producing GIL Refs "
"have been altered. Instead, variants using `Bound<T>` smart pointers have "
"been introduced, for example `PyTuple::new_bound` which returns "
"`Bound<PyTuple>` is the replacement form of `PyTuple::new`. The GIL Ref APIs "
"have been deprecated, but to make migration easier it is possible to disable "
"these deprecation warnings by enabling the `gil-refs` feature."
msgstr ""

#: src/migration.md:175
msgid ""
"The one single exception where an existing API was changed in-place is the "
"`pyo3::intern!` macro. Almost all uses of this macro did not need to update "
"code to account it changing to return `&Bound<PyString>` immediately, and "
"adding an `intern_bound!` replacement was perceived as adding more work for "
"users."
msgstr ""

#: src/migration.md:177
msgid ""
"It is recommended that users do this as a first step of updating to PyO3 "
"0.21 so that the deprecation warnings do not get in the way of resolving the "
"rest of the migration steps."
msgstr ""

#: src/migration.md:181
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[dependencies]\n"
"pyo3 = \"0.20\"\n"
"```"
msgstr ""

#: src/migration.md:189
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.21\", features = [\"gil-refs\"] }\n"
"```"
msgstr ""

#: src/migration.md:196
msgid "`PyTypeInfo` and `PyTryFrom` have been adjusted"
msgstr ""

#: src/migration.md:200
msgid ""
"The `PyTryFrom` trait has aged poorly, its `try_from` method now conflicts "
"with `TryFrom::try_from` in the 2021 edition prelude. A lot of its "
"functionality was also duplicated with `PyTypeInfo`."
msgstr ""

#: src/migration.md:202
msgid ""
"To tighten up the PyO3 traits as part of the deprecation of the GIL Refs API "
"the `PyTypeInfo` trait has had a simpler companion `PyTypeCheck`. The "
"methods `PyAny::downcast` and `PyAny::downcast_exact` no longer use "
"`PyTryFrom` as a bound, instead using `PyTypeCheck` and `PyTypeInfo` "
"respectively."
msgstr ""

#: src/migration.md:204
msgid ""
"To migrate, switch all type casts to use `obj.downcast()` instead of "
"`try_from(obj)` (and similar for `downcast_exact`)."
msgstr ""

#: src/migration.md:228
msgid ""
"// Note that PyList::new is deprecated for PyList::new_bound as part of the "
"GIL Refs API removal,\n"
"    // see the section below on migration to Bound<T>.\n"
msgstr ""

#: src/migration.md:239
msgid "`Iter(A)NextOutput` are deprecated"
msgstr ""

#: src/migration.md:243
msgid ""
"The `__next__` and `__anext__` magic methods can now return any type "
"convertible into Python objects directly just like all other `#[pymethods]`. "
"The `IterNextOutput` used by `__next__` and `IterANextOutput` used by "
"`__anext__` are subsequently deprecated. Most importantly, this change "
"allows returning an awaitable from `__anext__` without non-sensically "
"wrapping it into `Yield` or `Some`. Only the return types `Option<T>` and "
"`Result<Option<T>, E>` are still handled in a special manner where "
"`Some(val)` yields `val` and `None` stops iteration."
msgstr ""

#: src/migration.md:245
msgid ""
"Starting with an implementation of a Python iterator using `IterNextOutput`, "
"e.g."
msgstr ""

#: src/migration.md:264 src/migration.md:313
msgid "\"done\""
msgstr ""

#: src/migration.md:270
msgid ""
"If returning `\"done\"` via `StopIteration` is not really required, this "
"should be written as"
msgstr ""

#: src/migration.md:293
msgid ""
"This form also has additional benefits: It has already worked in previous "
"PyO3 versions, it matches the signature of Rust's [`Iterator` trait](https://"
"doc.rust-lang.org/stable/std/iter/trait.Iterator.html) and it allows using a "
"fast path in CPython which completely avoids the cost of raising a "
"`StopIteration` exception. Note that using [`Option::transpose`](https://doc."
"rust-lang.org/stable/std/option/enum.Option.html#method.transpose) and the "
"`Result<Option<T>, E>` variant, this form can also be used to wrap fallible "
"iterators."
msgstr ""

#: src/migration.md:295
msgid ""
"Alternatively, the implementation can also be done as it would in Python "
"itself, i.e. by \"raising\" a `StopIteration` exception"
msgstr ""

#: src/migration.md:319
msgid ""
"Finally, an asynchronous iterator can directly return an awaitable without "
"confusing wrapping"
msgstr ""

#: src/migration.md:361
msgid "`PyType::name` has been renamed to `PyType::qualname`"
msgstr ""

#: src/migration.md:365
msgid ""
"`PyType::name` has been renamed to `PyType::qualname` to indicate that it "
"does indeed return the [qualified name](https://docs.python.org/3/glossary."
"html#term-qualified-name), matching the `__qualname__` attribute. The newly "
"added `PyType::name` yields the full name including the module name now "
"which corresponds to `__module__.__name__` on the level of attributes."
msgstr ""

#: src/migration.md:368
msgid "`PyCell` has been deprecated"
msgstr ""

#: src/migration.md:372
msgid ""
"Interactions with Python objects implemented in Rust no longer need to go "
"though `PyCell<T>`. Instead iteractions with Python object now consistently "
"go through `Bound<T>` or `Py<T>` independently of whether `T` is native "
"Python object or a `#[pyclass]` implemented in Rust. Use `Bound::new` or "
"`Py::new` respectively to create and `Bound::borrow(_mut)` / `Py::"
"borrow(_mut)` to borrow the Rust object."
msgstr ""

#: src/migration.md:375
msgid "Migrating from the GIL Refs API to `Bound<T>`"
msgstr ""

#: src/migration.md:379
msgid ""
"To minimise breakage of code using the GIL Refs API, the `Bound<T>` smart "
"pointer has been introduced by adding complements to all functions which "
"accept or return GIL Refs. This allows code to migrate by replacing the "
"deprecated APIs with the new ones."
msgstr ""

#: src/migration.md:381
msgid ""
"To identify what to migrate, temporarily switch off the `gil-refs` feature "
"to see deprecation warnings on [almost](#cases-where-pyo3-cannot-emit-gil-"
"ref-deprecation-warnings) all uses of APIs accepting and producing GIL "
"Refs . Over one or more PRs it should be possible to follow the deprecation "
"hints to update code. Depending on your development environment, switching "
"off the `gil-refs` feature may introduce [some very targeted breakages]"
"(#deactivating-the-gil-refs-feature), so you may need to fixup those first."
msgstr ""

#: src/migration.md:383
msgid "For example, the following APIs have gained updated variants:"
msgstr ""

#: src/migration.md:384
msgid ""
"`PyList::new`, `PyTyple::new` and similar constructors have replacements "
"`PyList::new_bound`, `PyTuple::new_bound` etc."
msgstr ""

#: src/migration.md:385
msgid ""
"`FromPyObject::extract` has a new `FromPyObject::extract_bound` (see the "
"section below)"
msgstr ""

#: src/migration.md:386
msgid ""
"The `PyTypeInfo` trait has had new `_bound` methods added to accept / return "
"`Bound<T>`."
msgstr ""

#: src/migration.md:388
msgid ""
"Because the new `Bound<T>` API brings ownership out of the PyO3 framework "
"and into user code, there are a few places where user code is expected to "
"need to adjust while switching to the new API:"
msgstr ""

#: src/migration.md:389
msgid ""
"Code will need to add the occasional `&` to borrow the new smart pointer as "
"`&Bound<T>` to pass these types around (or use `.clone()` at the very small "
"cost of increasing the Python reference count)"
msgstr ""

#: src/migration.md:390
msgid ""
"`Bound<PyList>` and `Bound<PyTuple>` cannot support indexing with `list[0]`, "
"you should use `list.get_item(0)` instead."
msgstr ""

#: src/migration.md:391
msgid ""
"`Bound<PyTuple>::iter_borrowed` is slightly more efficient than "
"`Bound<PyTuple>::iter`. The default iteration of `Bound<PyTuple>` cannot "
"return borrowed references because Rust does not (yet) have \"lending "
"iterators\". Similarly `Bound<PyTuple>::get_borrowed_item` is more efficient "
"than `Bound<PyTuple>::get_item` for the same reason."
msgstr ""

#: src/migration.md:392
msgid ""
"`&Bound<T>` does not implement `FromPyObject` (although it might be possible "
"to do this in the future once the GIL Refs API is completely removed). Use "
"`bound_any.downcast::<T>()` instead of `bound_any.extract::<&Bound<T>>()`."
msgstr ""

#: src/migration.md:393
msgid ""
"`Bound<PyString>::to_str` now borrows from the `Bound<PyString>` rather than "
"from the `'py` lifetime, so code will need to store the smart pointer as a "
"value in some cases where previously `&PyString` was just used as a "
"temporary. (There are some more details relating to this in [the section "
"below](#deactivating-the-gil-refs-feature).)"
msgstr ""

#: src/migration.md:394
msgid ""
"`.extract::<&str>()` now borrows from the source Python object. The simplest "
"way to update is to change to `.extract::<PyBackedStr>()`, which retains "
"ownership of the Python reference. See more information [in the section on "
"deactivating the `gil-refs` feature](#deactivating-the-gil-refs-feature)."
msgstr ""

#: src/migration.md:396
msgid ""
"To convert between `&PyAny` and `&Bound<PyAny>` use the `as_borrowed()` "
"method:"
msgstr ""

#: src/migration.md:403
msgid ""
"To convert between `Py<T>` and `Bound<T>` use the `bind()` / `into_bound()` "
"methods, and `as_unbound()` / `unbind()` to go back from `Bound<T>` to "
"`Py<T>`."
msgstr ""

#: src/migration.md:416
msgid "‚ö†Ô∏è Warning: dangling pointer trap üí£"
msgstr ""

#: src/migration.md:418
msgid ""
"Because of the ownership changes, code which uses `.as_ptr()` to convert "
"`&PyAny` and other GIL Refs to a `*mut pyo3_ffi::PyObject` should take care "
"to avoid creating dangling pointers now that `Bound<PyAny>` carries "
"ownership."
msgstr ""

#: src/migration.md:420
msgid ""
"For example, the following pattern with `Option<&PyAny>` can easily create a "
"dangling pointer when migrating to the `Bound<PyAny>` smart pointer:"
msgstr ""

#: src/migration.md:427
msgid ""
"The correct way to migrate this code is to use `.as_ref()` to avoid dropping "
"the `Bound<PyAny>` in the `map_or` closure:"
msgstr ""

#: src/migration.md:435
msgid "Migrating `FromPyObject` implementations"
msgstr ""

#: src/migration.md:437
msgid ""
"`FromPyObject` has had a new method `extract_bound` which takes `&Bound<'py, "
"PyAny>` as an argument instead of `&PyAny`. Both `extract` and "
"`extract_bound` have been given default implementations in terms of the "
"other, to avoid breaking code immediately on update to 0.21."
msgstr ""

#: src/migration.md:439
msgid ""
"All implementations of `FromPyObject` should be switched from `extract` to "
"`extract_bound`."
msgstr ""

#: src/migration.md:446 src/migration.md:456
msgid "/* ... */"
msgstr ""

#: src/migration.md:461
msgid ""
"The expectation is that in 0.22 `extract_bound` will have the default "
"implementation removed and in 0.23 `extract` will be removed."
msgstr ""

#: src/migration.md:463
msgid "Cases where PyO3 cannot emit GIL Ref deprecation warnings"
msgstr ""

#: src/migration.md:465
msgid ""
"Despite a large amount of deprecations warnings produced by PyO3 to aid with "
"the transition from GIL Refs to the Bound API, there are a few cases where "
"PyO3 cannot automatically warn on uses of GIL Refs. It is worth checking for "
"these cases manually after the deprecation warnings have all been addressed:"
msgstr ""

#: src/migration.md:467
msgid ""
"Individual implementations of the `FromPyObject` trait cannot be deprecated, "
"so PyO3 cannot warn about uses of code patterns like `.extract<&PyAny>()` "
"which produce a GIL Ref."
msgstr ""

#: src/migration.md:468
msgid ""
"GIL Refs in `#[pyfunction]` arguments emit a warning, but if the GIL Ref is "
"wrapped inside another container such as `Vec<&PyAny>` then PyO3 cannot warn "
"against this."
msgstr ""

#: src/migration.md:469
msgid ""
"The `wrap_pyfunction!(function)(py)` deferred argument form of the "
"`wrap_pyfunction` macro taking `py: Python<'py>` produces a GIL Ref, and due "
"to limitations in type inference PyO3 cannot warn against this specific case."
msgstr ""

#: src/migration.md:473
msgid "Deactivating the `gil-refs` feature"
msgstr ""

#: src/migration.md:477
msgid ""
"As a final step of migration, deactivating the `gil-refs` feature will set "
"up code for best performance and is intended to set up a forward-compatible "
"API for PyO3 0.22."
msgstr ""

#: src/migration.md:479
msgid ""
"At this point code that needed to manage GIL Ref memory can safely remove "
"uses of `GILPool` (which are constructed by calls to `Python::new_pool` and "
"`Python::with_pool`). Deprecation warnings will highlight these cases."
msgstr ""

#: src/migration.md:481
msgid ""
"There is just one case of code that changes upon disabling these features: "
"`FromPyObject` trait implementations for types that borrow directly from the "
"input data cannot be implemented by PyO3 without GIL Refs (while the GIL "
"Refs API is in the process of being removed). The main types affected are "
"`&str`, `Cow<'_, str>`, `&[u8]`, `Cow<'_, u8>`."
msgstr ""

#: src/migration.md:483
msgid ""
"To make PyO3's core functionality continue to work while the GIL Refs API is "
"in the process of being removed, disabling the `gil-refs` feature moves the "
"implementations of `FromPyObject` for `&str`, `Cow<'_, str>`, `&[u8]`, "
"`Cow<'_, u8>` to a new temporary trait `FromPyObjectBound`. This trait is "
"the expected future form of `FromPyObject` and has an additional lifetime "
"`'a` to enable these types to borrow data from Python objects."
msgstr ""

#: src/migration.md:485
msgid ""
"PyO3 0.21 has introduced the [`PyBackedStr`](https://pyo3.rs/main/doc/pyo3/"
"pybacked/struct.PyBackedStr.html) and [`PyBackedBytes`](https://pyo3.rs/main/"
"doc/pyo3/pybacked/struct.PyBackedBytes.html) types to help with this case. "
"The easiest way to avoid lifetime challenges from extracting `&str` is to "
"use these. For more complex types like `Vec<&str>`, is now impossible to "
"extract directly from a Python object and `Vec<PyBackedStr>` is the "
"recommended upgrade path."
msgstr ""

#: src/migration.md:487
msgid ""
"A key thing to note here is because extracting to these types now ties them "
"to the input lifetime, some extremely common patterns may need to be split "
"into multiple Rust lines. For example, the following snippet of calling `."
"extract::<&str>()` directly on the result of `.getattr()` needs to be "
"adjusted when deactivating the `gil-refs` feature."
msgstr ""

#: src/migration.md:492
msgid "\"gil-refs\""
msgstr ""

#: src/migration.md:496
msgid "// GIL Ref API\n"
msgstr ""

#: src/migration.md:498 src/migration.md:514 src/migration.md:535
msgid "\"__name__\""
msgstr ""

#: src/migration.md:499 src/migration.md:518 src/migration.md:536
msgid "\"list\""
msgstr ""

#: src/migration.md:514
msgid ""
"// the lifetime of the data is no longer `'py` but the much shorter\n"
"// lifetime of the `name_obj` smart pointer above\n"
msgstr ""

#: src/migration.md:525
msgid ""
"To avoid needing to worry about lifetimes at all, it is also possible to use "
"the new `PyBackedStr` type, which stores a reference to the Python `str` "
"without a lifetime attachment. In particular, `PyBackedStr` helps for `abi3` "
"builds for Python older than 3.10. Due to limitations in the `abi3` CPython "
"API for those older versions, PyO3 cannot offer a `FromPyObjectBound` "
"implementation for `&str` on those versions. The easiest way to migrate for "
"older `abi3` builds is to replace any cases of `.extract::<&str>()` with `."
"extract::<PyBackedStr>()`. Alternatively, use `.extract::<Cow<str>>()`, `."
"extract::<String>()` to copy the data into Rust."
msgstr ""

#: src/migration.md:527
msgid ""
"The following example uses the same snippet as those just above, but this "
"time the final extracted type is `PyBackedStr`:"
msgstr ""

#: src/migration.md:543
msgid "from 0.19.\\* to 0.20"
msgstr ""

#: src/migration.md:545 src/migration.md:1049
msgid "Drop support for older technologies"
msgstr ""

#: src/migration.md:549
msgid ""
"PyO3 0.20 has increased minimum Rust version to 1.56. This enables use of "
"newer language features and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:552
msgid "`PyDict::get_item` now returns a `Result`"
msgstr ""

#: src/migration.md:556
msgid ""
"`PyDict::get_item` in PyO3 0.19 and older was implemented using a Python API "
"which would suppress all exceptions and return `None` in those cases. This "
"included errors in `__hash__` and `__eq__` implementations of the key being "
"looked up."
msgstr ""

#: src/migration.md:558
msgid ""
"Newer recommendations by the Python core developers advise against using "
"these APIs which suppress exceptions, instead allowing exceptions to bubble "
"upwards. `PyDict::get_item_with_error` already implemented this recommended "
"behavior, so that API has been renamed to `PyDict::get_item`."
msgstr ""

#: src/migration.md:571 src/migration.md:573 src/migration.md:595
#: src/migration.md:597
msgid "\"a\""
msgstr ""

#: src/migration.md:572 src/migration.md:596
msgid "// `a` is in the dictionary, with value 1\n"
msgstr ""

#: src/migration.md:574 src/migration.md:598
msgid "// `b` is not in the dictionary\n"
msgstr ""

#: src/migration.md:575 src/migration.md:599
msgid "\"b\""
msgstr ""

#: src/migration.md:576 src/migration.md:600
msgid "// `dict` is not hashable, so this fails with a `TypeError`\n"
msgstr ""

#: src/migration.md:612
msgid "Required arguments are no longer accepted after optional arguments"
msgstr ""

#: src/migration.md:616
msgid ""
"[Trailing `Option<T>` arguments](./function/signature.md#trailing-optional-"
"arguments) have an automatic default of `None`. To avoid unwanted changes "
"when modifying function signatures, in PyO3 0.18 it was deprecated to have a "
"required argument after an `Option<T>` argument without using "
"`#[pyo3(signature = (...))]` to specify the intended defaults. In PyO3 0.20, "
"this becomes a hard error."
msgstr ""

#: src/migration.md:634
msgid "// both x and y have no defaults and are required\n"
msgstr ""

#: src/migration.md:641
msgid "Remove deprecated function forms"
msgstr ""

#: src/migration.md:645
msgid ""
"In PyO3 0.18 the `#[args]` attribute for `#[pymethods]`, and directly "
"specifying the function signature in `#[pyfunction]`, was deprecated. This "
"functionality has been removed in PyO3 0.20."
msgstr ""

#: src/migration.md:651
msgid "\"0\""
msgstr ""

#: src/migration.md:651
msgid "\"/\""
msgstr ""

#: src/migration.md:672
msgid "`IntoPyPointer` trait removed"
msgstr ""

#: src/migration.md:676
msgid ""
"The trait `IntoPyPointer`, which provided the `into_ptr` method on many "
"types, has been removed. `into_ptr` is now available as an inherent method "
"on all types that previously implemented this trait."
msgstr ""

#: src/migration.md:679
msgid "`AsPyPointer` now `unsafe` trait"
msgstr ""

#: src/migration.md:683
msgid ""
"The trait `AsPyPointer` is now `unsafe trait`, meaning any external "
"implementation of it must be marked as `unsafe impl`, and ensure that they "
"uphold the invariant of returning valid pointers."
msgstr ""

#: src/migration.md:686
msgid "from 0.18.\\* to 0.19"
msgstr ""

#: src/migration.md:688
msgid ""
"Access to `Python` inside `__traverse__` implementations are now forbidden"
msgstr ""

#: src/migration.md:692
msgid ""
"During `__traverse__` implementations for Python's Garbage Collection it is "
"forbidden to do anything other than visit the members of the `#[pyclass]` "
"being traversed. This means making Python function calls or other API calls "
"are forbidden."
msgstr ""

#: src/migration.md:694
msgid ""
"Previous versions of PyO3 would allow access to `Python` (e.g. via `Python::"
"with_gil`), which could cause the Python interpreter to crash or otherwise "
"confuse the garbage collection algorithm."
msgstr ""

#: src/migration.md:696
msgid ""
"Attempts to acquire the GIL will now panic. See [\\#3165](https://github.com/"
"PyO3/pyo3/issues/3165) for more detail."
msgstr ""

#: src/migration.md:706
msgid "/*...*/"
msgstr ""

#: src/migration.md:706
msgid "// ERROR: this will panic\n"
msgstr ""

#: src/migration.md:712
msgid ""
"Smarter `anyhow::Error` / `eyre::Report` conversion when inner error is "
"\"simple\" `PyErr`"
msgstr ""

#: src/migration.md:716
msgid ""
"When converting from `anyhow::Error` or `eyre::Report` to `PyErr`, if the "
"inner error is a \"simple\" `PyErr` (with no source error), then the inner "
"error will be used directly as the `PyErr` instead of wrapping it in a new "
"`PyRuntimeError` with the original information converted into a string."
msgstr ""

#: src/migration.md:719
msgid "\"anyhow\""
msgstr ""

#: src/migration.md:726
msgid "\"original error message\""
msgstr ""

#: src/migration.md:735
msgid ""
"r\"\n"
"        try:\n"
"            rs_func()\n"
"        except Exception as e:\n"
"            print(repr(e))\n"
"        \""
msgstr ""

#: src/migration.md:747
msgid ""
"Before, the above code would have printed `RuntimeError('ValueError: "
"original error message')`, which might be confusing."
msgstr ""

#: src/migration.md:749
msgid ""
"After, the same code will print `ValueError: original error message`, which "
"is more straightforward."
msgstr ""

#: src/migration.md:751
msgid ""
"However, if the `anyhow::Error` or `eyre::Report` has a source, then the "
"original exception will still be wrapped in a `PyRuntimeError`."
msgstr ""

#: src/migration.md:754
msgid ""
"The deprecated `Python::acquire_gil` was removed and `Python::with_gil` must "
"be used instead"
msgstr ""

#: src/migration.md:758
msgid ""
"While the API provided by [`Python::acquire_gil`](https://docs.rs/"
"pyo3/0.18.3/pyo3/marker/struct.Python.html#method.acquire_gil) seems "
"convenient, it is somewhat brittle as the design of the GIL token [`Python`]"
"(https://docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html) relies on "
"proper nesting and panics if not used correctly, e.g."
msgstr ""

#: src/migration.md:782
msgid "// Panics because the guard within `second` is still alive.\n"
msgstr ""

#: src/migration.md:788
msgid ""
"The replacement is [`Python::with_gil`](https://docs.rs/pyo3/0.18.3/pyo3/"
"marker/struct.Python.html#method.with_gil) which is more cumbersome but "
"enforces the proper nesting by design, e.g."
msgstr ""

#: src/migration.md:808
msgid "// It either forces us to release the GIL before aquiring it again.\n"
msgstr ""

#: src/migration.md:814
msgid "// Or it ensures releasing the inner lock before the outer one.\n"
msgstr ""

#: src/migration.md:824
msgid ""
"Furthermore, `Python::acquire_gil` provides ownership of a `GILGuard` which "
"can be freely stored and passed around. This is usually not helpful as it "
"may keep the lock held for a long time thereby blocking progress in other "
"parts of the program. Due to the generative lifetime attached to the GIL "
"token supplied by `Python::with_gil`, the problem is avoided as the GIL "
"token can only be passed down the call chain. Often, this issue can also be "
"avoided entirely as any GIL-bound reference `&'py PyAny` implies access to a "
"GIL token `Python<'py>` via the [`PyAny::py`](https://docs.rs/pyo3/latest/"
"pyo3/types/struct.PyAny.html#method.py) method."
msgstr ""

#: src/migration.md:827
msgid "from 0.17.\\* to 0.18"
msgstr ""

#: src/migration.md:829
msgid ""
"Required arguments after `Option<_>` arguments will no longer be "
"automatically inferred"
msgstr ""

#: src/migration.md:833
msgid ""
"In `#[pyfunction]` and `#[pymethods]`, if a \"required\" function input such "
"as `i32` came after an `Option<_>` input, then the `Option<_>` would be "
"implicitly treated as required. (All trailing `Option<_>` arguments were "
"treated as optional with a default value of `None`)."
msgstr ""

#: src/migration.md:835
msgid ""
"Starting with PyO3 0.18, this is deprecated and a future PyO3 version will "
"require a [`#[pyo3(signature = (...))]` option](./function/signature.md) to "
"explicitly declare the programmer's intention."
msgstr ""

#: src/migration.md:837
msgid ""
"Before, x in the below example would be required to be passed from Python "
"code:"
msgstr ""

#: src/migration.md:847
msgid "After, specify the intended Python signature explicitly:"
msgstr ""

#: src/migration.md:852
msgid "// If x really was intended to be required\n"
msgstr ""

#: src/migration.md:856
msgid "// If x was intended to be optional, y needs a default too\n"
msgstr ""

#: src/migration.md:863
msgid ""
"`__text_signature__` is now automatically generated for `#[pyfunction]` and "
"`#[pymethods]`"
msgstr ""

#: src/migration.md:867
msgid ""
"The [`#[pyo3(text_signature = \"...\")]` option](./function/signature."
"md#making-the-function-signature-available-to-python) was previously the "
"only supported way to set the `__text_signature__` attribute on generated "
"Python functions."
msgstr ""

#: src/migration.md:869
msgid ""
"PyO3 is now able to automatically populate `__text_signature__` for all "
"functions automatically based on their Rust signature (or the [new "
"`#[pyo3(signature = (...))]` option](./function/signature.md)). These "
"automatically-generated `__text_signature__` values will currently only "
"render `...` for all default values. Many `#[pyo3(text_signature = \"..."
"\")]` options can be removed from functions when updating to PyO3 0.18, "
"however in cases with default values a manual implementation may still be "
"preferred for now."
msgstr ""

#: src/migration.md:871
msgid "As examples:"
msgstr ""

#: src/migration.md:875
msgid ""
"// The `text_signature` option here is no longer necessary, as PyO3 will "
"automatically\n"
"// generate exactly the same value.\n"
msgstr ""

#: src/migration.md:878 src/migration.md:889
msgid "\"(a, b, c)\""
msgstr ""

#: src/migration.md:880
msgid ""
"// The `text_signature` still provides value here as of PyO3 0.18, because "
"the automatically\n"
"// generated signature would be \"(a, b=..., c=...)\".\n"
msgstr ""

#: src/migration.md:883 src/migration.md:891
msgid "\"(a, b=1, c=2)\""
msgstr ""

#: src/migration.md:889 src/migration.md:891
msgid "\"__text_signature__\""
msgstr ""

#: src/migration.md:897
msgid "from 0.16.\\* to 0.17"
msgstr ""

#: src/migration.md:899
msgid "Type checks have been changed for `PyMapping` and `PySequence` types"
msgstr ""

#: src/migration.md:903
msgid ""
"Previously the type checks for `PyMapping` and `PySequence` (implemented in "
"`PyTryFrom`) used the Python C-API functions `PyMapping_Check` and "
"`PySequence_Check`. Unfortunately these functions are not sufficient for "
"distinguishing such types, leading to inconsistent behavior (see [pyo3/"
"pyo3#2072](https://github.com/PyO3/pyo3/issues/2072))."
msgstr ""

#: src/migration.md:909
msgid ""
"PyO3 0.17 changes these downcast checks to explicitly test if the type is a "
"subclass of the corresponding abstract base class `collections.abc.Mapping` "
"or `collections.abc.Sequence`. Note this requires calling into Python, which "
"may incur a performance penalty over the previous method. If this "
"performance penalty is a problem, you may be able to perform your own checks "
"and use `try_from_unchecked` (unsafe)."
msgstr ""

#: src/migration.md:916
msgid ""
"Another side-effect is that a pyclass defined in Rust with PyO3 will need to "
"be _registered_ with the corresponding Python abstract base class for "
"downcasting to succeed. `PySequence::register` and `PyMapping:register` have "
"been added to make it easy to do this from Rust code. These are equivalent "
"to calling `collections.abc.Mapping.register(MappingPyClass)` or "
"`collections.abc.Sequence.register(SequencePyClass)` from Python."
msgstr ""

#: src/migration.md:923
msgid "For example, for a mapping class defined in Rust:"
msgstr ""

#: src/migration.md:937
msgid ""
"// ...\n"
"    // truncated implementation of this mapping pyclass - basically a "
"wrapper around a HashMap\n"
msgstr ""

#: src/migration.md:942
msgid ""
"You must register the class with `collections.abc.Mapping` before the "
"downcast will work:"
msgstr ""

#: src/migration.md:950
msgid ""
"Note that this requirement may go away in the future when a pyclass is able "
"to inherit from the abstract base class directly (see [pyo3/pyo3#991]"
"(https://github.com/PyO3/pyo3/issues/991))."
msgstr ""

#: src/migration.md:953
msgid "The `multiple-pymethods` feature now requires Rust 1.62"
msgstr ""

#: src/migration.md:957
msgid ""
"Due to limitations in the `inventory` crate which the `multiple-pymethods` "
"feature depends on, this feature now requires Rust 1.62. For more "
"information see [dtolnay/inventory#32](https://github.com/dtolnay/inventory/"
"issues/32)."
msgstr ""

#: src/migration.md:961
msgid "Added `impl IntoPy<Py<PyString>> for &str`"
msgstr ""

#: src/migration.md:965
msgid "This may cause inference errors."
msgstr ""

#: src/migration.md:973
msgid "// Cannot infer either `Py<PyAny>` or `Py<PyString>`\n"
msgstr ""

#: src/migration.md:974 src/migration.md:986
msgid "\"test\""
msgstr ""

#: src/migration.md:979
msgid "After, some type annotations may be necessary:"
msgstr ""

#: src/migration.md:992
msgid "The `pyproto` feature is now disabled by default"
msgstr ""

#: src/migration.md:996
msgid ""
"In preparation for removing the deprecated `#[pyproto]` attribute macro in a "
"future PyO3 version, it is now gated behind an opt-in feature flag. This "
"also gives a slight saving to compile times for code which does not use the "
"deprecated macro."
msgstr ""

#: src/migration.md:999
msgid "`PyTypeObject` trait has been deprecated"
msgstr ""

#: src/migration.md:1003
msgid ""
"The `PyTypeObject` trait already was near-useless; almost all functionality "
"was already on the `PyTypeInfo` trait, which `PyTypeObject` had a blanket "
"implementation based upon. In PyO3 0.17 the final method, `PyTypeObject::"
"type_object` was moved to `PyTypeInfo::type_object`."
msgstr ""

#: src/migration.md:1005
msgid ""
"To migrate, update trait bounds and imports from `PyTypeObject` to "
"`PyTypeInfo`."
msgstr ""

#: src/migration.md:1019 src/migration.md:1091 src/migration.md:1454
msgid "After"
msgstr ""

#: src/migration.md:1033
msgid ""
"`impl<T, const N: usize> IntoPy<PyObject> for [T; N]` now requires `T: "
"IntoPy` rather than `T: ToPyObject`"
msgstr ""

#: src/migration.md:1037
msgid ""
"If this leads to errors, simply implement `IntoPy`. Because pyclasses "
"already implement `IntoPy`, you probably don't need to worry about this."
msgstr ""

#: src/migration.md:1040
msgid "Each `#[pymodule]` can now only be initialized once per process"
msgstr ""

#: src/migration.md:1044
msgid ""
"To make PyO3 modules sound in the presence of Python sub-interpreters, for "
"now it has been necessary to explicitly disable the ability to initialize a "
"`#[pymodule]` more than once in the same process. Attempting to do this will "
"now raise an `ImportError`."
msgstr ""

#: src/migration.md:1047
msgid "from 0.15.\\* to 0.16"
msgstr ""

#: src/migration.md:1053
msgid ""
"PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python "
"version to 3.7. This enables use of newer language features (enabling some "
"of the other additions in 0.16) and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:1056
msgid "`#[pyproto]` has been deprecated"
msgstr ""

#: src/migration.md:1060
msgid ""
"In PyO3 0.15, the `#[pymethods]` attribute macro gained support for "
"implementing \"magic methods\" such as `__str__` (aka \"dunder\" methods). "
"This implementation was not quite finalized at the time, with a few edge "
"cases to be decided upon. The existing `#[pyproto]` attribute macro was left "
"untouched, because it covered these edge cases."
msgstr ""

#: src/migration.md:1062
msgid ""
"In PyO3 0.16, the `#[pymethods]` implementation has been completed and is "
"now the preferred way to implement magic methods. To allow the PyO3 project "
"to move forward, `#[pyproto]` has been deprecated (with expected removal in "
"PyO3 0.18)."
msgstr ""

#: src/migration.md:1064
msgid ""
"Migration from `#[pyproto]` to `#[pymethods]` is straightforward; copying "
"the existing methods directly from the `#[pyproto]` trait implementation is "
"all that is needed in most cases."
msgstr ""

#: src/migration.md:1079 src/migration.md:1103 src/migration.md:1289
#: src/migration.md:1305
msgid "b\"hello, world\""
msgstr ""

#: src/migration.md:1086 src/migration.md:1107
msgid "\"hello, world\""
msgstr ""

#: src/migration.md:1113
msgid "Removed `PartialEq` for object wrappers"
msgstr ""

#: src/migration.md:1117
msgid ""
"The Python object wrappers `Py` and `PyAny` had implementations of "
"`PartialEq` so that `object_a == object_b` would compare the Python objects "
"for pointer equality, which corresponds to the `is` operator, not the `==` "
"operator in Python.  This has been removed in favor of a new method: use "
"`object_a.is(object_b)`.  This also has the advantage of not requiring the "
"same wrapper type for `object_a` and `object_b`; you can now directly "
"compare a `Py<T>` with a `&PyAny` without having to convert."
msgstr ""

#: src/migration.md:1125
msgid ""
"To check for Python object equality (the Python `==` operator), use the new "
"method `eq()`."
msgstr ""

#: src/migration.md:1129
msgid "Container magic methods now match Python behavior"
msgstr ""

#: src/migration.md:1133
msgid ""
"In PyO3 0.15, `__getitem__`, `__setitem__` and `__delitem__` in "
"`#[pymethods]` would generate only the _mapping_ implementation for a "
"`#[pyclass]`. To match the Python behavior, these methods now generate both "
"the _mapping_ **and** _sequence_ implementations."
msgstr ""

#: src/migration.md:1135
msgid ""
"This means that classes implementing these `#[pymethods]` will now also be "
"treated as sequences, same as a Python `class` would be. Small differences "
"in behavior may result:"
msgstr ""

#: src/migration.md:1136
msgid ""
"PyO3 will allow instances of these classes to be cast to `PySequence` as "
"well as `PyMapping`."
msgstr ""

#: src/migration.md:1137
msgid ""
"Python will provide a default implementation of `__iter__` (if the class did "
"not have one) which repeatedly calls `__getitem__` with integers (starting "
"at 0) until an `IndexError` is raised."
msgstr ""

#: src/migration.md:1139
msgid "To explain this in detail, consider the following Python class:"
msgstr ""

#: src/migration.md:1153
msgid ""
"This class implements a Python [sequence](https://docs.python.org/3/glossary."
"html#term-sequence)."
msgstr ""

#: src/migration.md:1155
msgid ""
"The `__len__` and `__getitem__` methods are also used to implement a Python "
"[mapping](https://docs.python.org/3/glossary.html#term-mapping). In the "
"Python C-API, these methods are not shared: the sequence `__len__` and "
"`__getitem__` are defined by the `sq_length` and `sq_item` slots, and the "
"mapping equivalents are `mp_length` and `mp_subscript`. There are similar "
"distinctions for `__setitem__` and `__delitem__`."
msgstr ""

#: src/migration.md:1157
msgid ""
"Because there is no such distinction from Python, implementing these methods "
"will fill the mapping and sequence slots simultaneously. A Python class with "
"`__len__` implemented, for example, will have both the `sq_length` and "
"`mp_length` slots filled."
msgstr ""

#: src/migration.md:1159
msgid ""
"The PyO3 behavior in 0.16 has been changed to be closer to this Python "
"behavior by default."
msgstr ""

#: src/migration.md:1162
msgid "`wrap_pymodule!` and `wrap_pyfunction!` now respect privacy correctly"
msgstr ""

#: src/migration.md:1166
msgid ""
"Prior to PyO3 0.16 the `wrap_pymodule!` and `wrap_pyfunction!` macros could "
"use modules and functions whose defining `fn` was not reachable according "
"Rust privacy rules."
msgstr ""

#: src/migration.md:1168
msgid ""
"For example, the following code was legal before 0.16, but in 0.16 is "
"rejected because the `wrap_pymodule!` macro cannot access the "
"`private_submodule` function:"
msgstr ""

#: src/migration.md:1190
msgid ""
"To fix it, make the private submodule visible, e.g. with `pub` or "
"`pub(crate)`."
msgstr ""

#: src/migration.md:1214
msgid "from 0.14.\\* to 0.15"
msgstr ""

#: src/migration.md:1216
msgid "Changes in sequence indexing"
msgstr ""

#: src/migration.md:1220
msgid ""
"For all types that take sequence indices (`PyList`, `PyTuple` and "
"`PySequence`), the API has been made consistent to only take `usize` "
"indices, for consistency with Rust's indexing conventions.  Negative "
"indices, which were only sporadically supported even in APIs that took "
"`isize`, now aren't supported anywhere."
msgstr ""

#: src/migration.md:1226
msgid ""
"Further, the `get_item` methods now always return a `PyResult` instead of "
"panicking on invalid indices.  The `Index` trait has been implemented "
"instead, and provides the same panic behavior as on Rust vectors."
msgstr ""

#: src/migration.md:1230
msgid ""
"Note that _slice_ indices (accepted by `PySequence::get_slice` and other) "
"still inherit the Python behavior of clamping the indices to the actual "
"length, and not panicking/returning an error on out of range indices."
msgstr ""

#: src/migration.md:1234
msgid ""
"An additional advantage of using Rust's indexing conventions for these types "
"is that these types can now also support Rust's indexing operators as part "
"of a consistent API:"
msgstr ""

#: src/migration.md:1244
msgid "\"[1, 2]\""
msgstr ""

#: src/migration.md:1249
msgid "from 0.13.\\* to 0.14"
msgstr ""

#: src/migration.md:1251
msgid "`auto-initialize` feature is now opt-in"
msgstr ""

#: src/migration.md:1255
msgid ""
"For projects embedding Python in Rust, PyO3 no longer automatically "
"initializes a Python interpreter on the first call to `Python::with_gil` (or "
"`Python::acquire_gil`) unless the [`auto-initialize` feature](features."
"md#auto-initialize) is enabled."
msgstr ""

#: src/migration.md:1258
msgid "New `multiple-pymethods` feature"
msgstr ""

#: src/migration.md:1262
msgid ""
"`#[pymethods]` have been reworked with a simpler default implementation "
"which removes the dependency on the `inventory` crate. This reduces "
"dependencies and compile times for the majority of users."
msgstr ""

#: src/migration.md:1264
msgid ""
"The limitation of the new default implementation is that it cannot support "
"multiple `#[pymethods]` blocks for the same `#[pyclass]`. If you need this "
"functionality, you must enable the `multiple-pymethods` feature which will "
"switch `#[pymethods]` to the inventory-based implementation."
msgstr ""

#: src/migration.md:1267
msgid "Deprecated `#[pyproto]` methods"
msgstr ""

#: src/migration.md:1271
msgid ""
"Some protocol (aka `__dunder__`) methods such as `__bytes__` and "
"`__format__` have been possible to implement two ways in PyO3 for some time: "
"via a `#[pyproto]` (e.g. `PyObjectProtocol` for the methods listed here), or "
"by writing them directly in `#[pymethods]`. This is only true for a handful "
"of the `#[pyproto]` methods (for technical reasons to do with the way PyO3 "
"currently interacts with the Python C-API)."
msgstr ""

#: src/migration.md:1273
msgid ""
"In the interest of having only one way to do things, the `#[pyproto]` forms "
"of these methods have been deprecated."
msgstr ""

#: src/migration.md:1275
msgid ""
"To migrate just move the affected methods from a `#[pyproto]` to a "
"`#[pymethods]` block."
msgstr ""

#: src/migration.md:1311
msgid "from 0.12.\\* to 0.13"
msgstr ""

#: src/migration.md:1313
msgid "Minimum Rust version increased to Rust 1.45"
msgstr ""

#: src/migration.md:1317
msgid ""
"PyO3 `0.13` makes use of new Rust language features stabilized between Rust "
"1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, "
"you will need to update your toolchain to be able to continue using PyO3."
msgstr ""

#: src/migration.md:1320
msgid "Runtime changes to support the CPython limited API"
msgstr ""

#: src/migration.md:1324
msgid ""
"In PyO3 `0.13` support was added for compiling against the CPython limited "
"API. This had a number of implications for _all_ PyO3 users, described here."
msgstr ""

#: src/migration.md:1326
msgid ""
"The largest of these is that all types created from PyO3 are what CPython "
"calls \"heap\" types. The specific implications of this are:"
msgstr ""

#: src/migration.md:1328
msgid ""
"If you wish to subclass one of these types _from Rust_ you must mark it "
"`#[pyclass(subclass)]`, as you would if you wished to allow subclassing it "
"from Python code."
msgstr ""

#: src/migration.md:1329
msgid "Type objects are now mutable - Python code can set attributes on them."
msgstr ""

#: src/migration.md:1330
msgid ""
"`__module__` on types without `#[pyclass(module=\"mymodule\")]` no longer "
"returns `builtins`, it now raises `AttributeError`."
msgstr ""

#: src/migration.md:1333
msgid "from 0.11.\\* to 0.12"
msgstr ""

#: src/migration.md:1335
msgid "`PyErr` has been reworked"
msgstr ""

#: src/migration.md:1339
msgid ""
"In PyO3 `0.12` the `PyErr` type has been re-implemented to be significantly "
"more compatible with the standard Rust error handling ecosystem. "
"Specifically `PyErr` now implements `Error + Send + Sync`, which are the "
"standard traits used for error types."
msgstr ""

#: src/migration.md:1343
msgid ""
"While this has necessitated the removal of a number of APIs, the resulting "
"`PyErr` type should now be much more easier to work with. The following "
"sections list the changes in detail and how to migrate to the new APIs."
msgstr ""

#: src/migration.md:1348
msgid ""
"`PyErr::new` and `PyErr::from_type` now require `Send + Sync` for their "
"argument"
msgstr ""

#: src/migration.md:1352
msgid ""
"For most uses no change will be needed. If you are trying to construct "
"`PyErr` from a value that is not `Send + Sync`, you will need to first "
"create the Python object and then use `PyErr::from_instance`."
msgstr ""

#: src/migration.md:1356
msgid ""
"Similarly, any types which implemented `PyErrArguments` will now need to be "
"`Send + Sync`."
msgstr ""

#: src/migration.md:1359
msgid "`PyErr`'s contents are now private"
msgstr ""

#: src/migration.md:1363
msgid ""
"It is no longer possible to access the fields `.ptype`, `.pvalue` and `."
"ptraceback` of a `PyErr`. You should instead now use the new methods `PyErr::"
"ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/migration.md:1367
msgid "`PyErrValue` and `PyErr::from_value` have been removed"
msgstr ""

#: src/migration.md:1371
msgid ""
"As these were part the internals of `PyErr` which have been reworked, these "
"APIs no longer exist."
msgstr ""

#: src/migration.md:1373
msgid ""
"If you used this API, it is recommended to use `PyException::new_err` (see "
"[the section on Exception types](#exception-types-have-been-reworked))."
msgstr ""

#: src/migration.md:1377
msgid "`Into<PyResult<T>>` for `PyErr` has been removed"
msgstr ""

#: src/migration.md:1381
msgid ""
"This implementation was redundant. Just construct the `Result::Err` variant "
"directly."
msgstr ""

#: src/migration.md:1385 src/migration.md:1391 src/migration.md:1406
#: src/migration.md:1415
msgid "\"error message\""
msgstr ""

#: src/migration.md:1388
msgid ""
"After (also using the new reworked exception types; see the following "
"section):"
msgstr ""

#: src/migration.md:1395
msgid "Exception types have been reworked"
msgstr ""

#: src/migration.md:1399
msgid ""
"Previously exception types were zero-sized marker types purely used to "
"construct `PyErr`. In PyO3 0.12, these types have been replaced with full "
"definitions and are usable in the same way as `PyAny`, `PyDict` etc. This "
"makes it possible to interact with Python exception objects."
msgstr ""

#: src/migration.md:1403
msgid ""
"The new types also have names starting with the \"Py\" prefix. For example, "
"before:"
msgstr ""

#: src/migration.md:1416
msgid "// Uses Display for PyErr, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:1418
msgid "\"TypeError: error message\""
msgstr ""

#: src/migration.md:1419
msgid ""
"// Now possible to interact with exception instances, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:1423
msgid "\"__class__\""
msgstr ""

#: src/migration.md:1431
msgid "`FromPy` has been removed"
msgstr ""

#: src/migration.md:1435
msgid ""
"To simplify the PyO3 conversion traits, the `FromPy` trait has been removed. "
"Previously there were two ways to define the to-Python conversion for a "
"type: `FromPy<T> for PyObject` and `IntoPy<PyObject> for T`."
msgstr ""

#: src/migration.md:1439
msgid ""
"Now there is only one way to define the conversion, `IntoPy`, so downstream "
"crates may need to adjust accordingly."
msgstr ""

#: src/migration.md:1467
msgid ""
"Similarly, code which was using the `FromPy` trait can be trivially "
"rewritten to use `IntoPy`."
msgstr ""

#: src/migration.md:1486
msgid "`PyObject` is now a type alias of `Py<PyAny>`"
msgstr ""

#: src/migration.md:1490
msgid ""
"This should change very little from a usage perspective. If you implemented "
"traits for both `PyObject` and `Py<T>`, you may find you can just remove the "
"`PyObject` implementation."
msgstr ""

#: src/migration.md:1494
msgid "`AsPyRef` has been removed"
msgstr ""

#: src/migration.md:1498
msgid ""
"As `PyObject` has been changed to be just a type alias, the only remaining "
"implementor of `AsPyRef` was `Py<T>`. This removed the need for a trait, so "
"the `AsPyRef::as_ref` method has been moved to `Py::as_ref`."
msgstr ""

#: src/migration.md:1502
msgid ""
"This should require no code changes except removing `use pyo3::AsPyRef` for "
"code which did not use `pyo3::prelude::*`."
msgstr ""

#: src/migration.md:1524
msgid "from 0.10.\\* to 0.11"
msgstr ""

#: src/migration.md:1526
msgid "Stable Rust"
msgstr ""

#: src/migration.md:1530
msgid ""
"PyO3 now supports the stable Rust toolchain. The minimum required version is "
"1.39.0."
msgstr ""

#: src/migration.md:1533
msgid "`#[pyclass]` structs must now be `Send` or `unsendable`"
msgstr ""

#: src/migration.md:1537
msgid ""
"Because `#[pyclass]` structs can be sent between threads by the Python "
"interpreter, they must implement `Send` or declared as `unsendable` (by "
"`#[pyclass(unsendable)]`). Note that `unsendable` is added in PyO3 `0.11.1` "
"and `Send` is always required in PyO3 `0.11.0`."
msgstr ""

#: src/migration.md:1541
msgid ""
"This may \"break\" some code which previously was accepted, even though it "
"could be unsound. There can be two fixes:"
msgstr ""

#: src/migration.md:1544
msgid ""
"If you think that your `#[pyclass]` actually must be `Send`able, then let's "
"implement `Send`. A common, safer way is using thread-safe types. E.g., "
"`Arc` instead of `Rc`, `Mutex` instead of `RefCell`, and `Box<dyn Send + T>` "
"instead of `Box<dyn T>`."
msgstr ""

#: src/migration.md:1574
msgid ""
"In situations where you cannot change your `#[pyclass]` to automatically "
"implement `Send` (e.g., when it contains a raw pointer), you can use `unsafe "
"impl Send`. In such cases, care should be taken to ensure the struct is "
"actually thread safe. See [the Rustonomicon](https://doc.rust-lang.org/"
"nomicon/send-and-sync.html) for more."
msgstr ""

#: src/migration.md:1579
msgid ""
"If you think that your `#[pyclass]` should not be accessed by another "
"thread, you can use `unsendable` flag. A class marked with `unsendable` "
"panics when accessed by another thread, making it thread-safe to expose an "
"unsendable object to the Python interpreter."
msgstr ""

#: src/migration.md:1605
msgid "All `PyObject` and `Py<T>` methods now take `Python` as an argument"
msgstr ""

#: src/migration.md:1609
msgid ""
"Previously, a few methods such as `Object::get_refcnt` did not take `Python` "
"as an argument (to ensure that the Python GIL was held by the current "
"thread). Technically, this was not sound. To migrate, just pass a `py` "
"argument to any calls to these methods."
msgstr ""

#: src/migration.md:1628
msgid "from 0.9.\\* to 0.10"
msgstr ""

#: src/migration.md:1630
msgid "`ObjectProtocol` is removed"
msgstr ""

#: src/migration.md:1634
msgid ""
"All methods are moved to [`PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html). And since now all native types (e.g., `PyList`) "
"implements `Deref<Target=PyAny>`, all you need to do is remove "
"`ObjectProtocol` from your code. Or if you use `ObjectProtocol` by `use "
"pyo3::prelude::*`, you have to do nothing."
msgstr ""

#: src/migration.md:1644 src/migration.md:1653
msgid "\"lambda: 'Hi :)'\""
msgstr ""

#: src/migration.md:1660
msgid "No `#![feature(specialization)]` in user code"
msgstr ""

#: src/migration.md:1664
msgid ""
"While PyO3 itself still requires specialization and nightly Rust, now you "
"don't have to use `#![feature(specialization)]` in your crate."
msgstr ""

#: src/migration.md:1668
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:1670
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:1674
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:1706
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](class.md#constructor) of this guide."
msgstr ""

#: src/migration.md:1710
msgid "PyCell"
msgstr ""

#: src/migration.md:1714
msgid ""
"PyO3 0.9 introduces `PyCell`, which is a [`RefCell`](https://doc.rust-lang."
"org/std/cell/struct.RefCell.html)\\-like object wrapper for ensuring Rust's "
"rules regarding aliasing of references are upheld. For more detail, see the "
"[Rust Book's section on Rust's rules of references](https://doc.rust-lang."
"org/book/ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:1719
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:1723
msgid "Here is an example."
msgstr ""

#: src/migration.md:1744
msgid ""
"r\"\n"
"#     try:\n"
"#        names.merge(names)\n"
"#        assert False, 'Unreachable'\n"
"#     except RuntimeError as e:\n"
"#        assert str(e) == 'Already borrowed'\n"
"#     \""
msgstr ""

#: src/migration.md:1753
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/main/doc/pyo3/pycell/"
"struct.PyBorrowMutError.html) exception, since it requires two mutable "
"borrows of `names`."
msgstr ""

#: src/migration.md:1757
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:1759
msgid "Object creation"
msgstr ""

#: src/migration.md:1760
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use `PyCell::new` "
"instead. If you need [`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html), just call `.borrow()` or `.borrow_mut()` on the newly-created "
"`PyCell`."
msgstr ""

#: src/migration.md:1788
msgid "Object extraction"
msgstr ""

#: src/migration.md:1789
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:1809
msgid "\"c\""
msgstr ""

#: src/migration.md:1810
msgid "\"c()\""
msgstr ""

#: src/migration.md:1813
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:1816
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:1823
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:1824
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) implementation. So if your protocol methods take `&T` or `&mut T` "
"(where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) instead."
msgstr ""

#: src/trait-bounds.md:1
msgid "Using in Python a Rust function with trait bounds"
msgstr ""

#: src/trait-bounds.md:3
msgid ""
"PyO3 allows for easy conversion from Rust to Python for certain functions "
"and classes (see the [conversion table](conversions/tables.md)). However, it "
"is not always straightforward to convert Rust code that requires a given "
"trait implementation as an argument."
msgstr ""

#: src/trait-bounds.md:6
msgid ""
"This tutorial explains how to convert a Rust function that takes a trait as "
"argument for use in Python with classes implementing the same methods as the "
"trait."
msgstr ""

#: src/trait-bounds.md:8
msgid "Why is this useful?"
msgstr ""

#: src/trait-bounds.md:10
msgid "Pros"
msgstr ""

#: src/trait-bounds.md:11
msgid "Make your Rust code available to Python users"
msgstr ""

#: src/trait-bounds.md:12
msgid "Code complex algorithms in Rust with the help of the borrow checker"
msgstr ""

#: src/trait-bounds.md:14
msgid "Cons"
msgstr ""

#: src/trait-bounds.md:15
msgid ""
"Not as fast as native Rust (type conversion has to be performed and one part "
"of the code runs in Python)"
msgstr ""

#: src/trait-bounds.md:16
msgid "You need to adapt your code to expose it"
msgstr ""

#: src/trait-bounds.md:18
msgid "Example"
msgstr ""

#: src/trait-bounds.md:20
msgid ""
"Let's work with the following basic example of an implementation of a "
"optimization solver operating on a given model."
msgstr ""

#: src/trait-bounds.md:22
msgid ""
"Let's say we have a function `solve` that operates on a model and mutates "
"its state. The argument of the function can be any model that implements the "
"`Model` trait :"
msgstr ""

#: src/trait-bounds.md:34 src/trait-bounds.md:471
msgid "\"Magic solver that mutates the model into a resolved state\""
msgstr ""

#: src/trait-bounds.md:37
msgid "Let's assume we have the following constraints:"
msgstr ""

#: src/trait-bounds.md:38
msgid "We cannot change that code as it runs on many Rust models."
msgstr ""

#: src/trait-bounds.md:39
msgid ""
"We also have many Python models that cannot be solved as this solver is not "
"available in that language. Rewriting it in Python would be cumbersome and "
"error-prone, as everything is already available in Rust."
msgstr ""

#: src/trait-bounds.md:42
msgid "How could we expose this solver to Python thanks to PyO3 ?"
msgstr ""

#: src/trait-bounds.md:44
msgid "Implementation of the trait bounds for the Python class"
msgstr ""

#: src/trait-bounds.md:46
msgid ""
"If a Python class implements the same three methods as the `Model` trait, it "
"seems logical it could be adapted to use the solver. However, it is not "
"possible to pass a `PyObject` to it as it does not implement the Rust trait "
"(even if the Python model has the required methods)."
msgstr ""

#: src/trait-bounds.md:49
msgid ""
"In order to implement the trait, we must write a wrapper around the calls in "
"Rust to the Python model. The method signatures must be the same as the "
"trait, keeping in mind that the Rust trait cannot be changed for the purpose "
"of making the code available in Python."
msgstr ""

#: src/trait-bounds.md:52
msgid ""
"The Python model we want to expose is the following one, which already "
"contains all the required methods:"
msgstr ""

#: src/trait-bounds.md:64
msgid ""
"The following wrapper will call the Python model from Rust, using a struct "
"to hold the model as a `PyAny` object:"
msgstr ""

#: src/trait-bounds.md:83 src/trait-bounds.md:182 src/trait-bounds.md:360
#: src/trait-bounds.md:419 src/trait-bounds.md:516
msgid "\"Rust calling Python to set the variables\""
msgstr ""

#: src/trait-bounds.md:87 src/trait-bounds.md:185 src/trait-bounds.md:363
#: src/trait-bounds.md:422 src/trait-bounds.md:520
msgid "\"set_variables\""
msgstr ""

#: src/trait-bounds.md:93 src/trait-bounds.md:191 src/trait-bounds.md:349
msgid "\"Rust calling Python to get the results\""
msgstr ""

#: src/trait-bounds.md:97 src/trait-bounds.md:195 src/trait-bounds.md:353
#: src/trait-bounds.md:405 src/trait-bounds.md:531
msgid "\"get_results\""
msgstr ""

#: src/trait-bounds.md:105 src/trait-bounds.md:203 src/trait-bounds.md:369
#: src/trait-bounds.md:428 src/trait-bounds.md:546
msgid "\"Rust calling Python to perform the computation\""
msgstr ""

#: src/trait-bounds.md:109 src/trait-bounds.md:207 src/trait-bounds.md:373
#: src/trait-bounds.md:432 src/trait-bounds.md:550
msgid "\"compute\""
msgstr ""

#: src/trait-bounds.md:116
msgid ""
"Now that this bit is implemented, let's expose the model wrapper to Python. "
"Let's add the PyO3 annotations and add a constructor:"
msgstr ""

#: src/trait-bounds.md:148
msgid "Now we add the PyO3 annotations to the trait implementation:"
msgstr ""

#: src/trait-bounds.md:153
msgid "// the previous trait implementation\n"
msgstr ""

#: src/trait-bounds.md:157
msgid ""
"However, the previous code will not compile. The compilation error is the "
"following one: `error: #[pymethods] cannot be used on trait impl blocks`"
msgstr ""

#: src/trait-bounds.md:160
msgid ""
"That's a bummer! However, we can write a second wrapper around these "
"functions to call them directly. This wrapper will also perform the type "
"conversions between Python and Rust."
msgstr ""

#: src/trait-bounds.md:217 src/trait-bounds.md:500
msgid "\"Set variables from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:222 src/trait-bounds.md:505
msgid "\"Get results from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:227
msgid "\"Compute from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:232
msgid ""
"This wrapper handles the type conversion between the PyO3 requirements and "
"the trait. In order to meet PyO3 requirements, this wrapper must:"
msgstr ""

#: src/trait-bounds.md:234
msgid "return an object of type `PyResult`"
msgstr ""

#: src/trait-bounds.md:235
msgid "use only values, not references in the method signatures"
msgstr ""

#: src/trait-bounds.md:237
msgid "Let's run the file python file:"
msgstr ""

#: src/trait-bounds.md:248
msgid "\"__main__\""
msgstr ""

#: src/trait-bounds.md:254
msgid "\"Print value from Python: \""
msgstr ""

#: src/trait-bounds.md:256
msgid "\"Print value from Python through Rust: \""
msgstr ""

#: src/trait-bounds.md:257
msgid "\"Print value directly from Python: \""
msgstr ""

#: src/trait-bounds.md:260
msgid "This outputs:"
msgstr ""

#: src/trait-bounds.md:274
msgid ""
"We have now successfully exposed a Rust model that implements the `Model` "
"trait to Python!"
msgstr ""

#: src/trait-bounds.md:276
msgid ""
"We will now expose the `solve` function, but before, let's talk about types "
"errors."
msgstr ""

#: src/trait-bounds.md:278
msgid "Type errors in Python"
msgstr ""

#: src/trait-bounds.md:280
msgid ""
"What happens if you have type errors when using Python and how can you "
"improve the error messages?"
msgstr ""

#: src/trait-bounds.md:283
msgid "Wrong types in Python function arguments"
msgstr ""

#: src/trait-bounds.md:285
msgid ""
"Let's assume in the first case that you will use in your Python file "
"`my_rust_model.set_variables(2.0)` instead of `my_rust_model."
"set_variables([2.0])`."
msgstr ""

#: src/trait-bounds.md:287
msgid ""
"The Rust signature expects a vector, which corresponds to a list in Python. "
"What happens if instead of a vector, we pass a single value ?"
msgstr ""

#: src/trait-bounds.md:290
msgid "At the execution of Python, we get :"
msgstr ""

#: src/trait-bounds.md:292
msgid ""
"```block\n"
"File \"main.py\", line 15, in <module>\n"
"   my_rust_model.set_variables(2)\n"
"TypeError\n"
"```"
msgstr ""

#: src/trait-bounds.md:298
msgid ""
"It is a type error and Python points to it, so it's easy to identify and "
"solve."
msgstr ""

#: src/trait-bounds.md:300
msgid "Wrong types in Python method signatures"
msgstr ""

#: src/trait-bounds.md:302
msgid ""
"Let's assume now that the return type of one of the methods of our Model "
"class is wrong, for example the `get_results` method that is expected to "
"return a `Vec<f64>` in Rust, a list in Python."
msgstr ""

#: src/trait-bounds.md:312
msgid "#return self.results <-- this is the expected output\n"
msgstr ""

#: src/trait-bounds.md:315
msgid "This call results in the following panic:"
msgstr ""

#: src/trait-bounds.md:321
msgid ""
"This error code is not helpful for a Python user that does not know anything "
"about Rust, or someone that does not know PyO3 was used to interface the "
"Rust code."
msgstr ""

#: src/trait-bounds.md:323
msgid ""
"However, as we are responsible for making the Rust code available to Python, "
"we can do something about it."
msgstr ""

#: src/trait-bounds.md:325
msgid ""
"The issue is that we called `unwrap` anywhere we could, and therefore any "
"panic from PyO3 will be directly forwarded to the end user."
msgstr ""

#: src/trait-bounds.md:327
msgid ""
"Let's modify the code performing the type conversion to give a helpful error "
"message to the Python user:"
msgstr ""

#: src/trait-bounds.md:329
msgid ""
"We used in our `get_results` method the following call that performs the "
"type conversion:"
msgstr ""

#: src/trait-bounds.md:380
msgid "Let's break it down in order to perform better error handling:"
msgstr ""

#: src/trait-bounds.md:400 src/trait-bounds.md:526
msgid "\"Get results from Rust calling Python\""
msgstr ""

#: src/trait-bounds.md:410 src/trait-bounds.md:536
msgid "\"Expected a list for the get_results() method signature, got {}\""
msgstr ""

#: src/trait-bounds.md:439
msgid ""
"By doing so, you catch the result of the Python computation and check its "
"type in order to be able to deliver a better error message before performing "
"the unwrapping."
msgstr ""

#: src/trait-bounds.md:441
msgid ""
"Of course, it does not cover all the possible wrong outputs: the user could "
"return a list of strings instead of a list of floats. In this case, a "
"runtime panic would still occur due to PyO3, but with an error message much "
"more difficult to decipher for non-rust user."
msgstr ""

#: src/trait-bounds.md:445
msgid ""
"It is up to the developer exposing the rust code to decide how much effort "
"to invest into Python type error handling and improved error messages."
msgstr ""

#: src/trait-bounds.md:447
msgid "The final code"
msgstr ""

#: src/trait-bounds.md:449
msgid ""
"Now let's expose the `solve()` function to make it available from Python."
msgstr ""

#: src/trait-bounds.md:451
msgid ""
"It is not possible to directly expose the `solve` function to Python, as the "
"type conversion cannot be performed. It requires an object implementing the "
"`Model` trait as input."
msgstr ""

#: src/trait-bounds.md:454
msgid ""
"However, the `UserModel` already implements this trait. Because of this, we "
"can write a function wrapper that takes the `UserModel`\\--which has already "
"been exposed to Python--as an argument in order to call the core function "
"`solve`."
msgstr ""

#: src/trait-bounds.md:457
msgid "It is also required to make the struct public."
msgstr ""

#: src/trait-bounds.md:475
msgid "\"solve\""
msgstr ""

#: src/python-typing-hints.md:1
msgid "Typing and IDE hints for your Python package"
msgstr ""

#: src/python-typing-hints.md:3
msgid ""
"PyO3 provides an easy to use interface to code native Python libraries in "
"Rust. The accompanying Maturin allows you to build and publish them as a "
"package. Yet, for a better user experience, Python libraries should provide "
"typing hints and documentation for all public entities, so that IDEs can "
"show them during development and type analyzing tools such as `mypy` can use "
"them to properly verify the code."
msgstr ""

#: src/python-typing-hints.md:5
msgid ""
"Currently the best solution for the problem is to manually maintain `*.pyi` "
"files and ship them along with the package."
msgstr ""

#: src/python-typing-hints.md:7
msgid ""
"There is a sketch of a roadmap towards completing [the `experimental-"
"inspect` feature](./features.md#experimental-inspect) which may eventually "
"lead to automatic type annotations generated by PyO3. This needs more "
"testing and implementation, please see [issue #2454](https://github.com/PyO3/"
"pyo3/issues/2454)."
msgstr ""

#: src/python-typing-hints.md:9
msgid "Introduction to `pyi` files"
msgstr ""

#: src/python-typing-hints.md:11
msgid ""
"`pyi` files (an abbreviation for `Python Interface`) are called \"stub "
"files\" in most of the documentation related to them. A very good definition "
"of what it is can be found in [old MyPy documentation](https://github.com/"
"python/mypy/wiki/Creating-Stubs-For-Python-Modules):"
msgstr ""

#: src/python-typing-hints.md:13
msgid ""
"A stubs file only contains a description of the public interface of the "
"module without any implementations."
msgstr ""

#: src/python-typing-hints.md:15
msgid ""
"There is also [extensive documentation on type stubs on the official Python "
"typing documentation](https://typing.readthedocs.io/en/latest/source/stubs."
"html)."
msgstr ""

#: src/python-typing-hints.md:17
msgid ""
"Most Python developers probably already encountered them when trying to use "
"their IDE's \"Go to Definition\" function on any builtin type. For example, "
"the definitions of a few standard exceptions look like this:"
msgstr ""

#: src/python-typing-hints.md:40
msgid ""
"As we can see, those are not full definitions containing implementation, but "
"just a description of the interface. It is usually all that the user of the "
"library needs."
msgstr ""

#: src/python-typing-hints.md:42
msgid "What do the PEPs say?"
msgstr ""

#: src/python-typing-hints.md:44
msgid ""
"At the time of writing this documentation, the `pyi` files are referenced in "
"three PEPs."
msgstr ""

#: src/python-typing-hints.md:46
msgid ""
"[PEP8 - Style Guide for Python Code - #Function Annotations](https://www."
"python.org/dev/peps/pep-0008/#function-annotations) (last point) recommends "
"all third party library creators to provide stub files as the source of "
"knowledge about the package for type checker tools."
msgstr ""

#: src/python-typing-hints.md:48
msgid ""
"(...) it is expected that users of third party library packages may want to "
"run type checkers over those packages. For this purpose [PEP 484](https://"
"www.python.org/dev/peps/pep-0484) recommends the use of stub files: .pyi "
"files that are read by the type checker in preference of the corresponding ."
"py files. (...)"
msgstr ""

#: src/python-typing-hints.md:50
msgid ""
"[PEP484 - Type Hints - #Stub Files](https://www.python.org/dev/peps/pep-0484/"
"#stub-files) defines stub files as follows."
msgstr ""

#: src/python-typing-hints.md:52
msgid ""
"Stub files are files containing type hints that are only for use by the type "
"checker, not at runtime."
msgstr ""

#: src/python-typing-hints.md:54
msgid ""
"It contains a specification for them (highly recommended reading, since it "
"contains at least one thing that is not used in normal Python code) and also "
"some general information about where to store the stub files."
msgstr ""

#: src/python-typing-hints.md:56
msgid ""
"[PEP561 - Distributing and Packaging Type Information](https://www.python."
"org/dev/peps/pep-0561/) describes in detail how to build packages that will "
"enable type checking. In particular it contains information about how the "
"stub files must be distributed in order for type checkers to use them."
msgstr ""

#: src/python-typing-hints.md:58
msgid "How to do it?"
msgstr ""

#: src/python-typing-hints.md:60
msgid ""
"[PEP561](https://www.python.org/dev/peps/pep-0561/) recognizes three ways of "
"distributing type information:"
msgstr ""

#: src/python-typing-hints.md:62
msgid "`inline` - the typing is placed directly in source (`py`) files;"
msgstr ""

#: src/python-typing-hints.md:63
msgid ""
"`separate package with stub files` - the typing is placed in `pyi` files "
"distributed in their own, separate package;"
msgstr ""

#: src/python-typing-hints.md:64
msgid ""
"`in-package stub files` - the typing is placed in `pyi` files distributed in "
"the same package as source files."
msgstr ""

#: src/python-typing-hints.md:66
msgid ""
"The first way is tricky with PyO3 since we do not have `py` files. When it "
"has been investigated and necessary changes are implemented, this document "
"will be updated."
msgstr ""

#: src/python-typing-hints.md:68
msgid ""
"The second way is easy to do, and the whole work can be fully separated from "
"the main library code. The example repo for the package with stub files can "
"be found in [PEP561 references section](https://www.python.org/dev/peps/"
"pep-0561/#references): [Stub package repository](https://github.com/ethanhs/"
"stub-package)"
msgstr ""

#: src/python-typing-hints.md:70
msgid "The third way is described below."
msgstr ""

#: src/python-typing-hints.md:72
msgid "Including `pyi` files in your PyO3/Maturin build package"
msgstr ""

#: src/python-typing-hints.md:74
msgid ""
"When source files are in the same package as stub files, they should be "
"placed next to each other. We need a way to do that with Maturin. Also, in "
"order to mark our package as typing-enabled we need to add an empty file "
"named `py.typed` to the package."
msgstr ""

#: src/python-typing-hints.md:76
msgid "If you do not have other Python files"
msgstr ""

#: src/python-typing-hints.md:78
msgid ""
"If you do not need to add any other Python files apart from `pyi` to the "
"package, Maturin provides a way to do most of the work for you. As "
"documented in the [Maturin Guide](https://github.com/PyO3/maturin/#mixed-"
"rustpython-projects), the only thing you need to do is to create a stub file "
"for your module named `<module_name>.pyi` in your project root and Maturin "
"will do the rest."
msgstr ""

#: src/python-typing-hints.md:89
msgid ""
"For an example `pyi` file see the [`my_project.pyi` content](#my_projectpyi-"
"content) section."
msgstr ""

#: src/python-typing-hints.md:91
msgid "If you need other Python files"
msgstr ""

#: src/python-typing-hints.md:93
msgid ""
"If you need to add other Python files apart from `pyi` to the package, you "
"can do it also, but that requires some more work. Maturin provides an easy "
"way to add files to a package ([documentation](https://github.com/PyO3/"
"maturin/blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-"
"rustpython-projects)). You just need to create a folder with the name of "
"your module next to the `Cargo.toml` file (for customization see "
"documentation linked above)."
msgstr ""

#: src/python-typing-hints.md:95
msgid "The folder structure would be:"
msgstr ""

#: src/python-typing-hints.md:111
msgid ""
"Let's go a little bit more into detail regarding the files inside the "
"package folder."
msgstr ""

#: src/python-typing-hints.md:113
msgid "`__init__.py` content"
msgstr ""

#: src/python-typing-hints.md:115
msgid ""
"As we now specify our own package content, we have to provide the `__init__."
"py` file, so the folder is treated as a package and we can import things "
"from it. We can always use the same content that Maturin creates for us if "
"we do not specify a Python source folder. For PyO3 bindings it would be:"
msgstr ""

#: src/python-typing-hints.md:121
msgid ""
"That way everything that is exposed by our native module can be imported "
"directly from the package."
msgstr ""

#: src/python-typing-hints.md:123
msgid "`py.typed` requirement"
msgstr ""

#: src/python-typing-hints.md:125
msgid "As stated in [PEP561](https://www.python.org/dev/peps/pep-0561/):"
msgstr ""

#: src/python-typing-hints.md:126
msgid ""
"Package maintainers who wish to support type checking of their code MUST add "
"a marker file named py.typed to their package supporting typing. This marker "
"applies recursively: if a top-level package includes it, all its sub-"
"packages MUST support type checking as well."
msgstr ""

#: src/python-typing-hints.md:128
msgid ""
"If we do not include that file, some IDEs might still use our `pyi` files to "
"show hints, but the type checkers might not. MyPy will raise an error in "
"this situation:"
msgstr ""

#: src/python-typing-hints.md:130
msgid ""
"```text\n"
"error: Skipping analyzing \"my_project\": found module but no type hints or "
"library stubs\n"
"```"
msgstr ""

#: src/python-typing-hints.md:134
msgid "The file is just a marker file, so it should be empty."
msgstr ""

#: src/python-typing-hints.md:136
msgid "`my_project.pyi` content"
msgstr ""

#: src/python-typing-hints.md:138
msgid ""
"Our module stub file. This document does not aim at describing how to write "
"them, since you can find a lot of documentation on it, starting from the "
"already quoted [PEP484](https://www.python.org/dev/peps/pep-0484/#stub-"
"files)."
msgstr ""

#: src/python-typing-hints.md:140
msgid "The example can look like this:"
msgstr ""

#: src/python-typing-hints.md:144
msgid ""
"\"\"\"\n"
"    A class representing a car.\n"
"\n"
"    :param body_type: the name of body type, e.g. hatchback, sedan\n"
"    :param horsepower: power of the engine in horsepower\n"
"    \"\"\""
msgstr ""

#: src/python-typing-hints.md:153
msgid "'Car'"
msgstr ""

#: src/python-typing-hints.md:154
msgid ""
"\"\"\"\n"
"        Creates a Car based on unique name\n"
"\n"
"        :param name: model name of a car to be created\n"
"        :return: a Car instance with default data\n"
"        \"\"\""
msgstr ""

#: src/python-typing-hints.md:162
msgid ""
"\"\"\"\n"
"        Gets the best color for the car.\n"
"\n"
"        :return: the name of the color our great algorithm thinks is the "
"best for this car\n"
"        \"\"\""
msgstr ""

#: src/building-and-distribution.md:1
msgid "Building and distribution"
msgstr ""

#: src/building-and-distribution.md:3
msgid ""
"This chapter of the guide goes into detail on how to build and distribute "
"projects using PyO3. The way to achieve this is very different depending on "
"whether the project is a Python module implemented in Rust, or a Rust binary "
"embedding Python. For both types of project there are also common problems "
"such as the Python version to build for and the [linker](https://en."
"wikipedia.org/wiki/Linker_(computing)) arguments to use."
msgstr ""

#: src/building-and-distribution.md:5
msgid ""
"The material in this chapter is intended for users who have already read the "
"PyO3 [README](./index.md). It covers in turn the choices that can be made "
"for Python modules and for Rust binaries. There is also a section at the end "
"about cross-compiling projects using PyO3."
msgstr ""

#: src/building-and-distribution.md:7
msgid ""
"There is an additional sub-chapter dedicated to [supporting multiple Python "
"versions](./building-and-distribution/multiple-python-versions.md)."
msgstr ""

#: src/building-and-distribution.md:9
msgid "Configuring the Python version"
msgstr ""

#: src/building-and-distribution.md:11
msgid ""
"PyO3 uses a build script (backed by the [`pyo3-build-config`](https://github."
"com/PyO3/pyo3/tree/main/pyo3-build-config) crate) to determine the Python "
"version and set the correct linker arguments. By default it will attempt to "
"use the following in order:"
msgstr ""

#: src/building-and-distribution.md:12
msgid "Any active Python virtualenv."
msgstr ""

#: src/building-and-distribution.md:13
msgid "The `python` executable (if it's a Python 3 interpreter)."
msgstr ""

#: src/building-and-distribution.md:14
msgid "The `python3` executable."
msgstr ""

#: src/building-and-distribution.md:16
msgid ""
"You can override the Python interpreter by setting the `PYO3_PYTHON` "
"environment variable, e.g. `PYO3_PYTHON=python3.7`, `PYO3_PYTHON=/usr/bin/"
"python3.9`, or even a PyPy interpreter `PYO3_PYTHON=pypy3`."
msgstr ""

#: src/building-and-distribution.md:18
msgid ""
"Once the Python interpreter is located, `pyo3-build-config` executes it to "
"query the information in the `sysconfig` module which is needed to configure "
"the rest of the compilation."
msgstr ""

#: src/building-and-distribution.md:20
msgid ""
"To validate the configuration which PyO3 will use, you can run a compilation "
"with the environment variable `PYO3_PRINT_CONFIG=1` set. An example output "
"of doing this is shown below:"
msgstr ""

#: src/building-and-distribution.md:48
msgid ""
"The `PYO3_ENVIRONMENT_SIGNATURE` environment variable can be used to trigger "
"rebuilds when its value changes, it has no other effect."
msgstr ""

#: src/building-and-distribution.md:50
msgid "Advanced: config files"
msgstr ""

#: src/building-and-distribution.md:52
msgid ""
"If you save the above output config from `PYO3_PRINT_CONFIG` to a file, it "
"is possible to manually override the contents and feed it back into PyO3 "
"using the `PYO3_CONFIG_FILE` env var."
msgstr ""

#: src/building-and-distribution.md:54
msgid ""
"If your build environment is unusual enough that PyO3's regular "
"configuration detection doesn't work, using a config file like this will "
"give you the flexibility to make PyO3 work for you. To see the full set of "
"options supported, see the documentation for the [`InterpreterConfig` struct]"
"(https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct."
"InterpreterConfig.html)."
msgstr ""

#: src/building-and-distribution.md:56
msgid "Building Python extension modules"
msgstr ""

#: src/building-and-distribution.md:58
msgid ""
"Python extension modules need to be compiled differently depending on the OS "
"(and architecture) that they are being compiled for. As well as multiple "
"OSes (and architectures), there are also many different Python versions "
"which are actively supported. Packages uploaded to [PyPI](https://pypi.org/) "
"usually want to upload prebuilt \"wheels\" covering many OS/arch/version "
"combinations so that users on all these different platforms don't have to "
"compile the package themselves. Package vendors can opt-in to the \"abi3\" "
"limited Python API which allows their wheels to be used on multiple Python "
"versions, reducing the number of wheels they need to compile, but restricts "
"the functionality they can use."
msgstr ""

#: src/building-and-distribution.md:60
msgid ""
"There are many ways to go about this: it is possible to use `cargo` to build "
"the extension module (along with some manual work, which varies with OS). "
"The PyO3 ecosystem has two packaging tools, [`maturin`](https://github.com/"
"PyO3/maturin) and [`setuptools-rust`](https://github.com/PyO3/setuptools-"
"rust), which abstract over the OS difference and also support building "
"wheels for PyPI upload."
msgstr ""

#: src/building-and-distribution.md:62
msgid ""
"PyO3 has some Cargo features to configure projects for building Python "
"extension modules:"
msgstr ""

#: src/building-and-distribution.md:63
msgid ""
"The `extension-module` feature, which must be enabled when building Python "
"extension modules."
msgstr ""

#: src/building-and-distribution.md:64
msgid ""
"The `abi3` feature and its version-specific `abi3-pyXY` companions, which "
"are used to opt-in to the limited Python API in order to support multiple "
"Python versions in a single wheel."
msgstr ""

#: src/building-and-distribution.md:66
msgid ""
"This section describes each of these packaging tools before describing how "
"to build manually without them. It then proceeds with an explanation of the "
"`extension-module` feature. Finally, there is a section describing PyO3's "
"`abi3` features."
msgstr ""

#: src/building-and-distribution.md:68
msgid "Packaging tools"
msgstr ""

#: src/building-and-distribution.md:70
msgid ""
"The PyO3 ecosystem has two main choices to abstract the process of "
"developing Python extension modules:"
msgstr ""

#: src/building-and-distribution.md:71
msgid ""
"[`maturin`](https://github.com/PyO3/maturin) is a command-line tool to "
"build, package and upload Python modules. It makes opinionated choices about "
"project layout meaning it needs very little configuration. This makes it a "
"great choice for users who are building a Python extension from scratch and "
"don't need flexibility."
msgstr ""

#: src/building-and-distribution.md:72
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is an add-on "
"for `setuptools` which adds extra keyword arguments to the `setup.py` "
"configuration file. It requires more configuration than `maturin`, however "
"this gives additional flexibility for users adding Rust to an existing "
"Python package that can't satisfy `maturin`'s constraints."
msgstr ""

#: src/building-and-distribution.md:74
msgid ""
"Consult each project's documentation for full details on how to get started "
"using them and how to upload wheels to PyPI. It should be noted that while "
"`maturin` is able to build [manylinux](https://github.com/pypa/manylinux)\\-"
"compliant wheels out-of-the-box, `setuptools-rust` requires a bit more "
"effort, [relying on Docker](https://setuptools-rust.readthedocs.io/en/latest/"
"building_wheels.html) for this purpose."
msgstr ""

#: src/building-and-distribution.md:76
msgid ""
"There are also [`maturin-starter`](https://github.com/PyO3/pyo3/tree/main/"
"examples/maturin-starter) and [`setuptools-rust-starter`](https://github.com/"
"PyO3/pyo3/tree/main/examples/setuptools-rust-starter) examples in the PyO3 "
"repository."
msgstr ""

#: src/building-and-distribution.md:78
msgid "Manual builds"
msgstr ""

#: src/building-and-distribution.md:80
msgid ""
"To build a PyO3-based Python extension manually, start by running `cargo "
"build` as normal in a library project which uses PyO3's `extension-module` "
"feature and has the [`cdylib` crate type](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#the-crate-type-field)."
msgstr ""

#: src/building-and-distribution.md:82
msgid ""
"Once built, symlink (or copy) and rename the shared library from Cargo's "
"`target/` directory to your desired output directory:"
msgstr ""

#: src/building-and-distribution.md:83
msgid "on macOS, rename `libyour_module.dylib` to `your_module.so`."
msgstr ""

#: src/building-and-distribution.md:84
msgid "on Windows, rename  `libyour_module.dll` to `your_module.pyd`."
msgstr ""

#: src/building-and-distribution.md:85
msgid "on Linux, rename `libyour_module.so` to `your_module.so`."
msgstr ""

#: src/building-and-distribution.md:87
msgid ""
"You can then open a Python shell in the output directory and you'll be able "
"to run `import your_module`."
msgstr ""

#: src/building-and-distribution.md:89
msgid ""
"If you're packaging your library for redistribution, you should indicated "
"the Python interpreter your library is compiled for by including the "
"[platform tag](#platform-tags) in its name. This prevents incompatible "
"interpreters from trying to import your library. If you're compiling for "
"PyPy you _must_ include the platform tag, or PyPy will ignore the module."
msgstr ""

#: src/building-and-distribution.md:91
msgid "Bazel builds"
msgstr ""

#: src/building-and-distribution.md:93
msgid ""
"To use PyO3 with bazel one needs to manually configure PyO3, PyO3-ffi and "
"PyO3-macros. In particular, one needs to make sure that it is compiled with "
"the right python flags for the version you intend to use. For example see:"
msgstr ""

#: src/building-and-distribution.md:95
msgid ""
"https://github.com/OliverFM/pytorch_with_gazelle -- for a minimal example of "
"a repo that can use PyO3, PyTorch and Gazelle to generate python Build files."
msgstr ""

#: src/building-and-distribution.md:96
msgid ""
"https://github.com/TheButlah/rules_pyo3 -- which has more extensive support, "
"but is outdated."
msgstr ""

#: src/building-and-distribution.md:98
msgid "Platform tags"
msgstr ""

#: src/building-and-distribution.md:100
msgid ""
"Rather than using just the `.so` or `.pyd` extension suggested above "
"(depending on OS), you can prefix the shared library extension with a "
"platform tag to indicate the interpreter it is compatible with. You can "
"query your interpreter's platform tag from the `sysconfig` module. Some "
"example outputs of this are seen below:"
msgstr ""

#: src/building-and-distribution.md:103
msgid "# CPython 3.10 on macOS\n"
msgstr ""

#: src/building-and-distribution.md:105
msgid "# PyPy 7.3 (Python 3.8) on Linux\n"
msgstr ""

#: src/building-and-distribution.md:107
msgid "'import sysconfig; print(sysconfig.get_config_var(\"EXT_SUFFIX\"))'"
msgstr ""

#: src/building-and-distribution.md:111
msgid ""
"So, for example, a valid module library name on CPython 3.10 for macOS is "
"`your_module.cpython-310-darwin.so`, and its equivalent when compiled for "
"PyPy 7.3 on Linux would be `your_module.pypy38-pp73-x86_64-linux-gnu.so`."
msgstr ""

#: src/building-and-distribution.md:113
msgid ""
"See [PEP 3149](https://peps.python.org/pep-3149/) for more background on "
"platform tags."
msgstr ""

#: src/building-and-distribution.md:115
msgid "macOS"
msgstr ""

#: src/building-and-distribution.md:117
msgid ""
"On macOS, because the `extension-module` feature disables linking to "
"`libpython` ([see the next section](#the-extension-module-feature)), some "
"additional linker arguments need to be set. `maturin` and `setuptools-rust` "
"both pass these arguments for PyO3 automatically, but projects using manual "
"builds will need to set these directly in order to support macOS."
msgstr ""

#: src/building-and-distribution.md:119
msgid ""
"The easiest way to set the correct linker arguments is to add a [`build.rs`]"
"(https://doc.rust-lang.org/cargo/reference/build-scripts.html) with the "
"following content:"
msgstr ""

#: src/building-and-distribution.md:127
msgid ""
"Remember to also add `pyo3-build-config` to the `build-dependencies` section "
"in `Cargo.toml`."
msgstr ""

#: src/building-and-distribution.md:129
msgid ""
"An alternative to using `pyo3-build-config` is add the following to a cargo "
"configuration file (e.g. `.cargo/config.toml`):"
msgstr ""

#: src/building-and-distribution.md:131
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"\n"
"[target.aarch64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/building-and-distribution.md:145
msgid ""
"Using the MacOS system python3 (`/usr/bin/python3`, as opposed to python "
"installed via homebrew, pyenv, nix, etc.) may result in runtime errors such "
"as `Library not loaded: @rpath/Python3.framework/Versions/3.8/Python3`. "
"These can be resolved with another addition to `.cargo/config.toml`:"
msgstr ""

#: src/building-and-distribution.md:147
msgid ""
"```toml\n"
"[build]\n"
"rustflags = [\n"
"  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/"
"Frameworks\",\n"
"]\n"
"```"
msgstr ""

#: src/building-and-distribution.md:154
msgid "Alternatively, one can include in `build.rs`:"
msgstr ""

#: src/building-and-distribution.md:159
msgid ""
"\"cargo:rustc-link-arg=-Wl,-rpath,/Library/Developer/CommandLineTools/"
"Library/Frameworks\""
msgstr ""

#: src/building-and-distribution.md:164
msgid ""
"For more discussion on and workarounds for MacOS linking problems [see this "
"issue](https://github.com/PyO3/pyo3/issues/1800#issuecomment-906786649)."
msgstr ""

#: src/building-and-distribution.md:166
msgid ""
"Finally, don't forget that on MacOS the `extension-module` feature will "
"cause `cargo test` to fail without the `--no-default-features` flag (see "
"[the FAQ](https://pyo3.rs/main/faq.html#i-cant-run-cargo-test-or-i-cant-"
"build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-"
"undefined-reference-to-_pyexc_systemerror))."
msgstr ""

#: src/building-and-distribution.md:168
msgid "The `extension-module` feature"
msgstr ""

#: src/building-and-distribution.md:170
msgid ""
"PyO3's `extension-module` feature is used to disable [linking](https://en."
"wikipedia.org/wiki/Linker_(computing)) to `libpython` on Unix targets."
msgstr ""

#: src/building-and-distribution.md:172
msgid ""
"This is necessary because by default PyO3 links to `libpython`. This makes "
"binaries, tests, and examples \"just work\". However, Python extensions on "
"Unix must not link to libpython for [manylinux](https://www.python.org/dev/"
"peps/pep-0513/) compliance."
msgstr ""

#: src/building-and-distribution.md:174
msgid ""
"The downside of not linking to `libpython` is that binaries, tests, and "
"examples (which usually embed Python) will fail to build. If you have an "
"extension module as well as other outputs in a single project, you need to "
"use optional Cargo features to disable the `extension-module` when you're "
"not building the extension module. See [the FAQ](faq.md#i-cant-run-cargo-"
"test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-"
"symbol-not-found-or-undefined-reference-to-_pyexc_systemerror) for an "
"example workaround."
msgstr ""

#: src/building-and-distribution.md:176
msgid "`Py_LIMITED_API`/`abi3`"
msgstr ""

#: src/building-and-distribution.md:178
msgid ""
"By default, Python extension modules can only be used with the same Python "
"version they were compiled against. For example, an extension module built "
"for Python 3.5 can't be imported in Python 3.8. [PEP 384](https://www.python."
"org/dev/peps/pep-0384/) introduced the idea of the limited Python API, which "
"would have a stable ABI enabling extension modules built with it to be used "
"against multiple Python versions. This is also known as `abi3`."
msgstr ""

#: src/building-and-distribution.md:180
msgid ""
"The advantage of building extension modules using the limited Python API is "
"that package vendors only need to build and distribute a single copy (for "
"each OS / architecture), and users can install it on all Python versions "
"from the [minimum version](#minimum-python-version-for-abi3) and up. The "
"downside of this is that PyO3 can't use optimizations which rely on being "
"compiled against a known exact Python version. It's up to you to decide "
"whether this matters for your extension module. It's also possible to design "
"your extension module such that you can distribute `abi3` wheels but allow "
"users compiling from source to benefit from additional optimizations - see "
"the [support for multiple python versions](./building-and-distribution/"
"multiple-python-versions.md) section of this guide, in particular the "
"`#[cfg(Py_LIMITED_API)]` flag."
msgstr ""

#: src/building-and-distribution.md:182
msgid ""
"There are three steps involved in making use of `abi3` when building Python "
"packages as wheels:"
msgstr ""

#: src/building-and-distribution.md:184
msgid ""
"Enable the `abi3` feature in `pyo3`. This ensures `pyo3` only calls Python C-"
"API functions which are part of the stable API, and on Windows also ensures "
"that the project links against the correct shared object (no special "
"behavior is required on other platforms):"
msgstr ""

#: src/building-and-distribution.md:186
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"abi3\"] }\n"
"```"
msgstr ""

#: src/building-and-distribution.md:191
msgid ""
"Ensure that the built shared objects are correctly marked as `abi3`. This is "
"accomplished by telling your build system that you're using the limited API. "
"[`maturin`](https://github.com/PyO3/maturin) >= 0.9.0 and [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) >= 0.11.4 support `abi3` wheels. "
"See the [corresponding](https://github.com/PyO3/maturin/pull/353) [PRs]"
"(https://github.com/PyO3/setuptools-rust/pull/82) for more."
msgstr ""

#: src/building-and-distribution.md:194
msgid ""
"Ensure that the `.whl` is correctly marked as `abi3`. For projects using "
"`setuptools`, this is accomplished by passing `--py-limited-api=cp3x` (where "
"`x` is the minimum Python version supported by the wheel, e.g. `--py-limited-"
"api=cp35` for Python 3.5) to `setup.py bdist_wheel`."
msgstr ""

#: src/building-and-distribution.md:196
msgid "Minimum Python version for `abi3`"
msgstr ""

#: src/building-and-distribution.md:198
msgid ""
"Because a single `abi3` wheel can be used with many different Python "
"versions, PyO3 has feature flags `abi3-py37`, `abi3-py38`, `abi3-py39` etc. "
"to set the minimum required Python version for your `abi3` wheel. For "
"example, if you set the `abi3-py37` feature, your extension wheel can be "
"used on all Python 3 versions from Python 3.7 and up. `maturin` and "
"`setuptools-rust` will give the wheel a name like `my-extension-1.0-cp37-"
"abi3-manylinux2020_x86_64.whl`."
msgstr ""

#: src/building-and-distribution.md:201
msgid ""
"As your extension module may be run with multiple different Python versions "
"you may occasionally find you need to check the Python version at runtime to "
"customize behavior. See [the relevant section of this guide](./building-and-"
"distribution/multiple-python-versions.md#checking-the-python-version-at-"
"runtime) on supporting multiple Python versions at runtime."
msgstr ""

#: src/building-and-distribution.md:203
msgid ""
"PyO3 is only able to link your extension module to abi3 version up to and "
"including your host Python version. E.g., if you set `abi3-py38` and try to "
"compile the crate with a host of Python 3.7, the build will fail."
msgstr ""

#: src/building-and-distribution.md:205
msgid ""
"Note: If you set more that one of these `abi3` version feature flags the "
"lowest version always wins. For example, with both `abi3-py37` and `abi3-"
"py38` set, PyO3 would build a wheel which supports Python 3.7 and up."
msgstr ""

#: src/building-and-distribution.md:207
msgid "Building `abi3` extensions without a Python interpreter"
msgstr ""

#: src/building-and-distribution.md:209
msgid ""
"As an advanced feature, you can build PyO3 wheel without calling Python "
"interpreter with the environment variable `PYO3_NO_PYTHON` set. Also, if the "
"build host Python interpreter is not found or is too old or otherwise "
"unusable, PyO3 will still attempt to compile `abi3` extension modules after "
"displaying a warning message. On Unix-like systems this works "
"unconditionally; on Windows you must also set the `RUSTFLAGS` environment "
"variable to contain `-L native=/path/to/python/libs` so that the linker can "
"find `python3.lib`."
msgstr ""

#: src/building-and-distribution.md:215
msgid ""
"If the `python3.dll` import library is not available, an experimental "
"`generate-import-lib` crate feature may be enabled, and the required library "
"will be created and used by PyO3 automatically."
msgstr ""

#: src/building-and-distribution.md:218
msgid ""
"_Note_: MSVC targets require LLVM binutils (`llvm-dlltool`) to be available "
"in `PATH` for the automatic import library generation feature to work."
msgstr ""

#: src/building-and-distribution.md:221
msgid "Missing features"
msgstr ""

#: src/building-and-distribution.md:223
msgid ""
"Due to limitations in the Python API, there are a few `pyo3` features that "
"do not work when compiling for `abi3`. These are:"
msgstr ""

#: src/building-and-distribution.md:226
msgid ""
"`#[pyo3(text_signature = \"...\")]` does not work on classes until Python "
"3.10 or greater."
msgstr ""

#: src/building-and-distribution.md:227
msgid ""
"The `dict` and `weakref` options on classes are not supported until Python "
"3.9 or greater."
msgstr ""

#: src/building-and-distribution.md:228
msgid "The buffer API is not supported until Python 3.11 or greater."
msgstr ""

#: src/building-and-distribution.md:229
msgid ""
"Optimizations which rely on knowledge of the exact Python version compiled "
"against."
msgstr ""

#: src/building-and-distribution.md:231
msgid "Embedding Python in Rust"
msgstr ""

#: src/building-and-distribution.md:233
msgid ""
"If you want to embed the Python interpreter inside a Rust program, there are "
"two modes in which this can be done: dynamically and statically. We'll cover "
"each of these modes in the following sections. Each of them affect how you "
"must distribute your program. Instead of learning how to do this yourself, "
"you might want to consider using a project like [PyOxidizer](https://github."
"com/indygreg/PyOxidizer) to ship your application and all of its "
"dependencies in a single file."
msgstr ""

#: src/building-and-distribution.md:235
msgid ""
"PyO3 automatically switches between the two linking modes depending on "
"whether the Python distribution you have configured PyO3 to use ([see above]"
"(#configuring-the-python-version)) contains a shared library or a static "
"library. The static library is most often seen in Python distributions "
"compiled from source without the `--enable-shared` configuration option."
msgstr ""

#: src/building-and-distribution.md:237
msgid "Dynamically embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:239
msgid ""
"Embedding the Python interpreter dynamically is much easier than doing so "
"statically. This is done by linking your program against a Python shared "
"library (such as `libpython.3.9.so` on UNIX, or `python39.dll` on Windows). "
"The implementation of the Python interpreter resides inside the shared "
"library. This means that when the OS runs your Rust program it also needs to "
"be able to find the Python shared library."
msgstr ""

#: src/building-and-distribution.md:241
msgid ""
"This mode of embedding works well for Rust tests which need access to the "
"Python interpreter. It is also great for Rust software which is installed "
"inside a Python virtualenv, because the virtualenv sets up appropriate "
"environment variables to locate the correct Python shared library."
msgstr ""

#: src/building-and-distribution.md:243
msgid ""
"For distributing your program to non-technical users, you will have to "
"consider including the Python shared library in your distribution as well as "
"setting up wrapper scripts to set the right environment variables (such as "
"`LD_LIBRARY_PATH` on UNIX, or `PATH` on Windows)."
msgstr ""

#: src/building-and-distribution.md:245
msgid ""
"Note that PyPy cannot be embedded in Rust (or any other software). Support "
"for this is tracked on the [PyPy issue tracker](https://github.com/pypy/pypy/"
"issues/3836)."
msgstr ""

#: src/building-and-distribution.md:247
msgid "Statically embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:249
msgid ""
"Embedding the Python interpreter statically means including the contents of "
"a Python static library directly inside your Rust binary. This means that to "
"distribute your program you only need to ship your binary file: it contains "
"the Python interpreter inside the binary!"
msgstr ""

#: src/building-and-distribution.md:251
msgid ""
"On Windows static linking is almost never done, so Python distributions "
"don't usually include a static library. The information below applies only "
"to UNIX."
msgstr ""

#: src/building-and-distribution.md:253
msgid "The Python static library is usually called `libpython.a`."
msgstr ""

#: src/building-and-distribution.md:255
msgid ""
"Static linking has a lot of complications, listed below. For these reasons "
"PyO3 does not yet have first-class support for this embedding mode. See "
"[issue 416 on PyO3's GitHub](https://github.com/PyO3/pyo3/issues/416) for "
"more information and to discuss any issues you encounter."
msgstr ""

#: src/building-and-distribution.md:257
msgid ""
"The [`auto-initialize`](features.md#auto-initialize) feature is deliberately "
"disabled when embedding the interpreter statically because this is often "
"unintentionally done by new users to PyO3 running test programs. Trying out "
"PyO3 is much easier using dynamic embedding."
msgstr ""

#: src/building-and-distribution.md:259
msgid "The known complications are:"
msgstr ""

#: src/building-and-distribution.md:260
msgid ""
"To import compiled extension modules (such as other Rust extension modules, "
"or those written in C), your binary must have the correct linker flags set "
"during compilation to export the original contents of `libpython.a` so that "
"extensions can use them (e.g. `-Wl,--export-dynamic`)."
msgstr ""

#: src/building-and-distribution.md:261
msgid ""
"The C compiler and flags which were used to create `libpython.a` must be "
"compatible with your Rust compiler and flags, else you will experience "
"compilation failures."
msgstr ""

#: src/building-and-distribution.md:263
msgid "Significantly different compiler versions may see errors like this:"
msgstr ""

#: src/building-and-distribution.md:269
msgid "Mismatching flags may lead to errors like this:"
msgstr ""

#: src/building-and-distribution.md:275
msgid ""
"If you encounter these or other complications when linking the interpreter "
"statically, discuss them on [issue 416 on PyO3's GitHub](https://github.com/"
"PyO3/pyo3/issues/416). It is hoped that eventually that discussion will "
"contain enough information and solutions that PyO3 can offer first-class "
"support for static embedding."
msgstr ""

#: src/building-and-distribution.md:277
msgid "Import your module when embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:279
msgid ""
"When you run your Rust binary with an embedded interpreter, any "
"`#[pymodule]` created modules won't be accessible to import unless added to "
"a table called `PyImport_Inittab` before the embedded interpreter is "
"initialized. This will cause Python statements in your embedded interpreter "
"such as `import your_new_module` to fail. You can call the macro "
"[`append_to_inittab`](https://pyo3.rs/main/doc/pyo3/macro.append_to_inittab."
"html) with your module before initializing the Python interpreter to add the "
"module function into that table. (The Python interpreter will be initialized "
"by calling `prepare_freethreaded_python`, "
"`with_embedded_python_interpreter`, or `Python::with_gil` with the [`auto-"
"initialize`](features.md#auto-initialize) feature enabled.)"
msgstr ""

#: src/building-and-distribution.md:281
msgid "Cross Compiling"
msgstr ""

#: src/building-and-distribution.md:283
msgid ""
"Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 "
"is relatively straightforward. To get started, you'll need a few pieces of "
"software:"
msgstr ""

#: src/building-and-distribution.md:285
msgid "A toolchain for your target."
msgstr ""

#: src/building-and-distribution.md:286
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building-and-distribution.md:287
msgid ""
"A Python interpreter that's already been compiled for your target (optional "
"when building \"abi3\" extension modules)."
msgstr ""

#: src/building-and-distribution.md:288
msgid ""
"A Python interpreter that is built for your host and available through the "
"`PATH` or setting the [`PYO3_PYTHON`](#configuring-the-python-version) "
"variable (optional when building \"abi3\" extension modules)."
msgstr ""

#: src/building-and-distribution.md:290
msgid ""
"After you've obtained the above, you can build a cross-compiled PyO3 module "
"by using Cargo's `--target` flag. PyO3's build script will detect that you "
"are attempting a cross-compile based on your host machine and the desired "
"target."
msgstr ""

#: src/building-and-distribution.md:292
msgid ""
"When cross-compiling, PyO3's build script cannot execute the target Python "
"interpreter to query the configuration, so there are a few additional "
"environment variables you may need to set:"
msgstr ""

#: src/building-and-distribution.md:294
msgid ""
"`PYO3_CROSS`: If present this variable forces PyO3 to configure as a cross-"
"compilation."
msgstr ""

#: src/building-and-distribution.md:295
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable can be set to the directory containing "
"the target's libpython DSO and the associated `_sysconfigdata*.py` file for "
"Unix-like targets, or the Python DLL import libraries for the Windows "
"target. This variable is only needed when the output binary must link to "
"libpython explicitly (e.g. when targeting Windows and Android or embedding a "
"Python interpreter), or when it is absolutely required to get the "
"interpreter configuration from `_sysconfigdata*.py`."
msgstr ""

#: src/building-and-distribution.md:296
msgid ""
"`PYO3_CROSS_PYTHON_VERSION`: Major and minor version (e.g. 3.9) of the "
"target Python installation. This variable is only needed if PyO3 cannot "
"determine the version to target from `abi3-py3*` features, or if "
"`PYO3_CROSS_LIB_DIR` is not set, or if there are multiple versions of Python "
"present in `PYO3_CROSS_LIB_DIR`."
msgstr ""

#: src/building-and-distribution.md:297
msgid ""
"`PYO3_CROSS_PYTHON_IMPLEMENTATION`: Python implementation name (\"CPython\" "
"or \"PyPy\") of the target Python installation. CPython is assumed by "
"default when this variable is not set, unless `PYO3_CROSS_LIB_DIR` is set "
"for a Unix-like target and PyO3 can get the interpreter configuration from "
"`_sysconfigdata*.py`."
msgstr ""

#: src/building-and-distribution.md:299
msgid ""
"An experimental `pyo3` crate feature `generate-import-lib` enables the user "
"to cross-compile extension modules for Windows targets without setting the "
"`PYO3_CROSS_LIB_DIR` environment variable or providing any Windows Python "
"library files. It uses an external [`python3-dll-a`](https://docs.rs/python3-"
"dll-a/latest/python3_dll_a/) crate to generate import libraries for the "
"Python DLL for MinGW-w64 and MSVC compile targets. `python3-dll-a` uses the "
"binutils `dlltool` program to generate DLL import libraries for MinGW-w64 "
"targets. It is possible to override the default `dlltool` command name for "
"the cross target by setting `PYO3_MINGW_DLLTOOL` environment variable. "
"_Note_: MSVC targets require LLVM binutils or MSVC build tools to be "
"available on the host system. More specifically, `python3-dll-a` requires "
"`llvm-dlltool` or `lib.exe` executable to be present in `PATH` when "
"targeting `*-pc-windows-msvc`. The Zig compiler executable can be used in "
"place of `llvm-dlltool` when the `ZIG_COMMAND` environment variable is set "
"to the installed Zig program name (`\"zig\"` or `\"python -m ziglang\"`)."
msgstr ""

#: src/building-and-distribution.md:311
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building-and-distribution.md:314 src/building-and-distribution.md:322
#: src/building-and-distribution.md:330
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/building-and-distribution.md:319
msgid ""
"If there are multiple python versions at the cross lib directory and you "
"cannot set a more precise location to include both the `libpython` DSO and "
"`_sysconfigdata*.py` files, you can set the required version:"
msgstr ""

#: src/building-and-distribution.md:321
msgid "3.8"
msgstr ""

#: src/building-and-distribution.md:327
msgid "Or another example with the same sys root but building for Windows:"
msgstr ""

#: src/building-and-distribution.md:329
msgid "3.9"
msgstr ""

#: src/building-and-distribution.md:335
msgid ""
"Any of the `abi3-py3*` features can be enabled instead of setting "
"`PYO3_CROSS_PYTHON_VERSION` in the above examples."
msgstr ""

#: src/building-and-distribution.md:337
msgid ""
"`PYO3_CROSS_LIB_DIR` can often be omitted when cross compiling extension "
"modules for Unix and macOS targets, or when cross compiling extension "
"modules for Windows and the experimental `generate-import-lib` crate feature "
"is enabled."
msgstr ""

#: src/building-and-distribution.md:341
msgid "The following resources may also be useful for cross-compiling:"
msgstr ""

#: src/building-and-distribution.md:342
msgid ""
"[github.com/japaric/rust-cross](https://github.com/japaric/rust-cross) is a "
"primer on cross compiling Rust."
msgstr ""

#: src/building-and-distribution.md:343
msgid ""
"[github.com/rust-embedded/cross](https://github.com/rust-embedded/cross) "
"uses Docker to make Rust cross-compilation easier."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:1
msgid "Supporting multiple Python versions"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:3
msgid ""
"PyO3 supports all actively-supported Python 3 and PyPy versions. As much as "
"possible, this is done internally to PyO3 so that your crate's code does not "
"need to adapt to the differences between each version. However, as Python "
"features grow and change between versions, PyO3 cannot a completely "
"identical API for every Python version. This may require you to add "
"conditional compilation to your crate or runtime checks for the Python "
"version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:5
msgid ""
"This section of the guide first introduces the `pyo3-build-config` crate, "
"which you can use as a `build-dependency` to add additional `#[cfg]` flags "
"which allow you to support multiple Python versions at compile-time."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:7
msgid ""
"Second, we'll show how to check the Python version at runtime. This can be "
"useful when building for multiple versions with the `abi3` feature, where "
"the Python API compiled against is not always the same as the one in use."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:9
msgid "Conditional compilation for different Python versions"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:11
msgid ""
"The `pyo3-build-config` exposes multiple [`#[cfg]` flags](https://doc.rust-"
"lang.org/rust-by-example/attribute/cfg.html) which can be used to "
"conditionally compile code for a given Python version. PyO3 itself depends "
"on this crate, so by using it you can be sure that you are configured "
"correctly for the Python version PyO3 is building against."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:13
msgid "This allows us to write code like the following"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:26
msgid ""
"The following sections first show how to add these `#[cfg]` flags to your "
"build process, and then cover some common patterns flags in a little more "
"detail."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:28
msgid ""
"To see a full reference of all the `#[cfg]` flags provided, see the [`pyo3-"
"build-cfg` docs](https://docs.rs/pyo3-build-config)."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:30
msgid "Using `pyo3-build-config`"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:32
msgid "You can use the `#[cfg]` flags in just two steps:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:34
msgid ""
"Add `pyo3-build-config` with the [`resolve-config`](../features.md#resolve-"
"config) feature enabled to your crate's build dependencies in `Cargo.toml`:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:36
msgid ""
"```toml\n"
"[build-dependencies]\n"
"pyo3-build-config = { git = \"https://github.com/pyo3/pyo3\", features = "
"[\"resolve-config\"] }\n"
"```"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:41
msgid ""
"Add a [`build.rs`](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html) file to your crate with the following contents:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:45
msgid "// If you have an existing build.rs file, just add this line to it.\n"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:50
msgid "After these steps you are ready to annotate your code!"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:52
msgid "Common usages of `pyo3-build-cfg` flags"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:54
msgid ""
"The `#[cfg]` flags added by `pyo3-build-cfg` can be combined with all of "
"Rust's logic in the `#[cfg]` attribute to create very precise conditional "
"code generation. The following are some common patterns implemented using "
"these flags:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:60
msgid ""
"This `#[cfg]` marks code that will only be present on Python 3.7 and "
"upwards. There are similar options `Py_3_8`, `Py_3_9`, `Py_3_10` and so on "
"for each minor version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:66
msgid ""
"This `#[cfg]` marks code that will only be present on Python versions before "
"(but not including) Python 3.7."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:72
msgid ""
"This `#[cfg]` marks code that is only available when building for the "
"unlimited Python API (i.e. PyO3's `abi3` feature is not enabled). This might "
"be useful if you want to ship your extension module as an `abi3` wheel and "
"also allow users to compile it from source to make use of optimizations only "
"possible with the unlimited API."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:78
msgid ""
"This `#[cfg]` marks code which is available when running Python 3.9 or "
"newer, or when using the unlimited API with an older Python version. "
"Patterns like this are commonly seen on Python APIs which were added to the "
"limited Python API in a specific minor version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:84
msgid "This `#[cfg]` marks code which is running on PyPy."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:86
msgid "Checking the Python version at runtime"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:88
msgid ""
"When building with PyO3's `abi3` feature, your extension module will be "
"compiled against a specific [minimum version](../building-and-distribution."
"md#minimum-python-version-for-abi3) of Python, but may be running on newer "
"Python versions."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:90
msgid ""
"For example with PyO3's `abi3-py38` feature, your extension will be compiled "
"as if it were for Python 3.8. If you were using `pyo3-build-config`, "
"`#[cfg(Py_3_8)]` would be present. Your user could freely install and run "
"your abi3 extension on Python 3.9."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:92
msgid ""
"There's no way to detect your user doing that at compile time, so instead "
"you need to fall back to runtime checks."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:94
msgid ""
"PyO3 provides the APIs [`Python::version()`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.version) and [`Python::version_info()`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method."
"version_info) to query the running Python version. This allows you to do the "
"following, for example:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:101
msgid "// PyO3 supports Python 3.7 and up.\n"
msgstr ""

#: src/python-from-rust.md:1
msgid "Calling Python in Rust code"
msgstr ""

#: src/python-from-rust.md:3
msgid ""
"This chapter of the guide documents some ways to interact with Python code "
"from Rust."
msgstr ""

#: src/python-from-rust.md:5
msgid ""
"Below is an introduction to the `'py` lifetime and some general remarks "
"about how PyO3's API reasons about Python code."
msgstr ""

#: src/python-from-rust.md:7
msgid "The subchapters also cover the following topics:"
msgstr ""

#: src/python-from-rust.md:8
msgid "Python object types available in PyO3's API"
msgstr ""

#: src/python-from-rust.md:9
msgid "How to work with Python exceptions"
msgstr ""

#: src/python-from-rust.md:10
msgid "How to call Python functions"
msgstr ""

#: src/python-from-rust.md:11
msgid "How to execute existing Python code"
msgstr ""

#: src/python-from-rust.md:13
msgid "The `'py` lifetime"
msgstr ""

#: src/python-from-rust.md:15
msgid ""
"To safely interact with the Python interpreter a Rust thread must have a "
"corresponding Python thread state and hold the [Global Interpreter Lock "
"(GIL)](#the-global-interpreter-lock). PyO3 has a `Python<'py>` token that is "
"used to prove that these conditions are met. Its lifetime `'py` is a central "
"part of PyO3's API."
msgstr ""

#: src/python-from-rust.md:18
msgid "The `Python<'py>` token serves three purposes:"
msgstr ""

#: src/python-from-rust.md:20
msgid ""
"It provides global APIs for the Python interpreter, such as \\[`py."
"eval_bound()`\\]\\[eval\\] and \\[`py.import_bound()`\\]\\[import\\]."
msgstr ""

#: src/python-from-rust.md:21
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as \\[`Py::clone_ref`\\]\\[clone_ref\\]."
msgstr ""

#: src/python-from-rust.md:22
msgid ""
"Its lifetime `'py` is used to bind many of PyO3's types to the Python "
"interpreter, such as \\[`Bound<'py, T>`\\]\\[Bound\\]."
msgstr ""

#: src/python-from-rust.md:24
msgid ""
"PyO3's types that are bound to the `'py` lifetime, for example `Bound<'py, "
"T>`, all contain a `Python<'py>` token. This means they have full access to "
"the Python interpreter and offer a complete API for interacting with Python "
"objects."
msgstr ""

#: src/python-from-rust.md:26
msgid ""
"Consult [PyO3's API documentation](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#obtaining-a-python-token) to learn how to acquire one of "
"these tokens."
msgstr ""

#: src/python-from-rust.md:28
msgid "The Global Interpreter Lock"
msgstr ""

#: src/python-from-rust.md:30
msgid ""
"Concurrent programming in Python is aided by the Global Interpreter Lock "
"(GIL), which ensures that only one Python thread can use the Python "
"interpreter and its API at the same time. This allows it to be used to "
"synchronize code. See the [`pyo3::sync`](https://pyo3.rs/main/doc/pyo3/sync/"
"index.html) module for synchronization tools PyO3 offers that are based on "
"the GIL's guarantees."
msgstr ""

#: src/python-from-rust.md:32
msgid ""
"Non-Python operations (system calls and native Rust code) can unlock the "
"GIL. See [the section on parallelism](parallelism.md) for how to do that "
"using PyO3's API."
msgstr ""

#: src/python-from-rust.md:34
msgid "Python's memory model"
msgstr ""

#: src/python-from-rust.md:36
msgid "Python's memory model differs from Rust's memory model in two key ways:"
msgstr ""

#: src/python-from-rust.md:37
msgid ""
"There is no concept of ownership; all Python objects are shared and usually "
"implemented via reference counting"
msgstr ""

#: src/python-from-rust.md:38
msgid ""
"There is no concept of exclusive (`&mut`) references; any reference can "
"mutate a Python object"
msgstr ""

#: src/python-from-rust.md:40
msgid ""
"PyO3's API reflects this by providing [smart pointer](https://doc.rust-lang."
"org/book/ch15-00-smart-pointers.html) types, `Py<T>`, `Bound<'py, T>`, and "
"(the very rarely used) `Borrowed<'a, 'py, T>`. These smart pointers all use "
"Python reference counting. See the [subchapter on types](./types.md) for "
"more detail on these types."
msgstr ""

#: src/python-from-rust.md:42
msgid ""
"Because of the lack of exclusive `&mut` references, PyO3's APIs for Python "
"objects, for example \\[`PyListMethods::append`\\], use shared references. "
"This is safe because Python objects have internal mechanisms to prevent data "
"races (as of time of writing, the Python GIL)."
msgstr ""

#: src/python-from-rust/function-calls.md:1
msgid "Calling Python functions"
msgstr ""

#: src/python-from-rust/function-calls.md:3
msgid ""
"The `Bound<'py, T>` smart pointer (such as `Bound<'py, PyAny>`, `Bound<'py, "
"PyList>`, or `Bound<'py, MyClass>`) can be used to call Python functions."
msgstr ""

#: src/python-from-rust/function-calls.md:5
msgid "PyO3 offers two APIs to make function calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:7
msgid ""
"[`call`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call) - call any callable Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:8
msgid ""
"[`call_method`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call_method) - call a method on the Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:10
msgid ""
"Both of these APIs take `args` and `kwargs` arguments (for positional and "
"keyword arguments respectively). There are variants for less complex calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:12
msgid ""
"[`call1`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call1) and [`call_method1`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method1) to call only with "
"positional `args`."
msgstr ""

#: src/python-from-rust/function-calls.md:13
msgid ""
"[`call0`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call0) and [`call_method0`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method0) to call with no "
"arguments."
msgstr ""

#: src/python-from-rust/function-calls.md:15
msgid ""
"For convenience the [`Py<T>`](../types.md#pyt-and-pyobject) smart pointer "
"also exposes these same six API methods, but needs a `Python` token as an "
"additional first argument to prove the GIL is held."
msgstr ""

#: src/python-from-rust/function-calls.md:17
msgid ""
"The example below calls a Python function behind a `PyObject` (aka "
"`Py<PyAny>`) reference:"
msgstr ""

#: src/python-from-rust/function-calls.md:24
msgid "\"arg1\""
msgstr ""

#: src/python-from-rust/function-calls.md:25
msgid "\"arg2\""
msgstr ""

#: src/python-from-rust/function-calls.md:26
msgid "\"arg3\""
msgstr ""

#: src/python-from-rust/function-calls.md:31
#: src/python-from-rust/function-calls.md:77
msgid ""
"\"def example(*args, **kwargs):\n"
"                if args != ():\n"
"                    print('called with args', args)\n"
"                if kwargs != {}:\n"
"                    print('called with kwargs', kwargs)\n"
"                if args == () and kwargs == {}:\n"
"                    print('called with no arguments')\""
msgstr ""

#: src/python-from-rust/function-calls.md:38
#: src/python-from-rust/function-calls.md:39
#: src/python-from-rust/function-calls.md:84
#: src/python-from-rust/function-calls.md:85
msgid "\"\""
msgstr ""

#: src/python-from-rust/function-calls.md:41
#: src/python-from-rust/function-calls.md:87
msgid "\"example\""
msgstr ""

#: src/python-from-rust/function-calls.md:44
msgid "// call object without any arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:47
msgid "// pass object with Rust tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:51
msgid "// call object with Python tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:59
msgid "Creating keyword arguments"
msgstr ""

#: src/python-from-rust/function-calls.md:61
msgid ""
"For the `call` and `call_method` APIs, `kwargs` are `Option<&Bound<'py, "
"PyDict>>`, so can either be `None` or `Some(&dict)`. You can use the "
"[`IntoPyDict`](https://pyo3.rs/main/doc/pyo3/types/trait.IntoPyDict.html) "
"trait to convert other dict-like containers, e.g. `HashMap` or `BTreeMap`, "
"as well as tuples with up to 10 elements and `Vec`s where each element is a "
"two-element tuple."
msgstr ""

#: src/python-from-rust/function-calls.md:69
msgid "\"key1\""
msgstr ""

#: src/python-from-rust/function-calls.md:71
msgid "\"key2\""
msgstr ""

#: src/python-from-rust/function-calls.md:90
msgid "// call object with PyDict\n"
msgstr ""

#: src/python-from-rust/function-calls.md:94
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/python-from-rust/function-calls.md:98
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/python-from-rust/function-calls.md:110
msgid ""
"During PyO3's [migration from \"GIL Refs\" to the `Bound<T>` smart pointer]"
"(../migration.md#migrating-from-the-gil-refs-api-to-boundt), `Py<T>::call` "
"is temporarily named [`Py<T>::call_bound`](https://pyo3.rs/main/doc/pyo3/"
"struct.Py.html#method.call_bound) (and `call_method` is temporarily "
"`call_method_bound`)."
msgstr ""

#: src/python-from-rust/function-calls.md:112
msgid ""
"(This temporary naming is only the case for the `Py<T>` smart pointer. The "
"methods on the `&PyAny` GIL Ref such as `call` have not been given "
"replacements, and the methods on the `Bound<PyAny>` smart pointer such as "
"[`Bound<PyAny>::call`](https://pyo3.rs/main/doc/pyo3/types/trait."
"PyAnyMethods.html#tymethod.call) already use follow the newest API "
"conventions.)"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:1
msgid "Executing existing Python code"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:3
msgid ""
"If you already have some existing Python code that you need to execute from "
"Rust, the following FAQs can help you select the right PyO3 functionality "
"for your situation:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:5
msgid "Want to access Python APIs? Then use `PyModule::import_bound`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:7
msgid ""
"[`PyModule::import_bound`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyModule.html#method.import_bound) can be used to get handle to a Python "
"module from Rust. You can use this to import and use any Python module "
"available in your environment."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:16
msgid "\"builtins\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:18
msgid "\"sum\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:27
msgid "Want to run just an expression? Then use `eval_bound`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:29
msgid ""
"[`Python::eval_bound`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.eval_bound) is a method to execute a [Python expression](https://"
"docs.python.org/3/reference/expressions.html) and return the evaluated value "
"as a `Bound<'py, PyAny>` object."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:39
msgid "\"[i * 10 for i in range(5)]\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:50
msgid "Want to run statements? Then use `run_bound`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:52
msgid ""
"\\[`Python::run_bound`\\] is a method to execute one or more [Python "
"statements](https://docs.python.org/3/reference/simple_stmts.html). This "
"method returns nothing (like any Python statement), but you can get access "
"to manipulated objects via the `locals` dict."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:57
msgid ""
"You can also use the [`py_run!`](https://pyo3.rs/main/doc/pyo3/macro.py_run."
"html) macro, which is a shorthand for \\[`Python::run_bound`\\]. Since "
"[`py_run!`](https://pyo3.rs/main/doc/pyo3/macro.py_run.html) panics on "
"exceptions, we recommend you use this macro only for quickly testing your "
"Python extensions."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:79
msgid "\"User {}(id: {})\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:86
#: src/python-from-rust/calling-existing-code.md:89
msgid "\"Yu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:90
msgid ""
"r#\"\n"
"assert repr(userdata) == \"User Yu(id: 34)\"\n"
"assert userdata.as_tuple() == userdata_as_tuple\n"
"    \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:98
msgid ""
"You have a Python file or code snippet? Then use `PyModule::from_code_bound`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:100
msgid ""
"[`PyModule::from_code_bound`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyModule.html#method.from_code_bound) can be used to generate a Python "
"module which can then be used just as if it was imported with `PyModule::"
"import`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:104
msgid ""
"**Warning**: This will compile and execute code. **Never** pass untrusted "
"code to this function!"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:114
msgid ""
"r#\"\n"
"def relu(x):\n"
"    \"\"\"see https://en.wikipedia.org/wiki/"
"Rectifier_(neural_networks)\"\"\"\n"
"    return max(0.0, x)\n"
"\n"
"def leaky_relu(x, slope=0.01):\n"
"    return x if x >= 0 else x * slope\n"
"    \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:122
msgid "\"activators.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:123
msgid "\"activators\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:126
msgid "\"relu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:129
msgid "\"slope\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:131
msgid "\"leaky_relu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:140
msgid "Want to embed Python in Rust with additional modules?"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:142
msgid ""
"Python maintains the `sys.modules` dict as a cache of all imported modules. "
"An import in Python will first attempt to lookup the module from this dict, "
"and if not present will use various strategies to attempt to locate and load "
"the module."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:147
msgid ""
"The [`append_to_inittab`](https://pyo3.rs/main/doc/pyo3/macro."
"append_to_inittab.html) macro can be used to add additional `#[pymodule]` "
"modules to an embedded Python interpreter. The macro **must** be invoked "
"_before_ initializing Python."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:151
msgid ""
"As an example, the below adds the module `foo` to the embedded interpreter:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:169
#: src/python-from-rust/calling-existing-code.md:200
msgid "\"import foo; foo.add_one(6)\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:173
msgid ""
"If `append_to_inittab` cannot be used due to constraints in the program, an "
"alternative is to create a module using [`PyModule::new_bound`](https://pyo3."
"rs/main/doc/pyo3/types/struct.PyModule.html#method.new_bound) and insert it "
"manually into `sys.modules`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:188
msgid "// Create new module\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:189
#: src/python-from-rust/calling-existing-code.md:197
msgid "\"foo\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:192
msgid "// Import and get sys.modules\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:193
#: src/python-from-rust/calling-existing-code.md:294
msgid "\"sys\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:194
msgid "\"modules\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:196
msgid "// Insert foo into sys.modules\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:199
msgid "// Now we can import + run our python code\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:205
msgid "Include multiple Python files"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:207
msgid ""
"You can include a file at compile time by using [`std::include_str`](https://"
"doc.rust-lang.org/std/macro.include_str.html) macro."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:210
msgid ""
"Or you can load a file at runtime by using [`std::fs::read_to_string`]"
"(https://doc.rust-lang.org/std/fs/fn.read_to_string.html) function."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:213
msgid ""
"Many Python files can be included and loaded as modules. If one file depends "
"on another you must preserve correct order while declaring `PyModule`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:216
msgid "Example directory structure:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:229
msgid "`python_app/app.py`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:238
msgid "`python_app/utils/foo.py`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:241
msgid "\"baz\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:244
#: src/python-from-rust/calling-existing-code.md:272
msgid "The example below shows:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:245
msgid ""
"how to include content of `app.py` and `utils/foo.py` into your rust binary"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:246
#: src/python-from-rust/calling-existing-code.md:275
msgid ""
"how to call function `run()` (declared in `app.py`) that needs function "
"imported from `utils/foo.py`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:249
#: src/python-from-rust/calling-existing-code.md:282
msgid "`src/main.rs`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:255
#: src/python-from-rust/calling-existing-code.md:258
msgid "\"CARGO_MANIFEST_DIR\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:256
msgid "\"/python_app/utils/foo.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:258
msgid "\"/python_app/app.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:260
msgid "\"utils.foo\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:262
#: src/python-from-rust/calling-existing-code.md:299
msgid "\"run\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:267
#: src/python-from-rust/calling-existing-code.md:304
msgid "\"py: {}\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:273
msgid ""
"how to load content of `app.py` at runtime so that it sees its dependencies "
"automatically"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:278
msgid ""
"It is recommended to use absolute paths because then your binary can be run "
"from anywhere as long as your `app.py` is in the expected directory (in this "
"example that directory is `/usr/share/python_app`)."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:290
msgid "\"/usr/share/python_app\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:291
msgid "\"app.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:295
msgid "\"path\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:313
msgid "Need to use a context manager from Rust?"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:315
msgid "Use context managers by directly invoking `__enter__` and `__exit__`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:324
msgid ""
"r#\"\n"
"class House(object):\n"
"    def __init__(self, address):\n"
"        self.address = address\n"
"    def __enter__(self):\n"
"        print(f\"Welcome to {self.address}!\")\n"
"    def __exit__(self, type, value, traceback):\n"
"        if type:\n"
"            print(f\"Sorry you had {type} trouble at {self.address}\")\n"
"        else:\n"
"            print(f\"Thank you for visiting {self.address}, come again soon!"
"\")\n"
"\n"
"        \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:337
msgid "\"house.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:338
msgid "\"house\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:342
msgid "\"House\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:343
msgid "\"123 Main Street\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:345
msgid "\"__enter__\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:347
msgid "\"undefined_variable + 1\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:349
msgid ""
"// If the eval threw an exception we'll pass it through to the context "
"manager.\n"
"        // Otherwise, __exit__  is called with empty arguments (Python "
"\"None\").\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:355
#: src/python-from-rust/calling-existing-code.md:361
msgid "\"__exit__\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:375
msgid "Handling system signals/interrupts (Ctrl-C)"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:377
msgid ""
"The best way to handle system signals when running Rust code is to "
"periodically call `Python::check_signals` to handle any signals captured by "
"Python's signal handler. See also [the FAQ entry](../faq.md#ctrl-c-doesnt-do-"
"anything-while-my-rust-code-is-executing)."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:379
msgid ""
"Alternatively, set Python's `signal` module to take the default action for a "
"signal:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:386
#: src/python-from-rust/calling-existing-code.md:389
msgid "\"signal\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:387
msgid "// Set SIGINT to have the default action\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:390
msgid "\"SIGINT\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:390
msgid "\"SIG_DFL\""
msgstr ""

#: src/exception.md:1
msgid "Python exceptions"
msgstr ""

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"Use the [`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"create_exception.html) macro:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr ""

#: src/exception.md:27 src/exception.md:49
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:31
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:33
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:37
msgid ""
"When using PyO3 to create an extension module, you can add the new exception "
"to the module like this, so that it is importable from Python:"
msgstr ""

#: src/exception.md:48
msgid "// ... other elements added to module ...\n"
msgstr ""

#: src/exception.md:55
msgid "Raising an exception"
msgstr ""

#: src/exception.md:57
msgid ""
"As described in the [function error handling](./function/error-handling.md) "
"chapter, to raise an exception from a `#[pyfunction]` or `#[pymethods]`, "
"return an `Err(PyErr)`. PyO3 will automatically raise this exception for you "
"when returning the result to Python."
msgstr ""

#: src/exception.md:59
msgid ""
"You can also manually write and fetch errors in the Python interpreter's "
"global state:"
msgstr ""

#: src/exception.md:66
msgid "\"Error\""
msgstr ""

#: src/exception.md:72
msgid "Checking exception types"
msgstr ""

#: src/exception.md:74
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type. In PyO3 every object has "
"the [`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/types/trait."
"PyAnyMethods.html#tymethod.is_instance) and [`PyAny::is_instance_of`]"
"(https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods.html#tymethod."
"is_instance_of) methods which do the same thing."
msgstr ""

#: src/exception.md:89
msgid "To check the type of an exception, you can similarly do:"
msgstr ""

#: src/exception.md:100
msgid "Using exceptions defined in Python code"
msgstr ""

#: src/exception.md:102
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The `import_exception!` macro allows importing a specific exception "
"class and defines a Rust type for that exception."
msgstr ""

#: src/exception.md:115
msgid "\"tell\""
msgstr ""

#: src/exception.md:116
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:122
msgid ""
"[`pyo3::exceptions`](https://pyo3.rs/main/doc/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""

#: src/types.md:1
msgid "Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"PyO3 offers two main sets of types to interact with Python objects. This "
"section of the guide expands into detail about these types and how to choose "
"which to use."
msgstr ""

#: src/types.md:5
msgid ""
"The first set of types are the [smart pointers](https://doc.rust-lang.org/"
"book/ch15-00-smart-pointers.html) which all Python objects are wrapped in. "
"These are `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`. The [first "
"section below](#pyo3s-smart-pointers) expands on each of these in detail and "
"why there are three of them."
msgstr ""

#: src/types.md:7
msgid ""
"The second set of types are types which fill in the generic parameter `T` of "
"the smart pointers. The most common is `PyAny`, which represents any Python "
"object (similar to Python's `typing.Any`). There are also concrete types for "
"many Python built-in types, such as `PyList`, `PyDict`, and `PyTuple`. User "
"defined `#[pyclass]` types also fit this category. The [second section below]"
"(#concrete-python-types) expands on how to use these types."
msgstr ""

#: src/types.md:9
msgid ""
"Before PyO3 0.21, PyO3's main API to interact with Python objects was a "
"deprecated API known as the \"GIL Refs\" API, containing reference types "
"such as `&PyAny`, `&PyList`, and `&PyCell<T>` for user-defined `#[pyclass]` "
"types. The [third section below](#the-gil-refs-api) details this deprecated "
"API."
msgstr ""

#: src/types.md:11
msgid "PyO3's smart pointers"
msgstr ""

#: src/types.md:13
msgid ""
"PyO3's API offers three generic smart pointers: `Py<T>`, `Bound<'py, T>` and "
"`Borrowed<'a, 'py, T>`. For each of these the type parameter `T` will be "
"filled by a [concrete Python type](#concrete-python-types). For example, a "
"Python list object can be represented by `Py<PyList>`, `Bound<'py, PyList>`, "
"and `Borrowed<'a, 'py, PyList>`."
msgstr ""

#: src/types.md:15
msgid ""
"These smart pointers behave differently due to their lifetime parameters. "
"`Py<T>` has no lifetime parameters, `Bound<'py, T>` has [the `'py` lifetime]"
"(./python-from-rust.md#the-py-lifetime) as a parameter, and `Borrowed<'a, "
"'py, T>` has the `'py` lifetime plus an additional lifetime `'a` to denote "
"the lifetime it is borrowing data for. (You can read more about these "
"lifetimes in the subsections below)."
msgstr ""

#: src/types.md:17
msgid ""
"Python objects are reference counted, like [`std::sync::Arc`](https://doc."
"rust-lang.org/stable/std/sync/struct.Arc.html). A major reason for these "
"smart pointers is to bring Python's reference counting to a Rust API."
msgstr ""

#: src/types.md:19
msgid ""
"The recommendation of when to use each of these smart pointers is as follows:"
msgstr ""

#: src/types.md:21
msgid ""
"Use `Bound<'py, T>` for as much as possible, as it offers the most efficient "
"and complete API."
msgstr ""

#: src/types.md:22
msgid ""
"Use `Py<T>` mostly just for storage inside Rust `struct`s which do not want "
"to or can't add a lifetime parameter for `Bound<'py, T>`."
msgstr ""

#: src/types.md:23
msgid ""
"`Borrowed<'a, 'py, T>` is almost never used. It is occasionally present at "
"the boundary between Rust and the Python interpreter, for example when "
"borrowing data from Python tuples (which is safe because they are immutable)."
msgstr ""

#: src/types.md:25
msgid ""
"The sections below also explain these smart pointers in a little more detail."
msgstr ""

#: src/types.md:27
msgid "`Py<T>` (and `PyObject`)"
msgstr ""

#: src/types.md:29
msgid ""
"[`Py<T>`](https://pyo3.rs/main/doc/pyo3/struct.Py.html) is the foundational "
"smart pointer in PyO3's API. The type parameter `T` denotes the type of the "
"Python object. Very frequently this is `PyAny`, meaning any Python object. "
"This is so common that `Py<PyAny>` has a type alias `PyObject`."
msgstr ""

#: src/types.md:31
msgid ""
"Because `Py<T>` is not bound to [the `'py` lifetime](./python-from-rust."
"md#the-py-lifetime), it is the type to use when storing a Python object "
"inside a Rust `struct` or `enum` which do not want to have a lifetime "
"parameter. In particular, [`#[pyclass]`](class.md) types are not permitted "
"to have a lifetime, so `Py<T>` is the correct type to store Python objects "
"inside them."
msgstr ""

#: src/types.md:33
msgid "The lack of binding to the `'py` lifetime also carries drawbacks:"
msgstr ""

#: src/types.md:34
msgid ""
"Almost all methods on `Py<T>` require a `Python<'py>` token as the first "
"argument"
msgstr ""

#: src/types.md:35
msgid ""
"Other functionality, such as [`Drop`](https://doc.rust-lang.org/std/ops/"
"trait.Drop.html), needs to check at runtime for attachment to the Python "
"GIL, at a small performance cost"
msgstr ""

#: src/types.md:37
msgid ""
"Because of the drawbacks `Bound<'py, T>` is preferred for many of PyO3's "
"APIs. In particular, `Bound<'py, T>` is the better for function arguments."
msgstr ""

#: src/types.md:39
msgid ""
"To convert a `Py<T>` into a `Bound<'py, T>`, the `Py::bind` and `Py::"
"into_bound` methods are available. `Bound<'py, T>` can be converted back "
"into `Py<T>` using [`Bound::unbind`](https://pyo3.rs/main/doc/pyo3/struct."
"Bound.html#method.unbind)."
msgstr ""

#: src/types.md:41
msgid "`Bound<'py, T>`"
msgstr ""

#: src/types.md:43
msgid ""
"[`Bound<'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html) is the "
"counterpart to `Py<T>` which is also bound to the `'py` lifetime. It can be "
"thought of as equivalent to the Rust tuple `(Python<'py>, Py<T>)`."
msgstr ""

#: src/types.md:45
msgid ""
"By having the binding to the `'py` lifetime, `Bound<'py, T>` can offer the "
"complete PyO3 API at maximum efficiency. This means that in almost all cases "
"where `Py<T>` is not necessary for lifetime reasons, `Bound<'py, T>` should "
"be used."
msgstr ""

#: src/types.md:47
msgid ""
"`Bound<'py, T>` engages in Python reference counting. This means that "
"`Bound<'py, T>` owns a Python object. Rust code which just wants to borrow a "
"Python object should use a shared reference `&Bound<'py, T>`. Just like "
"`std::sync::Arc`, using `.clone()` and `drop()` will cheaply increment and "
"decrement the reference count of the object (just in this case, the "
"reference counting is implemented by the Python interpreter itself)."
msgstr ""

#: src/types.md:49
msgid ""
"To give an example of how `Bound<'py, T>` is PyO3's primary API type, "
"consider the following Python code:"
msgstr ""

#: src/types.md:53
msgid "# create a Python list\n"
msgstr ""

#: src/types.md:54
msgid "# append the integer 1 to it\n"
msgstr ""

#: src/types.md:55
msgid "# create a second reference to the list\n"
msgstr ""

#: src/types.md:56
msgid "# delete the original reference\n"
msgstr ""

#: src/types.md:59
msgid ""
"Using PyO3's API, and in particular `Bound<'py, PyList>`, this code "
"translates into the following Rust code:"
msgstr ""

#: src/types.md:68
msgid "// y is a new reference to the same list\n"
msgstr ""

#: src/types.md:69
msgid "// release the original reference x\n"
msgstr ""

#: src/types.md:75
msgid "Or, without the type annotations:"
msgstr ""

#: src/types.md:91
msgid "Function argument lifetimes"
msgstr ""

#: src/types.md:93
msgid ""
"Because the `'py` lifetime often appears in many function arguments as part "
"of the `Bound<'py, T>` smart pointer, the Rust compiler will often require "
"annotations of input and output lifetimes. This occurs when the function "
"output has at least one lifetime, and there is more than one lifetime "
"present on the inputs."
msgstr ""

#: src/types.md:95
msgid ""
"To demonstrate, consider this function which takes accepts Python objects "
"and applies the [Python `+` operation](https://pyo3.rs/main/doc/pyo3/types/"
"trait.PyAnyMethods.html#tymethod.add) to them:"
msgstr ""

#: src/types.md:104
msgid ""
"Because the Python `+` operation might raise an exception, this function "
"returns `PyResult<Bound<'_, PyAny>>`. It doesn't need ownership of the "
"inputs, so it takes `&Bound<'_, PyAny>` shared references. To demonstrate "
"the point, all lifetimes have used the wildcard `'_` to allow the Rust "
"compiler to attempt to infer them. Because there are four input lifetimes "
"(two lifetimes of the shared references, and two `'py` lifetimes unnamed "
"inside the `Bound<'_, PyAny>` pointers), the compiler cannot reason about "
"which must be connected to the output."
msgstr ""

#: src/types.md:106
msgid ""
"The correct way to solve this is to add the `'py` lifetime as a parameter "
"for the function, and name all the `'py` lifetimes inside the `Bound<'py, "
"PyAny>` smart pointers. For the shared references, it's also fine to reduce "
"`&'_` to just `&`. The working end result is below:"
msgstr ""

#: src/types.md:117 src/types.md:131
msgid "\"s\""
msgstr ""

#: src/types.md:118 src/types.md:132
msgid "\"ss\""
msgstr ""

#: src/types.md:122
msgid ""
"If naming the `'py` lifetime adds unwanted complexity to the function "
"signature, it is also acceptable to return `PyObject` (aka `Py<PyAny>`), "
"which has no lifetime. The cost is instead paid by a slight increase in "
"implementation complexity, as seen by the introduction of a call to [`Bound::"
"unbind`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html#method.unbind):"
msgstr ""

#: src/types.md:136
msgid "`Borrowed<'a, 'py, T>`"
msgstr ""

#: src/types.md:138
msgid ""
"[`Borrowed<'a, 'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Borrowed.html) "
"is an advanced type used just occasionally at the edge of interaction with "
"the Python interpreter. It can be thought of as analogous to the shared "
"reference `&'a Bound<'py, T>`. The difference is that `Borrowed<'a, 'py, T>` "
"is just a smart pointer rather than a reference-to-a-smart-pointer, which is "
"a helpful reduction in indirection in specific interactions with the Python "
"interpreter."
msgstr ""

#: src/types.md:140
msgid ""
"`Borrowed<'a, 'py, T>` dereferences to `Bound<'py, T>`, so all methods on "
"`Bound<'py, T>` are available on `Borrowed<'a, 'py, T>`."
msgstr ""

#: src/types.md:142
msgid ""
"An example where `Borrowed<'a, 'py, T>` is used is in [`PyTupleMethods::"
"get_borrowed_item`](https://pyo3.rs/main/doc/pyo3/types/trait.PyTupleMethods."
"html#tymethod.get_item):"
msgstr ""

#: src/types.md:148
msgid "// Create a new tuple with the elements (0, 1, 2)\n"
msgstr ""

#: src/types.md:153
msgid ""
"// `PyAnyMethods::extract` is available on `Borrowed`\n"
"    // via the dereference to `Bound`\n"
msgstr ""

#: src/types.md:163
msgid "Casting between smart pointer types"
msgstr ""

#: src/types.md:165
msgid ""
"To convert between `Py<T>` and `Bound<'py, T>` use the `bind()` / "
"`into_bound()` methods. Use the `as_unbound()` / `unbind()` methods to go "
"back from `Bound<'py, T>` to `Py<T>`."
msgstr ""

#: src/types.md:176
msgid ""
"To convert between `Bound<'py, T>` and `Borrowed<'a, 'py, T>` use the "
"`as_borrowed()` method. `Borrowed<'a, 'py, T>` has a deref coercion to "
"`Bound<'py, T>`. Use the `to_owned()` method to increment the Python "
"reference count and to create a new `Bound<'py, T>` from the `Borrowed<'a, "
"'py, T>`."
msgstr ""

#: src/types.md:181
msgid "// deref coercion\n"
msgstr ""

#: src/types.md:184
msgid "// create a new Bound by increase the Python reference count\n"
msgstr ""

#: src/types.md:189
msgid ""
"To convert between `Py<T>` and `Borrowed<'a, 'py, T>` use the "
"`bind_borrowed()` method. Use either `as_unbound()` or `.to_owned()."
"unbind()` to go back to `Py<T>` from `Borrowed<'a, 'py, T>`, via `Bound<'py, "
"T>`."
msgstr ""

#: src/types.md:194
msgid "// via deref coercion to Bound and then using Bound::as_unbound\n"
msgstr ""

#: src/types.md:197
msgid ""
"// via a new Bound by increasing the Python reference count, and unbind it\n"
msgstr ""

#: src/types.md:202
msgid "Concrete Python types"
msgstr ""

#: src/types.md:204
msgid ""
"In all of `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`, the type "
"parameter `T` denotes the type of the Python object referred to by the smart "
"pointer."
msgstr ""

#: src/types.md:206
msgid "This parameter `T` can be filled by:"
msgstr ""

#: src/types.md:207
msgid ""
"[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html), which "
"represents any Python object,"
msgstr ""

#: src/types.md:208
msgid "Native Python types such as `PyList`, `PyTuple`, and `PyDict`, and"
msgstr ""

#: src/types.md:209
msgid "[`#[pyclass]`](class.md) types defined from Rust"
msgstr ""

#: src/types.md:211
msgid ""
"The following subsections covers some further detail about how to work with "
"these types:"
msgstr ""

#: src/types.md:212
msgid "the APIs that are available for these concrete types,"
msgstr ""

#: src/types.md:213
msgid "how to cast `Bound<'py, T>` to a specific concrete type, and"
msgstr ""

#: src/types.md:214
msgid "how to get Rust data out of a `Bound<'py, T>`."
msgstr ""

#: src/types.md:216
msgid "Using APIs for concrete Python types"
msgstr ""

#: src/types.md:218
msgid ""
"Each concrete Python type such as `PyAny`, `PyTuple` and `PyDict` exposes "
"its API on the corresponding bound smart pointer `Bound<'py, PyAny>`, "
"`Bound<'py, PyTuple>` and `Bound<'py, PyDict>`."
msgstr ""

#: src/types.md:220
msgid ""
"Each type's API is exposed as a trait: [`PyAnyMethods`](https://pyo3.rs/main/"
"doc/pyo3/types/trait.PyAnyMethods.html), [`PyTupleMethods`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyTupleMethods.html), [`PyDictMethods`](https://"
"pyo3.rs/main/doc/pyo3/types/trait.PyDictMethods.html), and so on for all "
"concrete types. Using traits rather than associated methods on the `Bound` "
"smart pointer is done for a couple of reasons:"
msgstr ""

#: src/types.md:221
msgid ""
"Clarity of documentation: each trait gets its own documentation page in the "
"PyO3 API docs. If all methods were on the `Bound` smart pointer directly, "
"the vast majority of PyO3's API would be on a single, extremely long, "
"documentation page."
msgstr ""

#: src/types.md:222
msgid ""
"Consistency: downstream code implementing Rust APIs for existing Python "
"types can also follow this pattern of using a trait. Downstream code would "
"not be allowed to add new associated methods directly on the `Bound` type."
msgstr ""

#: src/types.md:223
msgid ""
"Future design: it is hoped that a future Rust with [arbitrary self types]"
"(https://github.com/rust-lang/rust/issues/44874) will remove the need for "
"these traits in favour of placing the methods directly on `PyAny`, "
"`PyTuple`, `PyDict`, and so on."
msgstr ""

#: src/types.md:225
msgid ""
"These traits are all included in the `pyo3::prelude` module, so with the "
"glob import `use pyo3::prelude::*` the full PyO3 API is made available to "
"downstream code."
msgstr ""

#: src/types.md:227
msgid ""
"The following function accesses the first item in the input Python list, "
"using the `.get_item()` method from the `PyListMethods` trait:"
msgstr ""

#: src/types.md:237 src/types.md:238
msgid "\"hello world\""
msgstr ""

#: src/types.md:242
msgid "Casting between Python object types"
msgstr ""

#: src/types.md:244
msgid ""
"To cast `Bound<'py, T>` smart pointers to some other type, use the [`."
"downcast()`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.downcast) family of functions. This converts `&Bound<'py, T>` "
"to a different `&Bound<'py, U>`, without transferring ownership. There is "
"also [`.downcast_into()`](https://pyo3.rs/main/doc/pyo3/types/trait."
"PyAnyMethods.html#tymethod.downcast_into) to convert `Bound<'py, T>` to "
"`Bound<'py, U>` with transfer of ownership. These methods are available for "
"all types `T` which implement the [`PyTypeCheck`](https://pyo3.rs/main/doc/"
"pyo3/type_object/trait.PyTypeCheck.html) trait."
msgstr ""

#: src/types.md:246
msgid ""
"Casting to `Bound<'py, PyAny>` can be done with `.as_any()` or `.into_any()`."
msgstr ""

#: src/types.md:248
msgid ""
"For example, the following snippet shows how to cast `Bound<'py, PyAny>` to "
"`Bound<'py, PyTuple>`:"
msgstr ""

#: src/types.md:253 src/types.md:275 src/types.md:298
msgid ""
"// create a new Python `tuple`, and use `.into_any()` to erase the type\n"
msgstr ""

#: src/types.md:256
msgid ""
"// use `.downcast()` to cast to `PyTuple` without transferring ownership\n"
msgstr ""

#: src/types.md:259
msgid ""
"// use `.downcast_into()` to cast to `PyTuple` with transfer of ownership\n"
msgstr ""

#: src/types.md:267
msgid ""
"Custom [`#[pyclass]`](class.md) types implement [`PyTypeCheck`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeCheck.html), so `.downcast()` also "
"works for these types. The snippet below is the same as the snippet above "
"casting instead to a custom type `MyClass`:"
msgstr ""

#: src/types.md:278
msgid ""
"// use `.downcast()` to cast to `MyClass` without transferring ownership\n"
msgstr ""

#: src/types.md:281
msgid ""
"// use `.downcast_into()` to cast to `MyClass` with transfer of ownership\n"
msgstr ""

#: src/types.md:289
msgid "Extracting Rust data from Python objects"
msgstr ""

#: src/types.md:291
msgid ""
"To extract Rust data from Python objects, use [`.extract()`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyAnyMethods.html#tymethod.extract) instead of `."
"downcast()`. This method is available for all types which implement the "
"\\[`FromPyObject`\\] trait."
msgstr ""

#: src/types.md:293
msgid ""
"For example, the following snippet extracts a Rust tuple of integers from a "
"Python tuple:"
msgstr ""

#: src/types.md:301
msgid "// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple\n"
msgstr ""

#: src/types.md:310
msgid ""
"To avoid copying data, [`#[pyclass]`](class.md) types can directly reference "
"Rust data stored within the Python objects without needing to `.extract()`. "
"See the [corresponding documentation in the class section of the guide](./"
"class.md#bound-and-interior-mutability) for more detail."
msgstr ""

#: src/types.md:313
msgid "The GIL Refs API"
msgstr ""

#: src/types.md:315
msgid ""
"The GIL Refs API was PyO3's primary API prior to PyO3 0.21. The main "
"difference was that instead of the `Bound<'py, PyAny>` smart pointer, the "
"\"GIL Reference\" `&'py PyAny` was used. (This was similar for other Python "
"types.)"
msgstr ""

#: src/types.md:317
msgid ""
"As of PyO3 0.21, the GIL Refs API is deprecated. See the [migration guide](./"
"migration.md#from-020-to-021) for details on how to upgrade."
msgstr ""

#: src/types.md:319
msgid ""
"The following sections note some historical detail about the GIL Refs API."
msgstr ""

#: src/types.md:321
msgid "[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/types.md:323
msgid ""
"**Represented:** a Python object of unspecified type. In the GIL Refs API, "
"this was only accessed as the GIL Ref `&'py PyAny`."
msgstr ""

#: src/types.md:325
msgid ""
"**Used:** `&'py PyAny` was used to refer to some Python object when the GIL "
"lifetime was available for the whole duration access was needed. For "
"example, intermediate values and arguments to `pyfunction`s or `pymethod`s "
"implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:327 src/types.md:394 src/types.md:444
msgid "**Conversions:**"
msgstr ""

#: src/types.md:329
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"Python-native type such as a list:"
msgstr ""

#: src/types.md:338 src/types.md:402
msgid "// PyList::empty is part of the deprecated \"GIL Refs\" API.\n"
msgstr ""

#: src/types.md:340
msgid "// To &PyList with PyAny::downcast\n"
msgstr ""

#: src/types.md:343 src/types.md:367
msgid "// To Py<PyAny> (aka PyObject) with .into()\n"
msgstr ""

#: src/types.md:346
msgid "// To Py<PyList> with PyAny::extract\n"
msgstr ""

#: src/types.md:353
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"`#[pyclass]`:"
msgstr ""

#: src/types.md:361
msgid "// into_ref is part of the deprecated GIL Refs API\n"
msgstr ""

#: src/types.md:363
msgid "// To &PyCell<MyClass> with PyAny::downcast\n"
msgstr ""

#: src/types.md:365 src/types.md:454
msgid "// &PyCell is part of the deprecated GIL Refs API\n"
msgstr ""

#: src/types.md:370
msgid "// To Py<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:373
msgid "// To MyClass with PyAny::extract, if MyClass: Clone\n"
msgstr ""

#: src/types.md:376
msgid "// To PyRef<'_, MyClass> or PyRefMut<'_, MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:384
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:386
msgid ""
"**Represented:** a native Python object of known type. In the GIL Refs API, "
"they were only accessed as the GIL Refs `&'py PyTuple`, `&'py PyDict`."
msgstr ""

#: src/types.md:388
msgid ""
"**Used:** `&'py PyTuple` and similar were used to operate with native Python "
"types while holding the GIL. Like `PyAny`, this is the most convenient form "
"to use for function arguments and intermediate values."
msgstr ""

#: src/types.md:390
msgid ""
"These GIL Refs implement `Deref<Target = PyAny>`, so they all expose the "
"same methods which can be found on `PyAny`."
msgstr ""

#: src/types.md:392
msgid ""
"To see all Python types exposed by `PyO3` consult the [`pyo3::types`]"
"(https://pyo3.rs/main/doc/pyo3/types/index.html) module."
msgstr ""

#: src/types.md:404
msgid ""
"// Use methods from PyAny on all Python types with Deref implementation\n"
msgstr ""

#: src/types.md:407 src/types.md:482
msgid "// To &PyAny automatically with Deref implementation\n"
msgstr ""

#: src/types.md:410 src/types.md:485
msgid "// To &PyAny explicitly with .as_ref()\n"
msgstr ""

#: src/types.md:412 src/types.md:487
msgid "// as_ref is part of the deprecated \"GIL Refs\" API.\n"
msgstr ""

#: src/types.md:414
msgid "// To Py<T> with .into() or Py::from()\n"
msgstr ""

#: src/types.md:417
msgid "// To PyObject with .into() or .to_object(py)\n"
msgstr ""

#: src/types.md:424
msgid "`Py<T>` and `PyObject`"
msgstr ""

#: src/types.md:426
msgid ""
"**Represented:** a GIL-independent reference to a Python object. This can be "
"a Python native type (like `PyTuple`), or a `pyclass` type implemented in "
"Rust. The most commonly-used variant, `Py<PyAny>`, is also known as "
"`PyObject`."
msgstr ""

#: src/types.md:430
msgid ""
"**Used:** Whenever you want to carry around references to a Python object "
"without caring about a GIL lifetime.  For example, storing Python object "
"references in a Rust struct that outlives the Python-Rust FFI boundary, or "
"returning objects from functions implemented in Rust back to Python."
msgstr ""

#: src/types.md:434
msgid "Can be cloned using Python reference counts with `.clone()`."
msgstr ""

#: src/types.md:436
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:438
msgid ""
"**Represented:** a reference to a Rust object (instance of `PyClass`) "
"wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:440
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:442
msgid ""
"Like PyO3's Python native types, the GIL Ref `&PyCell<T>` implements "
"`Deref<Target = PyAny>`, so it also exposed all of the methods on `PyAny`."
msgstr ""

#: src/types.md:446
msgid ""
"`PyCell<T>` was used to access `&T` and `&mut T` via `PyRef<T>` and "
"`PyRefMut<T>` respectively."
msgstr ""

#: src/types.md:456
msgid "// To PyRef<T> with .borrow() or .try_borrow()\n"
msgstr ""

#: src/types.md:461
msgid "// To PyRefMut<T> with .borrow_mut() or .try_borrow_mut()\n"
msgstr ""

#: src/types.md:469
msgid "`PyCell<T>` was also accessed like a Python-native type."
msgstr ""

#: src/types.md:477
msgid "// &PyCell is part of the deprecate GIL Refs API\n"
msgstr ""

#: src/types.md:479
msgid "// Use methods from PyAny on PyCell<T> with Deref implementation\n"
msgstr ""

#: src/changelog.md:1
msgid "Changelog"
msgstr ""

#: src/changelog.md:3
msgid ""
"All notable changes to this project will be documented in this file. For "
"help with updating to new PyO3 versions, please see the [migration guide]"
"(https://pyo3.rs/latest/migration.html)."
msgstr ""

#: src/changelog.md:6
msgid ""
"The format is based on [Keep a Changelog](https://keepachangelog.com/"
"en/1.0.0/) and this project adheres to [Semantic Versioning](https://semver."
"org/spec/v2.0.0.html)."
msgstr ""

#: src/changelog.md:9
msgid ""
"To see unreleased changes, please see the [CHANGELOG on the main branch "
"guide](https://pyo3.rs/main/changelog.html)."
msgstr ""

#: src/changelog.md:13
msgid ""
"[0.22.6](https://github.com/pyo3/pyo3/compare/v0.22.5...v0.22.6) - 2024-11-05"
msgstr ""

#: src/changelog.md:15 src/changelog.md:21 src/changelog.md:36
#: src/changelog.md:66 src/changelog.md:90 src/changelog.md:103
#: src/changelog.md:164 src/changelog.md:181 src/changelog.md:202
#: src/changelog.md:269 src/changelog.md:287 src/changelog.md:298
#: src/changelog.md:315 src/changelog.md:371 src/changelog.md:406
#: src/changelog.md:435 src/changelog.md:474 src/changelog.md:492
#: src/changelog.md:520 src/changelog.md:541 src/changelog.md:595
#: src/changelog.md:618 src/changelog.md:634 src/changelog.md:642
#: src/changelog.md:707 src/changelog.md:756 src/changelog.md:775
#: src/changelog.md:805 src/changelog.md:825 src/changelog.md:907
#: src/changelog.md:940 src/changelog.md:992 src/changelog.md:1010
#: src/changelog.md:1026 src/changelog.md:1049 src/changelog.md:1065
#: src/changelog.md:1145 src/changelog.md:1184 src/changelog.md:1218
#: src/changelog.md:1272 src/changelog.md:1284 src/changelog.md:1290
#: src/changelog.md:1301 src/changelog.md:1309 src/changelog.md:1367
#: src/changelog.md:1424 src/changelog.md:1433 src/changelog.md:1468
#: src/changelog.md:1485 src/changelog.md:1491 src/changelog.md:1533
#: src/changelog.md:1563 src/changelog.md:1574 src/changelog.md:1590
#: src/changelog.md:1618 src/changelog.md:1638 src/changelog.md:1705
#: src/changelog.md:1713 src/changelog.md:1719 src/changelog.md:1760
#: src/changelog.md:1774 src/changelog.md:1802 src/changelog.md:1825
#: src/changelog.md:1831 src/changelog.md:1841 src/changelog.md:1856
#: src/changelog.md:1867 src/changelog.md:1883
msgid "Fixed"
msgstr ""

#: src/changelog.md:17
msgid ""
"Fix detection of freethreaded Python 3.13t added in PyO3 0.22.2; "
"freethreaded is not yet supported (support coming soon in 0.23). [\\#4684]"
"(https://github.com/PyO3/pyo3/pull/4684)"
msgstr ""

#: src/changelog.md:19
msgid ""
"[0.22.5](https://github.com/pyo3/pyo3/compare/v0.22.4...v0.22.5) - 2024-10-15"
msgstr ""

#: src/changelog.md:23
msgid ""
"Fix regression in 0.22.4 of naming collision in `__clear__` slot and `clear` "
"method generated code. [\\#4619](https://github.com/PyO3/pyo3/pull/4619)"
msgstr ""

#: src/changelog.md:26
msgid ""
"[0.22.4](https://github.com/pyo3/pyo3/compare/v0.22.3...v0.22.4) - 2024-10-12"
msgstr ""

#: src/changelog.md:28 src/changelog.md:47 src/changelog.md:98
#: src/changelog.md:122 src/changelog.md:191 src/changelog.md:213
#: src/changelog.md:305 src/changelog.md:333 src/changelog.md:389
#: src/changelog.md:425 src/changelog.md:448 src/changelog.md:486
#: src/changelog.md:506 src/changelog.md:530 src/changelog.md:558
#: src/changelog.md:614 src/changelog.md:630 src/changelog.md:654
#: src/changelog.md:747 src/changelog.md:763 src/changelog.md:787
#: src/changelog.md:843 src/changelog.md:931 src/changelog.md:958
#: src/changelog.md:1005 src/changelog.md:1022 src/changelog.md:1038
#: src/changelog.md:1061 src/changelog.md:1078 src/changelog.md:1171
#: src/changelog.md:1196 src/changelog.md:1236 src/changelog.md:1296
#: src/changelog.md:1316 src/changelog.md:1383 src/changelog.md:1393
#: src/changelog.md:1439 src/changelog.md:1481 src/changelog.md:1498
#: src/changelog.md:1546 src/changelog.md:1553 src/changelog.md:1570
#: src/changelog.md:1586 src/changelog.md:1598 src/changelog.md:1624
#: src/changelog.md:1667 src/changelog.md:1729 src/changelog.md:1808
#: src/changelog.md:1837 src/changelog.md:1850 src/changelog.md:1889
#: src/changelog.md:1906
msgid "Added"
msgstr ""

#: src/changelog.md:30
msgid ""
"Add FFI definition `PyWeakref_GetRef` and `compat::PyWeakref_GetRef`. "
"[\\#4528](https://github.com/PyO3/pyo3/pull/4528)"
msgstr ""

#: src/changelog.md:32 src/changelog.md:56 src/changelog.md:85
#: src/changelog.md:145 src/changelog.md:177 src/changelog.md:197
#: src/changelog.md:242 src/changelog.md:345 src/changelog.md:399
#: src/changelog.md:458 src/changelog.md:513 src/changelog.md:536
#: src/changelog.md:573 src/changelog.md:673 src/changelog.md:737
#: src/changelog.md:752 src/changelog.md:769 src/changelog.md:798
#: src/changelog.md:862 src/changelog.md:936 src/changelog.md:974
#: src/changelog.md:1016 src/changelog.md:1044 src/changelog.md:1098
#: src/changelog.md:1179 src/changelog.md:1251 src/changelog.md:1332
#: src/changelog.md:1387 src/changelog.md:1402 src/changelog.md:1451
#: src/changelog.md:1512 src/changelog.md:1606 src/changelog.md:1632
#: src/changelog.md:1675 src/changelog.md:1738 src/changelog.md:1770
#: src/changelog.md:1784 src/changelog.md:1796 src/changelog.md:1813
#: src/changelog.md:1863 src/changelog.md:1877 src/changelog.md:1899
msgid "Changed"
msgstr ""

#: src/changelog.md:34
msgid ""
"Deprecate `_borrowed` methods on `PyWeakRef` and `PyWeakrefProxy` (just use "
"the owning forms). [\\#4590](https://github.com/PyO3/pyo3/pull/4590)"
msgstr ""

#: src/changelog.md:38
msgid ""
"Revert removal of private FFI function `_PyLong_NumBits` on Python 3.13 and "
"later. [\\#4450](https://github.com/PyO3/pyo3/pull/4450)"
msgstr ""

#: src/changelog.md:39
msgid ""
"Fix `__traverse__` functions for base classes not being called by subclasses "
"created with `#[pyclass(extends = ...)]`. [\\#4563](https://github.com/PyO3/"
"pyo3/pull/4563)"
msgstr ""

#: src/changelog.md:40
msgid ""
"Fix regression in 0.22.3 failing compiles under `#![forbid(unsafe_code)]`. "
"[\\#4574](https://github.com/PyO3/pyo3/pull/4574)"
msgstr ""

#: src/changelog.md:41
msgid ""
"Workaround possible use-after-free in `_borrowed` methods on `PyWeakRef` and "
"`PyWeakrefProxy` by leaking their contents. [\\#4590](https://github.com/"
"PyO3/pyo3/pull/4590)"
msgstr ""

#: src/changelog.md:42
msgid ""
"Fix crash calling `PyType_GetSlot` on static types before Python 3.10. "
"[\\#4599](https://github.com/PyO3/pyo3/pull/4599)"
msgstr ""

#: src/changelog.md:45
msgid ""
"[0.22.3](https://github.com/pyo3/pyo3/compare/v0.22.2...v0.22.3) - 2024-09-15"
msgstr ""

#: src/changelog.md:49
msgid ""
"Add `pyo3::ffi::compat` namespace with compatibility shims for C API "
"functions added in recent versions of Python."
msgstr ""

#: src/changelog.md:50
msgid ""
"Add FFI definition `PyDict_GetItemRef` on Python 3.13 and newer, and "
"`compat::PyDict_GetItemRef` for all versions. [\\#4355](https://github.com/"
"PyO3/pyo3/pull/4355)"
msgstr ""

#: src/changelog.md:51
msgid ""
"Add FFI definition `PyList_GetItemRef` on Python 3.13 and newer, and "
"`pyo3_ffi::compat::PyList_GetItemRef` for all versions. [\\#4410](https://"
"github.com/PyO3/pyo3/pull/4410)"
msgstr ""

#: src/changelog.md:52
msgid ""
"Add FFI definitions `compat::Py_NewRef` and `compat::Py_XNewRef`. [\\#4445]"
"(https://github.com/PyO3/pyo3/pull/4445)"
msgstr ""

#: src/changelog.md:53
msgid ""
"Add FFI definitions `compat::PyObject_CallNoArgs` and `compat::"
"PyObject_CallMethodNoArgs`. [\\#4461](https://github.com/PyO3/pyo3/pull/4461)"
msgstr ""

#: src/changelog.md:54
msgid ""
"Add `GilOnceCell<Py<T>>::clone_ref`. [\\#4511](https://github.com/PyO3/pyo3/"
"pull/4511)"
msgstr ""

#: src/changelog.md:58
msgid ""
"Improve error messages for `#[pyfunction]` defined inside `#[pymethods]`. "
"[\\#4349](https://github.com/PyO3/pyo3/pull/4349)"
msgstr ""

#: src/changelog.md:59
msgid ""
"Improve performance of calls to Python by using the vectorcall calling "
"convention where possible. [\\#4456](https://github.com/PyO3/pyo3/pull/4456)"
msgstr ""

#: src/changelog.md:60
msgid ""
"Mention the type name in the exception message when trying to instantiate a "
"class with no constructor defined. [\\#4481](https://github.com/PyO3/pyo3/"
"pull/4481)"
msgstr ""

#: src/changelog.md:62 src/changelog.md:265 src/changelog.md:366
#: src/changelog.md:470 src/changelog.md:590 src/changelog.md:702
#: src/changelog.md:901 src/changelog.md:1127 src/changelog.md:1212
#: src/changelog.md:1267 src/changelog.md:1357 src/changelog.md:1420
#: src/changelog.md:1460 src/changelog.md:1523 src/changelog.md:1559
#: src/changelog.md:1613 src/changelog.md:1698 src/changelog.md:1752
#: src/changelog.md:1778 src/changelog.md:1790 src/changelog.md:1871
msgid "Removed"
msgstr ""

#: src/changelog.md:64
msgid ""
"Remove private FFI definition `_Py_PackageContext`. [\\#4420](https://github."
"com/PyO3/pyo3/pull/4420)"
msgstr ""

#: src/changelog.md:68 src/changelog.md:92
msgid ""
"Fix compile failure in declarative `#[pymodule]` under presence of `#!"
"[no_implicit_prelude]`. [\\#4328](https://github.com/PyO3/pyo3/pull/4328)"
msgstr ""

#: src/changelog.md:69
msgid ""
"Fix use of borrowed reference in `PyDict::get_item` (unsafe in free-threaded "
"Python). [\\#4355](https://github.com/PyO3/pyo3/pull/4355)"
msgstr ""

#: src/changelog.md:70
msgid ""
"Fix `#[pyclass(eq)]` macro hygiene issues for structs and enums. [\\#4359]"
"(https://github.com/PyO3/pyo3/pull/4359)"
msgstr ""

#: src/changelog.md:71
msgid ""
"Fix hygiene/span issues of `'#[pyfunction]` and `#[pymethods]` generated "
"code which affected expansion in `macro_rules` context. [\\#4382](https://"
"github.com/PyO3/pyo3/pull/4382)"
msgstr ""

#: src/changelog.md:72
msgid ""
"Fix `unsafe_code` lint error in `#[pyclass]` generated code. [\\#4396]"
"(https://github.com/PyO3/pyo3/pull/4396)"
msgstr ""

#: src/changelog.md:73
msgid ""
"Fix async functions returning a tuple only returning the first element to "
"Python. [\\#4407](https://github.com/PyO3/pyo3/pull/4407)"
msgstr ""

#: src/changelog.md:74
msgid ""
"Fix use of borrowed reference in `PyList::get_item` (unsafe in free-threaded "
"Python). [\\#4410](https://github.com/PyO3/pyo3/pull/4410)"
msgstr ""

#: src/changelog.md:75
msgid ""
"Correct FFI definition `PyArg_ParseTupleAndKeywords` to take `*const *const "
"c_char` instead of `*mut *mut c_char` on Python 3.13 and up. [\\#4420]"
"(https://github.com/PyO3/pyo3/pull/4420)"
msgstr ""

#: src/changelog.md:76
msgid ""
"Fix a soundness bug with `PyClassInitializer`: panic if adding subclass to "
"existing instance via `PyClassInitializer::from(Py<BaseClass>)."
"add_subclass(SubClass)`. [\\#4454](https://github.com/PyO3/pyo3/pull/4454)"
msgstr ""

#: src/changelog.md:77
msgid ""
"Fix illegal reference counting op inside implementation of `__traverse__` "
"handlers. [\\#4479](https://github.com/PyO3/pyo3/pull/4479)"
msgstr ""

#: src/changelog.md:79
msgid ""
"[0.22.2](https://github.com/pyo3/pyo3/compare/v0.22.1...v0.22.2) - 2024-07-17"
msgstr ""

#: src/changelog.md:81 src/changelog.md:114 src/changelog.md:282
#: src/changelog.md:294 src/changelog.md:323 src/changelog.md:419
#: src/changelog.md:444 src/changelog.md:502 src/changelog.md:552
#: src/changelog.md:610 src/changelog.md:626 src/changelog.md:650
#: src/changelog.md:783 src/changelog.md:814 src/changelog.md:821
#: src/changelog.md:832 src/changelog.md:925 src/changelog.md:950
#: src/changelog.md:1071 src/changelog.md:1167 src/changelog.md:1228
msgid "Packaging"
msgstr ""

#: src/changelog.md:83
msgid ""
"Require opt-in to freethreaded Python using the "
"`UNSAFE_PYO3_BUILD_FREE_THREADED=1` environment variable (it is not yet "
"supported by PyO3). [\\#4327](https://github.com/PyO3/pyo3/pull/4327)"
msgstr ""

#: src/changelog.md:87
msgid ""
"Use FFI function calls for reference counting on all abi3 versions. [\\#4324]"
"(https://github.com/PyO3/pyo3/pull/4324)"
msgstr ""

#: src/changelog.md:88
msgid ""
"`#[pymodule(...)]` now directly accepts all relevant `#[pyo3(...)]` options. "
"[\\#4330](https://github.com/PyO3/pyo3/pull/4330)"
msgstr ""

#: src/changelog.md:93
msgid ""
"Fix compile failure due to c-string literals on Rust \\< 1.79. [\\#4353]"
"(https://github.com/PyO3/pyo3/pull/4353)"
msgstr ""

#: src/changelog.md:96
msgid ""
"[0.22.1](https://github.com/pyo3/pyo3/compare/v0.22.0...v0.22.1) - 2024-07-06"
msgstr ""

#: src/changelog.md:100
msgid ""
"Add `#[pyo3(submodule)]` option for declarative `#[pymodule]`s. [\\#4301]"
"(https://github.com/PyO3/pyo3/pull/4301)"
msgstr ""

#: src/changelog.md:101
msgid ""
"Implement `PartialEq<bool>` for `Bound<'py, PyBool>`. [\\#4305](https://"
"github.com/PyO3/pyo3/pull/4305)"
msgstr ""

#: src/changelog.md:105
msgid ""
"Return `NotImplemented` instead of raising `TypeError` from generated "
"equality method when comparing different types. [\\#4287](https://github.com/"
"PyO3/pyo3/pull/4287)"
msgstr ""

#: src/changelog.md:106
msgid ""
"Handle full-path `#[pyo3::prelude::pymodule]` and similar for `#[pyclass]` "
"and `#[pyfunction]` in declarative modules.[\\#4288](https://github.com/PyO3/"
"pyo3/pull/4288)"
msgstr ""

#: src/changelog.md:107
msgid ""
"Fix 128-bit int regression on big-endian platforms with Python \\<3.13. "
"[\\#4291](https://github.com/PyO3/pyo3/pull/4291)"
msgstr ""

#: src/changelog.md:108
msgid ""
"Stop generating code that will never be covered with declarative modules. "
"[\\#4297](https://github.com/PyO3/pyo3/pull/4297)"
msgstr ""

#: src/changelog.md:109
msgid ""
"Fix invalid deprecation warning for trailing optional on `#[setter]` "
"function. [\\#4304](https://github.com/PyO3/pyo3/pull/4304)"
msgstr ""

#: src/changelog.md:112
msgid ""
"[0.22.0](https://github.com/pyo3/pyo3/compare/v0.21.2...v0.22.0) - 2024-06-24"
msgstr ""

#: src/changelog.md:116
msgid ""
"Update `heck` dependency to 0.5. [\\#3966](https://github.com/PyO3/pyo3/"
"pull/3966)"
msgstr ""

#: src/changelog.md:117
msgid ""
"Extend range of supported versions of `chrono-tz` optional dependency to "
"include version 0.10. [\\#4061](https://github.com/PyO3/pyo3/pull/4061)"
msgstr ""

#: src/changelog.md:118
msgid "Update MSRV to 1.63. [\\#4129](https://github.com/PyO3/pyo3/pull/4129)"
msgstr ""

#: src/changelog.md:119
msgid ""
"Add optional `num-rational` feature to add conversions with Python's "
"`fractions.Fraction`. [\\#4148](https://github.com/PyO3/pyo3/pull/4148)"
msgstr ""

#: src/changelog.md:120
msgid "Support Python 3.13. [\\#4184](https://github.com/PyO3/pyo3/pull/4184)"
msgstr ""

#: src/changelog.md:124
msgid ""
"Add `PyWeakref`, `PyWeakrefReference` and `PyWeakrefProxy`. [\\#3835]"
"(https://github.com/PyO3/pyo3/pull/3835)"
msgstr ""

#: src/changelog.md:125
msgid ""
"Support `#[pyclass]` on enums that have tuple variants. [\\#4072](https://"
"github.com/PyO3/pyo3/pull/4072)"
msgstr ""

#: src/changelog.md:126
msgid ""
"Add support for scientific notation in `Decimal` conversion. [\\#4079]"
"(https://github.com/PyO3/pyo3/pull/4079)"
msgstr ""

#: src/changelog.md:127
msgid ""
"Add `pyo3_disable_reference_pool` conditional compilation flag to avoid the "
"overhead of the global reference pool at the cost of known limitations as "
"explained in the performance section of the guide. [\\#4095](https://github."
"com/PyO3/pyo3/pull/4095)"
msgstr ""

#: src/changelog.md:128
msgid ""
"Add `#[pyo3(constructor = (...))]` to customize the generated constructors "
"for complex enum variants. [\\#4158](https://github.com/PyO3/pyo3/pull/4158)"
msgstr ""

#: src/changelog.md:129
msgid ""
"Add `PyType::module`, which always matches Python `__module__`. [\\#4196]"
"(https://github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:130
msgid ""
"Add `PyType::fully_qualified_name` which matches the \"fully qualified "
"name\" defined in [PEP 737](https://peps.python.org/pep-0737). [\\#4196]"
"(https://github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:131
msgid ""
"Add `PyTypeMethods::mro` and `PyTypeMethods::bases`. [\\#4197](https://"
"github.com/PyO3/pyo3/pull/4197)"
msgstr ""

#: src/changelog.md:132
msgid ""
"Add `#[pyclass(ord)]` to implement ordering based on `PartialOrd`. [\\#4202]"
"(https://github.com/PyO3/pyo3/pull/4202)"
msgstr ""

#: src/changelog.md:133
msgid ""
"Implement `ToPyObject` and `IntoPy<PyObject>` for `PyBackedStr` and "
"`PyBackedBytes`. [\\#4205](https://github.com/PyO3/pyo3/pull/4205)"
msgstr ""

#: src/changelog.md:134
msgid ""
"Add `#[pyclass(hash)]` option to implement `__hash__` in terms of the `Hash` "
"implementation [\\#4206](https://github.com/PyO3/pyo3/pull/4206)"
msgstr ""

#: src/changelog.md:135
msgid ""
"Add `#[pyclass(eq)]` option to generate `__eq__` based on `PartialEq`, and "
"`#[pyclass(eq_int)]` for simple enums to implement equality based on their "
"discriminants. [\\#4210](https://github.com/PyO3/pyo3/pull/4210)"
msgstr ""

#: src/changelog.md:136
msgid ""
"Implement `From<Bound<'py, T>>` for `PyClassInitializer<T>`. [\\#4214]"
"(https://github.com/PyO3/pyo3/pull/4214)"
msgstr ""

#: src/changelog.md:137
msgid ""
"Add `as_super` methods to `PyRef` and `PyRefMut` for accesing the base class "
"by reference. [\\#4219](https://github.com/PyO3/pyo3/pull/4219)"
msgstr ""

#: src/changelog.md:138
msgid ""
"Implement `PartialEq<str>` for `Bound<'py, PyString>`. [\\#4245](https://"
"github.com/PyO3/pyo3/pull/4245)"
msgstr ""

#: src/changelog.md:139
msgid ""
"Implement `PyModuleMethods::filename` on PyPy. [\\#4249](https://github.com/"
"PyO3/pyo3/pull/4249)"
msgstr ""

#: src/changelog.md:140
msgid ""
"Implement `PartialEq<[u8]>` for `Bound<'py, PyBytes>`. [\\#4250](https://"
"github.com/PyO3/pyo3/pull/4250)"
msgstr ""

#: src/changelog.md:141
msgid ""
"Add `pyo3_ffi::c_str` macro to create `&'static CStr` on Rust versions which "
"don't have 1.77's `c\"\"` literals. [\\#4255](https://github.com/PyO3/pyo3/"
"pull/4255)"
msgstr ""

#: src/changelog.md:142
msgid ""
"Support `bool` conversion with `numpy` 2.0's `numpy.bool` type [\\#4258]"
"(https://github.com/PyO3/pyo3/pull/4258)"
msgstr ""

#: src/changelog.md:143
msgid ""
"Add `PyAnyMethods::{bitnot, matmul, floor_div, rem, divmod}`. [\\#4264]"
"(https://github.com/PyO3/pyo3/pull/4264)"
msgstr ""

#: src/changelog.md:147
msgid ""
"Change the type of `PySliceIndices::slicelength` and the `length` parameter "
"of `PySlice::indices()`. [\\#3761](https://github.com/PyO3/pyo3/pull/3761)"
msgstr ""

#: src/changelog.md:148
msgid ""
"Deprecate implicit default for trailing optional arguments [\\#4078](https://"
"github.com/PyO3/pyo3/pull/4078)"
msgstr ""

#: src/changelog.md:149
msgid ""
"`Clone`ing pointers into the Python heap has been moved behind the `py-"
"clone` feature, as it must panic without the GIL being held as a soundness "
"fix. [\\#4095](https://github.com/PyO3/pyo3/pull/4095)"
msgstr ""

#: src/changelog.md:150
msgid ""
"Add `#[track_caller]` to all `Py<T>`, `Bound<'py, T>` and `Borrowed<'a, 'py, "
"T>` methods which can panic. [\\#4098](https://github.com/PyO3/pyo3/"
"pull/4098)"
msgstr ""

#: src/changelog.md:151
msgid ""
"Change `PyAnyMethods::dir` to be fallible and return `PyResult<Bound<'py, "
"PyList>>` (and similar for `PyAny::dir`). [\\#4100](https://github.com/PyO3/"
"pyo3/pull/4100)"
msgstr ""

#: src/changelog.md:152
msgid ""
"The global reference pool (to track pending reference count decrements) is "
"now initialized lazily to avoid the overhead of taking a mutex upon function "
"entry when the functionality is not actually used. [\\#4178](https://github."
"com/PyO3/pyo3/pull/4178)"
msgstr ""

#: src/changelog.md:153
msgid ""
"Emit error messages when using `weakref` or `dict` when compiling for `abi3` "
"for Python older than 3.9. [\\#4194](https://github.com/PyO3/pyo3/pull/4194)"
msgstr ""

#: src/changelog.md:154
msgid ""
"Change `PyType::name` to always match Python `__name__`. [\\#4196](https://"
"github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:155
msgid ""
"Remove CPython internal ffi call for complex number including: add, sub, "
"mul, div, neg, abs, pow. Added PyAnyMethods::{abs, pos, neg} [\\#4201]"
"(https://github.com/PyO3/pyo3/pull/4201)"
msgstr ""

#: src/changelog.md:156
msgid ""
"Deprecate implicit integer comparision for simple enums in favor of "
"`#[pyclass(eq_int)]`. [\\#4210](https://github.com/PyO3/pyo3/pull/4210)"
msgstr ""

#: src/changelog.md:157
msgid ""
"Set the `module=` attribute of declarative modules' child `#[pymodule]`s and "
"`#[pyclass]`es. [\\#4213](https://github.com/PyO3/pyo3/pull/4213)"
msgstr ""

#: src/changelog.md:158
msgid ""
"Set the `module` option for complex enum variants from the value set on the "
"complex enum `module`. [\\#4228](https://github.com/PyO3/pyo3/pull/4228)"
msgstr ""

#: src/changelog.md:159
msgid ""
"Respect the Python \"limited API\" when building for the `abi3` feature on "
"PyPy or GraalPy. [\\#4237](https://github.com/PyO3/pyo3/pull/4237)"
msgstr ""

#: src/changelog.md:160
msgid ""
"Optimize code generated by `#[pyo3(get)]` on `#[pyclass]` fields. [\\#4254]"
"(https://github.com/PyO3/pyo3/pull/4254)"
msgstr ""

#: src/changelog.md:161
msgid ""
"`PyCFunction::new`, `PyCFunction::new_with_keywords` and `PyCFunction::"
"new_closure` now take `&'static CStr` name and doc arguments (previously was "
"`&'static str`). [\\#4255](https://github.com/PyO3/pyo3/pull/4255)"
msgstr ""

#: src/changelog.md:162
msgid ""
"The `experimental-declarative-modules` feature is now stabilized and "
"available by default. [\\#4257](https://github.com/PyO3/pyo3/pull/4257)"
msgstr ""

#: src/changelog.md:166
msgid ""
"Fix panic when `PYO3_CROSS_LIB_DIR` is set to a missing path. [\\#4043]"
"(https://github.com/PyO3/pyo3/pull/4043)"
msgstr ""

#: src/changelog.md:167
msgid ""
"Fix a compile error when exporting an exception created with "
"`create_exception!` living in a different Rust module using the `declarative-"
"module` feature. [\\#4086](https://github.com/PyO3/pyo3/pull/4086)"
msgstr ""

#: src/changelog.md:168
msgid ""
"Fix FFI definitions of `PY_VECTORCALL_ARGUMENTS_OFFSET` and "
"`PyVectorcall_NARGS` to fix a false-positive assertion. [\\#4104](https://"
"github.com/PyO3/pyo3/pull/4104)"
msgstr ""

#: src/changelog.md:169
msgid ""
"Disable `PyUnicode_DATA` on PyPy: not exposed by PyPy. [\\#4116](https://"
"github.com/PyO3/pyo3/pull/4116)"
msgstr ""

#: src/changelog.md:170
msgid ""
"Correctly handle `#[pyo3(from_py_with = ...)]` attribute on dunder "
"(`__magic__`) method arguments instead of silently ignoring it. [\\#4117]"
"(https://github.com/PyO3/pyo3/pull/4117)"
msgstr ""

#: src/changelog.md:171
msgid ""
"Fix a compile error when declaring a standalone function or class method "
"with a Python name that is a Rust keyword. [\\#4226](https://github.com/PyO3/"
"pyo3/pull/4226)"
msgstr ""

#: src/changelog.md:172
msgid ""
"Fix declarative modules discarding doc comments on the `mod` node. [\\#4236]"
"(https://github.com/PyO3/pyo3/pull/4236)"
msgstr ""

#: src/changelog.md:173
msgid ""
"Fix `__dict__` attribute missing for `#[pyclass(dict)]` instances when "
"building for `abi3` on Python 3.9. [\\#4251](https://github.com/PyO3/pyo3/"
"pull/4251)"
msgstr ""

#: src/changelog.md:175
msgid ""
"[0.21.2](https://github.com/pyo3/pyo3/compare/v0.21.1...v0.21.2) - 2024-04-16"
msgstr ""

#: src/changelog.md:179
msgid ""
"Deprecate the `PySet::empty()` gil-ref constructor. [\\#4082](https://github."
"com/PyO3/pyo3/pull/4082)"
msgstr ""

#: src/changelog.md:183
msgid ""
"Fix compile error for `async fn` in `#[pymethods]` with a `&self` receiver "
"and more than one additional argument. [\\#4035](https://github.com/PyO3/"
"pyo3/pull/4035)"
msgstr ""

#: src/changelog.md:184
msgid ""
"Improve error message for wrong receiver type in `__traverse__`. [\\#4045]"
"(https://github.com/PyO3/pyo3/pull/4045)"
msgstr ""

#: src/changelog.md:185
msgid ""
"Fix compile error when exporting a `#[pyclass]` living in a different Rust "
"module using the `experimental-declarative-modules` feature. [\\#4054]"
"(https://github.com/PyO3/pyo3/pull/4054)"
msgstr ""

#: src/changelog.md:186
msgid ""
"Fix `missing_docs` lint triggering on documented `#[pymodule]` functions. "
"[\\#4067](https://github.com/PyO3/pyo3/pull/4067)"
msgstr ""

#: src/changelog.md:187
msgid ""
"Fix undefined symbol errors for extension modules on AIX (by linking "
"`libpython`). [\\#4073](https://github.com/PyO3/pyo3/pull/4073)"
msgstr ""

#: src/changelog.md:189
msgid ""
"[0.21.1](https://github.com/pyo3/pyo3/compare/v0.21.0...v0.21.1) - 2024-04-01"
msgstr ""

#: src/changelog.md:193
msgid ""
"Implement `Send` and `Sync` for `PyBackedStr` and `PyBackedBytes`. [\\#4007]"
"(https://github.com/PyO3/pyo3/pull/4007)"
msgstr ""

#: src/changelog.md:194
msgid ""
"Implement `Clone`, `Debug`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and "
"`Hash` implementation for `PyBackedBytes` and `PyBackedStr`, and `Display` "
"for `PyBackedStr`. [\\#4020](https://github.com/PyO3/pyo3/pull/4020)"
msgstr ""

#: src/changelog.md:195
msgid ""
"Add `import_exception_bound!` macro to import exception types without "
"generating GIL Ref functionality for them. [\\#4027](https://github.com/PyO3/"
"pyo3/pull/4027)"
msgstr ""

#: src/changelog.md:199
msgid ""
"Emit deprecation warning for uses of GIL Refs as `#[setter]` function "
"arguments. [\\#3998](https://github.com/PyO3/pyo3/pull/3998)"
msgstr ""

#: src/changelog.md:200
msgid ""
"Add `#[inline]` hints on many `Bound` and `Borrowed` methods. [\\#4024]"
"(https://github.com/PyO3/pyo3/pull/4024)"
msgstr ""

#: src/changelog.md:204
msgid ""
"Handle `#[pyo3(from_py_with = \"\")]` in `#[setter]` methods [\\#3995]"
"(https://github.com/PyO3/pyo3/pull/3995)"
msgstr ""

#: src/changelog.md:205
msgid ""
"Allow extraction of `&Bound` in `#[setter]` methods. [\\#3998](https://"
"github.com/PyO3/pyo3/pull/3998)"
msgstr ""

#: src/changelog.md:206
msgid ""
"Fix some uncovered code blocks emitted by `#[pymodule]`, `#[pyfunction]` and "
"`#[pyclass]` macros. [\\#4009](https://github.com/PyO3/pyo3/pull/4009)"
msgstr ""

#: src/changelog.md:207
msgid ""
"Fix typo in the panic message when a class referenced in `pyo3::"
"import_exception!` does not exist. [\\#4012](https://github.com/PyO3/pyo3/"
"pull/4012)"
msgstr ""

#: src/changelog.md:208
msgid ""
"Fix compile error when using an async `#[pymethod]` with a receiver and "
"additional arguments. [\\#4015](https://github.com/PyO3/pyo3/pull/4015)"
msgstr ""

#: src/changelog.md:211
msgid ""
"[0.21.0](https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0) - 2024-03-25"
msgstr ""

#: src/changelog.md:215
msgid ""
"Add support for GraalPy (24.0 and up). [\\#3247](https://github.com/PyO3/"
"pyo3/pull/3247)"
msgstr ""

#: src/changelog.md:216
msgid ""
"Add `PyMemoryView` type. [\\#3514](https://github.com/PyO3/pyo3/pull/3514)"
msgstr ""

#: src/changelog.md:217
msgid ""
"Allow `async fn` in for `#[pyfunction]` and `#[pymethods]`, with the "
"`experimental-async` feature. [\\#3540](https://github.com/PyO3/pyo3/"
"pull/3540) [\\#3588](https://github.com/PyO3/pyo3/pull/3588) [\\#3599]"
"(https://github.com/PyO3/pyo3/pull/3599) [\\#3931](https://github.com/PyO3/"
"pyo3/pull/3931)"
msgstr ""

#: src/changelog.md:218
msgid ""
"Implement `PyTypeInfo` for `PyEllipsis`, `PyNone` and `PyNotImplemented`. "
"[\\#3577](https://github.com/PyO3/pyo3/pull/3577)"
msgstr ""

#: src/changelog.md:219
msgid ""
"Support `#[pyclass]` on enums that have non-unit variants. [\\#3582](https://"
"github.com/PyO3/pyo3/pull/3582)"
msgstr ""

#: src/changelog.md:220
msgid ""
"Support `chrono` feature with `abi3` feature. [\\#3664](https://github.com/"
"PyO3/pyo3/pull/3664)"
msgstr ""

#: src/changelog.md:221
msgid ""
"`FromPyObject`, `IntoPy<PyObject>` and `ToPyObject` are implemented on `std::"
"duration::Duration` [\\#3670](https://github.com/PyO3/pyo3/pull/3670)"
msgstr ""

#: src/changelog.md:222
msgid ""
"Add `PyString::to_cow`. Add `Py<PyString>::to_str`, `Py<PyString>::to_cow`, "
"and `Py<PyString>::to_string_lossy`, as ways to access Python string data "
"safely beyond the GIL lifetime. [\\#3677](https://github.com/PyO3/pyo3/"
"pull/3677)"
msgstr ""

#: src/changelog.md:223
msgid ""
"Add `Bound<T>` and `Borrowed<T>` smart pointers as a new API for accessing "
"Python objects. [\\#3686](https://github.com/PyO3/pyo3/pull/3686)"
msgstr ""

#: src/changelog.md:224
msgid ""
"Add `PyNativeType::as_borrowed` to convert \"GIL refs\" to the new `Bound` "
"smart pointer. [\\#3692](https://github.com/PyO3/pyo3/pull/3692)"
msgstr ""

#: src/changelog.md:225
msgid ""
"Add `FromPyObject::extract_bound` method, to migrate `FromPyObject` "
"implementations to the Bound API. [\\#3706](https://github.com/PyO3/pyo3/"
"pull/3706)"
msgstr ""

#: src/changelog.md:226
msgid ""
"Add `gil-refs` feature to allow continued use of the deprecated GIL Refs "
"APIs. [\\#3707](https://github.com/PyO3/pyo3/pull/3707)"
msgstr ""

#: src/changelog.md:227
msgid ""
"Add methods to `PyAnyMethods` for binary operators (`add`, `sub`, etc.) "
"[\\#3712](https://github.com/PyO3/pyo3/pull/3712)"
msgstr ""

#: src/changelog.md:228
msgid ""
"Add `chrono-tz` feature allowing conversion between `chrono_tz::Tz` and "
"`zoneinfo.ZoneInfo` [\\#3730](https://github.com/PyO3/pyo3/pull/3730)"
msgstr ""

#: src/changelog.md:229
msgid ""
"Add FFI definition `PyType_GetModuleByDef`. [\\#3734](https://github.com/"
"PyO3/pyo3/pull/3734)"
msgstr ""

#: src/changelog.md:230
msgid ""
"Conversion between `std::time::SystemTime` and `datetime.datetime` [\\#3736]"
"(https://github.com/PyO3/pyo3/pull/3736)"
msgstr ""

#: src/changelog.md:231
msgid ""
"Add `Py::as_any` and `Py::into_any`. [\\#3785](https://github.com/PyO3/pyo3/"
"pull/3785)"
msgstr ""

#: src/changelog.md:232
msgid ""
"Add `PyStringMethods::encode_utf8`. [\\#3801](https://github.com/PyO3/pyo3/"
"pull/3801)"
msgstr ""

#: src/changelog.md:233
msgid ""
"Add `PyBackedStr` and `PyBackedBytes`, as alternatives to `&str` and "
"`&bytes` where a Python object owns the data. [\\#3802](https://github.com/"
"PyO3/pyo3/pull/3802) [\\#3991](https://github.com/PyO3/pyo3/pull/3991)"
msgstr ""

#: src/changelog.md:234
msgid ""
"Allow `#[pymodule]` macro on Rust `mod` blocks, with the `experimental-"
"declarative-modules` feature. [\\#3815](https://github.com/PyO3/pyo3/"
"pull/3815)"
msgstr ""

#: src/changelog.md:235
msgid ""
"Implement `ExactSizeIterator` for `set` and `frozenset` iterators on `abi3` "
"feature. [\\#3849](https://github.com/PyO3/pyo3/pull/3849)"
msgstr ""

#: src/changelog.md:236
msgid ""
"Add `Py::drop_ref` to explicitly drop a \\`Py\\`` and immediately decrease "
"the Python reference count if the GIL is already held. [\\#3871](https://"
"github.com/PyO3/pyo3/pull/3871)"
msgstr ""

#: src/changelog.md:237
msgid ""
"Allow `#[pymodule]` macro on single argument functions that take `&Bound<'_, "
"PyModule>`. [\\#3905](https://github.com/PyO3/pyo3/pull/3905)"
msgstr ""

#: src/changelog.md:238
msgid ""
"Implement `FromPyObject` for `Cow<str>`. [\\#3928](https://github.com/PyO3/"
"pyo3/pull/3928)"
msgstr ""

#: src/changelog.md:239
msgid ""
"Implement `Default` for `GILOnceCell`. [\\#3971](https://github.com/PyO3/"
"pyo3/pull/3971)"
msgstr ""

#: src/changelog.md:240
msgid ""
"Add `PyDictMethods::into_mapping`, `PyListMethods::into_sequence` and "
"`PyTupleMethods::into_sequence`. [\\#3982](https://github.com/PyO3/pyo3/"
"pull/3982)"
msgstr ""

#: src/changelog.md:244
msgid ""
"`PyDict::from_sequence` now takes a single argument of type `&PyAny` "
"(previously took two arguments `Python` and `PyObject`). [\\#3532](https://"
"github.com/PyO3/pyo3/pull/3532)"
msgstr ""

#: src/changelog.md:245
msgid ""
"Deprecate `Py::is_ellipsis` and `PyAny::is_ellipsis` in favour of `any.is(py."
"Ellipsis())`. [\\#3577](https://github.com/PyO3/pyo3/pull/3577)"
msgstr ""

#: src/changelog.md:246
msgid ""
"Split some `PyTypeInfo` functionality into new traits `HasPyGilRef` and "
"`PyTypeCheck`. [\\#3600](https://github.com/PyO3/pyo3/pull/3600)"
msgstr ""

#: src/changelog.md:247
msgid ""
"Deprecate `PyTryFrom` and `PyTryInto` traits in favor of `any.downcast()` "
"via the `PyTypeCheck` and `PyTypeInfo` traits. [\\#3601](https://github.com/"
"PyO3/pyo3/pull/3601)"
msgstr ""

#: src/changelog.md:248
msgid ""
"Allow async methods to accept `&self`/`&mut self` [\\#3609](https://github."
"com/PyO3/pyo3/pull/3609)"
msgstr ""

#: src/changelog.md:249
msgid ""
"`FromPyObject` for set types now also accept `frozenset` objects as input. "
"[\\#3632](https://github.com/PyO3/pyo3/pull/3632)"
msgstr ""

#: src/changelog.md:250
msgid ""
"`FromPyObject` for `bool` now also accepts NumPy's `bool_` as input. "
"[\\#3638](https://github.com/PyO3/pyo3/pull/3638)"
msgstr ""

#: src/changelog.md:251
msgid ""
"Add `AsRefSource` associated type to `PyNativeType`. [\\#3653](https://"
"github.com/PyO3/pyo3/pull/3653)"
msgstr ""

#: src/changelog.md:252
msgid ""
"Rename `.is_true` to `.is_truthy` on `PyAny` and `Py<PyAny>` to clarify that "
"the test is not based on identity with or equality to the True singleton. "
"[\\#3657](https://github.com/PyO3/pyo3/pull/3657)"
msgstr ""

#: src/changelog.md:253
msgid ""
"`PyType::name` is now `PyType::qualname` whereas `PyType::name` efficiently "
"accesses the full name which includes the module name. [\\#3660](https://"
"github.com/PyO3/pyo3/pull/3660)"
msgstr ""

#: src/changelog.md:254
msgid ""
"The `Iter(A)NextOutput` types are now deprecated and `__(a)next__` can "
"directly return anything which can be converted into Python objects, i.e. "
"awaitables do not need to be wrapped into `IterANextOutput` or `Option` any "
"more. `Option` can still be used as well and returning `None` will trigger "
"the fast path for `__next__`, stopping iteration without having to raise a "
"`StopIteration` exception. [\\#3661](https://github.com/PyO3/pyo3/pull/3661)"
msgstr ""

#: src/changelog.md:255
msgid ""
"Implement `FromPyObject` on `chrono::DateTime<Tz>` for all `Tz`, not just "
"`FixedOffset` and `Utc`. [\\#3663](https://github.com/PyO3/pyo3/pull/3663)"
msgstr ""

#: src/changelog.md:256
msgid ""
"Add lifetime parameter to `PyTzInfoAccess` trait. For the deprecated gil-ref "
"API, the trait is now implemented for `&'py PyTime` and `&'py PyDateTime` "
"instead of `PyTime` and `PyDate`. [\\#3679](https://github.com/PyO3/pyo3/"
"pull/3679)"
msgstr ""

#: src/changelog.md:257
msgid ""
"Calls to `__traverse__` become no-ops for unsendable pyclasses if on the "
"wrong thread, thereby avoiding hard aborts at the cost of potential leakage. "
"[\\#3689](https://github.com/PyO3/pyo3/pull/3689)"
msgstr ""

#: src/changelog.md:258
msgid ""
"Include `PyNativeType` in `pyo3::prelude`. [\\#3692](https://github.com/PyO3/"
"pyo3/pull/3692)"
msgstr ""

#: src/changelog.md:259
msgid ""
"Improve performance of `extract::<i64>` (and other integer types) by "
"avoiding call to `__index__()` converting the value to an integer for 3.10+. "
"Gives performance improvement of around 30% for successful extraction. "
"[\\#3742](https://github.com/PyO3/pyo3/pull/3742)"
msgstr ""

#: src/changelog.md:260
msgid ""
"Relax bound of `FromPyObject` for `Py<T>` to just `T: PyTypeCheck`. [\\#3776]"
"(https://github.com/PyO3/pyo3/pull/3776)"
msgstr ""

#: src/changelog.md:261
msgid ""
"`PySet` and `PyFrozenSet` iterators now always iterate the equivalent of "
"`iter(set)`. (A \"fast path\" with no noticeable performance benefit was "
"removed.) [\\#3849](https://github.com/PyO3/pyo3/pull/3849)"
msgstr ""

#: src/changelog.md:262
msgid ""
"Move implementations of `FromPyObject` for `&str`, `Cow<str>`, `&[u8]` and "
"`Cow<[u8]>` onto a temporary trait `FromPyObjectBound` when `gil-refs` "
"feature is deactivated. [\\#3928](https://github.com/PyO3/pyo3/pull/3928)"
msgstr ""

#: src/changelog.md:263
msgid ""
"Deprecate `GILPool`, `Python::with_pool`, and `Python::new_pool`. [\\#3947]"
"(https://github.com/PyO3/pyo3/pull/3947)"
msgstr ""

#: src/changelog.md:267
msgid ""
"Remove all functionality deprecated in PyO3 0.19. [\\#3603](https://github."
"com/PyO3/pyo3/pull/3603)"
msgstr ""

#: src/changelog.md:271
msgid ""
"Match PyPy 7.3.14 in removing PyPy-only symbol `Py_MAX_NDIMS` in favour of "
"`PyBUF_MAX_NDIM`. [\\#3757](https://github.com/PyO3/pyo3/pull/3757)"
msgstr ""

#: src/changelog.md:272
msgid ""
"Fix segmentation fault using `datetime` types when an invalid `datetime` "
"module is on sys.path. [\\#3818](https://github.com/PyO3/pyo3/pull/3818)"
msgstr ""

#: src/changelog.md:273
msgid ""
"Fix `non_local_definitions` lint warning triggered by many PyO3 macros. "
"[\\#3901](https://github.com/PyO3/pyo3/pull/3901)"
msgstr ""

#: src/changelog.md:274
msgid ""
"Disable `PyCode` and `PyCode_Type` on PyPy: `PyCode_Type` is not exposed by "
"PyPy. [\\#3934](https://github.com/PyO3/pyo3/pull/3934)"
msgstr ""

#: src/changelog.md:276
msgid ""
"[0.21.0-beta.0](https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0-"
"beta.0) - 2024-03-10"
msgstr ""

#: src/changelog.md:278
msgid ""
"Prerelease of PyO3 0.21. See [the GitHub diff](https://github.com/pyo3/pyo3/"
"compare/v0.21.0-beta.0...v0.21.0) for what changed between 0.21.0-beta.0 and "
"the final release."
msgstr ""

#: src/changelog.md:280
msgid ""
"[0.20.3](https://github.com/pyo3/pyo3/compare/v0.20.2...v0.20.3) - 2024-02-23"
msgstr ""

#: src/changelog.md:284
msgid ""
"Add `portable-atomic` dependency. [\\#3619](https://github.com/PyO3/pyo3/"
"pull/3619)"
msgstr ""

#: src/changelog.md:285
msgid ""
"Check maximum version of Python at build time and for versions not yet "
"supported require opt-in to the `abi3` stable ABI by the environment "
"variable `PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1`. [\\#3821](https://github."
"com/PyO3/pyo3/pull/3821)"
msgstr ""

#: src/changelog.md:289
msgid ""
"Use `portable-atomic` to support platforms without 64-bit atomics. [\\#3619]"
"(https://github.com/PyO3/pyo3/pull/3619)"
msgstr ""

#: src/changelog.md:290
msgid ""
"Fix compilation failure with `either` feature enabled without `experimental-"
"inspect` enabled. [\\#3834](https://github.com/PyO3/pyo3/pull/3834)"
msgstr ""

#: src/changelog.md:292
msgid ""
"[0.20.2](https://github.com/pyo3/pyo3/compare/v0.20.1...v0.20.2) - 2024-01-04"
msgstr ""

#: src/changelog.md:296
msgid ""
"Pin `pyo3` and `pyo3-ffi` dependencies on `pyo3-build-config` to require the "
"same patch version, i.e. `pyo3` 0.20.2 requires _exactly_ `pyo3-build-"
"config` 0.20.2. [\\#3721](https://github.com/PyO3/pyo3/pull/3721)"
msgstr ""

#: src/changelog.md:300
msgid ""
"Fix compile failure when building `pyo3` 0.20.0 with latest `pyo3-build-"
"config` 0.20.X. [\\#3724](https://github.com/PyO3/pyo3/pull/3724)"
msgstr ""

#: src/changelog.md:301
msgid "Fix docs.rs build. [\\#3722](https://github.com/PyO3/pyo3/pull/3722)"
msgstr ""

#: src/changelog.md:303
msgid ""
"[0.20.1](https://github.com/pyo3/pyo3/compare/v0.20.0...v0.20.1) - 2023-12-30"
msgstr ""

#: src/changelog.md:307
msgid ""
"Add optional `either` feature to add conversions for `either::Either<L, R>` "
"sum type. [\\#3456](https://github.com/PyO3/pyo3/pull/3456)"
msgstr ""

#: src/changelog.md:308
msgid ""
"Add optional `smallvec` feature to add conversions for `smallvec::SmallVec`. "
"[\\#3507](https://github.com/PyO3/pyo3/pull/3507)"
msgstr ""

#: src/changelog.md:309
msgid ""
"Add `take` and `into_inner` methods to `GILOnceCell` [\\#3556](https://"
"github.com/PyO3/pyo3/pull/3556)"
msgstr ""

#: src/changelog.md:310
msgid ""
"`#[classmethod]` methods can now also receive `Py<PyType>` as their first "
"argument. [\\#3587](https://github.com/PyO3/pyo3/pull/3587)"
msgstr ""

#: src/changelog.md:311
msgid ""
"`#[pyfunction(pass_module)]` can now also receive `Py<PyModule>` as their "
"first argument. [\\#3587](https://github.com/PyO3/pyo3/pull/3587)"
msgstr ""

#: src/changelog.md:312
msgid ""
"Add `traverse` method to `GILProtected`. [\\#3616](https://github.com/PyO3/"
"pyo3/pull/3616)"
msgstr ""

#: src/changelog.md:313
msgid ""
"Added `abi3-py312` feature [\\#3687](https://github.com/PyO3/pyo3/pull/3687)"
msgstr ""

#: src/changelog.md:317
msgid ""
"Fix minimum version specification for optional `chrono` dependency. [\\#3512]"
"(https://github.com/PyO3/pyo3/pull/3512)"
msgstr ""

#: src/changelog.md:318
msgid ""
"Silenced new `clippy::unnecessary_fallible_conversions` warning when using a "
"`Py<Self>` `self` receiver. [\\#3564](https://github.com/PyO3/pyo3/pull/3564)"
msgstr ""

#: src/changelog.md:321
msgid ""
"[0.20.0](https://github.com/pyo3/pyo3/compare/v0.19.2...v0.20.0) - 2023-10-11"
msgstr ""

#: src/changelog.md:325
msgid ""
"Dual-license PyO3 under either the Apache 2.0 OR the MIT license. This makes "
"the project GPLv2 compatible. [\\#3108](https://github.com/PyO3/pyo3/"
"pull/3108)"
msgstr ""

#: src/changelog.md:326
msgid ""
"Update MSRV to Rust 1.56. [\\#3208](https://github.com/PyO3/pyo3/pull/3208)"
msgstr ""

#: src/changelog.md:327
msgid ""
"Bump `indoc` dependency to 2.0 and `unindent` dependency to 0.2. [\\#3237]"
"(https://github.com/PyO3/pyo3/pull/3237)"
msgstr ""

#: src/changelog.md:328
msgid ""
"Bump `syn` dependency to 2.0. [\\#3239](https://github.com/PyO3/pyo3/"
"pull/3239)"
msgstr ""

#: src/changelog.md:329
msgid ""
"Drop support for debug builds of Python 3.7. [\\#3387](https://github.com/"
"PyO3/pyo3/pull/3387)"
msgstr ""

#: src/changelog.md:330
msgid ""
"Bump `chrono` optional dependency to require 0.4.25 or newer. [\\#3427]"
"(https://github.com/PyO3/pyo3/pull/3427)"
msgstr ""

#: src/changelog.md:331
msgid "Support Python 3.12. [\\#3488](https://github.com/PyO3/pyo3/pull/3488)"
msgstr ""

#: src/changelog.md:335
msgid ""
"Support `__lt__`, `__le__`, `__eq__`, `__ne__`, `__gt__` and `__ge__` in "
"`#[pymethods]`. [\\#3203](https://github.com/PyO3/pyo3/pull/3203)"
msgstr ""

#: src/changelog.md:336
msgid ""
"Add FFI definition `Py_GETENV`. [\\#3336](https://github.com/PyO3/pyo3/"
"pull/3336)"
msgstr ""

#: src/changelog.md:337
msgid ""
"Add `as_ptr` and `into_ptr` inherent methods for `Py`, `PyAny`, `PyRef`, and "
"`PyRefMut`. [\\#3359](https://github.com/PyO3/pyo3/pull/3359)"
msgstr ""

#: src/changelog.md:338
msgid ""
"Implement `DoubleEndedIterator` for `PyTupleIterator` and `PyListIterator`. "
"[\\#3366](https://github.com/PyO3/pyo3/pull/3366)"
msgstr ""

#: src/changelog.md:339
msgid ""
"Add `#[pyclass(rename_all = \"...\")]` option: this allows renaming all "
"getters and setters of a struct, or all variants of an enum. Available "
"renaming rules are: `\"camelCase\"`, `\"kebab-case\"`, `\"lowercase\"`, "
"`\"PascalCase\"`, `\"SCREAMING-KEBAB-CASE\"`, `\"SCREAMING_SNAKE_CASE\"`, "
"`\"snake_case\"`, `\"UPPERCASE\"`. [\\#3384](https://github.com/PyO3/pyo3/"
"pull/3384)"
msgstr ""

#: src/changelog.md:340
msgid ""
"Add FFI definitions `PyObject_GC_IsTracked` and `PyObject_GC_IsFinalized` on "
"Python 3.9 and up (PyPy 3.10 and up). [\\#3403](https://github.com/PyO3/pyo3/"
"pull/3403)"
msgstr ""

#: src/changelog.md:341
msgid ""
"Add types for `None`, `Ellipsis`, and `NotImplemented`. [\\#3408](https://"
"github.com/PyO3/pyo3/pull/3408)"
msgstr ""

#: src/changelog.md:342
msgid ""
"Add FFI definitions for the `Py_mod_multiple_interpreters` constant and its "
"possible values. [\\#3494](https://github.com/PyO3/pyo3/pull/3494)"
msgstr ""

#: src/changelog.md:343
msgid ""
"Add FFI definitions for `PyInterpreterConfig` struct, its constants and "
"`Py_NewInterpreterFromConfig`. [\\#3502](https://github.com/PyO3/pyo3/"
"pull/3502)"
msgstr ""

#: src/changelog.md:347
msgid ""
"Change `PySet::discard` to return `PyResult<bool>` (previously returned "
"nothing). [\\#3281](https://github.com/PyO3/pyo3/pull/3281)"
msgstr ""

#: src/changelog.md:348
msgid ""
"Optimize implmentation of `IntoPy` for Rust tuples to Python tuples. "
"[\\#3321](https://github.com/PyO3/pyo3/pull/3321)"
msgstr ""

#: src/changelog.md:349
msgid ""
"Change `PyDict::get_item` to no longer suppress arbitrary exceptions (the "
"return type is now `PyResult<Option<&PyAny>>` instead of `Option<&PyAny>`), "
"and deprecate `PyDict::get_item_with_error`. [\\#3330](https://github.com/"
"PyO3/pyo3/pull/3330)"
msgstr ""

#: src/changelog.md:350
msgid ""
"Deprecate FFI definitions which are deprecated in Python 3.12. [\\#3336]"
"(https://github.com/PyO3/pyo3/pull/3336)"
msgstr ""

#: src/changelog.md:351
msgid ""
"`AsPyPointer` is now an `unsafe trait`. [\\#3358](https://github.com/PyO3/"
"pyo3/pull/3358)"
msgstr ""

#: src/changelog.md:352
msgid ""
"Accept all `os.PathLike` values in implementation of `FromPyObject` for "
"`PathBuf`. [\\#3374](https://github.com/PyO3/pyo3/pull/3374)"
msgstr ""

#: src/changelog.md:353
msgid ""
"Add `__builtins__` to globals in `py.run()` and `py.eval()` if they're "
"missing. [\\#3378](https://github.com/PyO3/pyo3/pull/3378)"
msgstr ""

#: src/changelog.md:354
msgid ""
"Optimize implementation of `FromPyObject` for `BigInt` and `BigUint`. "
"[\\#3379](https://github.com/PyO3/pyo3/pull/3379)"
msgstr ""

#: src/changelog.md:355
msgid ""
"`PyIterator::from_object` and `PyByteArray::from` now take a single argument "
"of type `&PyAny` (previously took two arguments `Python` and `AsPyPointer`). "
"[\\#3389](https://github.com/PyO3/pyo3/pull/3389)"
msgstr ""

#: src/changelog.md:356
msgid ""
"Replace `AsPyPointer` with `AsRef<PyAny>` as a bound in the blanket "
"implementation of `From<&T> for PyObject`. [\\#3391](https://github.com/PyO3/"
"pyo3/pull/3391)"
msgstr ""

#: src/changelog.md:357
msgid ""
"Replace blanket `impl IntoPy<PyObject> for &T where T: AsPyPointer` with "
"implementations of `impl IntoPy<PyObject>` for `&PyAny`, `&T where T: "
"AsRef<PyAny>`, and `&Py<T>`. [\\#3393](https://github.com/PyO3/pyo3/"
"pull/3393)"
msgstr ""

#: src/changelog.md:358
msgid ""
"Preserve `std::io::Error` kind in implementation of `From<std::io::"
"IntoInnerError>` for `PyErr` [\\#3396](https://github.com/PyO3/pyo3/"
"pull/3396)"
msgstr ""

#: src/changelog.md:359
msgid ""
"Try to select a relevant `ErrorKind` in implementation of `From<PyErr>` for "
"`OSError` subclass. [\\#3397](https://github.com/PyO3/pyo3/pull/3397)"
msgstr ""

#: src/changelog.md:360
msgid ""
"Retrieve the original `PyErr` in implementation of `From<std::io::Error>` "
"for `PyErr` if the `std::io::Error` has been built using a Python exception "
"(previously would create a new exception wrapping the `std::io::Error`). "
"[\\#3402](https://github.com/PyO3/pyo3/pull/3402)"
msgstr ""

#: src/changelog.md:361
msgid ""
"`#[pymodule]` will now return the same module object on repeated import by "
"the same Python interpreter, on Python 3.9 and up. [\\#3446](https://github."
"com/PyO3/pyo3/pull/3446)"
msgstr ""

#: src/changelog.md:362
msgid ""
"Truncate leap-seconds and warn when converting `chrono` types to Python "
"`datetime` types (`datetime` cannot represent leap-seconds). [\\#3458]"
"(https://github.com/PyO3/pyo3/pull/3458)"
msgstr ""

#: src/changelog.md:363
msgid ""
"`Err` returned from `#[pyfunction]` will now have a non-None `__context__` "
"if called from inside a `catch` block. [\\#3455](https://github.com/PyO3/"
"pyo3/pull/3455)"
msgstr ""

#: src/changelog.md:364
msgid ""
"Deprecate undocumented `#[__new__]` form of `#[new]` attribute. [\\#3505]"
"(https://github.com/PyO3/pyo3/pull/3505)"
msgstr ""

#: src/changelog.md:368
msgid ""
"Remove all functionality deprecated in PyO3 0.18, including `#[args]` "
"attribute for `#[pymethods]`. [\\#3232](https://github.com/PyO3/pyo3/"
"pull/3232)"
msgstr ""

#: src/changelog.md:369
msgid ""
"Remove `IntoPyPointer` trait in favour of `into_ptr` inherent methods. "
"[\\#3385](https://github.com/PyO3/pyo3/pull/3385)"
msgstr ""

#: src/changelog.md:373
msgid ""
"Handle exceptions properly in `PySet::discard`. [\\#3281](https://github.com/"
"PyO3/pyo3/pull/3281)"
msgstr ""

#: src/changelog.md:374
msgid ""
"The `PyTupleIterator` type returned by `PyTuple::iter` is now public and "
"hence can be named by downstream crates. [\\#3366](https://github.com/PyO3/"
"pyo3/pull/3366)"
msgstr ""

#: src/changelog.md:375
msgid ""
"Linking of `PyOS_FSPath` on PyPy. [\\#3374](https://github.com/PyO3/pyo3/"
"pull/3374)"
msgstr ""

#: src/changelog.md:376
msgid ""
"Fix memory leak in `PyTypeBuilder::build`. [\\#3401](https://github.com/PyO3/"
"pyo3/pull/3401)"
msgstr ""

#: src/changelog.md:377
msgid ""
"Disable removed FFI definitions `_Py_GetAllocatedBlocks`, "
"`_PyObject_GC_Malloc`, and `_PyObject_GC_Calloc` on Python 3.11 and up. "
"[\\#3403](https://github.com/PyO3/pyo3/pull/3403)"
msgstr ""

#: src/changelog.md:378
msgid ""
"Fix `ResourceWarning` and crashes related to GC when running with debug "
"builds of CPython. [\\#3404](https://github.com/PyO3/pyo3/pull/3404)"
msgstr ""

#: src/changelog.md:379
msgid ""
"Some-wrapping of `Option<T>` default arguments will no longer re-wrap "
"`Some(T)` or expressions evaluating to `None`. [\\#3461](https://github.com/"
"PyO3/pyo3/pull/3461)"
msgstr ""

#: src/changelog.md:380
msgid ""
"Fix `IterNextOutput::Return` not returning a value on PyPy. [\\#3471]"
"(https://github.com/PyO3/pyo3/pull/3471)"
msgstr ""

#: src/changelog.md:381
msgid ""
"Emit compile errors instead of ignoring macro invocations inside "
"`#[pymethods]` blocks. [\\#3491](https://github.com/PyO3/pyo3/pull/3491)"
msgstr ""

#: src/changelog.md:382
msgid ""
"Emit error on invalid arguments to `#[new]`, `#[classmethod]`, "
"`#[staticmethod]`, and `#[classattr]`. [\\#3484](https://github.com/PyO3/"
"pyo3/pull/3484)"
msgstr ""

#: src/changelog.md:383
msgid ""
"Disable `PyMarshal_WriteObjectToString` from "
"`PyMarshal_ReadObjectFromString` with the `abi3` feature. [\\#3490](https://"
"github.com/PyO3/pyo3/pull/3490)"
msgstr ""

#: src/changelog.md:384
msgid ""
"Fix FFI definitions for `_PyFrameEvalFunction` on Python 3.11 and up (it now "
"receives a `_PyInterpreterFrame` opaque struct). [\\#3500](https://github."
"com/PyO3/pyo3/pull/3500)"
msgstr ""

#: src/changelog.md:387
msgid ""
"[0.19.2](https://github.com/pyo3/pyo3/compare/v0.19.1...v0.19.2) - 2023-08-01"
msgstr ""

#: src/changelog.md:391
msgid ""
"Add FFI definitions `PyState_AddModule`, `PyState_RemoveModule` and "
"`PyState_FindModule` for PyPy 3.9 and up. [\\#3295](https://github.com/PyO3/"
"pyo3/pull/3295)"
msgstr ""

#: src/changelog.md:392
msgid ""
"Add FFI definitions `_PyObject_CallFunction_SizeT` and "
"`_PyObject_CallMethod_SizeT`. [\\#3297](https://github.com/PyO3/pyo3/"
"pull/3297)"
msgstr ""

#: src/changelog.md:393
msgid ""
"Add a \"performance\" section to the guide collecting performance-related "
"tricks and problems. [\\#3304](https://github.com/PyO3/pyo3/pull/3304)"
msgstr ""

#: src/changelog.md:394
msgid ""
"Add `PyErr::Display` for all Python versions, and FFI symbol "
"`PyErr_DisplayException` for Python 3.12. [\\#3334](https://github.com/PyO3/"
"pyo3/pull/3334)"
msgstr ""

#: src/changelog.md:395
msgid ""
"Add FFI definition `PyType_GetDict()` for Python 3.12. [\\#3339](https://"
"github.com/PyO3/pyo3/pull/3339)"
msgstr ""

#: src/changelog.md:396
msgid ""
"Add `PyAny::downcast_exact`. [\\#3346](https://github.com/PyO3/pyo3/"
"pull/3346)"
msgstr ""

#: src/changelog.md:397
msgid ""
"Add `PySlice::full()` to construct a full slice (`::`). [\\#3353](https://"
"github.com/PyO3/pyo3/pull/3353)"
msgstr ""

#: src/changelog.md:401
msgid ""
"Update `PyErr` for 3.12 betas to avoid deprecated ffi methods. [\\#3306]"
"(https://github.com/PyO3/pyo3/pull/3306)"
msgstr ""

#: src/changelog.md:402
msgid ""
"Update FFI definitions of `object.h` for Python 3.12.0b4. [\\#3335](https://"
"github.com/PyO3/pyo3/pull/3335)"
msgstr ""

#: src/changelog.md:403
msgid ""
"Update `pyo3::ffi` struct definitions to be compatible with 3.12.0b4. "
"[\\#3342](https://github.com/PyO3/pyo3/pull/3342)"
msgstr ""

#: src/changelog.md:404
msgid ""
"Optimize conversion of `float` to `f64` (and `PyFloat::value`) on non-abi3 "
"builds. [\\#3345](https://github.com/PyO3/pyo3/pull/3345)"
msgstr ""

#: src/changelog.md:408
msgid ""
"Fix timezone conversion bug for FixedOffset datetimes that were being "
"incorrectly converted to and from UTC. [\\#3269](https://github.com/PyO3/"
"pyo3/pull/3269)"
msgstr ""

#: src/changelog.md:409
msgid ""
"Fix `SystemError` raised in `PyUnicodeDecodeError_Create` on PyPy 3.10. "
"[\\#3297](https://github.com/PyO3/pyo3/pull/3297)"
msgstr ""

#: src/changelog.md:410
msgid ""
"Correct FFI definition `Py_EnterRecursiveCall` to return `c_int` (was "
"incorrectly returning `()`). [\\#3300](https://github.com/PyO3/pyo3/"
"pull/3300)"
msgstr ""

#: src/changelog.md:411
msgid ""
"Fix case where `PyErr::matches` and `PyErr::is_instance` returned results "
"inconsistent with `PyErr::get_type`. [\\#3313](https://github.com/PyO3/pyo3/"
"pull/3313)"
msgstr ""

#: src/changelog.md:412
msgid ""
"Fix loss of panic message in `PanicException` when unwinding after the "
"exception was \"normalized\". [\\#3326](https://github.com/PyO3/pyo3/"
"pull/3326)"
msgstr ""

#: src/changelog.md:413
msgid ""
"Fix `PyErr::from_value` and `PyErr::into_value` losing traceback on "
"conversion. [\\#3328](https://github.com/PyO3/pyo3/pull/3328)"
msgstr ""

#: src/changelog.md:414
msgid ""
"Fix reference counting of immortal objects on Python 3.12.0b4. [\\#3335]"
"(https://github.com/PyO3/pyo3/pull/3335)"
msgstr ""

#: src/changelog.md:417
msgid ""
"[0.19.1](https://github.com/pyo3/pyo3/compare/v0.19.0...v0.19.1) - 2023-07-03"
msgstr ""

#: src/changelog.md:421
msgid ""
"Extend range of supported versions of `hashbrown` optional dependency to "
"include version 0.14 [\\#3258](https://github.com/PyO3/pyo3/pull/3258)"
msgstr ""

#: src/changelog.md:422
msgid ""
"Extend range of supported versions of `indexmap` optional dependency to "
"include version 2. [\\#3277](https://github.com/PyO3/pyo3/pull/3277)"
msgstr ""

#: src/changelog.md:423
msgid "Support PyPy 3.10. [\\#3289](https://github.com/PyO3/pyo3/pull/3289)"
msgstr ""

#: src/changelog.md:427
msgid ""
"Add `pyo3::types::PyFrozenSetBuilder` to allow building a `PyFrozenSet` item "
"by item. [\\#3156](https://github.com/PyO3/pyo3/pull/3156)"
msgstr ""

#: src/changelog.md:428
msgid ""
"Add support for converting to and from Python's `ipaddress.IPv4Address`/"
"`ipaddress.IPv6Address` and `std::net::IpAddr`. [\\#3197](https://github.com/"
"PyO3/pyo3/pull/3197)"
msgstr ""

#: src/changelog.md:429
msgid ""
"Add support for `num-bigint` feature in combination with `abi3`. [\\#3198]"
"(https://github.com/PyO3/pyo3/pull/3198)"
msgstr ""

#: src/changelog.md:430
msgid ""
"Add `PyErr_GetRaisedException()`, `PyErr_SetRaisedException()` to FFI "
"definitions for Python 3.12 and later. [\\#3248](https://github.com/PyO3/"
"pyo3/pull/3248)"
msgstr ""

#: src/changelog.md:431
msgid ""
"Add `Python::with_pool` which is a safer but more limited alternative to "
"`Python::new_pool`. [\\#3263](https://github.com/PyO3/pyo3/pull/3263)"
msgstr ""

#: src/changelog.md:432
msgid ""
"Add `PyDict::get_item_with_error` on PyPy. [\\#3270](https://github.com/PyO3/"
"pyo3/pull/3270)"
msgstr ""

#: src/changelog.md:433
msgid ""
"Allow `#[new]` methods may to return `Py<Self>` in order to return existing "
"instances. [\\#3287](https://github.com/PyO3/pyo3/pull/3287)"
msgstr ""

#: src/changelog.md:437
msgid ""
"Fix conversion of classes implementing `__complex__` to `Complex` when using "
"`abi3` or PyPy. [\\#3185](https://github.com/PyO3/pyo3/pull/3185)"
msgstr ""

#: src/changelog.md:438
msgid ""
"Stop suppressing unrelated exceptions in `PyAny::hasattr`. [\\#3271](https://"
"github.com/PyO3/pyo3/pull/3271)"
msgstr ""

#: src/changelog.md:439
msgid ""
"Fix memory leak when creating `PySet` or `PyFrozenSet` or returning types "
"converted into these internally, e.g. `HashSet` or `BTreeSet`. [\\#3286]"
"(https://github.com/PyO3/pyo3/pull/3286)"
msgstr ""

#: src/changelog.md:442
msgid ""
"[0.19.0](https://github.com/pyo3/pyo3/compare/v0.18.3...v0.19.0) - 2023-05-31"
msgstr ""

#: src/changelog.md:446
msgid ""
"Correct dependency on syn to version 1.0.85 instead of the incorrect version "
"1.0.56. [\\#3152](https://github.com/PyO3/pyo3/pull/3152)"
msgstr ""

#: src/changelog.md:450
msgid ""
"Accept `text_signature` option (and automatically generate signature) for "
"`#[new]` in `#[pymethods]`. [\\#2980](https://github.com/PyO3/pyo3/pull/2980)"
msgstr ""

#: src/changelog.md:451
msgid ""
"Add support for converting to and from Python's `decimal.Decimal` and "
"`rust_decimal::Decimal`. [\\#3016](https://github.com/PyO3/pyo3/pull/3016)"
msgstr ""

#: src/changelog.md:452
msgid ""
"Add `#[pyo3(from_item_all)]` when deriving `FromPyObject` to specify "
"`get_item` as getter for all fields. [\\#3120](https://github.com/PyO3/pyo3/"
"pull/3120)"
msgstr ""

#: src/changelog.md:453
msgid ""
"Add `pyo3::exceptions::PyBaseExceptionGroup` for Python 3.11, and "
"corresponding FFI definition `PyExc_BaseExceptionGroup`. [\\#3141](https://"
"github.com/PyO3/pyo3/pull/3141)"
msgstr ""

#: src/changelog.md:454
msgid ""
"Accept `#[new]` with `#[classmethod]` to create a constructor which receives "
"a (subtype's) class/`PyType` as its first argument. [\\#3157](https://github."
"com/PyO3/pyo3/pull/3157)"
msgstr ""

#: src/changelog.md:455
msgid ""
"Add `PyClass::get` and `Py::get` for GIL-indepedent access to classes with "
"`#[pyclass(frozen)]`. [\\#3158](https://github.com/PyO3/pyo3/pull/3158)"
msgstr ""

#: src/changelog.md:456
msgid ""
"Add `PyAny::is_exact_instance` and `PyAny::is_exact_instance_of`. [\\#3161]"
"(https://github.com/PyO3/pyo3/pull/3161)"
msgstr ""

#: src/changelog.md:460
msgid ""
"`PyAny::is_instance_of::<T>(obj)` is now equivalent to `T::is_type_of(obj)`, "
"and now returns `bool` instead of `PyResult<bool>`. [\\#2881](https://github."
"com/PyO3/pyo3/pull/2881)"
msgstr ""

#: src/changelog.md:461
msgid ""
"Deprecate `text_signature` option on `#[pyclass]` structs. [\\#2980](https://"
"github.com/PyO3/pyo3/pull/2980)"
msgstr ""

#: src/changelog.md:462
msgid ""
"No longer wrap `anyhow::Error`/`eyre::Report` containing a basic `PyErr` "
"without a chain in a `PyRuntimeError`. [\\#3004](https://github.com/PyO3/"
"pyo3/pull/3004)"
msgstr ""

#: src/changelog.md:463
msgid ""
"Change `#[getter]` and `#[setter]` to use a common call \"trampoline\" to "
"slightly reduce generated code size and compile times. [\\#3029](https://"
"github.com/PyO3/pyo3/pull/3029)"
msgstr ""

#: src/changelog.md:464
msgid ""
"Improve default values for str, numbers and bool in automatically-generated "
"`text_signature`. [\\#3050](https://github.com/PyO3/pyo3/pull/3050)"
msgstr ""

#: src/changelog.md:465
msgid ""
"Improve default value for `None` in automatically-generated "
"`text_signature`. [\\#3066](https://github.com/PyO3/pyo3/pull/3066)"
msgstr ""

#: src/changelog.md:466
msgid ""
"Rename `PySequence::list` and `PySequence::tuple` to `PySequence::to_list` "
"and `PySequence::to_tuple`. (The old names continue to exist as deprecated "
"forms.) [\\#3111](https://github.com/PyO3/pyo3/pull/3111)"
msgstr ""

#: src/changelog.md:467
msgid ""
"Extend the lifetime of the GIL token returned by `PyRef::py` and `PyRefMut::"
"py` to match the underlying borrow. [\\#3131](https://github.com/PyO3/pyo3/"
"pull/3131)"
msgstr ""

#: src/changelog.md:468
msgid ""
"Safe access to the GIL, for example via `Python::with_gil`, is now locked "
"inside of implementations of the `__traverse__` slot. [\\#3168](https://"
"github.com/PyO3/pyo3/pull/3168)"
msgstr ""

#: src/changelog.md:472
msgid ""
"Remove all functionality deprecated in PyO3 0.17, most prominently `Python::"
"acquire_gil` is replaced by `Python::with_gil`. [\\#2981](https://github.com/"
"PyO3/pyo3/pull/2981)"
msgstr ""

#: src/changelog.md:476
msgid ""
"Correct FFI definitions `PyGetSetDef`, `PyMemberDef`, "
"`PyStructSequence_Field` and `PyStructSequence_Desc` to have `*const c_char` "
"members for `name` and `doc` (not `*mut c_char`). [\\#3036](https://github."
"com/PyO3/pyo3/pull/3036)"
msgstr ""

#: src/changelog.md:477
msgid ""
"Fix panic on `fmt::Display`, instead return `\"<unprintable object>\"` "
"string and report error via `sys.unraisablehook()` [\\#3062](https://github."
"com/PyO3/pyo3/pull/3062)"
msgstr ""

#: src/changelog.md:478
msgid ""
"Fix a compile error of \"temporary value dropped while borrowed\" when "
"`#[pyfunction]`s take references into `#[pyclass]`es [\\#3142](https://"
"github.com/PyO3/pyo3/pull/3142)"
msgstr ""

#: src/changelog.md:479
msgid ""
"Fix crashes caused by PyO3 applying deferred reference count updates when "
"entering a `__traverse__` implementation. [\\#3168](https://github.com/PyO3/"
"pyo3/pull/3168)"
msgstr ""

#: src/changelog.md:480
msgid ""
"Forbid running the `Drop` implementations of unsendable classes on other "
"threads. [\\#3176](https://github.com/PyO3/pyo3/pull/3176)"
msgstr ""

#: src/changelog.md:481
msgid ""
"Fix a compile error when `#[pymethods]` items come from somewhere else (for "
"example, as a macro argument) and a custom receiver like `Py<Self>` is used. "
"[\\#3178](https://github.com/PyO3/pyo3/pull/3178)"
msgstr ""

#: src/changelog.md:484
msgid ""
"[0.18.3](https://github.com/pyo3/pyo3/compare/v0.18.2...v0.18.3) - 2023-04-13"
msgstr ""

#: src/changelog.md:488
msgid ""
"Add `GILProtected<T>` to mediate concurrent access to a value using Python's "
"global interpreter lock (GIL). [\\#2975](https://github.com/PyO3/pyo3/"
"pull/2975)"
msgstr ""

#: src/changelog.md:489
msgid ""
"Support `PyASCIIObject` / `PyUnicode` and associated methods on big-endian "
"architectures. [\\#3015](https://github.com/PyO3/pyo3/pull/3015)"
msgstr ""

#: src/changelog.md:490
msgid ""
"Add FFI definition `_PyDict_Contains_KnownHash()` for CPython 3.10 and up. "
"[\\#3088](https://github.com/PyO3/pyo3/pull/3088)"
msgstr ""

#: src/changelog.md:494
msgid ""
"Fix compile error for `#[pymethods]` and `#[pyfunction]` called \"output\". "
"[\\#3022](https://github.com/PyO3/pyo3/pull/3022)"
msgstr ""

#: src/changelog.md:495
msgid ""
"Fix compile error in generated code for magic methods implemented as a "
"`#[staticmethod]`. [\\#3055](https://github.com/PyO3/pyo3/pull/3055)"
msgstr ""

#: src/changelog.md:496
msgid ""
"Fix `is_instance` for `PyDateTime` (would incorrectly check for a `PyDate`). "
"[\\#3071](https://github.com/PyO3/pyo3/pull/3071)"
msgstr ""

#: src/changelog.md:497
msgid ""
"Fix upstream deprecation of `PyUnicode_InternImmortal` since Python 3.10. "
"[\\#3071](https://github.com/PyO3/pyo3/pull/3087)"
msgstr ""

#: src/changelog.md:500
msgid ""
"[0.18.2](https://github.com/pyo3/pyo3/compare/v0.18.1...v0.18.2) - 2023-03-24"
msgstr ""

#: src/changelog.md:504
msgid ""
"Disable default features of `chrono` to avoid depending on `time` v0.1.x. "
"[\\#2939](https://github.com/PyO3/pyo3/pull/2939)"
msgstr ""

#: src/changelog.md:508
msgid ""
"Implement `IntoPy<PyObject>`, `ToPyObject` and `FromPyObject` for "
"`Cow<[u8]>` to efficiently handle both `bytes` and `bytearray` objects. "
"[\\#2899](https://github.com/PyO3/pyo3/pull/2899)"
msgstr ""

#: src/changelog.md:509
msgid ""
"Implement `IntoPy<PyObject>`, `ToPyObject` and `FromPyObject` for `Cell<T>`. "
"[\\#3014](https://github.com/PyO3/pyo3/pull/3014)"
msgstr ""

#: src/changelog.md:510
msgid ""
"Add `PyList::to_tuple()`, as a convenient and efficient conversion from "
"lists to tuples. [\\#3042](https://github.com/PyO3/pyo3/pull/3042)"
msgstr ""

#: src/changelog.md:511
msgid ""
"Add `PyTuple::to_list()`, as a convenient and efficient conversion from "
"tuples to lists. [\\#3044](https://github.com/PyO3/pyo3/pull/3044)"
msgstr ""

#: src/changelog.md:515
msgid ""
"Optimize `PySequence` conversion for `list` and `tuple` inputs. [\\#2944]"
"(https://github.com/PyO3/pyo3/pull/2944)"
msgstr ""

#: src/changelog.md:516
msgid ""
"Improve exception raised when creating `#[pyclass]` type object fails during "
"module import. [\\#2947](https://github.com/PyO3/pyo3/pull/2947)"
msgstr ""

#: src/changelog.md:517
msgid ""
"Optimize `PyMapping` conversion for `dict` inputs. [\\#2954](https://github."
"com/PyO3/pyo3/pull/2954)"
msgstr ""

#: src/changelog.md:518
msgid ""
"Allow `create_exception!` to take a `dotted.module` to place the exception "
"in a submodule. [\\#2979](https://github.com/PyO3/pyo3/pull/2979)"
msgstr ""

#: src/changelog.md:522
msgid ""
"Fix a reference counting race condition affecting `PyObject`s cloned in "
"`allow_threads` blocks. [\\#2952](https://github.com/PyO3/pyo3/pull/2952)"
msgstr ""

#: src/changelog.md:523
msgid ""
"Fix `clippy::redundant_closure` lint on default arguments in "
"`#[pyo3(signature = (...))]` annotations. [\\#2990](https://github.com/PyO3/"
"pyo3/pull/2990)"
msgstr ""

#: src/changelog.md:524
msgid ""
"Fix `non_snake_case` lint on generated code in `#[pyfunction]` macro. "
"[\\#2993](https://github.com/PyO3/pyo3/pull/2993)"
msgstr ""

#: src/changelog.md:525
msgid ""
"Fix some FFI definitions for the upcoming PyPy 3.10 release. [\\#3031]"
"(https://github.com/PyO3/pyo3/pull/3031)"
msgstr ""

#: src/changelog.md:528
msgid ""
"[0.18.1](https://github.com/pyo3/pyo3/compare/v0.18.0...v0.18.1) - 2023-02-07"
msgstr ""

#: src/changelog.md:532
msgid ""
"Add `PyErr::write_unraisable()`. [\\#2889](https://github.com/PyO3/pyo3/"
"pull/2889)"
msgstr ""

#: src/changelog.md:533
msgid ""
"Add `Python::Ellipsis()` and `PyAny::is_ellipsis()` methods. [\\#2911]"
"(https://github.com/PyO3/pyo3/pull/2911)"
msgstr ""

#: src/changelog.md:534
msgid ""
"Add `PyDict::update()` and `PyDict::update_if_missing()` methods. [\\#2912]"
"(https://github.com/PyO3/pyo3/pull/2912)"
msgstr ""

#: src/changelog.md:538
msgid ""
"FFI definition `PyIter_Check` on CPython 3.7 is now implemented as "
"`hasattr(type(obj), \"__next__\")`, which works correctly on all platforms "
"and adds support for `abi3`. [\\#2914](https://github.com/PyO3/pyo3/"
"pull/2914)"
msgstr ""

#: src/changelog.md:539
msgid ""
"Warn about unknown config keys in `PYO3_CONFIG_FILE` instead of denying. "
"[\\#2926](https://github.com/PyO3/pyo3/pull/2926)"
msgstr ""

#: src/changelog.md:543
msgid ""
"Send errors returned by `__releasebuffer__` to `sys.unraisablehook` rather "
"than causing `SystemError`. [\\#2886](https://github.com/PyO3/pyo3/pull/2886)"
msgstr ""

#: src/changelog.md:544
msgid ""
"Fix downcast to `PyIterator` succeeding for Python classes which did not "
"implement `__next__`. [\\#2914](https://github.com/PyO3/pyo3/pull/2914)"
msgstr ""

#: src/changelog.md:545
msgid ""
"Fix segfault in `__traverse__` when visiting `None` fields of `Option<T: "
"AsPyPointer>`. [\\#2921](https://github.com/PyO3/pyo3/pull/2921)"
msgstr ""

#: src/changelog.md:546
msgid ""
"Fix `#[pymethods(crate = \"...\")]` option being ignored. [\\#2923](https://"
"github.com/PyO3/pyo3/pull/2923)"
msgstr ""

#: src/changelog.md:547
msgid ""
"Link against `pythonXY_d.dll` for debug Python builds on Windows. [\\#2937]"
"(https://github.com/PyO3/pyo3/pull/2937)"
msgstr ""

#: src/changelog.md:550
msgid ""
"[0.18.0](https://github.com/pyo3/pyo3/compare/v0.17.3...v0.18.0) - 2023-01-17"
msgstr ""

#: src/changelog.md:554
msgid ""
"Relax `indexmap` optional depecency to allow `>= 1.6, < 2`. [\\#2849]"
"(https://github.com/PyO3/pyo3/pull/2849)"
msgstr ""

#: src/changelog.md:555
msgid ""
"Relax `hashbrown` optional dependency to allow `>= 0.9, < 0.14`. [\\#2875]"
"(https://github.com/PyO3/pyo3/pull/2875)"
msgstr ""

#: src/changelog.md:556
msgid ""
"Update `memoffset` dependency to 0.8. [\\#2875](https://github.com/PyO3/pyo3/"
"pull/2875)"
msgstr ""

#: src/changelog.md:560
msgid ""
"Add `GILOnceCell::get_or_try_init` for fallible `GILOnceCell` "
"initialization. [\\#2398](https://github.com/PyO3/pyo3/pull/2398)"
msgstr ""

#: src/changelog.md:561
msgid ""
"Add experimental feature `experimental-inspect` with `type_input()` and "
"`type_output()` helpers to get the Python type of any Python-compatible "
"object. [\\#2490](https://github.com/PyO3/pyo3/pull/2490) [\\#2882](https://"
"github.com/PyO3/pyo3/pull/2882)"
msgstr ""

#: src/changelog.md:562
msgid ""
"The `#[pyclass]` macro can now take `get_all` and `set_all` to create "
"getters and setters for every field. [\\#2692](https://github.com/PyO3/pyo3/"
"pull/2692)"
msgstr ""

#: src/changelog.md:563
msgid ""
"Add `#[pyo3(signature = (...))]` option for `#[pyfunction]` and "
"`#[pymethods]`. [\\#2702](https://github.com/PyO3/pyo3/pull/2702)"
msgstr ""

#: src/changelog.md:564
msgid ""
"`pyo3-build-config`: rebuild when `PYO3_ENVIRONMENT_SIGNATURE` environment "
"variable value changes. [\\#2727](https://github.com/PyO3/pyo3/pull/2727)"
msgstr ""

#: src/changelog.md:565
msgid ""
"Add conversions between non-zero int types in `std::num` and Python `int`. "
"[\\#2730](https://github.com/PyO3/pyo3/pull/2730)"
msgstr ""

#: src/changelog.md:566
msgid ""
"Add `Py::downcast()` as a companion to `PyAny::downcast()`, as well as "
"`downcast_unchecked()` for both types. [\\#2734](https://github.com/PyO3/"
"pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:567
msgid ""
"Add types for all built-in `Warning` classes as well as `PyErr::"
"warn_explicit`. [\\#2742](https://github.com/PyO3/pyo3/pull/2742)"
msgstr ""

#: src/changelog.md:568
msgid ""
"Add `abi3-py311` feature. [\\#2776](https://github.com/PyO3/pyo3/pull/2776)"
msgstr ""

#: src/changelog.md:569
msgid ""
"Add FFI definition `_PyErr_ChainExceptions()` for CPython. [\\#2788](https://"
"github.com/PyO3/pyo3/pull/2788)"
msgstr ""

#: src/changelog.md:570
msgid ""
"Add FFI definitions `PyVectorcall_NARGS` and "
"`PY_VECTORCALL_ARGUMENTS_OFFSET` for PyPy 3.8 and up. [\\#2811](https://"
"github.com/PyO3/pyo3/pull/2811)"
msgstr ""

#: src/changelog.md:571
msgid ""
"Add `PyList::get_item_unchecked` for PyPy. [\\#2827](https://github.com/PyO3/"
"pyo3/pull/2827)"
msgstr ""

#: src/changelog.md:575
msgid ""
"PyO3's macros now emit a much nicer error message if function return values "
"don't implement the required trait(s). [\\#2664](https://github.com/PyO3/"
"pyo3/pull/2664)"
msgstr ""

#: src/changelog.md:576
msgid ""
"Use a TypeError, rather than a ValueError, when refusing to treat a str as a "
"Vec. [\\#2685](https://github.com/PyO3/pyo3/pull/2685)"
msgstr ""

#: src/changelog.md:577
msgid ""
"Change `PyCFunction::new_closure` to take `name` and `doc` arguments. "
"[\\#2686](https://github.com/PyO3/pyo3/pull/2686)"
msgstr ""

#: src/changelog.md:578
msgid ""
"`PyType::is_subclass`, `PyErr::is_instance` and `PyAny::is_instance` now "
"take `&PyAny` instead of `&PyType` arguments, so that they work with objects "
"that pretend to be types using `__subclasscheck__` and `__instancecheck__`. "
"[\\#2695](https://github.com/PyO3/pyo3/pull/2695)"
msgstr ""

#: src/changelog.md:579
msgid ""
"Deprecate `#[args]` attribute and passing \"args\" specification directly to "
"`#[pyfunction]` in favor of the new `#[pyo3(signature = (...))]` option. "
"[\\#2702](https://github.com/PyO3/pyo3/pull/2702)"
msgstr ""

#: src/changelog.md:580
msgid ""
"Deprecate required arguments after `Option<T>` arguments to `#[pyfunction]` "
"and `#[pymethods]` without also using `#[pyo3(signature)]` to specify "
"whether the arguments should be required or have defaults. [\\#2703](https://"
"github.com/PyO3/pyo3/pull/2703)"
msgstr ""

#: src/changelog.md:581
msgid ""
"Change `#[pyfunction]` and `#[pymethods]` to use a common call "
"\"trampoline\" to slightly reduce generated code size and compile times. "
"[\\#2705](https://github.com/PyO3/pyo3/pull/2705)"
msgstr ""

#: src/changelog.md:582
msgid ""
"`PyAny::cast_as()` and `Py::cast_as()` are now deprecated in favor of "
"`PyAny::downcast()` and the new `Py::downcast()`. [\\#2734](https://github."
"com/PyO3/pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:583
msgid ""
"Relax lifetime bounds on `PyAny::downcast()`. [\\#2734](https://github.com/"
"PyO3/pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:584
msgid ""
"Automatically generate `__text_signature__` for all Python functions created "
"using `#[pyfunction]` and `#[pymethods]`. [\\#2784](https://github.com/PyO3/"
"pyo3/pull/2784)"
msgstr ""

#: src/changelog.md:585
msgid ""
"Accept any iterator in `PySet::new` and `PyFrozenSet::new`. [\\#2795]"
"(https://github.com/PyO3/pyo3/pull/2795)"
msgstr ""

#: src/changelog.md:586
msgid ""
"Mixing `#[cfg(...)]` and `#[pyo3(...)]` attributes on `#[pyclass]` struct "
"fields will now work. [\\#2796](https://github.com/PyO3/pyo3/pull/2796)"
msgstr ""

#: src/changelog.md:587
msgid ""
"Re-enable `PyFunction` on when building for abi3 or PyPy. [\\#2838](https://"
"github.com/PyO3/pyo3/pull/2838)"
msgstr ""

#: src/changelog.md:588
msgid ""
"Improve `derive(FromPyObject)` to use `intern!` when applicable for "
"`#[pyo3(item)]`. [\\#2879](https://github.com/PyO3/pyo3/pull/2879)"
msgstr ""

#: src/changelog.md:592
msgid ""
"Remove the deprecated `pyproto` feature, `#[pyproto]` macro, and all "
"accompanying APIs. [\\#2587](https://github.com/PyO3/pyo3/pull/2587)"
msgstr ""

#: src/changelog.md:593
msgid ""
"Remove all functionality deprecated in PyO3 0.16. [\\#2843](https://github."
"com/PyO3/pyo3/pull/2843)"
msgstr ""

#: src/changelog.md:597
msgid ""
"Disable `PyModule::filename` on PyPy. [\\#2715](https://github.com/PyO3/pyo3/"
"pull/2715)"
msgstr ""

#: src/changelog.md:598
msgid ""
"`PyCodeObject` is now once again defined with fields on Python 3.7. [\\#2726]"
"(https://github.com/PyO3/pyo3/pull/2726)"
msgstr ""

#: src/changelog.md:599
msgid ""
"Raise a `TypeError` if `#[new]` pymethods with no arguments receive "
"arguments when called from Python. [\\#2749](https://github.com/PyO3/pyo3/"
"pull/2749)"
msgstr ""

#: src/changelog.md:600
msgid ""
"Use the `NOARGS` argument calling convention for methods that have a single "
"`py: Python` argument (as a performance optimization). [\\#2760](https://"
"github.com/PyO3/pyo3/pull/2760)"
msgstr ""

#: src/changelog.md:601
msgid ""
"Fix truncation of `isize` values to `c_long` in `PySlice::new`. [\\#2769]"
"(https://github.com/PyO3/pyo3/pull/2769)"
msgstr ""

#: src/changelog.md:602
msgid ""
"Fix soundness issue with FFI definition `PyUnicodeDecodeError_Create` on "
"PyPy leading to indeterminate behavior (typically a `TypeError`). [\\#2772]"
"(https://github.com/PyO3/pyo3/pull/2772)"
msgstr ""

#: src/changelog.md:603
msgid ""
"Allow functions taking `**kwargs` to accept keyword arguments which share a "
"name with a positional-only argument (as permitted by PEP 570). [\\#2800]"
"(https://github.com/PyO3/pyo3/pull/2800)"
msgstr ""

#: src/changelog.md:604
msgid ""
"Fix unresolved symbol for `PyObject_Vectorcall` on PyPy 3.9 and up. [\\#2811]"
"(https://github.com/PyO3/pyo3/pull/2811)"
msgstr ""

#: src/changelog.md:605
msgid ""
"Fix memory leak in `PyCFunction::new_closure`. [\\#2842](https://github.com/"
"PyO3/pyo3/pull/2842)"
msgstr ""

#: src/changelog.md:608
msgid ""
"[0.17.3](https://github.com/pyo3/pyo3/compare/v0.17.2...v0.17.3) - 2022-11-01"
msgstr ""

#: src/changelog.md:612
msgid ""
"Support Python 3.11. (Previous versions of PyO3 0.17 have been tested "
"against Python 3.11 release candidates and are expected to be compatible, "
"this is the first version tested against Python 3.11.0.) [\\#2708](https://"
"github.com/PyO3/pyo3/pull/2708)"
msgstr ""

#: src/changelog.md:616
msgid ""
"Implemented `ExactSizeIterator` for `PyListIterator`, `PyDictIterator`, "
"`PySetIterator` and `PyFrozenSetIterator`. [\\#2676](https://github.com/PyO3/"
"pyo3/pull/2676)"
msgstr ""

#: src/changelog.md:620
msgid ""
"Fix regression of `impl FromPyObject for [T; N]` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since version 0.17.0. This "
"the same fix that was applied `impl FromPyObject for Vec<T>` in version "
"0.17.1 extended to fixed-size arrays. [\\#2675](https://github.com/PyO3/pyo3/"
"pull/2675)"
msgstr ""

#: src/changelog.md:621
msgid ""
"Fix UB in `FunctionDescription::extract_arguments_fastcall` due to creating "
"slices from a null pointer. [\\#2687](https://github.com/PyO3/pyo3/pull/2687)"
msgstr ""

#: src/changelog.md:624
msgid ""
"[0.17.2](https://github.com/pyo3/pyo3/compare/v0.17.1...v0.17.2) - 2022-10-04"
msgstr ""

#: src/changelog.md:628
msgid ""
"Added optional `chrono` feature to convert `chrono` types into types in the "
"`datetime` module. [\\#2612](https://github.com/PyO3/pyo3/pull/2612)"
msgstr ""

#: src/changelog.md:632
msgid ""
"Add support for `num-bigint` feature on `PyPy`. [\\#2626](https://github.com/"
"PyO3/pyo3/pull/2626)"
msgstr ""

#: src/changelog.md:636
msgid ""
"Correctly implement `__richcmp__` for enums, fixing `__ne__` returning "
"always returning `True`. [\\#2622](https://github.com/PyO3/pyo3/pull/2622)"
msgstr ""

#: src/changelog.md:637
msgid ""
"Fix compile error since 0.17.0 with `Option<&SomePyClass>` argument with a "
"default. [\\#2630](https://github.com/PyO3/pyo3/pull/2630)"
msgstr ""

#: src/changelog.md:638
msgid ""
"Fix regression of `impl FromPyObject for Vec<T>` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since 0.17.0. [\\#2631]"
"(https://github.com/PyO3/pyo3/pull/2631)"
msgstr ""

#: src/changelog.md:640
msgid ""
"[0.17.1](https://github.com/pyo3/pyo3/compare/v0.17.0...v0.17.1) - 2022-08-28"
msgstr ""

#: src/changelog.md:644
msgid ""
"Fix visibility of `PyDictItems`, `PyDictKeys`, and `PyDictValues` types "
"added in PyO3 0.17.0."
msgstr ""

#: src/changelog.md:645
msgid ""
"Fix compile failure when using `#[pyo3(from_py_with = \"...\")]` attribute "
"on an argument of type `Option<T>`. [\\#2592](https://github.com/PyO3/pyo3/"
"pull/2592)"
msgstr ""

#: src/changelog.md:646
msgid ""
"Fix clippy `redundant-closure` lint on `**kwargs` arguments for "
"`#[pyfunction]` and `#[pymethods]`. [\\#2595](https://github.com/PyO3/pyo3/"
"pull/2595)"
msgstr ""

#: src/changelog.md:648
msgid ""
"[0.17.0](https://github.com/pyo3/pyo3/compare/v0.16.6...v0.17.0) - 2022-08-23"
msgstr ""

#: src/changelog.md:652
msgid ""
"Update inventory dependency to `0.3` (the `multiple-pymethods` feature now "
"requires Rust 1.62 for correctness). [\\#2492](https://github.com/PyO3/pyo3/"
"pull/2492)"
msgstr ""

#: src/changelog.md:656
msgid "Add `timezone_utc`. [\\#1588](https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:657
msgid ""
"Implement `ToPyObject` for `[T; N]`. [\\#2313](https://github.com/PyO3/pyo3/"
"pull/2313)"
msgstr ""

#: src/changelog.md:658
msgid ""
"Add `PyDictKeys`, `PyDictValues` and `PyDictItems` Rust types. [\\#2358]"
"(https://github.com/PyO3/pyo3/pull/2358)"
msgstr ""

#: src/changelog.md:659
msgid ""
"Add `append_to_inittab`. [\\#2377](https://github.com/PyO3/pyo3/pull/2377)"
msgstr ""

#: src/changelog.md:660
msgid ""
"Add FFI definition `PyFrame_GetCode`. [\\#2406](https://github.com/PyO3/pyo3/"
"pull/2406)"
msgstr ""

#: src/changelog.md:661
msgid ""
"Add `PyCode` and `PyFrame` high level objects. [\\#2408](https://github.com/"
"PyO3/pyo3/pull/2408)"
msgstr ""

#: src/changelog.md:662
msgid ""
"Add FFI definitions `Py_fstring_input`, `sendfunc`, and `_PyErr_StackItem`. "
"[\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:663
msgid ""
"Add `PyDateTime::new_with_fold`, `PyTime::new_with_fold`, `PyTime::"
"get_fold`, and `PyDateTime::get_fold` for PyPy. [\\#2428](https://github.com/"
"PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:664
msgid ""
"Add `#[pyclass(frozen)]`. [\\#2448](https://github.com/PyO3/pyo3/pull/2448)"
msgstr ""

#: src/changelog.md:665
msgid ""
"Accept `#[pyo3(name)]` on enum variants. [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:666
msgid ""
"Add `CompareOp::matches` to implement `__richcmp__` as the result of a Rust "
"`std::cmp::Ordering` comparison. [\\#2460](https://github.com/PyO3/pyo3/"
"pull/2460)"
msgstr ""

#: src/changelog.md:667
msgid "Add `PySuper` type. [\\#2486](https://github.com/PyO3/pyo3/pull/2486)"
msgstr ""

#: src/changelog.md:668
msgid ""
"Support PyPy on Windows with the `generate-import-lib` feature. [\\#2506]"
"(https://github.com/PyO3/pyo3/pull/2506)"
msgstr ""

#: src/changelog.md:669
msgid ""
"Add FFI definitions `Py_EnterRecursiveCall` and `Py_LeaveRecursiveCall`. "
"[\\#2511](https://github.com/PyO3/pyo3/pull/2511)"
msgstr ""

#: src/changelog.md:670
msgid ""
"Add `PyDict::get_item_with_error`. [\\#2536](https://github.com/PyO3/pyo3/"
"pull/2536)"
msgstr ""

#: src/changelog.md:671
msgid ""
"Add `#[pyclass(sequence)]` option. [\\#2567](https://github.com/PyO3/pyo3/"
"pull/2567)"
msgstr ""

#: src/changelog.md:675
msgid ""
"Change datetime constructors taking a `tzinfo` to take `Option<&PyTzInfo>` "
"instead of `Option<&PyObject>`: `PyDateTime::new`, `PyDateTime::"
"new_with_fold`, `PyTime::new`, and `PyTime::new_with_fold`. [\\#1588]"
"(https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:676
msgid ""
"Move `PyTypeObject::type_object` method to the `PyTypeInfo` trait, and "
"deprecate the `PyTypeObject` trait. [\\#2287](https://github.com/PyO3/pyo3/"
"pull/2287)"
msgstr ""

#: src/changelog.md:677
msgid ""
"Methods of `Py` and `PyAny` now accept `impl IntoPy<Py<PyString>>` rather "
"than just `&str` to allow use of the `intern!` macro. [\\#2312](https://"
"github.com/PyO3/pyo3/pull/2312)"
msgstr ""

#: src/changelog.md:678
msgid ""
"Change the deprecated `pyproto` feature to be opt-in instead of opt-out. "
"[\\#2322](https://github.com/PyO3/pyo3/pull/2322)"
msgstr ""

#: src/changelog.md:679
msgid ""
"Emit better error messages when `#[pyfunction]` return types do not "
"implement `IntoPy`. [\\#2326](https://github.com/PyO3/pyo3/pull/2326)"
msgstr ""

#: src/changelog.md:680
msgid ""
"Require `T: IntoPy` for `impl<T, const N: usize> IntoPy<PyObject> for [T; "
"N]` instead of `T: ToPyObject`. [\\#2326](https://github.com/PyO3/pyo3/"
"pull/2326)"
msgstr ""

#: src/changelog.md:681
msgid ""
"Deprecate the `ToBorrowedObject` trait. [\\#2333](https://github.com/PyO3/"
"pyo3/pull/2333)"
msgstr ""

#: src/changelog.md:682 src/changelog.md:683
msgid ""
"Iterators over `PySet` and `PyDict` will now panic if the underlying "
"collection is mutated during the iteration. [\\#2380](https://github.com/"
"PyO3/pyo3/pull/2380)"
msgstr ""

#: src/changelog.md:684
msgid ""
"Allow `#[classattr]` methods to be fallible. [\\#2385](https://github.com/"
"PyO3/pyo3/pull/2385)"
msgstr ""

#: src/changelog.md:685
msgid ""
"Prevent multiple `#[pymethods]` with the same name for a single "
"`#[pyclass]`. [\\#2399](https://github.com/PyO3/pyo3/pull/2399)"
msgstr ""

#: src/changelog.md:686
msgid ""
"Fixup `lib_name` when using `PYO3_CONFIG_FILE`. [\\#2404](https://github.com/"
"PyO3/pyo3/pull/2404)"
msgstr ""

#: src/changelog.md:687
msgid ""
"Add a message to the `ValueError` raised by the `#[derive(FromPyObject)]` "
"implementation for a tuple struct. [\\#2414](https://github.com/PyO3/pyo3/"
"pull/2414)"
msgstr ""

#: src/changelog.md:688
msgid ""
"Allow `#[classattr]` methods to take `Python` argument. [\\#2456](https://"
"github.com/PyO3/pyo3/pull/2456)"
msgstr ""

#: src/changelog.md:689
msgid ""
"Rework `PyCapsule` type to resolve soundness issues: [\\#2485](https://"
"github.com/PyO3/pyo3/pull/2485)"
msgstr ""

#: src/changelog.md:690
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take `name: "
"Option<CString>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:691
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` must now be `Send`."
msgstr ""

#: src/changelog.md:692
msgid ""
"`PyCapsule::get_context` deprecated in favor of `PyCapsule::context` which "
"doesn't take a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:693
msgid "`PyCapsule::set_context` no longer takes a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:694
msgid ""
"`PyCapsule::name` now returns `PyResult<Option<&CStr>>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:695
msgid ""
"`FromPyObject::extract` for `Vec<T>` no longer accepts Python `str` inputs. "
"[\\#2500](https://github.com/PyO3/pyo3/pull/2500)"
msgstr ""

#: src/changelog.md:696
msgid ""
"Ensure each `#[pymodule]` is only initialized once. [\\#2523](https://github."
"com/PyO3/pyo3/pull/2523)"
msgstr ""

#: src/changelog.md:697
msgid ""
"`pyo3_build_config::add_extension_module_link_args` now also emits linker "
"arguments for `wasm32-unknown-emscripten`. [\\#2538](https://github.com/PyO3/"
"pyo3/pull/2538)"
msgstr ""

#: src/changelog.md:698
msgid ""
"Type checks for `PySequence` and `PyMapping` now require inputs to inherit "
"from (or register with) `collections.abc.Sequence` and `collections.abc."
"Mapping` respectively. [\\#2477](https://github.com/PyO3/pyo3/pull/2477)"
msgstr ""

#: src/changelog.md:699
msgid ""
"Disable `PyFunction` on when building for abi3 or PyPy. [\\#2542](https://"
"github.com/PyO3/pyo3/pull/2542)"
msgstr ""

#: src/changelog.md:700
msgid ""
"Deprecate `Python::acquire_gil`. [\\#2549](https://github.com/PyO3/pyo3/"
"pull/2549)"
msgstr ""

#: src/changelog.md:704
msgid ""
"Remove all functionality deprecated in PyO3 0.15. [\\#2283](https://github."
"com/PyO3/pyo3/pull/2283)"
msgstr ""

#: src/changelog.md:705
msgid ""
"Make the `Dict`, `WeakRef` and `BaseNativeType` members of the `PyClass` "
"private implementation details. [\\#2572](https://github.com/PyO3/pyo3/"
"pull/2572)"
msgstr ""

#: src/changelog.md:709
msgid ""
"Enable incorrectly disabled FFI definition `PyThreadState_DeleteCurrent`. "
"[\\#2357](https://github.com/PyO3/pyo3/pull/2357)"
msgstr ""

#: src/changelog.md:710
msgid ""
"Fix `wrap_pymodule` interactions with name resolution rules: it no longer "
"\"sees through\" glob imports of `use submodule::*` when `submodule::"
"submodule` is a `#[pymodule]`. [\\#2363](https://github.com/PyO3/pyo3/"
"pull/2363)"
msgstr ""

#: src/changelog.md:711
msgid ""
"Correct FFI definition `PyEval_EvalCodeEx` to take `*const *mut PyObject` "
"array arguments instead of `*mut *mut PyObject`. [\\#2368](https://github."
"com/PyO3/pyo3/pull/2368)"
msgstr ""

#: src/changelog.md:712
msgid ""
"Fix \"raw-ident\" structs (e.g. `#[pyclass] struct r#RawName`) incorrectly "
"having `r#` at the start of the class name created in Python. [\\#2395]"
"(https://github.com/PyO3/pyo3/pull/2395)"
msgstr ""

#: src/changelog.md:713
msgid ""
"Correct FFI definition `Py_tracefunc` to be `unsafe extern \"C\" fn` (was "
"previously safe). [\\#2407](https://github.com/PyO3/pyo3/pull/2407)"
msgstr ""

#: src/changelog.md:714
msgid ""
"Fix compile failure with `#[pyo3(from_py_with = \"...\")]` annotations on a "
"field in a `#[derive(FromPyObject)]` struct. [\\#2414](https://github.com/"
"PyO3/pyo3/pull/2414)"
msgstr ""

#: src/changelog.md:715
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"lacking leading underscores in their names. [\\#2421](https://github.com/"
"PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:716
msgid ""
"Remove FFI definition `PyArena` on Python 3.10 and up. [\\#2421](https://"
"github.com/PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:717
msgid ""
"Fix FFI definition `PyCompilerFlags` missing member `cf_feature_version` on "
"Python 3.8 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:718
msgid ""
"Fix FFI definition `PyAsyncMethods` missing member `am_send` on Python 3.10 "
"and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:719
msgid ""
"Fix FFI definition `PyGenObject` having multiple incorrect members on "
"various Python versions. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:720
msgid ""
"Fix FFI definition `PySyntaxErrorObject` missing members `end_lineno` and "
"`end_offset` on Python 3.10 and up. [\\#2423](https://github.com/PyO3/pyo3/"
"pull/2423)"
msgstr ""

#: src/changelog.md:721
msgid ""
"Fix FFI definition `PyHeapTypeObject` missing member `ht_module` on Python "
"3.9 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:722
msgid ""
"Fix FFI definition `PyFrameObject` having multiple incorrect members on "
"various Python versions. [\\#2424](https://github.com/PyO3/pyo3/pull/2424) "
"[\\#2434](https://github.com/PyO3/pyo3/pull/2434)"
msgstr ""

#: src/changelog.md:723
msgid ""
"Fix FFI definition `PyTypeObject` missing deprecated field `tp_print` on "
"Python 3.8. [\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:724
msgid ""
"Fix FFI definitions `PyDateTime_CAPI`. `PyDateTime_Date`, `PyASCIIObject`, "
"`PyBaseExceptionObject`, `PyListObject`, and `PyTypeObject` on PyPy. "
"[\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:725
msgid ""
"Fix FFI definition `_inittab` field `initfunc` typo'd as `initfun`. [\\#2431]"
"(https://github.com/PyO3/pyo3/pull/2431)"
msgstr ""

#: src/changelog.md:726
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"incorrectly having `fold` member. [\\#2432](https://github.com/PyO3/pyo3/"
"pull/2432)"
msgstr ""

#: src/changelog.md:727
msgid ""
"Fix FFI definitions `PyTypeObject`. `PyHeapTypeObject`, and "
"`PyCFunctionObject` having incorrect members on PyPy 3.9. [\\#2433](https://"
"github.com/PyO3/pyo3/pull/2433)"
msgstr ""

#: src/changelog.md:728
msgid ""
"Fix FFI definition `PyGetSetDef` to have `*const c_char` for `doc` member "
"(not `*mut c_char`). [\\#2439](https://github.com/PyO3/pyo3/pull/2439)"
msgstr ""

#: src/changelog.md:729
msgid ""
"Fix `#[pyo3(from_py_with = \"...\")]` being ignored for 1-element tuple "
"structs and transparent structs. [\\#2440](https://github.com/PyO3/pyo3/"
"pull/2440)"
msgstr ""

#: src/changelog.md:730
msgid ""
"Use `memoffset` to avoid UB when computing `PyCell` layout. [\\#2450]"
"(https://github.com/PyO3/pyo3/pull/2450)"
msgstr ""

#: src/changelog.md:731
msgid ""
"Fix incorrect enum names being returned by the generated `repr` for enums "
"renamed by `#[pyclass(name = \"...\")]` [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:732
msgid ""
"Fix `PyObject_CallNoArgs` incorrectly being available when building for abi3 "
"on Python 3.9. [\\#2476](https://github.com/PyO3/pyo3/pull/2476)"
msgstr ""

#: src/changelog.md:733
msgid ""
"Fix several clippy warnings generated by `#[pyfunction]` arguments. [\\#2503]"
"(https://github.com/PyO3/pyo3/pull/2503)"
msgstr ""

#: src/changelog.md:735
msgid ""
"[0.16.6](https://github.com/pyo3/pyo3/compare/v0.16.5...v0.16.6) - 2022-08-23"
msgstr ""

#: src/changelog.md:739
msgid ""
"Fix soundness issues with `PyCapsule` type with select workarounds. Users "
"are encourage to upgrade to PyO3 0.17 at their earliest convenience which "
"contains API breakages which fix the issues in a long-term fashion. [\\#2522]"
"(https://github.com/PyO3/pyo3/pull/2522)"
msgstr ""

#: src/changelog.md:740
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take ownership of "
"a copy of the `name` to resolve a possible use-after-free."
msgstr ""

#: src/changelog.md:741
msgid ""
"`PyCapsule::name` now returns an empty `CStr` instead of dereferencing a "
"null pointer if the capsule has no name."
msgstr ""

#: src/changelog.md:742
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` will never be called "
"if the capsule is deleted from a thread other than the one which the capsule "
"was created in (a warning will be emitted)."
msgstr ""

#: src/changelog.md:743
msgid ""
"Panics during drop of panic payload caught by PyO3 will now abort. [\\#2544]"
"(https://github.com/PyO3/pyo3/pull/2544)"
msgstr ""

#: src/changelog.md:745
msgid ""
"[0.16.5](https://github.com/pyo3/pyo3/compare/v0.16.4...v0.16.5) - 2022-05-15"
msgstr ""

#: src/changelog.md:749
msgid ""
"Add an experimental `generate-import-lib` feature to support auto-generating "
"non-abi3 python import libraries for Windows targets. [\\#2364](https://"
"github.com/PyO3/pyo3/pull/2364)"
msgstr ""

#: src/changelog.md:750
msgid ""
"Add FFI definition `Py_ExitStatusException`. [\\#2374](https://github.com/"
"PyO3/pyo3/pull/2374)"
msgstr ""

#: src/changelog.md:754
msgid ""
"Deprecate experimental `generate-abi3-import-lib` feature in favor of the "
"new `generate-import-lib` feature. [\\#2364](https://github.com/PyO3/pyo3/"
"pull/2364)"
msgstr ""

#: src/changelog.md:758
msgid ""
"Added missing `warn_default_encoding` field to `PyConfig` on 3.10+. The "
"previously missing field could result in incorrect behavior or crashes. "
"[\\#2370](https://github.com/PyO3/pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:759
msgid ""
"Fixed order of `pathconfig_warnings` and `program_name` fields of `PyConfig` "
"on 3.10+. Previously, the order of the fields was swapped and this could "
"lead to incorrect behavior or crashes. [\\#2370](https://github.com/PyO3/"
"pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:761
msgid ""
"[0.16.4](https://github.com/pyo3/pyo3/compare/v0.16.3...v0.16.4) - 2022-04-14"
msgstr ""

#: src/changelog.md:765
msgid ""
"Add `PyTzInfoAccess` trait for safe access to time zone information. "
"[\\#2263](https://github.com/PyO3/pyo3/pull/2263)"
msgstr ""

#: src/changelog.md:766
msgid ""
"Add an experimental `generate-abi3-import-lib` feature to auto-generate "
"`python3.dll` import libraries for Windows. [\\#2282](https://github.com/"
"PyO3/pyo3/pull/2282)"
msgstr ""

#: src/changelog.md:767
msgid ""
"Add FFI definitions for `PyDateTime_BaseTime` and `PyDateTime_BaseDateTime`. "
"[\\#2294](https://github.com/PyO3/pyo3/pull/2294)"
msgstr ""

#: src/changelog.md:771
msgid ""
"Improved performance of failing calls to `FromPyObject::extract` which is "
"common when functions accept multiple distinct types. [\\#2279](https://"
"github.com/PyO3/pyo3/pull/2279)"
msgstr ""

#: src/changelog.md:772
msgid ""
"Default to \"m\" ABI tag when choosing `libpython` link name for CPython 3.7 "
"on Unix. [\\#2288](https://github.com/PyO3/pyo3/pull/2288)"
msgstr ""

#: src/changelog.md:773
msgid ""
"Allow to compile \"abi3\" extensions without a working build host Python "
"interpreter. [\\#2293](https://github.com/PyO3/pyo3/pull/2293)"
msgstr ""

#: src/changelog.md:777
msgid ""
"Crates depending on PyO3 can collect code coverage via LLVM instrumentation "
"using stable Rust. [\\#2286](https://github.com/PyO3/pyo3/pull/2286)"
msgstr ""

#: src/changelog.md:778
msgid ""
"Fix segfault when calling FFI methods `PyDateTime_DATE_GET_TZINFO` or "
"`PyDateTime_TIME_GET_TZINFO` on `datetime` or `time` without a tzinfo. "
"[\\#2289](https://github.com/PyO3/pyo3/pull/2289)"
msgstr ""

#: src/changelog.md:779
msgid ""
"Fix directory names starting with the letter `n` breaking serialization of "
"the interpreter configuration on Windows since PyO3 0.16.3. [\\#2299]"
"(https://github.com/PyO3/pyo3/pull/2299)"
msgstr ""

#: src/changelog.md:781
msgid ""
"[0.16.3](https://github.com/pyo3/pyo3/compare/v0.16.2...v0.16.3) - 2022-04-05"
msgstr ""

#: src/changelog.md:785
msgid ""
"Extend `parking_lot` dependency supported versions to include 0.12. [\\#2239]"
"(https://github.com/PyO3/pyo3/pull/2239)"
msgstr ""

#: src/changelog.md:789
msgid ""
"Add methods to `pyo3_build_config::InterpreterConfig` to run Python scripts "
"using the configured executable. [\\#2092](https://github.com/PyO3/pyo3/"
"pull/2092)"
msgstr ""

#: src/changelog.md:790
msgid ""
"Add `as_bytes` method to `Py<PyBytes>`. [\\#2235](https://github.com/PyO3/"
"pyo3/pull/2235)"
msgstr ""

#: src/changelog.md:791
msgid ""
"Add FFI definitions for `PyType_FromModuleAndSpec`, `PyType_GetModule`, "
"`PyType_GetModuleState` and `PyModule_AddType`. [\\#2250](https://github.com/"
"PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:792
msgid ""
"Add `pyo3_build_config::cross_compiling_from_to` as a helper to detect when "
"PyO3 is cross-compiling. [\\#2253](https://github.com/PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:793
msgid ""
"Add `#[pyclass(mapping)]` option to leave sequence slots empty in container "
"implementations. [\\#2265](https://github.com/PyO3/pyo3/pull/2265)"
msgstr ""

#: src/changelog.md:794
msgid ""
"Add `PyString::intern` to enable usage of the Python's built-in string "
"interning. [\\#2268](https://github.com/PyO3/pyo3/pull/2268)"
msgstr ""

#: src/changelog.md:795
msgid ""
"Add `intern!` macro which can be used to amortize the cost of creating "
"Python strings by storing them inside a `GILOnceCell`. [\\#2269](https://"
"github.com/PyO3/pyo3/pull/2269)"
msgstr ""

#: src/changelog.md:796
msgid ""
"Add `PYO3_CROSS_PYTHON_IMPLEMENTATION` environment variable for selecting "
"the default cross Python implementation. [\\#2272](https://github.com/PyO3/"
"pyo3/pull/2272)"
msgstr ""

#: src/changelog.md:800
msgid ""
"Allow `#[pyo3(crate = \"...\", text_signature = \"...\")]` options to be "
"used directly in `#[pyclass(crate = \"...\", text_signature = \"...\")]`. "
"[\\#2234](https://github.com/PyO3/pyo3/pull/2234)"
msgstr ""

#: src/changelog.md:801
msgid ""
"Make `PYO3_CROSS_LIB_DIR` environment variable optional when cross "
"compiling. [\\#2241](https://github.com/PyO3/pyo3/pull/2241)"
msgstr ""

#: src/changelog.md:802
msgid ""
"Mark `METH_FASTCALL` calling convention as limited API on Python 3.10. "
"[\\#2250](https://github.com/PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:803
msgid ""
"Deprecate `pyo3_build_config::cross_compiling` in favor of "
"`pyo3_build_config::cross_compiling_from_to`. [\\#2253](https://github.com/"
"PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:807
msgid ""
"Fix `abi3-py310` feature: use Python 3.10 ABI when available instead of "
"silently falling back to the 3.9 ABI. [\\#2242](https://github.com/PyO3/pyo3/"
"pull/2242)"
msgstr ""

#: src/changelog.md:808
msgid ""
"Use shared linking mode when cross compiling against a [Framework bundle]"
"(https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/"
"BPFrameworks/Concepts/FrameworkAnatomy.html) for macOS. [\\#2233](https://"
"github.com/PyO3/pyo3/pull/2233)"
msgstr ""

#: src/changelog.md:809
msgid ""
"Fix panic during compilation when `PYO3_CROSS_LIB_DIR` is set for some host/"
"target combinations. [\\#2232](https://github.com/PyO3/pyo3/pull/2232)"
msgstr ""

#: src/changelog.md:810
msgid ""
"Correct dependency version for `syn` to require minimal patch version "
"1.0.56. [\\#2240](https://github.com/PyO3/pyo3/pull/2240)"
msgstr ""

#: src/changelog.md:812
msgid ""
"[0.16.2](https://github.com/pyo3/pyo3/compare/v0.16.1...v0.16.2) - 2022-03-15"
msgstr ""

#: src/changelog.md:816
msgid ""
"Warn when modules are imported on PyPy 3.7 versions older than PyPy 7.3.8, "
"as they are known to have binary compatibility issues. [\\#2217](https://"
"github.com/PyO3/pyo3/pull/2217)"
msgstr ""

#: src/changelog.md:817
msgid ""
"Ensure build script of `pyo3-ffi` runs before that of `pyo3` to fix cross "
"compilation. [\\#2224](https://github.com/PyO3/pyo3/pull/2224)"
msgstr ""

#: src/changelog.md:819
msgid ""
"[0.16.1](https://github.com/pyo3/pyo3/compare/v0.16.0...v0.16.1) - 2022-03-05"
msgstr ""

#: src/changelog.md:823
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.12. "
"[\\#2197](https://github.com/PyO3/pyo3/pull/2197)"
msgstr ""

#: src/changelog.md:827
msgid ""
"Fix incorrect platform detection for Windows in `pyo3-build-config`. "
"[\\#2198](https://github.com/PyO3/pyo3/pull/2198)"
msgstr ""

#: src/changelog.md:828
msgid ""
"Fix regression from 0.16 preventing cross compiling to aarch64 macOS. "
"[\\#2201](https://github.com/PyO3/pyo3/pull/2201)"
msgstr ""

#: src/changelog.md:830
msgid ""
"[0.16.0](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.16.0) - 2022-02-27"
msgstr ""

#: src/changelog.md:834
msgid ""
"Update MSRV to Rust 1.48. [\\#2004](https://github.com/PyO3/pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:835
msgid ""
"Update `indoc` optional dependency to 1.0. [\\#2004](https://github.com/PyO3/"
"pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:836
msgid ""
"Drop support for Python 3.6, remove `abi3-py36` feature. [\\#2006](https://"
"github.com/PyO3/pyo3/pull/2006)"
msgstr ""

#: src/changelog.md:837
msgid ""
"`pyo3-build-config` no longer enables the `resolve-config` feature by "
"default. [\\#2008](https://github.com/PyO3/pyo3/pull/2008)"
msgstr ""

#: src/changelog.md:838
msgid ""
"Update `inventory` optional dependency to 0.2. [\\#2019](https://github.com/"
"PyO3/pyo3/pull/2019)"
msgstr ""

#: src/changelog.md:839
msgid ""
"Drop `paste` dependency. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:840
msgid ""
"The bindings found in `pyo3::ffi` are now a re-export of a separate `pyo3-"
"ffi` crate. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:841
msgid "Support PyPy 3.9. [\\#2143](https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:845
msgid ""
"Add `PyCapsule` type exposing the [Capsule API](https://docs.python.org/3/c-"
"api/capsule.html#capsules). [\\#1980](https://github.com/PyO3/pyo3/pull/1980)"
msgstr ""

#: src/changelog.md:846
msgid ""
"Add `pyo3_build_config::Sysconfigdata` and supporting APIs. [\\#1996]"
"(https://github.com/PyO3/pyo3/pull/1996)"
msgstr ""

#: src/changelog.md:847
msgid ""
"Add `Py::setattr` method. [\\#2009](https://github.com/PyO3/pyo3/pull/2009)"
msgstr ""

#: src/changelog.md:848
msgid ""
"Add `#[pyo3(crate = \"some::path\")]` option to all attribute macros (except "
"the deprecated `#[pyproto]`). [\\#2022](https://github.com/PyO3/pyo3/"
"pull/2022)"
msgstr ""

#: src/changelog.md:849
msgid ""
"Enable `create_exception!` macro to take an optional docstring. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:850
msgid ""
"Enable `#[pyclass]` for fieldless (aka C-like) enums. [\\#2034](https://"
"github.com/PyO3/pyo3/pull/2034)"
msgstr ""

#: src/changelog.md:851
msgid ""
"Add buffer magic methods `__getbuffer__` and `__releasebuffer__` to "
"`#[pymethods]`. [\\#2067](https://github.com/PyO3/pyo3/pull/2067)"
msgstr ""

#: src/changelog.md:852
msgid ""
"Add support for paths in `wrap_pyfunction` and `wrap_pymodule`. [\\#2081]"
"(https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:853
msgid ""
"Enable `wrap_pyfunction!` to wrap a `#[pyfunction]` implemented in a "
"different Rust module or crate. [\\#2091](https://github.com/PyO3/pyo3/"
"pull/2091)"
msgstr ""

#: src/changelog.md:854
msgid ""
"Add `PyAny::contains` method (`in` operator for `PyAny`). [\\#2115](https://"
"github.com/PyO3/pyo3/pull/2115)"
msgstr ""

#: src/changelog.md:855
msgid ""
"Add `PyMapping::contains` method (`in` operator for `PyMapping`). [\\#2133]"
"(https://github.com/PyO3/pyo3/pull/2133)"
msgstr ""

#: src/changelog.md:856
msgid ""
"Add garbage collection magic magic methods `__traverse__` and `__clear__` to "
"`#[pymethods]`. [\\#2159](https://github.com/PyO3/pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:857
msgid ""
"Add support for `from_py_with` on struct tuples and enums to override the "
"default from-Python conversion. [\\#2181](https://github.com/PyO3/pyo3/"
"pull/2181)"
msgstr ""

#: src/changelog.md:858
msgid ""
"Add `eq`, `ne`, `lt`, `le`, `gt`, `ge` methods to `PyAny` that wrap "
"`rich_compare`. [\\#2175](https://github.com/PyO3/pyo3/pull/2175)"
msgstr ""

#: src/changelog.md:859
msgid ""
"Add `Py::is` and `PyAny::is` methods to check for object identity. [\\#2183]"
"(https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:860
msgid ""
"Add support for the `__getattribute__` magic method. [\\#2187](https://"
"github.com/PyO3/pyo3/pull/2187)"
msgstr ""

#: src/changelog.md:864
msgid ""
"`PyType::is_subclass`, `PyErr::is_instance` and `PyAny::is_instance` now "
"operate run-time type object instead of a type known at compile-time. The "
"old behavior is still available as `PyType::is_subclass_of`, `PyErr::"
"is_instance_of` and `PyAny::is_instance_of`.  [\\#1985](https://github.com/"
"PyO3/pyo3/pull/1985)"
msgstr ""

#: src/changelog.md:865
msgid ""
"Rename some methods on `PyErr` (the old names are just marked deprecated for "
"now): [\\#2026](https://github.com/PyO3/pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:866
msgid "`pytype` -> `get_type`"
msgstr ""

#: src/changelog.md:867
msgid "`pvalue` -> `value` (and deprecate equivalent `instance`)"
msgstr ""

#: src/changelog.md:868
msgid "`ptraceback` -> `traceback`"
msgstr ""

#: src/changelog.md:869
msgid "`from_instance` -> `from_value`"
msgstr ""

#: src/changelog.md:870
msgid "`into_instance` -> `into_value`"
msgstr ""

#: src/changelog.md:871
msgid ""
"`PyErr::new_type` now takes an optional docstring and now returns "
"`PyResult<Py<PyType>>` rather than a `ffi::PyTypeObject` pointer. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:872
msgid ""
"Deprecate `PyType::is_instance`; it is inconsistent with other `is_instance` "
"methods in PyO3. Instead of `typ.is_instance(obj)`, use `obj."
"is_instance(typ)`. [\\#2031](https://github.com/PyO3/pyo3/pull/2031)"
msgstr ""

#: src/changelog.md:873
msgid ""
"`__getitem__`, `__setitem__` and `__delitem__` in `#[pymethods]` now "
"implement both a Python mapping and sequence by default. [\\#2065](https://"
"github.com/PyO3/pyo3/pull/2065)"
msgstr ""

#: src/changelog.md:874
msgid ""
"Improve performance and error messages for `#[derive(FromPyObject)]` for "
"enums. [\\#2068](https://github.com/PyO3/pyo3/pull/2068)"
msgstr ""

#: src/changelog.md:875
msgid "Reduce generated LLVM code size (to improve compile times) for:"
msgstr ""

#: src/changelog.md:876
msgid ""
"internal `handle_panic` helper [\\#2074](https://github.com/PyO3/pyo3/"
"pull/2074) [\\#2158](https://github.com/PyO3/pyo3/pull/2158)"
msgstr ""

#: src/changelog.md:877
msgid ""
"`#[pyfunction]` and `#[pymethods]` argument extraction [\\#2075](https://"
"github.com/PyO3/pyo3/pull/2075) [\\#2085](https://github.com/PyO3/pyo3/"
"pull/2085)"
msgstr ""

#: src/changelog.md:878
msgid ""
"`#[pyclass]` type object creation [\\#2076](https://github.com/PyO3/pyo3/"
"pull/2076) [\\#2081](https://github.com/PyO3/pyo3/pull/2081) [\\#2157]"
"(https://github.com/PyO3/pyo3/pull/2157)"
msgstr ""

#: src/changelog.md:879
msgid ""
"Respect Rust privacy rules for items wrapped with `wrap_pyfunction` and "
"`wrap_pymodule`. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:880
msgid ""
"Add modulo argument to `__ipow__` magic method. [\\#2083](https://github.com/"
"PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:881
msgid ""
"Fix FFI definition for `_PyCFunctionFast`. [\\#2126](https://github.com/PyO3/"
"pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:882
msgid ""
"`PyDateTimeAPI` and `PyDateTime_TimeZone_UTC` are now unsafe functions "
"instead of statics. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:883
msgid ""
"`PyDateTimeAPI` does not implicitly call `PyDateTime_IMPORT` anymore to "
"reflect the original Python API more closely. Before the first call to "
"`PyDateTime_IMPORT` a null pointer is returned. Therefore before calling any "
"of the following FFI functions `PyDateTime_IMPORT` must be called to avoid "
"undefined behavior: [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:884
msgid "`PyDateTime_TimeZone_UTC`"
msgstr ""

#: src/changelog.md:885
msgid "`PyDate_Check`"
msgstr ""

#: src/changelog.md:886
msgid "`PyDate_CheckExact`"
msgstr ""

#: src/changelog.md:887
msgid "`PyDateTime_Check`"
msgstr ""

#: src/changelog.md:888
msgid "`PyDateTime_CheckExact`"
msgstr ""

#: src/changelog.md:889
msgid "`PyTime_Check`"
msgstr ""

#: src/changelog.md:890
msgid "`PyTime_CheckExact`"
msgstr ""

#: src/changelog.md:891
msgid "`PyDelta_Check`"
msgstr ""

#: src/changelog.md:892
msgid "`PyDelta_CheckExact`"
msgstr ""

#: src/changelog.md:893
msgid "`PyTZInfo_Check`"
msgstr ""

#: src/changelog.md:894
msgid "`PyTZInfo_CheckExact`"
msgstr ""

#: src/changelog.md:895
msgid "`PyDateTime_FromTimestamp`"
msgstr ""

#: src/changelog.md:896
msgid "`PyDate_FromTimestamp`"
msgstr ""

#: src/changelog.md:897
msgid ""
"Deprecate the `gc` option for `pyclass` (e.g. `#[pyclass(gc)]`). Just "
"implement a `__traverse__` `#[pymethod]`. [\\#2159](https://github.com/PyO3/"
"pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:898
msgid ""
"The `ml_meth` field of `PyMethodDef` is now represented by the "
"`PyMethodDefPointer` union. [2166](https://github.com/PyO3/pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:899
msgid ""
"Deprecate the `#[pyproto]` traits. [\\#2173](https://github.com/PyO3/pyo3/"
"pull/2173)"
msgstr ""

#: src/changelog.md:903
msgid ""
"Remove all functionality deprecated in PyO3 0.14. [\\#2007](https://github."
"com/PyO3/pyo3/pull/2007)"
msgstr ""

#: src/changelog.md:904
msgid ""
"Remove `Default` impl for `PyMethodDef`. [\\#2166](https://github.com/PyO3/"
"pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:905
msgid ""
"Remove `PartialEq` impl for `Py` and `PyAny` (use the new `is` instead). "
"[\\#2183](https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:909
msgid ""
"Fix undefined symbol for `PyObject_HasAttr` on PyPy. [\\#2025](https://"
"github.com/PyO3/pyo3/pull/2025)"
msgstr ""

#: src/changelog.md:910
msgid ""
"Fix memory leak in `PyErr::into_value`. [\\#2026](https://github.com/PyO3/"
"pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:911
msgid ""
"Fix clippy warning `needless-option-as-deref` in code generated by "
"`#[pyfunction]` and `#[pymethods]`. [\\#2040](https://github.com/PyO3/pyo3/"
"pull/2040)"
msgstr ""

#: src/changelog.md:912
msgid ""
"Fix undefined behavior in `PySlice::indices`. [\\#2061](https://github.com/"
"PyO3/pyo3/pull/2061)"
msgstr ""

#: src/changelog.md:913
msgid ""
"Fix the `wrap_pymodule!` macro using the wrong name for a `#[pymodule]` with "
"a `#[pyo3(name = \"..\")]` attribute. [\\#2081](https://github.com/PyO3/pyo3/"
"pull/2081)"
msgstr ""

#: src/changelog.md:914
msgid ""
"Fix magic methods in `#[pymethods]` accepting implementations with the wrong "
"number of arguments. [\\#2083](https://github.com/PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:915
msgid ""
"Fix panic in `#[pyfunction]` generated code when a required argument "
"following an `Option` was not provided.  [\\#2093](https://github.com/PyO3/"
"pyo3/pull/2093)"
msgstr ""

#: src/changelog.md:916
msgid ""
"Fixed undefined behavior caused by incorrect `ExactSizeIterator` "
"implementations. [\\#2124](https://github.com/PyO3/pyo3/pull/2124)"
msgstr ""

#: src/changelog.md:917
msgid ""
"Fix missing FFI definition `PyCMethod_New` on Python 3.9 and up. [\\#2143]"
"(https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:918
msgid ""
"Add missing FFI definitions `_PyLong_NumBits` and `_PyLong_AsByteArray` on "
"PyPy. [\\#2146](https://github.com/PyO3/pyo3/pull/2146)"
msgstr ""

#: src/changelog.md:919
msgid ""
"Fix memory leak in implementation of `AsPyPointer` for `Option<T>`. [\\#2160]"
"(https://github.com/PyO3/pyo3/pull/2160)"
msgstr ""

#: src/changelog.md:920
msgid ""
"Fix FFI definition of `_PyLong_NumBits` to return `size_t` instead of "
"`c_int`. [\\#2161](https://github.com/PyO3/pyo3/pull/2161)"
msgstr ""

#: src/changelog.md:921
msgid ""
"Fix `TypeError` thrown when argument parsing failed missing the originating "
"causes. [2177](https://github.com/PyO3/pyo3/pull/2178)"
msgstr ""

#: src/changelog.md:923
msgid ""
"[0.15.2](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2) - 2022-04-14"
msgstr ""

#: src/changelog.md:927
msgid ""
"Backport of PyPy 3.9 support from PyO3 0.16. [\\#2262](https://github.com/"
"PyO3/pyo3/pull/2262)"
msgstr ""

#: src/changelog.md:929
msgid ""
"[0.15.1](https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1) - 2021-11-19"
msgstr ""

#: src/changelog.md:933
msgid ""
"Add implementations for `Py::as_ref` and `Py::into_ref` for "
"`Py<PySequence>`, `Py<PyIterator>` and `Py<PyMapping>`. [\\#1682](https://"
"github.com/PyO3/pyo3/pull/1682)"
msgstr ""

#: src/changelog.md:934
msgid ""
"Add `PyTraceback` type to represent and format Python tracebacks. [\\#1977]"
"(https://github.com/PyO3/pyo3/pull/1977)"
msgstr ""

#: src/changelog.md:938
msgid ""
"`#[classattr]` constants with a known magic method name (which is lowercase) "
"no longer trigger lint warnings expecting constants to be uppercase. "
"[\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:942
msgid ""
"Fix creating `#[classattr]` by functions with the name of a known magic "
"method. [\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:943
msgid ""
"Fix use of `catch_unwind` in `allow_threads` which can cause fatal crashes. "
"[\\#1989](https://github.com/PyO3/pyo3/pull/1989)"
msgstr ""

#: src/changelog.md:944
msgid ""
"Fix build failure on PyPy when abi3 features are activated. [\\#1991]"
"(https://github.com/PyO3/pyo3/pull/1991)"
msgstr ""

#: src/changelog.md:945
msgid ""
"Fix mingw platform detection. [\\#1993](https://github.com/PyO3/pyo3/"
"pull/1993)"
msgstr ""

#: src/changelog.md:946
msgid ""
"Fix panic in `__get__` implementation when accessing descriptor on type "
"object. [\\#1997](https://github.com/PyO3/pyo3/pull/1997)"
msgstr ""

#: src/changelog.md:948
msgid ""
"[0.15.0](https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0) - 2021-11-03"
msgstr ""

#: src/changelog.md:952
msgid ""
"`pyo3`'s `Cargo.toml` now advertises `links = \"python\"` to inform Cargo "
"that it links against _libpython_. [\\#1819](https://github.com/PyO3/pyo3/"
"pull/1819)"
msgstr ""

#: src/changelog.md:953
msgid ""
"Added optional `anyhow` feature to convert `anyhow::Error` into `PyErr`. "
"[\\#1822](https://github.com/PyO3/pyo3/pull/1822)"
msgstr ""

#: src/changelog.md:954
msgid "Support Python 3.10. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:955
msgid ""
"Added optional `eyre` feature to convert `eyre::Report` into `PyErr`. "
"[\\#1893](https://github.com/PyO3/pyo3/pull/1893)"
msgstr ""

#: src/changelog.md:956
msgid "Support PyPy 3.8. [\\#1948](https://github.com/PyO3/pyo3/pull/1948)"
msgstr ""

#: src/changelog.md:960
msgid ""
"Add `PyList::get_item_unchecked` and `PyTuple::get_item_unchecked` to get "
"items without bounds checks. [\\#1733](https://github.com/PyO3/pyo3/"
"pull/1733)"
msgstr ""

#: src/changelog.md:961
msgid ""
"Support `#[doc = include_str!(...)]` attributes on Rust 1.54 and up. "
"[\\#1746](https://github.com/PyO3/pyo3/issues/1746)"
msgstr ""

#: src/changelog.md:962
msgid ""
"Add `PyAny::py` as a convenience for `PyNativeType::py`. [\\#1751](https://"
"github.com/PyO3/pyo3/pull/1751)"
msgstr ""

#: src/changelog.md:963
msgid ""
"Add implementation of `std::ops::Index<usize>` for `PyList`, `PyTuple` and "
"`PySequence`. [\\#1825](https://github.com/PyO3/pyo3/pull/1825)"
msgstr ""

#: src/changelog.md:964
msgid ""
"Add range indexing implementations of `std::ops::Index` for `PyList`, "
"`PyTuple` and `PySequence`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:965
msgid ""
"Add `PyMapping` type to represent the Python mapping protocol. [\\#1844]"
"(https://github.com/PyO3/pyo3/pull/1844)"
msgstr ""

#: src/changelog.md:966
msgid ""
"Add commonly-used sequence methods to `PyList` and `PyTuple`. [\\#1849]"
"(https://github.com/PyO3/pyo3/pull/1849)"
msgstr ""

#: src/changelog.md:967
msgid ""
"Add `as_sequence` methods to `PyList` and `PyTuple`. [\\#1860](https://"
"github.com/PyO3/pyo3/pull/1860)"
msgstr ""

#: src/changelog.md:968
msgid ""
"Add support for magic methods in `#[pymethods]`, intended as a replacement "
"for `#[pyproto]`. [\\#1864](https://github.com/PyO3/pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:969
msgid ""
"Add `abi3-py310` feature. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:970
msgid ""
"Add `PyCFunction::new_closure` to create a Python function from a Rust "
"closure. [\\#1901](https://github.com/PyO3/pyo3/pull/1901)"
msgstr ""

#: src/changelog.md:971
msgid ""
"Add support for positional-only arguments in `#[pyfunction]`. [\\#1925]"
"(https://github.com/PyO3/pyo3/pull/1925)"
msgstr ""

#: src/changelog.md:972
msgid ""
"Add `PyErr::take` to attempt to fetch a Python exception if present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:976
msgid ""
"`PyList`, `PyTuple` and `PySequence`'s APIs now accepts only `usize` indices "
"instead of `isize`. [\\#1733](https://github.com/PyO3/pyo3/pull/1733), "
"[\\#1802](https://github.com/PyO3/pyo3/pull/1802), [\\#1803](https://github."
"com/PyO3/pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:979
msgid ""
"`PyList::get_item` and `PyTuple::get_item` now return `PyResult<&PyAny>` "
"instead of panicking. [\\#1733](https://github.com/PyO3/pyo3/pull/1733)"
msgstr ""

#: src/changelog.md:980
msgid ""
"`PySequence::in_place_repeat` and `PySequence::in_place_concat` now return "
"`PyResult<&PySequence>` instead of `PyResult<()>`, which is needed in case "
"of immutable sequences such as tuples. [\\#1803](https://github.com/PyO3/"
"pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:981
msgid ""
"`PySequence::get_slice` now returns `PyResult<&PySequence>` instead of "
"`PyResult<&PyAny>`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:982
msgid ""
"Deprecate `PyTuple::split_from`. [\\#1804](https://github.com/PyO3/pyo3/"
"pull/1804)"
msgstr ""

#: src/changelog.md:983
msgid ""
"Deprecate `PyTuple::slice`, new method `PyTuple::get_slice` added with "
"`usize` indices. [\\#1828](https://github.com/PyO3/pyo3/pull/1828)"
msgstr ""

#: src/changelog.md:984
msgid ""
"Deprecate FFI definitions `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags` "
"when building for Python 3.9. [\\#1830](https://github.com/PyO3/pyo3/"
"pull/1830)"
msgstr ""

#: src/changelog.md:985
msgid ""
"Mark FFI definitions removed in Python 3.10 `PyParser_ASTFromString`, "
"`PyParser_ASTFromStringObject`, `PyParser_ASTFromFile`, "
"`PyParser_ASTFromFileObject`, `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags`, "
"`PyParser_SimpleParseString`, `PyParser_SimpleParseFile`, "
"`Py_SymtableString`, and `Py_SymtableStringObject`. [\\#1830](https://github."
"com/PyO3/pyo3/pull/1830)"
msgstr ""

#: src/changelog.md:986
msgid ""
"`#[pymethods]` now handles magic methods similarly to `#[pyproto]`. In the "
"future, `#[pyproto]` may be deprecated. [\\#1864](https://github.com/PyO3/"
"pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:987
msgid ""
"Deprecate FFI definitions `PySys_AddWarnOption`, "
"`PySys_AddWarnOptionUnicode` and `PySys_HasWarnOptions`. [\\#1887](https://"
"github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:988
msgid ""
"Deprecate `#[call]` attribute in favor of using `fn __call__`. [\\#1929]"
"(https://github.com/PyO3/pyo3/pull/1929)"
msgstr ""

#: src/changelog.md:989 src/changelog.md:1001
msgid ""
"Fix missing FFI definition `_PyImport_FindExtensionObject` on Python 3.10. "
"[\\#1942](https://github.com/PyO3/pyo3/pull/1942)"
msgstr ""

#: src/changelog.md:990
msgid ""
"Change `PyErr::fetch` to panic in debug mode if no exception is present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:994
msgid ""
"Fix building with a conda environment on Windows. [\\#1873](https://github."
"com/PyO3/pyo3/pull/1873)"
msgstr ""

#: src/changelog.md:995
msgid ""
"Fix panic on Python 3.6 when calling `Python::with_gil` with Python "
"initialized but threading not initialized. [\\#1874](https://github.com/PyO3/"
"pyo3/pull/1874)"
msgstr ""

#: src/changelog.md:996
msgid ""
"Fix incorrect linking to version-specific DLL instead of `python3.dll` when "
"cross-compiling to Windows with `abi3`. [\\#1880](https://github.com/PyO3/"
"pyo3/pull/1880)"
msgstr ""

#: src/changelog.md:997
msgid ""
"Fix FFI definition for `PyTuple_ClearFreeList` incorrectly being present for "
"Python 3.9 and up. [\\#1887](https://github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:998
msgid ""
"Fix panic in generated `#[derive(FromPyObject)]` for enums. [\\#1888]"
"(https://github.com/PyO3/pyo3/pull/1888)"
msgstr ""

#: src/changelog.md:999
msgid ""
"Fix cross-compiling to Python 3.7 builds with the \"m\" abi flag. [\\#1908]"
"(https://github.com/PyO3/pyo3/pull/1908)"
msgstr ""

#: src/changelog.md:1000
msgid ""
"Fix `__mod__` magic method fallback to `__rmod__`. [\\#1934](https://github."
"com/PyO3/pyo3/pull/1934)."
msgstr ""

#: src/changelog.md:1003
msgid ""
"[0.14.5](https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5) - 2021-09-05"
msgstr ""

#: src/changelog.md:1007
msgid ""
"Make `pyo3_build_config::InterpreterConfig` and subfields public. [\\#1848]"
"(https://github.com/PyO3/pyo3/pull/1848)"
msgstr ""

#: src/changelog.md:1008
msgid ""
"Add `resolve-config` feature to the `pyo3-build-config` to control whether "
"its build script does anything. [\\#1856](https://github.com/PyO3/pyo3/"
"pull/1856)"
msgstr ""

#: src/changelog.md:1012
msgid ""
"Fix 0.14.4 compile regression on `s390x-unknown-linux-gnu` target. [\\#1850]"
"(https://github.com/PyO3/pyo3/pull/1850)"
msgstr ""

#: src/changelog.md:1014
msgid ""
"[0.14.4](https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4) - 2021-08-29"
msgstr ""

#: src/changelog.md:1018
msgid ""
"Mark `PyString::data` as `unsafe` and disable it and some supporting "
"PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. "
"[\\#1834](https://github.com/PyO3/pyo3/pull/1834)"
msgstr ""

#: src/changelog.md:1020
msgid ""
"[0.14.3](https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3) - 2021-08-22"
msgstr ""

#: src/changelog.md:1024
msgid ""
"Add `PyString::data` to access the raw bytes stored in a Python string. "
"[\\#1794](https://github.com/PyO3/pyo3/pull/1794)"
msgstr ""

#: src/changelog.md:1028
msgid ""
"Raise `AttributeError` to avoid panic when calling `del` on a `#[setter]` "
"defined class property. [\\#1779](https://github.com/PyO3/pyo3/pull/1779)"
msgstr ""

#: src/changelog.md:1029
msgid ""
"Restrict FFI definitions `PyGILState_Check` and `Py_tracefunc` to the "
"unlimited API. [\\#1787](https://github.com/PyO3/pyo3/pull/1787)"
msgstr ""

#: src/changelog.md:1030
msgid ""
"Add missing `_type` field to `PyStatus` struct definition. [\\#1791](https://"
"github.com/PyO3/pyo3/pull/1791)"
msgstr ""

#: src/changelog.md:1031
msgid ""
"Reduce lower bound `num-complex` optional dependency to support interop with "
"`rust-numpy` and `ndarray` when building with the MSRV of 1.41 [\\#1799]"
"(https://github.com/PyO3/pyo3/pull/1799)"
msgstr ""

#: src/changelog.md:1032
msgid ""
"Fix memory leak in `Python::run_code`. [\\#1806](https://github.com/PyO3/"
"pyo3/pull/1806)"
msgstr ""

#: src/changelog.md:1033
msgid ""
"Fix memory leak in `PyModule::from_code`. [\\#1810](https://github.com/PyO3/"
"pyo3/pull/1810)"
msgstr ""

#: src/changelog.md:1034
msgid ""
"Remove use of `pyo3::` in `pyo3::types::datetime` which broke builds using `-"
"Z avoid-dev-deps` [\\#1811](https://github.com/PyO3/pyo3/pull/1811)"
msgstr ""

#: src/changelog.md:1036
msgid ""
"[0.14.2](https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2) - 2021-08-09"
msgstr ""

#: src/changelog.md:1040
msgid ""
"Add `indexmap` feature to add `ToPyObject`, `IntoPy` and `FromPyObject` "
"implementations for `indexmap::IndexMap`. [\\#1728](https://github.com/PyO3/"
"pyo3/pull/1728)"
msgstr ""

#: src/changelog.md:1041
msgid ""
"Add `pyo3_build_config::add_extension_module_link_args` to use in build "
"scripts to set linker arguments (for macOS). [\\#1755](https://github.com/"
"PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:1042
msgid ""
"Add `Python::with_gil_unchecked` unsafe variation of `Python::with_gil` to "
"allow obtaining a `Python` in scenarios where `Python::with_gil` would fail. "
"[\\#1769](https://github.com/PyO3/pyo3/pull/1769)"
msgstr ""

#: src/changelog.md:1046
msgid ""
"`PyErr::new` no longer acquires the Python GIL internally. [\\#1724](https://"
"github.com/PyO3/pyo3/pull/1724)"
msgstr ""

#: src/changelog.md:1047
msgid ""
"Reverted PyO3 0.14.0's use of `cargo:rustc-cdylib-link-arg` in its build "
"script, as Cargo unintentionally allowed crates to pass linker args to "
"downstream crates in this way. Projects supporting macOS may need to restore "
"`.cargo/config.toml` files. [\\#1755](https://github.com/PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:1051
msgid ""
"Fix regression in 0.14.0 rejecting usage of `#[doc(hidden)]` on structs and "
"functions annotated with PyO3 macros. [\\#1722](https://github.com/PyO3/pyo3/"
"pull/1722)"
msgstr ""

#: src/changelog.md:1052
msgid ""
"Fix regression in 0.14.0 leading to incorrect code coverage being computed "
"for `#[pyfunction]`s. [\\#1726](https://github.com/PyO3/pyo3/pull/1726)"
msgstr ""

#: src/changelog.md:1053
msgid ""
"Fix incorrect FFI definition of `Py_Buffer` on PyPy. [\\#1737](https://"
"github.com/PyO3/pyo3/pull/1737)"
msgstr ""

#: src/changelog.md:1054
msgid ""
"Fix incorrect calculation of `dictoffset` on 32-bit Windows. [\\#1475]"
"(https://github.com/PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:1055
msgid ""
"Fix regression in 0.13.2 leading to linking to incorrect Python library on "
"Windows \"gnu\" targets. [\\#1759](https://github.com/PyO3/pyo3/pull/1759)"
msgstr ""

#: src/changelog.md:1056
msgid ""
"Fix compiler warning: deny trailing semicolons in expression macro. [\\#1762]"
"(https://github.com/PyO3/pyo3/pull/1762)"
msgstr ""

#: src/changelog.md:1057
msgid ""
"Fix incorrect FFI definition of `Py_DecodeLocale`. The 2nd argument is now "
"`*mut Py_ssize_t` instead of `Py_ssize_t`. [\\#1766](https://github.com/PyO3/"
"pyo3/pull/1766)"
msgstr ""

#: src/changelog.md:1059
msgid ""
"[0.14.1](https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1) - 2021-07-04"
msgstr ""

#: src/changelog.md:1063
msgid ""
"Implement `IntoPy<PyObject>` for `&PathBuf` and `&OsString`. [\\#1712]"
"(https://github.com/PyO3/pyo3/pull/1712)"
msgstr ""

#: src/changelog.md:1067
msgid ""
"Fix crashes on PyPy due to incorrect definitions of `PyList_SET_ITEM`. "
"[\\#1713](https://github.com/PyO3/pyo3/pull/1713)"
msgstr ""

#: src/changelog.md:1069
msgid ""
"[0.14.0](https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0) - 2021-07-03"
msgstr ""

#: src/changelog.md:1073
msgid ""
"Update `num-bigint` optional dependency to 0.4. [\\#1481](https://github.com/"
"PyO3/pyo3/pull/1481)"
msgstr ""

#: src/changelog.md:1074
msgid ""
"Update `num-complex` optional dependency to 0.4. [\\#1482](https://github."
"com/PyO3/pyo3/pull/1482)"
msgstr ""

#: src/changelog.md:1075
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.11. "
"[\\#1496](https://github.com/PyO3/pyo3/pull/1496)"
msgstr ""

#: src/changelog.md:1076
msgid "Support PyPy 3.7. [\\#1538](https://github.com/PyO3/pyo3/pull/1538)"
msgstr ""

#: src/changelog.md:1080
msgid ""
"Extend conversions for `[T; N]` to all `N` using const generics (on Rust "
"1.51 and up). [\\#1128](https://github.com/PyO3/pyo3/pull/1128)"
msgstr ""

#: src/changelog.md:1081
msgid ""
"Add conversions between `OsStr`/ `OsString` and Python strings. [\\#1379]"
"(https://github.com/PyO3/pyo3/pull/1379)"
msgstr ""

#: src/changelog.md:1082
msgid ""
"Add conversions between `Path`/ `PathBuf` and Python strings (and `pathlib."
"Path` objects). [\\#1379](https://github.com/PyO3/pyo3/pull/1379) [\\#1654]"
"(https://github.com/PyO3/pyo3/pull/1654)"
msgstr ""

#: src/changelog.md:1083
msgid ""
"Add a new set of `#[pyo3(...)]` attributes to control various PyO3 macro "
"functionality:"
msgstr ""

#: src/changelog.md:1084
msgid ""
"`#[pyo3(from_py_with = \"...\")]` function arguments and struct fields to "
"override the default from-Python conversion. [\\#1411](https://github.com/"
"PyO3/pyo3/pull/1411)"
msgstr ""

#: src/changelog.md:1085
msgid ""
"`#[pyo3(name = \"...\")]` for setting Python names. [\\#1567](https://github."
"com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:1086
msgid ""
"`#[pyo3(text_signature = \"...\")]` for setting text signature. [\\#1658]"
"(https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:1087
msgid ""
"Add FFI definition `PyCFunction_CheckExact` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1088
msgid ""
"Add FFI definition `Py_IS_TYPE`. [\\#1429](https://github.com/PyO3/pyo3/"
"pull/1429)"
msgstr ""

#: src/changelog.md:1089
msgid ""
"Add FFI definition `_Py_InitializeMain`. [\\#1473](https://github.com/PyO3/"
"pyo3/pull/1473)"
msgstr ""

#: src/changelog.md:1090
msgid ""
"Add FFI definitions from `cpython/import.h`.[\\#1475](https://github.com/"
"PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:1091
msgid ""
"Add tuple and unit struct support for `#[pyclass]` macro. [\\#1504](https://"
"github.com/PyO3/pyo3/pull/1504)"
msgstr ""

#: src/changelog.md:1092
msgid ""
"Add FFI definition `PyDateTime_TimeZone_UTC`. [\\#1572](https://github.com/"
"PyO3/pyo3/pull/1572)"
msgstr ""

#: src/changelog.md:1093
msgid ""
"Add support for `#[pyclass(extends=Exception)]`. [\\#1591](https://github."
"com/PyO3/pyo3/pull/1591)"
msgstr ""

#: src/changelog.md:1094
msgid ""
"Add `PyErr::cause` and `PyErr::set_cause`. [\\#1679](https://github.com/PyO3/"
"pyo3/pull/1679)"
msgstr ""

#: src/changelog.md:1095
msgid ""
"Add FFI definitions from `cpython/pystate.h`. [\\#1687](https://github.com/"
"PyO3/pyo3/pull/1687/)"
msgstr ""

#: src/changelog.md:1096
msgid ""
"Add `wrap_pyfunction!` macro to `pyo3::prelude`. [\\#1695](https://github."
"com/PyO3/pyo3/pull/1695)"
msgstr ""

#: src/changelog.md:1100
msgid ""
"Allow only one `#[pymethods]` block per `#[pyclass]` by default, to remove "
"the dependency on `inventory`. Add a `multiple-pymethods` feature to opt-in "
"the original behavior and dependency on `inventory`. [\\#1457](https://"
"github.com/PyO3/pyo3/pull/1457)"
msgstr ""

#: src/changelog.md:1101
msgid ""
"Change `PyTimeAccess::get_fold` to return a `bool` instead of a `u8`. "
"[\\#1397](https://github.com/PyO3/pyo3/pull/1397)"
msgstr ""

#: src/changelog.md:1102
msgid ""
"Deprecate FFI definition `PyCFunction_Call` for Python 3.9 and up. [\\#1425]"
"(https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1103
msgid ""
"Deprecate FFI definition `PyModule_GetFilename`. [\\#1425](https://github."
"com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1104
msgid ""
"The `auto-initialize` feature is no longer enabled by default. [\\#1443]"
"(https://github.com/PyO3/pyo3/pull/1443)"
msgstr ""

#: src/changelog.md:1105
msgid ""
"Change `PyCFunction::new` and `PyCFunction::new_with_keywords` to take "
"`&'static str` arguments rather than implicitly copying (and leaking) them. "
"[\\#1450](https://github.com/PyO3/pyo3/pull/1450)"
msgstr ""

#: src/changelog.md:1106
msgid ""
"Deprecate `PyModule::call`, `PyModule::call0`, `PyModule::call1` and "
"`PyModule::get`. [\\#1492](https://github.com/PyO3/pyo3/pull/1492)"
msgstr ""

#: src/changelog.md:1107
msgid ""
"Add length information to `PyBufferError`s raised from `PyBuffer::"
"copy_to_slice` and `PyBuffer::copy_from_slice`. [\\#1534](https://github.com/"
"PyO3/pyo3/pull/1534)"
msgstr ""

#: src/changelog.md:1108
msgid ""
"Automatically set `-undefined` and `dynamic_lookup` linker arguments on "
"macOS with the `extension-module` feature. [\\#1539](https://github.com/PyO3/"
"pyo3/pull/1539)"
msgstr ""

#: src/changelog.md:1109
msgid ""
"Deprecate `#[pyproto]` methods which are easier to implement as "
"`#[pymethods]`: [\\#1560](https://github.com/PyO3/pyo3/pull/1560)"
msgstr ""

#: src/changelog.md:1110
msgid "`PyBasicProtocol::__bytes__` and `PyBasicProtocol::__format__`"
msgstr ""

#: src/changelog.md:1111
msgid "`PyContextProtocol::__enter__` and `PyContextProtocol::__exit__`"
msgstr ""

#: src/changelog.md:1112
msgid "`PyDescrProtocol::__delete__` and `PyDescrProtocol::__set_name__`"
msgstr ""

#: src/changelog.md:1113
msgid "`PyMappingProtocol::__reversed__`"
msgstr ""

#: src/changelog.md:1114
msgid "`PyNumberProtocol::__complex__` and `PyNumberProtocol::__round__`"
msgstr ""

#: src/changelog.md:1115
msgid "`PyAsyncProtocol::__aenter__` and `PyAsyncProtocol::__aexit__`"
msgstr ""

#: src/changelog.md:1116
msgid ""
"Deprecate several attributes in favor of the new `#[pyo3(...)]` options:"
msgstr ""

#: src/changelog.md:1117
msgid ""
"`#[name = \"...\"]`, replaced by `#[pyo3(name = \"...\")]` [\\#1567](https://"
"github.com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:1118
msgid ""
"`#[pyfn(m, \"name\")]`, replaced by `#[pyfn(m)] #[pyo3(name = \"...\")]`. "
"[\\#1610](https://github.com/PyO3/pyo3/pull/1610)"
msgstr ""

#: src/changelog.md:1119
msgid ""
"`#[pymodule(name)]`, replaced by `#[pymodule] #[pyo3(name = \"...\")]` "
"[\\#1650](https://github.com/PyO3/pyo3/pull/1650)"
msgstr ""

#: src/changelog.md:1120
msgid ""
"`#[text_signature = \"...\"]`, replaced by `#[pyo3(text_signature = \"..."
"\")]`. [\\#1658](https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:1121
msgid ""
"Reduce LLVM line counts to improve compilation times. [\\#1604](https://"
"github.com/PyO3/pyo3/pull/1604)"
msgstr ""

#: src/changelog.md:1122
msgid ""
"No longer call `PyEval_InitThreads` in `#[pymodule]` init code. [\\#1630]"
"(https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:1123
msgid ""
"Use `METH_FASTCALL` argument passing convention, when possible, to improve "
"`#[pyfunction]` and method performance. [\\#1619](https://github.com/PyO3/"
"pyo3/pull/1619), [\\#1660](https://github.com/PyO3/pyo3/pull/1660)"
msgstr ""

#: src/changelog.md:1125
msgid ""
"Filter sysconfigdata candidates by architecture when cross-compiling. "
"[\\#1626](https://github.com/PyO3/pyo3/pull/1626)"
msgstr ""

#: src/changelog.md:1129
msgid ""
"Remove deprecated exception names `BaseException` etc. [\\#1426](https://"
"github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1130
msgid ""
"Remove deprecated methods `Python::is_instance`, `Python::is_subclass`, "
"`Python::release`, `Python::xdecref`, and `Py::from_owned_ptr_or_panic`. "
"[\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1131
msgid "Remove many FFI definitions which never existed in the Python C-API:"
msgstr ""

#: src/changelog.md:1132
msgid ""
"(previously deprecated) `PyGetSetDef_INIT`, `PyGetSetDef_DICT`, "
"`PyCoro_Check`, `PyCoroWrapper_Check`, and `PyAsyncGen_Check` [\\#1426]"
"(https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1133
msgid "`PyMethodDef_INIT` [\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1134
msgid "`PyTypeObject_INIT` [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:1135
msgid ""
"`PyObject_Check`, `PySuper_Check`, and `FreeFunc` [\\#1438](https://github."
"com/PyO3/pyo3/pull/1438)"
msgstr ""

#: src/changelog.md:1136
msgid "`PyModuleDef_INIT` [\\#1630](https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:1137
msgid "Remove pyclass implementation details from `PyTypeInfo`:"
msgstr ""

#: src/changelog.md:1138
msgid ""
"`Type`, `DESCRIPTION`, and `FLAGS` [\\#1456](https://github.com/PyO3/pyo3/"
"pull/1456)"
msgstr ""

#: src/changelog.md:1139
msgid ""
"`BaseType`, `BaseLayout`, `Layout`, `Initializer` [\\#1596](https://github."
"com/PyO3/pyo3/pull/1596)"
msgstr ""

#: src/changelog.md:1140
msgid ""
"Remove `PYO3_CROSS_INCLUDE_DIR` environment variable and the associated C "
"header parsing functionality. [\\#1521](https://github.com/PyO3/pyo3/"
"pull/1521)"
msgstr ""

#: src/changelog.md:1141
msgid ""
"Remove `raw_pycfunction!` macro. [\\#1619](https://github.com/PyO3/pyo3/"
"pull/1619)"
msgstr ""

#: src/changelog.md:1142
msgid ""
"Remove `PyClassAlloc` trait. [\\#1657](https://github.com/PyO3/pyo3/"
"pull/1657)"
msgstr ""

#: src/changelog.md:1143
msgid ""
"Remove `PyList::get_parked_item`. [\\#1664](https://github.com/PyO3/pyo3/"
"pull/1664)"
msgstr ""

#: src/changelog.md:1147
msgid ""
"Remove FFI definition `PyCFunction_ClearFreeList` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1148
msgid ""
"`PYO3_CROSS_LIB_DIR` environment variable no long required when compiling "
"for x86-64 Python from macOS arm64 and reverse. [\\#1428](https://github.com/"
"PyO3/pyo3/pull/1428)"
msgstr ""

#: src/changelog.md:1149
msgid ""
"Fix FFI definition `_PyEval_RequestCodeExtraIndex`, which took an argument "
"of the wrong type. [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:1150
msgid ""
"Fix FFI definition `PyIndex_Check` missing with the `abi3` feature. [\\#1436]"
"(https://github.com/PyO3/pyo3/pull/1436)"
msgstr ""

#: src/changelog.md:1151
msgid ""
"Fix incorrect `TypeError` raised when keyword-only argument passed along "
"with a positional argument in `*args`. [\\#1440](https://github.com/PyO3/"
"pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:1152
msgid ""
"Fix inability to use a named lifetime for `&PyTuple` of `*args` in "
"`#[pyfunction]`. [\\#1440](https://github.com/PyO3/pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:1153
msgid ""
"Fix use of Python argument for `#[pymethods]` inside macro expansions. "
"[\\#1505](https://github.com/PyO3/pyo3/pull/1505)"
msgstr ""

#: src/changelog.md:1154
msgid ""
"No longer include `__doc__` in `__all__` generated for `#[pymodule]`. "
"[\\#1509](https://github.com/PyO3/pyo3/pull/1509)"
msgstr ""

#: src/changelog.md:1155
msgid ""
"Always use cross-compiling configuration if any of the `PYO3_CROSS` family "
"of environment variables are set. [\\#1514](https://github.com/PyO3/pyo3/"
"pull/1514)"
msgstr ""

#: src/changelog.md:1156
msgid ""
"Support `EnvironmentError`, `IOError`, and `WindowsError` on PyPy. [\\#1533]"
"(https://github.com/PyO3/pyo3/pull/1533)"
msgstr ""

#: src/changelog.md:1157
msgid ""
"Fix unnecessary rebuilds when cycling between `cargo check` and `cargo "
"clippy` in a Python virtualenv. [\\#1557](https://github.com/PyO3/pyo3/"
"pull/1557)"
msgstr ""

#: src/changelog.md:1158
msgid ""
"Fix segfault when dereferencing `ffi::PyDateTimeAPI` without the GIL. "
"[\\#1563](https://github.com/PyO3/pyo3/pull/1563)"
msgstr ""

#: src/changelog.md:1159
msgid ""
"Fix memory leak in `FromPyObject` implementations for `u128` and `i128`. "
"[\\#1638](https://github.com/PyO3/pyo3/pull/1638)"
msgstr ""

#: src/changelog.md:1160
msgid ""
"Fix `#[pyclass(extends=PyDict)]` leaking the dict contents on drop. [\\#1657]"
"(https://github.com/PyO3/pyo3/pull/1657)"
msgstr ""

#: src/changelog.md:1161
msgid ""
"Fix segfault when calling `PyList::get_item` with negative indices. [\\#1668]"
"(https://github.com/PyO3/pyo3/pull/1668)"
msgstr ""

#: src/changelog.md:1162
msgid ""
"Fix FFI definitions of `PyEval_SetProfile`/`PyEval_SetTrace` to take "
"`Option<Py_tracefunc>` parameters. [\\#1692](https://github.com/PyO3/pyo3/"
"pull/1692)"
msgstr ""

#: src/changelog.md:1163
msgid ""
"Fix `ToPyObject` impl for `HashSet` to accept non-default hashers. [\\#1702]"
"(https://github.com/PyO3/pyo3/pull/1702)"
msgstr ""

#: src/changelog.md:1165
msgid ""
"[0.13.2](https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2) - 2021-02-12"
msgstr ""

#: src/changelog.md:1169
msgid ""
"Lower minimum supported Rust version to 1.41. [\\#1421](https://github.com/"
"PyO3/pyo3/pull/1421)"
msgstr ""

#: src/changelog.md:1173
msgid ""
"Add unsafe API `with_embedded_python_interpreter` to initialize a Python "
"interpreter, execute a closure, and finalize the interpreter. [\\#1355]"
"(https://github.com/PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:1174
msgid ""
"Add `serde` feature which provides implementations of `Serialize` and "
"`Deserialize` for `Py<T>`. [\\#1366](https://github.com/PyO3/pyo3/pull/1366)"
msgstr ""

#: src/changelog.md:1175
msgid ""
"Add FFI definition `_PyCFunctionFastWithKeywords` on Python 3.7 and up. "
"[\\#1384](https://github.com/PyO3/pyo3/pull/1384)"
msgstr ""

#: src/changelog.md:1176
msgid ""
"Add `PyDateTime::new_with_fold` method. [\\#1398](https://github.com/PyO3/"
"pyo3/pull/1398)"
msgstr ""

#: src/changelog.md:1177
msgid ""
"Add `size_hint` impls for `{PyDict,PyList,PySet,PyTuple}Iterator`s. [\\#1699]"
"(https://github.com/PyO3/pyo3/pull/1699)"
msgstr ""

#: src/changelog.md:1181
msgid ""
"`prepare_freethreaded_python` will no longer register an `atexit` handler to "
"call `Py_Finalize`. This resolves a number of issues with incompatible C "
"extensions causing crashes at finalization. [\\#1355](https://github.com/"
"PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:1182
msgid ""
"Mark `PyLayout::py_init`, `PyClassDict::clear_dict`, and `opt_to_pyobj` "
"safe, as they do not perform any unsafe operations. [\\#1404](https://github."
"com/PyO3/pyo3/pull/1404)"
msgstr ""

#: src/changelog.md:1186
msgid ""
"Fix support for using `r#raw_idents` as argument names in pyfunctions. "
"[\\#1383](https://github.com/PyO3/pyo3/pull/1383)"
msgstr ""

#: src/changelog.md:1187
msgid ""
"Fix typo in FFI definition for `PyFunction_GetCode` (was incorrectly "
"`PyFunction_Code`). [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1188
msgid ""
"Fix FFI definitions `PyMarshal_WriteObjectToString` and "
"`PyMarshal_ReadObjectFromString` as available in limited API. [\\#1387]"
"(https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1189
msgid ""
"Fix FFI definitions `PyListObject` and those from `funcobject.h` as "
"requiring non-limited API. [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1190
msgid ""
"Fix unqualified `Result` usage in `pyobject_native_type_base`. [\\#1402]"
"(https://github.com/PyO3/pyo3/pull/1402)"
msgstr ""

#: src/changelog.md:1191
msgid ""
"Fix build on systems where the default Python encoding is not UTF-8. "
"[\\#1405](https://github.com/PyO3/pyo3/pull/1405)"
msgstr ""

#: src/changelog.md:1192
msgid ""
"Fix build on mingw / MSYS2. [\\#1423](https://github.com/PyO3/pyo3/pull/1423)"
msgstr ""

#: src/changelog.md:1194
msgid ""
"[0.13.1](https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1) - 2021-01-10"
msgstr ""

#: src/changelog.md:1198
msgid ""
"Add support for `#[pyclass(dict)]` and `#[pyclass(weakref)]` with the `abi3` "
"feature on Python 3.9 and up. [\\#1342](https://github.com/PyO3/pyo3/"
"pull/1342)"
msgstr ""

#: src/changelog.md:1199
msgid ""
"Add FFI definitions `PyOS_BeforeFork`, `PyOS_AfterFork_Parent`, "
"`PyOS_AfterFork_Child` for Python 3.7 and up. [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1200
msgid ""
"Add an `auto-initialize` feature to control whether PyO3 should "
"automatically initialize an embedded Python interpreter. For compatibility "
"this feature is enabled by default in PyO3 0.13.1, but is planned to become "
"opt-in from PyO3 0.14.0. [\\#1347](https://github.com/PyO3/pyo3/pull/1347)"
msgstr ""

#: src/changelog.md:1201
msgid ""
"Add support for cross-compiling to Windows without needing "
"`PYO3_CROSS_INCLUDE_DIR`. [\\#1350](https://github.com/PyO3/pyo3/pull/1350)"
msgstr ""

#: src/changelog.md:1203 src/changelog.md:1263
msgid "Deprecated"
msgstr ""

#: src/changelog.md:1205
msgid ""
"Deprecate FFI definitions `PyEval_CallObjectWithKeywords`, "
"`PyEval_CallObject`, `PyEval_CallFunction`, `PyEval_CallMethod` when "
"building for Python 3.9. [\\#1338](https://github.com/PyO3/pyo3/pull/1338)"
msgstr ""

#: src/changelog.md:1206
msgid ""
"Deprecate FFI definitions `PyGetSetDef_DICT` and `PyGetSetDef_INIT` which "
"have never been in the Python API. [\\#1341](https://github.com/PyO3/pyo3/"
"pull/1341)"
msgstr ""

#: src/changelog.md:1207
msgid ""
"Deprecate FFI definitions `PyGen_NeedsFinalizing`, `PyImport_Cleanup` "
"(removed in 3.9), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github."
"com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1208
msgid ""
"Deprecate FFI definition `PyOS_AfterFork` for Python 3.7 and up. [\\#1348]"
"(https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1209
msgid ""
"Deprecate FFI definitions `PyCoro_Check`, `PyAsyncGen_Check`, and "
"`PyCoroWrapper_Check`, which have never been in the Python API (for the "
"first two, it is possible to use `PyCoro_CheckExact` and "
"`PyAsyncGen_CheckExact` instead; these are the actual functions provided by "
"the Python API). [\\#1348](https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1210
msgid ""
"Deprecate FFI definitions for `PyUnicode_FromUnicode`, `PyUnicode_AsUnicode` "
"and `PyUnicode_AsUnicodeAndSize`, which will be removed from 3.12 and up due "
"to [PEP 623](https://www.python.org/dev/peps/pep-0623/). [\\#1370](https://"
"github.com/PyO3/pyo3/pull/1370)"
msgstr ""

#: src/changelog.md:1214
msgid ""
"Remove FFI definition `PyFrame_ClearFreeList` when building for Python 3.9. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:1215
msgid ""
"Remove FFI definition `_PyDict_Contains` when building for Python 3.10. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:1216
msgid ""
"Remove FFI definitions `PyGen_NeedsFinalizing` and `PyImport_Cleanup` (for "
"3.9 and up), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1220
msgid ""
"Stop including `Py_TRACE_REFS` config setting automatically if `Py_DEBUG` is "
"set on Python 3.8 and up. [\\#1334](https://github.com/PyO3/pyo3/pull/1334)"
msgstr ""

#: src/changelog.md:1221
msgid ""
"Remove `#[deny(warnings)]` attribute (and instead refuse warnings only in "
"CI). [\\#1340](https://github.com/PyO3/pyo3/pull/1340)"
msgstr ""

#: src/changelog.md:1222
msgid ""
"Fix deprecation warning for missing `__module__` with `#[pyclass]`. [\\#1343]"
"(https://github.com/PyO3/pyo3/pull/1343)"
msgstr ""

#: src/changelog.md:1223
msgid ""
"Correct return type of `PyFrozenSet::empty` to `&PyFrozenSet` (was "
"incorrectly `&PySet`). [\\#1351](https://github.com/PyO3/pyo3/pull/1351)"
msgstr ""

#: src/changelog.md:1224
msgid ""
"Fix missing `Py_INCREF` on heap type objects on Python versions before 3.8. "
"[\\#1365](https://github.com/PyO3/pyo3/pull/1365)"
msgstr ""

#: src/changelog.md:1226
msgid ""
"[0.13.0](https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0) - 2020-12-22"
msgstr ""

#: src/changelog.md:1230
msgid ""
"Drop support for Python 3.5 (as it is now end-of-life). [\\#1250](https://"
"github.com/PyO3/pyo3/pull/1250)"
msgstr ""

#: src/changelog.md:1231
msgid ""
"Bump minimum supported Rust version to 1.45. [\\#1272](https://github.com/"
"PyO3/pyo3/pull/1272)"
msgstr ""

#: src/changelog.md:1232
msgid ""
"Bump indoc dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:1233
msgid ""
"Bump paste dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:1234
msgid ""
"Rename internal crates `pyo3cls` and `pyo3-derive-backend` to `pyo3-macros` "
"and `pyo3-macros-backend` respectively. [\\#1317](https://github.com/PyO3/"
"pyo3/pull/1317)"
msgstr ""

#: src/changelog.md:1238
msgid ""
"Add support for building for CPython limited API. Opting-in to the limited "
"API enables a single extension wheel built with PyO3 to be installable on "
"multiple Python versions. This required a few minor changes to runtime "
"behavior of of PyO3 `#[pyclass]` types. See the migration guide for full "
"details. [\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1239
msgid ""
"Add feature flags `abi3-py36`, `abi3-py37`, `abi3-py38` etc. to set the "
"minimum Python version when using the limited API. [\\#1263](https://github."
"com/PyO3/pyo3/pull/1263)"
msgstr ""

#: src/changelog.md:1240
msgid ""
"Add argument names to `TypeError` messages generated by pymethod wrappers. "
"[\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:1241
msgid ""
"Add FFI definitions for PEP 587 \"Python Initialization Configuration\". "
"[\\#1247](https://github.com/PyO3/pyo3/pull/1247)"
msgstr ""

#: src/changelog.md:1242
msgid ""
"Add FFI definitions for `PyEval_SetProfile` and `PyEval_SetTrace`. [\\#1255]"
"(https://github.com/PyO3/pyo3/pull/1255)"
msgstr ""

#: src/changelog.md:1243
msgid ""
"Add FFI definitions for context.h functions (`PyContext_New`, etc). [\\#1259]"
"(https://github.com/PyO3/pyo3/pull/1259)"
msgstr ""

#: src/changelog.md:1244
msgid ""
"Add `PyAny::is_instance` method. [\\#1276](https://github.com/PyO3/pyo3/"
"pull/1276)"
msgstr ""

#: src/changelog.md:1245
msgid ""
"Add support for conversion between `char` and `PyString`. [\\#1282](https://"
"github.com/PyO3/pyo3/pull/1282)"
msgstr ""

#: src/changelog.md:1246
msgid ""
"Add FFI definitions for `PyBuffer_SizeFromFormat`, `PyObject_LengthHint`, "
"`PyObject_CallNoArgs`, `PyObject_CallOneArg`, `PyObject_CallMethodNoArgs`, "
"`PyObject_CallMethodOneArg`, `PyObject_VectorcallDict`, and "
"`PyObject_VectorcallMethod`. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1287)"
msgstr ""

#: src/changelog.md:1247
msgid ""
"Add conversions between `u128`/`i128` and `PyLong` for PyPy. [\\#1310]"
"(https://github.com/PyO3/pyo3/pull/1310)"
msgstr ""

#: src/changelog.md:1248
msgid ""
"Add `Python::version` and `Python::version_info` to get the running "
"interpreter version. [\\#1322](https://github.com/PyO3/pyo3/pull/1322)"
msgstr ""

#: src/changelog.md:1249
msgid ""
"Add conversions for tuples of length 10, 11, and 12. [\\#1454](https://"
"github.com/PyO3/pyo3/pull/1454)"
msgstr ""

#: src/changelog.md:1253
msgid ""
"Change return type of `PyType::name` from `Cow<str>` to `PyResult<&str>`. "
"[\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1254
msgid ""
"`#[pyclass(subclass)]` is now required for subclassing from Rust (was "
"previously just required for subclassing from Python). [\\#1152](https://"
"github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1255
msgid ""
"Change `PyIterator` to be consistent with other native types: it is now used "
"as `&PyIterator` instead of `PyIterator<'a>`. [\\#1176](https://github.com/"
"PyO3/pyo3/pull/1176)"
msgstr ""

#: src/changelog.md:1256
msgid ""
"Change formatting of `PyDowncastError` messages to be closer to Python's "
"builtin error messages. [\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:1257
msgid ""
"Change `Debug` and `Display` impls for `PyException` to be consistent with "
"`PyAny`. [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:1258
msgid ""
"Change `Debug` impl of `PyErr` to output more helpful information (acquiring "
"the GIL if necessary). [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:1259
msgid ""
"Rename `PyTypeInfo::is_instance` and `PyTypeInfo::is_exact_instance` to "
"`PyTypeInfo::is_type_of` and `PyTypeInfo::is_exact_type_of`. [\\#1278]"
"(https://github.com/PyO3/pyo3/pull/1278)"
msgstr ""

#: src/changelog.md:1260
msgid ""
"Optimize `PyAny::call0`, `Py::call0` and `PyAny::call_method0` and `Py::"
"call_method0` on Python 3.9 and up. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1285)"
msgstr ""

#: src/changelog.md:1261
msgid ""
"Require double-quotes for pyclass name argument e.g `#[pyclass(name = "
"\"MyClass\")]`. [\\#1303](https://github.com/PyO3/pyo3/pull/1303)"
msgstr ""

#: src/changelog.md:1265
msgid ""
"Deprecate `Python::is_instance`, `Python::is_subclass`, `Python::release`, "
"and `Python::xdecref`. [\\#1292](https://github.com/PyO3/pyo3/pull/1292)"
msgstr ""

#: src/changelog.md:1269
msgid ""
"Remove deprecated ffi definitions `PyUnicode_AsUnicodeCopy`, "
"`PyUnicode_GetMax`, `_Py_CheckRecursionLimit`, `PyObject_AsCharBuffer`, "
"`PyObject_AsReadBuffer`, `PyObject_CheckReadBuffer` and "
"`PyObject_AsWriteBuffer`, which will be removed in Python 3.10. [\\#1217]"
"(https://github.com/PyO3/pyo3/pull/1217)"
msgstr ""

#: src/changelog.md:1270
msgid ""
"Remove unused `python3` feature. [\\#1235](https://github.com/PyO3/pyo3/"
"pull/1235)"
msgstr ""

#: src/changelog.md:1274
msgid ""
"Fix missing field in `PyCodeObject` struct (`co_posonlyargcount`) - caused "
"invalid access to other fields in Python >3.7. [\\#1260](https://github.com/"
"PyO3/pyo3/pull/1260)"
msgstr ""

#: src/changelog.md:1275
msgid ""
"Fix building for `x86_64-unknown-linux-musl` target from `x86_64-unknown-"
"linux-gnu` host. [\\#1267](https://github.com/PyO3/pyo3/pull/1267)"
msgstr ""

#: src/changelog.md:1276
msgid ""
"Fix `#[text_signature]` interacting badly with rust `r#raw_identifiers`. "
"[\\#1286](https://github.com/PyO3/pyo3/pull/1286)"
msgstr ""

#: src/changelog.md:1277
msgid ""
"Fix FFI definitions for `PyObject_Vectorcall` and `PyVectorcall_Call`. "
"[\\#1287](https://github.com/PyO3/pyo3/pull/1285)"
msgstr ""

#: src/changelog.md:1278
msgid ""
"Fix building with Anaconda python inside a virtualenv. [\\#1290](https://"
"github.com/PyO3/pyo3/pull/1290)"
msgstr ""

#: src/changelog.md:1279
msgid ""
"Fix definition of opaque FFI types. [\\#1312](https://github.com/PyO3/pyo3/"
"pull/1312)"
msgstr ""

#: src/changelog.md:1280
msgid ""
"Fix using custom error type in pyclass `#[new]` methods. [\\#1319](https://"
"github.com/PyO3/pyo3/pull/1319)"
msgstr ""

#: src/changelog.md:1282
msgid ""
"[0.12.4](https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4) - 2020-11-28"
msgstr ""

#: src/changelog.md:1286
msgid ""
"Fix reference count bug in implementation of `From<Py<T>>` for `PyObject`, a "
"regression introduced in PyO3 0.12. [\\#1297](https://github.com/PyO3/pyo3/"
"pull/1297)"
msgstr ""

#: src/changelog.md:1288
msgid ""
"[0.12.3](https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3) - 2020-10-12"
msgstr ""

#: src/changelog.md:1292
msgid ""
"Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal "
"update to paste 1.0 which was done in PyO3 0.12.2. [\\#1234](https://github."
"com/PyO3/pyo3/pull/1234)"
msgstr ""

#: src/changelog.md:1294
msgid ""
"[0.12.2](https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2) - 2020-10-12"
msgstr ""

#: src/changelog.md:1298
msgid ""
"Add support for keyword-only arguments without default values in "
"`#[pyfunction]`. [\\#1209](https://github.com/PyO3/pyo3/pull/1209)"
msgstr ""

#: src/changelog.md:1299
msgid ""
"Add `Python::check_signals` as a safe a wrapper for `PyErr_CheckSignals`. "
"[\\#1214](https://github.com/PyO3/pyo3/pull/1214)"
msgstr ""

#: src/changelog.md:1303
msgid ""
"Fix invalid document for protocol methods. [\\#1169](https://github.com/PyO3/"
"pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:1304
msgid ""
"Hide docs of PyO3 private implementation details in `pyo3::class::methods`. "
"[\\#1169](https://github.com/PyO3/pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:1305
msgid ""
"Fix unnecessary rebuild on PATH changes when the python interpreter is "
"provided by PYO3_PYTHON. [\\#1231](https://github.com/PyO3/pyo3/pull/1231)"
msgstr ""

#: src/changelog.md:1307
msgid ""
"[0.12.1](https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1) - 2020-09-16"
msgstr ""

#: src/changelog.md:1311
msgid ""
"Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust "
"toolchain. [\\#1179](https://github.com/PyO3/pyo3/pull/1179)"
msgstr ""

#: src/changelog.md:1312
msgid ""
"Fix building on platforms where `c_char` is `u8`. [\\#1182](https://github."
"com/PyO3/pyo3/pull/1182)"
msgstr ""

#: src/changelog.md:1314
msgid ""
"[0.12.0](https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0) - 2020-09-12"
msgstr ""

#: src/changelog.md:1318
msgid ""
"Add FFI definitions `Py_FinalizeEx`, `PyOS_getsig`, and `PyOS_setsig`. "
"[\\#1021](https://github.com/PyO3/pyo3/pull/1021)"
msgstr ""

#: src/changelog.md:1319
msgid ""
"Add `PyString::to_str` for accessing `PyString` as `&str`. [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:1320
msgid ""
"Add `Python::with_gil` for executing a closure with the Python GIL. [\\#1037]"
"(https://github.com/PyO3/pyo3/pull/1037)"
msgstr ""

#: src/changelog.md:1321
msgid ""
"Add type information to failures in `PyAny::downcast`. [\\#1050](https://"
"github.com/PyO3/pyo3/pull/1050)"
msgstr ""

#: src/changelog.md:1322
msgid ""
"Implement `Debug` for `PyIterator`. [\\#1051](https://github.com/PyO3/pyo3/"
"pull/1051)"
msgstr ""

#: src/changelog.md:1323
msgid ""
"Add `PyBytes::new_with` and `PyByteArray::new_with` for initialising `bytes` "
"and `bytearray` objects using a closure. [\\#1074](https://github.com/PyO3/"
"pyo3/pull/1074)"
msgstr ""

#: src/changelog.md:1324
msgid ""
"Add `#[derive(FromPyObject)]` macro for enums and structs. [\\#1065](https://"
"github.com/PyO3/pyo3/pull/1065)"
msgstr ""

#: src/changelog.md:1325
msgid ""
"Add `Py::as_ref` and `Py::into_ref` for converting `Py<T>` to `&T`. [\\#1098]"
"(https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:1326
msgid ""
"Add ability to return `Result` types other than `PyResult` from "
"`#[pyfunction]`, `#[pymethod]` and `#[pyproto]` functions. [\\#1106](https://"
"github.com/PyO3/pyo3/pull/1118)."
msgstr ""

#: src/changelog.md:1327
msgid ""
"Implement `ToPyObject`, `IntoPy`, and `FromPyObject` for [hashbrown](https://"
"crates.io/crates/hashbrown)'s `HashMap` and `HashSet` types (requires the "
"`hashbrown` feature). [\\#1114](https://github.com/PyO3/pyo3/pull/1114)"
msgstr ""

#: src/changelog.md:1328
msgid ""
"Add `#[pyfunction(pass_module)]` and `#[pyfn(pass_module)]` to pass the "
"module object as the first function argument. [\\#1143](https://github.com/"
"PyO3/pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:1329
msgid ""
"Add `PyModule::add_function` and `PyModule::add_submodule` as typed "
"alternatives to `PyModule::add_wrapped`. [\\#1143](https://github.com/PyO3/"
"pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:1330
msgid ""
"Add native `PyCFunction` and `PyFunction` types. [\\#1163](https://github."
"com/PyO3/pyo3/pull/1163)"
msgstr ""

#: src/changelog.md:1334
msgid ""
"Rework exception types: [\\#1024](https://github.com/PyO3/pyo3/pull/1024) "
"[\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1335
msgid ""
"Rename exception types from e.g. `RuntimeError` to `PyRuntimeError`. The old "
"names continue to exist but are deprecated."
msgstr ""

#: src/changelog.md:1336
msgid ""
"Exception objects are now accessible as `&T` or `Py<T>`, just like other "
"Python-native types."
msgstr ""

#: src/changelog.md:1337
msgid "Rename `PyException::py_err` to `PyException::new_err`."
msgstr ""

#: src/changelog.md:1338
msgid "Rename `PyUnicodeDecodeErr::new_err` to `PyUnicodeDecodeErr::new`."
msgstr ""

#: src/changelog.md:1339
msgid "Remove `PyStopIteration::stop_iteration`."
msgstr ""

#: src/changelog.md:1340
msgid ""
"Require `T: Send` for the return value `T` of `Python::allow_threads`. "
"[\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:1341
msgid ""
"Rename `PYTHON_SYS_EXECUTABLE` to `PYO3_PYTHON`. The old name will continue "
"to work (undocumented) but will be removed in a future release. [\\#1039]"
"(https://github.com/PyO3/pyo3/pull/1039)"
msgstr ""

#: src/changelog.md:1342
msgid ""
"Remove `unsafe` from signature of `PyType::as_type_ptr`. [\\#1047](https://"
"github.com/PyO3/pyo3/pull/1047)"
msgstr ""

#: src/changelog.md:1343
msgid ""
"Change return type of `PyIterator::from_object` to `PyResult<PyIterator>` "
"(was `Result<PyIterator, PyDowncastError>`). [\\#1051](https://github.com/"
"PyO3/pyo3/pull/1051)"
msgstr ""

#: src/changelog.md:1344
msgid ""
"`IntoPy` is no longer implied by `FromPy`. [\\#1063](https://github.com/PyO3/"
"pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1345
msgid ""
"Change `PyObject` to be a type alias for `Py<PyAny>`. [\\#1063](https://"
"github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1346
msgid ""
"Rework `PyErr` to be compatible with the `std::error::Error` trait: [\\#1067]"
"(https://github.com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/"
"pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1347
msgid ""
"Implement `Display`, `Error`, `Send` and `Sync` for `PyErr` and "
"`PyErrArguments`."
msgstr ""

#: src/changelog.md:1348
msgid "Add `PyErr::instance` for accessing `PyErr` as `&PyBaseException`."
msgstr ""

#: src/changelog.md:1349
msgid ""
"`PyErr`'s fields are now an implementation detail. The equivalent values can "
"be accessed with `PyErr::ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/changelog.md:1350
msgid ""
"Change receiver of `PyErr::print` and `PyErr::print_and_set_sys_last_vars` "
"to `&self` (was `self`)."
msgstr ""

#: src/changelog.md:1351
msgid ""
"Remove `PyErrValue`, `PyErr::from_value`, `PyErr::into_normalized`, and "
"`PyErr::normalize`."
msgstr ""

#: src/changelog.md:1352
msgid "Remove `PyException::into`."
msgstr ""

#: src/changelog.md:1353
msgid "Remove `Into<PyResult<T>>` for `PyErr` and `PyException`."
msgstr ""

#: src/changelog.md:1354
msgid ""
"Change methods generated by `#[pyproto]` to return `NotImplemented` if "
"Python should try a reversed operation. #[1072](https://github.com/PyO3/pyo3/"
"pull/1072)"
msgstr ""

#: src/changelog.md:1355
msgid ""
"Change argument to `PyModule::add` to `impl IntoPy<PyObject>` (was `impl "
"ToPyObject`). #[1124](https://github.com/PyO3/pyo3/pull/1124)"
msgstr ""

#: src/changelog.md:1359
msgid ""
"Remove many exception and `PyErr` APIs; see the \"changed\" section above. "
"[\\#1024](https://github.com/PyO3/pyo3/pull/1024) [\\#1067](https://github."
"com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1360
msgid ""
"Remove `PyString::to_string` (use new `PyString::to_str`). [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:1361
msgid ""
"Remove `PyString::as_bytes`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:1362
msgid ""
"Remove `Python::register_any`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:1363
msgid ""
"Remove `GILGuard::acquire` from the public API. Use `Python::acquire_gil` or "
"`Python::with_gil`. [\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:1364
msgid ""
"Remove the `FromPy` trait. [\\#1063](https://github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1365
msgid ""
"Remove the `AsPyRef` trait. [\\#1098](https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:1369
msgid ""
"Correct FFI definitions `Py_SetProgramName` and `Py_SetPythonHome` to take "
"`*const` arguments (was `*mut`). [\\#1021](https://github.com/PyO3/pyo3/"
"pull/1021)"
msgstr ""

#: src/changelog.md:1370
msgid ""
"Fix `FromPyObject` for `num_bigint::BigInt` for Python objects with an "
"`__index__` method. [\\#1027](https://github.com/PyO3/pyo3/pull/1027)"
msgstr ""

#: src/changelog.md:1371
msgid ""
"Correct FFI definition `_PyLong_AsByteArray` to take `*mut c_uchar` argument "
"(was `*const c_uchar`). [\\#1029](https://github.com/PyO3/pyo3/pull/1029)"
msgstr ""

#: src/changelog.md:1372
msgid ""
"Fix segfault with `#[pyclass(dict, unsendable)]`. [\\#1058](https://github."
"com/PyO3/pyo3/pull/1058) [\\#1059](https://github.com/PyO3/pyo3/pull/1059)"
msgstr ""

#: src/changelog.md:1373
msgid ""
"Fix using `&Self` as an argument type for functions in a `#[pymethods]` "
"block. [\\#1071](https://github.com/PyO3/pyo3/pull/1071)"
msgstr ""

#: src/changelog.md:1374
msgid ""
"Fix best-effort build against PyPy 3.6. [\\#1092](https://github.com/PyO3/"
"pyo3/pull/1092)"
msgstr ""

#: src/changelog.md:1375
msgid ""
"Fix many cases of lifetime elision in `#[pyproto]` implementations. [\\#1093]"
"(https://github.com/PyO3/pyo3/pull/1093)"
msgstr ""

#: src/changelog.md:1376
msgid ""
"Fix detection of Python build configuration when cross-compiling. [\\#1095]"
"(https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:1377
msgid ""
"Always link against libpython on android with the `extension-module` "
"feature. [\\#1095](https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:1378
msgid ""
"Fix the `+` operator not trying `__radd__` when both `__add__` and "
"`__radd__` are defined in `PyNumberProtocol` (and similar for all other "
"reversible operators). [\\#1107](https://github.com/PyO3/pyo3/pull/1107)"
msgstr ""

#: src/changelog.md:1379
msgid ""
"Fix building with Anaconda python. [\\#1175](https://github.com/PyO3/pyo3/"
"pull/1175)"
msgstr ""

#: src/changelog.md:1381
msgid ""
"[0.11.1](https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1) - 2020-06-30"
msgstr ""

#: src/changelog.md:1385
msgid ""
"`#[pyclass(unsendable)]`. [\\#1009](https://github.com/PyO3/pyo3/pull/1009)"
msgstr ""

#: src/changelog.md:1389
msgid ""
"Update `parking_lot` dependency to `0.11`. [\\#1010](https://github.com/PyO3/"
"pyo3/pull/1010)"
msgstr ""

#: src/changelog.md:1391
msgid ""
"[0.11.0](https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0) - 2020-06-28"
msgstr ""

#: src/changelog.md:1395
msgid ""
"Support stable versions of Rust (>=1.39). [\\#969](https://github.com/PyO3/"
"pyo3/pull/969)"
msgstr ""

#: src/changelog.md:1396
msgid ""
"Add FFI definition `PyObject_AsFileDescriptor`. [\\#938](https://github.com/"
"PyO3/pyo3/pull/938)"
msgstr ""

#: src/changelog.md:1397
msgid ""
"Add `PyByteArray::data`, `PyByteArray::as_bytes`, and `PyByteArray::"
"as_bytes_mut`. [\\#967](https://github.com/PyO3/pyo3/pull/967)"
msgstr ""

#: src/changelog.md:1398
msgid ""
"Add `GILOnceCell` to use in situations where `lazy_static` or `once_cell` "
"can deadlock. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:1399
msgid ""
"Add `Py::borrow`, `Py::borrow_mut`, `Py::try_borrow`, and `Py::"
"try_borrow_mut` for accessing `#[pyclass]` values. [\\#976](https://github."
"com/PyO3/pyo3/pull/976)"
msgstr ""

#: src/changelog.md:1400
msgid ""
"Add `IterNextOutput` and `IterANextOutput` for returning from `__next__` / "
"`__anext__`. [\\#997](https://github.com/PyO3/pyo3/pull/997)"
msgstr ""

#: src/changelog.md:1404
msgid ""
"Simplify internals of `#[pyo3(get)]` attribute. (Remove the hidden API "
"`GetPropertyValue`.) [\\#934](https://github.com/PyO3/pyo3/pull/934)"
msgstr ""

#: src/changelog.md:1405
msgid ""
"Call `Py_Finalize` at exit to flush buffers, etc. [\\#943](https://github."
"com/PyO3/pyo3/pull/943)"
msgstr ""

#: src/changelog.md:1406
msgid ""
"Add type parameter to PyBuffer. #[951](https://github.com/PyO3/pyo3/pull/951)"
msgstr ""

#: src/changelog.md:1407
msgid ""
"Require `Send` bound for `#[pyclass]`. [\\#966](https://github.com/PyO3/pyo3/"
"pull/966)"
msgstr ""

#: src/changelog.md:1408
msgid ""
"Add `Python` argument to most methods on `PyObject` and `Py<T>` to ensure "
"GIL safety. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:1409
msgid ""
"Change signature of `PyTypeObject::type_object` - now takes `Python` "
"argument and returns `&PyType`. [\\#970](https://github.com/PyO3/pyo3/"
"pull/970)"
msgstr ""

#: src/changelog.md:1410
msgid ""
"Change return type of `PyTuple::slice` and `PyTuple::split_from` from "
"`Py<PyTuple>` to `&PyTuple`. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:1411
msgid ""
"Change return type of `PyTuple::as_slice` to `&[&PyAny]`. [\\#971](https://"
"github.com/PyO3/pyo3/pull/971)"
msgstr ""

#: src/changelog.md:1412
msgid ""
"Rename `PyTypeInfo::type_object` to `type_object_raw`, and add `Python` "
"argument. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:1413
msgid ""
"Update `num-complex` optional dependendency from `0.2` to `0.3`. [\\#977]"
"(https://github.com/PyO3/pyo3/pull/977)"
msgstr ""

#: src/changelog.md:1414
msgid ""
"Update `num-bigint` optional dependendency from `0.2` to `0.3`. [\\#978]"
"(https://github.com/PyO3/pyo3/pull/978)"
msgstr ""

#: src/changelog.md:1415
msgid ""
"`#[pyproto]` is re-implemented without specialization. [\\#961](https://"
"github.com/PyO3/pyo3/pull/961)"
msgstr ""

#: src/changelog.md:1416
msgid ""
"`PyClassAlloc::alloc` is renamed to `PyClassAlloc::new`. [\\#990](https://"
"github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:1417
msgid ""
"`#[pyproto]` methods can now have return value `T` or `PyResult<T>` "
"(previously only `PyResult<T>` was supported). [\\#996](https://github.com/"
"PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:1418
msgid ""
"`#[pyproto]` methods can now skip annotating the return type if it is `()`. "
"[\\#998](https://github.com/PyO3/pyo3/pull/998)"
msgstr ""

#: src/changelog.md:1422
msgid ""
"Remove `ManagedPyRef` (unused, and needs specialization) [\\#930](https://"
"github.com/PyO3/pyo3/pull/930)"
msgstr ""

#: src/changelog.md:1426
msgid ""
"Fix passing explicit `None` to `Option<T>` argument `#[pyfunction]` with a "
"default value. [\\#936](https://github.com/PyO3/pyo3/pull/936)"
msgstr ""

#: src/changelog.md:1427
msgid ""
"Fix `PyClass.__new__`'s not respecting subclasses when inherited by a Python "
"class. [\\#990](https://github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:1428
msgid ""
"Fix returning `Option<T>` from `#[pyproto]` methods. [\\#996](https://github."
"com/PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:1429
msgid ""
"Fix accepting `PyRef<Self>` and `PyRefMut<Self>` to `#[getter]` and "
"`#[setter]` methods. [\\#999](https://github.com/PyO3/pyo3/pull/999)"
msgstr ""

#: src/changelog.md:1431
msgid ""
"[0.10.1](https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1) - 2020-05-14"
msgstr ""

#: src/changelog.md:1435
msgid ""
"Fix deadlock in `Python::acquire_gil` after dropping a `PyObject` or "
"`Py<T>`. [\\#924](https://github.com/PyO3/pyo3/pull/924)"
msgstr ""

#: src/changelog.md:1437
msgid ""
"[0.10.0](https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0) - 2020-05-13"
msgstr ""

#: src/changelog.md:1441
msgid ""
"Add FFI definition `_PyDict_NewPresized`. [\\#849](https://github.com/PyO3/"
"pyo3/pull/849)"
msgstr ""

#: src/changelog.md:1442
msgid ""
"Implement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`. [\\#864](https://"
"github.com/PyO3/pyo3/pull/864)"
msgstr ""

#: src/changelog.md:1443
msgid ""
"Add `PyAny::dir` method. [\\#886](https://github.com/PyO3/pyo3/pull/886)"
msgstr ""

#: src/changelog.md:1444
msgid ""
"Gate macros behind a `macros` feature (enabled by default). [\\#897](https://"
"github.com/PyO3/pyo3/pull/897)"
msgstr ""

#: src/changelog.md:1445
msgid ""
"Add ability to define class attributes using `#[classattr]` on functions in "
"`#[pymethods]`. [\\#905](https://github.com/PyO3/pyo3/pull/905)"
msgstr ""

#: src/changelog.md:1446
msgid ""
"Implement `Clone` for `PyObject` and `Py<T>`. [\\#908](https://github.com/"
"PyO3/pyo3/pull/908)"
msgstr ""

#: src/changelog.md:1447
msgid ""
"Implement `Deref<Target = PyAny>` for all builtin types. (`PyList`, "
"`PyTuple`, `PyDict` etc.) [\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1448
msgid ""
"Implement `Deref<Target = PyAny>` for `PyCell<T>`. [\\#911](https://github."
"com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1449
msgid ""
"Add `#[classattr]` support for associated constants in `#[pymethods]`. "
"[\\#914](https://github.com/PyO3/pyo3/pull/914)"
msgstr ""

#: src/changelog.md:1453
msgid ""
"Panics will now be raised as a Python `PanicException`. [\\#797](https://"
"github.com/PyO3/pyo3/pull/797)"
msgstr ""

#: src/changelog.md:1454
msgid ""
"Change `PyObject` and `Py<T>` reference counts to decrement immediately upon "
"drop when the GIL is held. [\\#851](https://github.com/PyO3/pyo3/pull/851)"
msgstr ""

#: src/changelog.md:1455
msgid ""
"Allow `PyIterProtocol` methods to use either `PyRef` or `PyRefMut` as the "
"receiver type. [\\#856](https://github.com/PyO3/pyo3/pull/856)"
msgstr ""

#: src/changelog.md:1456
msgid ""
"Change the implementation of `FromPyObject` for `Py<T>` to apply to a wider "
"range of `T`, including all `T: PyClass`. [\\#880](https://github.com/PyO3/"
"pyo3/pull/880)"
msgstr ""

#: src/changelog.md:1457
msgid ""
"Move all methods from the `ObjectProtocol` trait to the `PyAny` struct. "
"[\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1458
msgid ""
"Remove need for `#![feature(specialization)]` in crates depending on PyO3. "
"[\\#917](https://github.com/PyO3/pyo3/pull/917)"
msgstr ""

#: src/changelog.md:1462
msgid ""
"Remove `PyMethodsProtocol` trait. [\\#889](https://github.com/PyO3/pyo3/"
"pull/889)"
msgstr ""

#: src/changelog.md:1463
msgid ""
"Remove `num-traits` dependency. [\\#895](https://github.com/PyO3/pyo3/"
"pull/895)"
msgstr ""

#: src/changelog.md:1464
msgid ""
"Remove `ObjectProtocol` trait. [\\#911](https://github.com/PyO3/pyo3/"
"pull/911)"
msgstr ""

#: src/changelog.md:1465
msgid ""
"Remove `PyAny::None`. Users should use `Python::None` instead. [\\#911]"
"(https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1466
msgid ""
"Remove all `*ProtocolImpl` traits. [\\#917](https://github.com/PyO3/pyo3/"
"pull/917)"
msgstr ""

#: src/changelog.md:1470
msgid ""
"Fix support for `__radd__` and other `__r*__` methods as implementations for "
"Python mathematical operators. [\\#839](https://github.com/PyO3/pyo3/"
"pull/839)"
msgstr ""

#: src/changelog.md:1471
msgid ""
"Fix panics during garbage collection when traversing objects that were "
"already mutably borrowed. [\\#855](https://github.com/PyO3/pyo3/pull/855)"
msgstr ""

#: src/changelog.md:1472
msgid ""
"Prevent `&'static` references to Python objects as arguments to "
"`#[pyfunction]` and `#[pymethods]`. [\\#869](https://github.com/PyO3/pyo3/"
"pull/869)"
msgstr ""

#: src/changelog.md:1473
msgid ""
"Fix lifetime safety bug with `AsPyRef::as_ref`. [\\#876](https://github.com/"
"PyO3/pyo3/pull/876)"
msgstr ""

#: src/changelog.md:1474
msgid ""
"Fix `#[pyo3(get)]` attribute on `Py<T>` fields. [\\#880](https://github.com/"
"PyO3/pyo3/pull/880)"
msgstr ""

#: src/changelog.md:1475
msgid ""
"Fix segmentation faults caused by functions such as `PyList::get_item` "
"returning borrowed objects when it was not safe to do so. [\\#890](https://"
"github.com/PyO3/pyo3/pull/890)"
msgstr ""

#: src/changelog.md:1476
msgid ""
"Fix segmentation faults caused by nested `Python::acquire_gil` calls "
"creating dangling references. [\\#893](https://github.com/PyO3/pyo3/pull/893)"
msgstr ""

#: src/changelog.md:1477
msgid ""
"Fix segmentatation faults when a panic occurs during a call to `Python::"
"allow_threads`. [\\#912](https://github.com/PyO3/pyo3/pull/912)"
msgstr ""

#: src/changelog.md:1479
msgid ""
"[0.9.2](https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2) - 2020-04-09"
msgstr ""

#: src/changelog.md:1483
msgid ""
"`FromPyObject` implementations for `HashSet` and `BTreeSet`. [\\#842]"
"(https://github.com/PyO3/pyo3/pull/842)"
msgstr ""

#: src/changelog.md:1487
msgid ""
"Correctly detect 32bit architecture. [\\#830](https://github.com/PyO3/pyo3/"
"pull/830)"
msgstr ""

#: src/changelog.md:1489
msgid ""
"[0.9.1](https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1) - 2020-03-23"
msgstr ""

#: src/changelog.md:1493
msgid ""
"Error messages for `#[pyclass]`. [\\#826](https://github.com/PyO3/pyo3/"
"pull/826)"
msgstr ""

#: src/changelog.md:1494
msgid ""
"`FromPyObject` implementation for `PySequence`. [\\#827](https://github.com/"
"PyO3/pyo3/pull/827)"
msgstr ""

#: src/changelog.md:1496
msgid ""
"[0.9.0](https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0) - 2020-03-19"
msgstr ""

#: src/changelog.md:1500
msgid ""
"`PyCell`, which has RefCell-like features. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1501
msgid ""
"`PyClass`, `PyLayout`, `PyClassInitializer`. [\\#683](https://github.com/"
"PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:1502
msgid ""
"Implemented `IntoIterator` for `PySet` and `PyFrozenSet`. [\\#716](https://"
"github.com/PyO3/pyo3/pull/716)"
msgstr ""

#: src/changelog.md:1503
msgid ""
"`FromPyObject` is now automatically implemented for `T: Clone` pyclasses. "
"[\\#730](https://github.com/PyO3/pyo3/pull/730)"
msgstr ""

#: src/changelog.md:1504
msgid ""
"`#[pyo3(get)]` and `#[pyo3(set)]` will now use the Rust doc-comment from the "
"field for the Python property. [\\#755](https://github.com/PyO3/pyo3/"
"pull/755)"
msgstr ""

#: src/changelog.md:1505
msgid ""
"`#[setter]` functions may now take an argument of `Pyo3::Python`. [\\#760]"
"(https://github.com/PyO3/pyo3/pull/760)"
msgstr ""

#: src/changelog.md:1506
msgid ""
"`PyTypeInfo::BaseLayout` and `PyClass::BaseNativeType`. [\\#770](https://"
"github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1507
msgid "`PyDowncastImpl`. [\\#770](https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1508
msgid ""
"Implement `FromPyObject` and `IntoPy<PyObject>` traits for arrays (up to "
"32). [\\#778](https://github.com/PyO3/pyo3/pull/778)"
msgstr ""

#: src/changelog.md:1509
msgid ""
"`migration.md` and `types.md` in the guide. [\\#795](https://github.com/PyO3/"
"pyo3/pull/795), #[802](https://github.com/PyO3/pyo3/pull/802)"
msgstr ""

#: src/changelog.md:1510
msgid ""
"`ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}"
"`. #[820](https://github.com/PyO3/pyo3/pull/820)"
msgstr ""

#: src/changelog.md:1514
msgid ""
"`#[new]` does not take `PyRawObject` and can return `Self`. [\\#683](https://"
"github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:1515
msgid ""
"The blanket implementations for `FromPyObject` for `&T` and `&mut T` are no "
"longer specializable. Implement `PyTryFrom` for your type to control the "
"behavior of `FromPyObject::extract` for your types. [\\#713](https://github."
"com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:1516
msgid ""
"The implementation for `IntoPy<U> for T` where `U: FromPy<T>` is no longer "
"specializable. Control the behavior of this via the implementation of "
"`FromPy`. [\\#713](https://github.com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:1517
msgid ""
"Use `parking_lot::Mutex` instead of `spin::Mutex`. [\\#734](https://github."
"com/PyO3/pyo3/pull/734)"
msgstr ""

#: src/changelog.md:1518
msgid ""
"Bumped minimum Rust version to `1.42.0-nightly 2020-01-21`. [\\#761](https://"
"github.com/PyO3/pyo3/pull/761)"
msgstr ""

#: src/changelog.md:1519
msgid ""
"`PyRef` and `PyRefMut` are renewed for `PyCell`. [\\#770](https://github.com/"
"PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1520
msgid ""
"Some new FFI functions for Python 3.8. [\\#784](https://github.com/PyO3/pyo3/"
"pull/784)"
msgstr ""

#: src/changelog.md:1521
msgid ""
"`PyAny` is now on the top level module and prelude. [\\#816](https://github."
"com/PyO3/pyo3/pull/816)"
msgstr ""

#: src/changelog.md:1525
msgid "`PyRawObject`. [\\#683](https://github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:1526
msgid "`PyNoArgsFunction`. [\\#741](https://github.com/PyO3/pyo3/pull/741)"
msgstr ""

#: src/changelog.md:1527
msgid ""
"`initialize_type`. To set the module name for a `#[pyclass]`, use the "
"`module` argument to the macro. #[751](https://github.com/PyO3/pyo3/pull/751)"
msgstr ""

#: src/changelog.md:1528
msgid ""
"`AsPyRef::as_mut/with/with_mut/into_py/into_mut_py`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1529
msgid ""
"`PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked`. [\\#770]"
"(https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1530
msgid ""
"`Python::mut_from_owned_ptr/mut_from_borrowed_ptr`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1531
msgid ""
"`ObjectProtocol::get_base/get_mut_base`. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1535
msgid ""
"Fixed unsoundness of subclassing. [\\#683](https://github.com/PyO3/pyo3/"
"pull/683)."
msgstr ""

#: src/changelog.md:1536
msgid ""
"Clear error indicator when the exception is handled on the Rust side. "
"[\\#719](https://github.com/PyO3/pyo3/pull/719)"
msgstr ""

#: src/changelog.md:1537
msgid ""
"Usage of raw identifiers with `#[pyo3(set)]`. [\\#745](https://github.com/"
"PyO3/pyo3/pull/745)"
msgstr ""

#: src/changelog.md:1538
msgid ""
"Usage of `PyObject` with `#[pyo3(get)]`. [\\#760](https://github.com/PyO3/"
"pyo3/pull/760)"
msgstr ""

#: src/changelog.md:1539
msgid ""
"`#[pymethods]` used in conjunction with `#[cfg]`. #[769](https://github.com/"
"PyO3/pyo3/pull/769)"
msgstr ""

#: src/changelog.md:1540
msgid ""
"`\"*\"` in a `#[pyfunction()]` argument list incorrectly accepting any "
"number of positional arguments (use `args = \"*\"` when this behavior is "
"desired). #[792](https://github.com/PyO3/pyo3/pull/792)"
msgstr ""

#: src/changelog.md:1541
msgid "`PyModule::dict`. #[809](https://github.com/PyO3/pyo3/pull/809)"
msgstr ""

#: src/changelog.md:1542
msgid ""
"Fix the case where `DESCRIPTION` is not null-terminated. #[822](https://"
"github.com/PyO3/pyo3/pull/822)"
msgstr ""

#: src/changelog.md:1544
msgid ""
"[0.8.5](https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5) - 2020-01-05"
msgstr ""

#: src/changelog.md:1548
msgid "Implemented `FromPyObject` for `HashMap` and `BTreeMap`"
msgstr ""

#: src/changelog.md:1549
msgid ""
"Support for `#[name = \"foo\"]` attribute for `#[pyfunction]` and in "
"`#[pymethods]`. [\\#692](https://github.com/PyO3/pyo3/pull/692)"
msgstr ""

#: src/changelog.md:1551
msgid ""
"[0.8.4](https://github.com/pyo3/pyo3/compare/v0.8.3...v0.8.4) - 2019-12-14"
msgstr ""

#: src/changelog.md:1555
msgid ""
"Support for `#[text_signature]` attribute. [\\#675](https://github.com/PyO3/"
"pyo3/pull/675)"
msgstr ""

#: src/changelog.md:1557
msgid ""
"[0.8.3](https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3) - 2019-11-23"
msgstr ""

#: src/changelog.md:1561
msgid "`#[init]` is removed. [\\#658](https://github.com/PyO3/pyo3/pull/658)"
msgstr ""

#: src/changelog.md:1565
msgid ""
"Now all `&Py~` types have `!Send` bound. [\\#655](https://github.com/PyO3/"
"pyo3/pull/655)"
msgstr ""

#: src/changelog.md:1566
msgid ""
"Fix a compile error raised by the stabilization of `!` type. [\\#672]"
"(https://github.com/PyO3/pyo3/issues/672)."
msgstr ""

#: src/changelog.md:1568
msgid ""
"[0.8.2](https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2) - 2019-10-27"
msgstr ""

#: src/changelog.md:1572
msgid ""
"FFI compatibility for PEP 590 Vectorcall. [\\#641](https://github.com/PyO3/"
"pyo3/pull/641)"
msgstr ""

#: src/changelog.md:1576
msgid ""
"Fix PySequenceProtocol::set_item. [\\#624](https://github.com/PyO3/pyo3/"
"pull/624)"
msgstr ""

#: src/changelog.md:1577
msgid ""
"Fix a corner case of BigInt::FromPyObject. [\\#630](https://github.com/PyO3/"
"pyo3/pull/630)"
msgstr ""

#: src/changelog.md:1578
msgid ""
"Fix index errors in parameter conversion. [\\#631](https://github.com/PyO3/"
"pyo3/pull/631)"
msgstr ""

#: src/changelog.md:1579
msgid ""
"Fix handling of invalid utf-8 sequences in `PyString::as_bytes`. [\\#639]"
"(https://github.com/PyO3/pyo3/pull/639) and `PyString::to_string_lossy` "
"[\\#642](https://github.com/PyO3/pyo3/pull/642)."
msgstr ""

#: src/changelog.md:1581
msgid ""
"Remove `__contains__` and `__iter__` from PyMappingProtocol. [\\#644]"
"(https://github.com/PyO3/pyo3/pull/644)"
msgstr ""

#: src/changelog.md:1582
msgid ""
"Fix proc-macro definition of PySetAttrProtocol. [\\#645](https://github.com/"
"PyO3/pyo3/pull/645)"
msgstr ""

#: src/changelog.md:1584
msgid ""
"[0.8.1](https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1) - 2019-10-08"
msgstr ""

#: src/changelog.md:1588
msgid ""
"Conversion between [num-bigint](https://github.com/rust-num/num-bigint) and "
"Python int. [\\#608](https://github.com/PyO3/pyo3/pull/608)"
msgstr ""

#: src/changelog.md:1592
msgid ""
"Make sure the right Python interpreter is used in OSX builds. [\\#604]"
"(https://github.com/PyO3/pyo3/pull/604)"
msgstr ""

#: src/changelog.md:1593
msgid ""
"Patch specialization being broken by Rust 1.40. [\\#614](https://github.com/"
"PyO3/pyo3/issues/614)"
msgstr ""

#: src/changelog.md:1594
msgid ""
"Fix a segfault around PyErr. [\\#597](https://github.com/PyO3/pyo3/pull/597)"
msgstr ""

#: src/changelog.md:1596
msgid ""
"[0.8.0](https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0) - 2019-09-16"
msgstr ""

#: src/changelog.md:1600
msgid ""
"`module` argument to `pyclass` macro. [\\#499](https://github.com/PyO3/pyo3/"
"pull/499)"
msgstr ""

#: src/changelog.md:1601
msgid "`py_run!` macro [\\#512](https://github.com/PyO3/pyo3/pull/512)"
msgstr ""

#: src/changelog.md:1602
msgid ""
"Use existing fields and methods before calling custom **getattr**. [\\#505]"
"(https://github.com/PyO3/pyo3/pull/505)"
msgstr ""

#: src/changelog.md:1603
msgid "`PyBytes` can now be indexed just like `Vec<u8>`"
msgstr ""

#: src/changelog.md:1604
msgid "Implement `IntoPy<PyObject>` for `PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:1608
msgid ""
"Implementing the Using the `gc` parameter for `pyclass` (e.g. "
"`#[pyclass(gc)]`) without implementing the `class::PyGCProtocol` trait is "
"now a compile-time error. Failing to implement this trait could lead to "
"segfaults. [\\#532](https://github.com/PyO3/pyo3/pull/532)"
msgstr ""

#: src/changelog.md:1609
msgid ""
"`PyByteArray::data` has been replaced with `PyDataArray::to_vec` because "
"returning a `&[u8]` is unsound. (See [this comment](https://github.com/PyO3/"
"pyo3/issues/373#issuecomment-512332696) for a great write-up for why that "
"was unsound)"
msgstr ""

#: src/changelog.md:1610
msgid "Replace `mashup` with `paste`."
msgstr ""

#: src/changelog.md:1611
msgid ""
"`GILPool` gained a `Python` marker to prevent it from being misused to "
"release Python objects without the GIL held."
msgstr ""

#: src/changelog.md:1615
msgid "`IntoPyObject` was replaced with `IntoPy<PyObject>`"
msgstr ""

#: src/changelog.md:1616
msgid ""
"`#[pyclass(subclass)]` is hidden a `unsound-subclass` feature because it's "
"causing segmentation faults."
msgstr ""

#: src/changelog.md:1620
msgid ""
"More readable error message for generics in pyclass [\\#503](https://github."
"com/PyO3/pyo3/pull/503)"
msgstr ""

#: src/changelog.md:1622
msgid ""
"[0.7.0](https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0) - 2019-05-26"
msgstr ""

#: src/changelog.md:1626
msgid ""
"PyPy support by omerbenamram in [\\#393](https://github.com/PyO3/pyo3/"
"pull/393)"
msgstr ""

#: src/changelog.md:1627
msgid "Have `PyModule` generate an index of its members (`__all__` list)."
msgstr ""

#: src/changelog.md:1628
msgid "Allow `slf: PyRef<T>` for pyclass(#419)"
msgstr ""

#: src/changelog.md:1629
msgid "Allow to use lifetime specifiers in `pymethods`"
msgstr ""

#: src/changelog.md:1630
msgid "Add `marshal` module. [\\#460](https://github.com/PyO3/pyo3/pull/460)"
msgstr ""

#: src/changelog.md:1634
msgid "`Python::run` returns `PyResult<()>` instead of `PyResult<&PyAny>`."
msgstr ""

#: src/changelog.md:1635
msgid ""
"Methods decorated with `#[getter]` and `#[setter]` can now omit wrapping the "
"result type in `PyResult` if they don't raise exceptions."
msgstr ""

#: src/changelog.md:1640
msgid ""
"`type_object::PyTypeObject` has been marked unsafe because breaking the "
"contract `type_object::PyTypeObject::init_type` can lead to UB."
msgstr ""

#: src/changelog.md:1641
msgid ""
"Fixed automatic derive of `PySequenceProtocol` implementation in [\\#423]"
"(https://github.com/PyO3/pyo3/pull/423)."
msgstr ""

#: src/changelog.md:1642
msgid "Capitalization & better wording to README.md."
msgstr ""

#: src/changelog.md:1643
msgid ""
"Docstrings of properties is now properly set using the doc of the "
"`#[getter]` method."
msgstr ""

#: src/changelog.md:1644
msgid ""
"Fixed issues with `pymethods` crashing on doc comments containing double "
"quotes."
msgstr ""

#: src/changelog.md:1645
msgid ""
"`PySet::new` and `PyFrozenSet::new` now return `PyResult<&Py[Frozen]Set>`; "
"exceptions are raised if the items are not hashable."
msgstr ""

#: src/changelog.md:1647
msgid "Fixed building using `venv` on Windows."
msgstr ""

#: src/changelog.md:1648
msgid "`PyTuple::new` now returns `&PyTuple` instead of `Py<PyTuple>`."
msgstr ""

#: src/changelog.md:1649
msgid ""
"Fixed several issues with argument parsing; notable, the `*args` and "
"`**kwargs` tuple/dict now doesn't contain arguments that are otherwise "
"assigned to parameters."
msgstr ""

#: src/changelog.md:1652
msgid ""
"[0.6.0](https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0) - 2019-03-28"
msgstr ""

#: src/changelog.md:1654
msgid "Regressions"
msgstr ""

#: src/changelog.md:1656
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For now you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/changelog.md:1658
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/changelog.md:1669
msgid ""
"Added a `wrap_pymodule!` macro similar to the existing `wrap_pyfunction!` "
"macro. Only available on python 3"
msgstr ""

#: src/changelog.md:1670
msgid ""
"Added support for cross compiling (e.g. to arm v7) by mtp401 in [\\#327]"
"(https://github.com/PyO3/pyo3/pull/327). See the \"Cross Compiling\" section "
"in the \"Building and Distribution\" chapter of the guide for more details."
msgstr ""

#: src/changelog.md:1671
msgid ""
"The `PyRef` and `PyRefMut` types, which allow to differentiate between an "
"instance of a rust struct on the rust heap and an instance that is embedded "
"inside a python object. By kngwyu in [\\#335](https://github.com/PyO3/pyo3/"
"pull/335)"
msgstr ""

#: src/changelog.md:1672
msgid ""
"Added `FromPy<T>` and `IntoPy<T>` which are equivalent to `From<T>` and "
"`Into<T>` except that they require a gil token."
msgstr ""

#: src/changelog.md:1673
msgid ""
"Added `ManagedPyRef`, which should eventually replace `ToBorrowedObject`."
msgstr ""

#: src/changelog.md:1677
msgid "Renamed `PyObjectRef` to `PyAny` in #388"
msgstr ""

#: src/changelog.md:1678
msgid ""
"Renamed `add_function` to `add_wrapped` as it now also supports modules."
msgstr ""

#: src/changelog.md:1679
msgid "Renamed `#[pymodinit]` to `#[pymodule]`"
msgstr ""

#: src/changelog.md:1680
msgid "`py.init(|| value)` becomes `Py::new(value)`"
msgstr ""

#: src/changelog.md:1681
msgid "`py.init_ref(|| value)` becomes `PyRef::new(value)`"
msgstr ""

#: src/changelog.md:1682
msgid "`py.init_mut(|| value)` becomes `PyRefMut::new(value)`."
msgstr ""

#: src/changelog.md:1683
msgid ""
"`PyRawObject::init` is now infallible, e.g. it returns `()` instead of "
"`PyResult<()>`."
msgstr ""

#: src/changelog.md:1684
msgid ""
"Renamed `py_exception!` to `create_exception!` and refactored the error "
"macros."
msgstr ""

#: src/changelog.md:1685
msgid "Renamed `wrap_function!` to `wrap_pyfunction!`"
msgstr ""

#: src/changelog.md:1686
msgid "Renamed `#[prop(get, set)]` to `#[pyo3(get, set)]`"
msgstr ""

#: src/changelog.md:1687
msgid "`#[pyfunction]` now supports the same arguments as `#[pyfn()]`"
msgstr ""

#: src/changelog.md:1688
msgid "Some macros now emit proper spanned errors instead of panics."
msgstr ""

#: src/changelog.md:1689
msgid "Migrated to the 2018 edition"
msgstr ""

#: src/changelog.md:1690
msgid "`crate::types::exceptions` moved to `crate::exceptions`"
msgstr ""

#: src/changelog.md:1691
msgid "Replace `IntoPyTuple` with `IntoPy<Py<PyTuple>>`."
msgstr ""

#: src/changelog.md:1692
msgid "`IntoPyPointer` and `ToPyPointer` moved into the crate root."
msgstr ""

#: src/changelog.md:1693
msgid "`class::CompareOp` moved into `class::basic::CompareOp`"
msgstr ""

#: src/changelog.md:1694
msgid ""
"PyTypeObject is now a direct subtrait PyTypeCreate, removing the old "
"cyclical implementation in [\\#350](https://github.com/PyO3/pyo3/pull/350)"
msgstr ""

#: src/changelog.md:1695
msgid ""
"Add `PyList::{sort, reverse}` by chr1sj0nes in [\\#357](https://github.com/"
"PyO3/pyo3/pull/357) and [\\#358](https://github.com/PyO3/pyo3/pull/358)"
msgstr ""

#: src/changelog.md:1696
msgid "Renamed the `typeob` module to `type_object`"
msgstr ""

#: src/changelog.md:1700
msgid ""
"`PyToken` was removed due to unsoundness (See [\\#94](https://github.com/"
"PyO3/pyo3/issues/94))."
msgstr ""

#: src/changelog.md:1701
msgid "Removed the unnecessary type parameter from `PyObjectAlloc`"
msgstr ""

#: src/changelog.md:1702
msgid "`NoArgs`. Just use an empty tuple"
msgstr ""

#: src/changelog.md:1703
msgid ""
"`PyObjectWithGIL`. `PyNativeType` is sufficient now that PyToken is removed."
msgstr ""

#: src/changelog.md:1707
msgid ""
"A soudness hole where every instances of a `#[pyclass]` struct was "
"considered to be part of a python object, even though you can create "
"instances that are not part of the python heap. This was fixed through "
"`PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:1708
msgid "Fix kwargs support in [\\#328](https://github.com/PyO3/pyo3/pull/328)."
msgstr ""

#: src/changelog.md:1709
msgid ""
"Add full support for `__dict__` in [\\#403](https://github.com/PyO3/pyo3/"
"pull/403)."
msgstr ""

#: src/changelog.md:1711
msgid ""
"[0.5.3](https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3) - 2019-01-04"
msgstr ""

#: src/changelog.md:1715
msgid ""
"Fix memory leak in ArrayList by kngwyu [\\#316](https://github.com/PyO3/pyo3/"
"pull/316)"
msgstr ""

#: src/changelog.md:1717
msgid ""
"[0.5.2](https://github.com/pyo3/pyo3/compare/v0.5.1...v0.5.2) - 2018-11-25"
msgstr ""

#: src/changelog.md:1721
msgid ""
"Fix undeterministic segfaults when creating many objects by kngwyu in "
"[\\#281](https://github.com/PyO3/pyo3/pull/281)"
msgstr ""

#: src/changelog.md:1723
msgid ""
"[0.5.1](https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.1) - 2018-11-24"
msgstr ""

#: src/changelog.md:1725
msgid "Yanked"
msgstr ""

#: src/changelog.md:1727
msgid ""
"[0.5.0](https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0) - 2018-11-11"
msgstr ""

#: src/changelog.md:1731
msgid "`#[pyclass]` objects can now be returned from rust functions"
msgstr ""

#: src/changelog.md:1732
msgid ""
"`PyComplex` by kngwyu in [\\#226](https://github.com/PyO3/pyo3/pull/226)"
msgstr ""

#: src/changelog.md:1733
msgid "`PyDict::from_sequence`, equivalent to `dict([(key, val), ...])`"
msgstr ""

#: src/changelog.md:1734
msgid ""
"Bindings for the `datetime` standard library types: `PyDate`, `PyTime`, "
"`PyDateTime`, `PyTzInfo`, `PyDelta` with associated `ffi` types, by pganssle "
"[\\#200](https://github.com/PyO3/pyo3/pull/200)."
msgstr ""

#: src/changelog.md:1735
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` now have an `as_bytes` method that "
"returns `&[u8]`."
msgstr ""

#: src/changelog.md:1736
msgid ""
"`PyObjectProtocol::get_type_ptr` by ijl in [\\#242](https://github.com/PyO3/"
"pyo3/pull/242)"
msgstr ""

#: src/changelog.md:1740
msgid ""
"Removes the types from the root module and the prelude. They now live in "
"`pyo3::types` instead."
msgstr ""

#: src/changelog.md:1741
msgid ""
"All exceptions are constructed with `py_err` instead of `new`, as they "
"return `PyErr` and not `Self`."
msgstr ""

#: src/changelog.md:1742
msgid "`as_mut` and friends take and `&mut self` instead of `&self`"
msgstr ""

#: src/changelog.md:1743
msgid ""
"`ObjectProtocol::call` now takes an `Option<&PyDict>` for the kwargs instead "
"of an `IntoPyDictPointer`."
msgstr ""

#: src/changelog.md:1744
msgid ""
"`IntoPyDictPointer` was replace by `IntoPyDict` which doesn't convert "
"`PyDict` itself anymore and returns a `PyDict` instead of `*mut PyObject`."
msgstr ""

#: src/changelog.md:1745
msgid "`PyTuple::new` now takes an `IntoIterator` instead of a slice"
msgstr ""

#: src/changelog.md:1746
msgid "Updated to syn 0.15"
msgstr ""

#: src/changelog.md:1747
msgid ""
"Splitted `PyTypeObject` into `PyTypeObject` without the create method and "
"`PyTypeCreate` with requires `PyObjectAlloc<Self> + PyTypeInfo + Sized`."
msgstr ""

#: src/changelog.md:1748
msgid ""
"Ran `cargo edition --fix` which prefixed path with `crate::` for rust 2018"
msgstr ""

#: src/changelog.md:1749
msgid ""
"Renamed `async` to `pyasync` as async will be a keyword in the 2018 edition."
msgstr ""

#: src/changelog.md:1750
msgid ""
"Starting to use `NonNull<*mut PyObject>` for Py and PyObject by ijl [\\#260]"
"(https://github.com/PyO3/pyo3/pull/260)"
msgstr ""

#: src/changelog.md:1754
msgid ""
"Removed most entries from the prelude. The new prelude is small and clear."
msgstr ""

#: src/changelog.md:1755
msgid "Slowly removing specialization uses"
msgstr ""

#: src/changelog.md:1756
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` no longer have a `data` method "
"(replaced by `as_bytes`) and `PyStringData` has been removed."
msgstr ""

#: src/changelog.md:1758
msgid "The pyobject_extract macro"
msgstr ""

#: src/changelog.md:1762
msgid ""
"Added an explanation that the GIL can temporarily be released even while "
"holding a GILGuard."
msgstr ""

#: src/changelog.md:1763
msgid "Lots of clippy errors"
msgstr ""

#: src/changelog.md:1764
msgid "Fix segfault on calling an unknown method on a PyObject"
msgstr ""

#: src/changelog.md:1765
msgid ""
"Work around a [bug](https://github.com/rust-lang/rust/issues/55380) in the "
"rust compiler by kngwyu [\\#252](https://github.com/PyO3/pyo3/pull/252)"
msgstr ""

#: src/changelog.md:1766
msgid ""
"Fixed a segfault with subclassing pyo3 create classes and using `__class__` "
"by kngwyu [\\#263](https://github.com/PyO3/pyo3/pull/263)"
msgstr ""

#: src/changelog.md:1768
msgid ""
"[0.4.1](https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1) - 2018-08-20"
msgstr ""

#: src/changelog.md:1772
msgid "PyTryFrom's error is always to `PyDowncastError`"
msgstr ""

#: src/changelog.md:1776
msgid "Fixed compilation on nightly since `use_extern_macros` was stabilized"
msgstr ""

#: src/changelog.md:1780
msgid "The pyobject_downcast macro"
msgstr ""

#: src/changelog.md:1782
msgid ""
"[0.4.0](https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0) - 2018-07-30"
msgstr ""

#: src/changelog.md:1786
msgid "Merged both examples into one"
msgstr ""

#: src/changelog.md:1787
msgid "Rustfmt all the things :heavy_check_mark:"
msgstr ""

#: src/changelog.md:1788
msgid "Switched to [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)"
msgstr ""

#: src/changelog.md:1792
msgid ""
"Conversions from tuples to PyDict due to [rust-lang/rust#52050](https://"
"github.com/rust-lang/rust/issues/52050)"
msgstr ""

#: src/changelog.md:1794
msgid ""
"[0.3.2](https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2) - 2018-07-22"
msgstr ""

#: src/changelog.md:1798
msgid "Replaced `concat_idents` with mashup"
msgstr ""

#: src/changelog.md:1800
msgid ""
"[0.3.1](https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1) - 2018-07-18"
msgstr ""

#: src/changelog.md:1804
msgid "Fixed scoping bug in pyobject_native_type that would break rust-numpy"
msgstr ""

#: src/changelog.md:1806
msgid ""
"[0.3.0](https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0) - 2018-07-18"
msgstr ""

#: src/changelog.md:1810
msgid ""
"A few internal macros became part of the public api ([\\#155](https://github."
"com/PyO3/pyo3/pull/155), [\\#186](https://github.com/PyO3/pyo3/pull/186))"
msgstr ""

#: src/changelog.md:1811
msgid ""
"Always clone in getters. This allows using the get-annotation on all Clone-"
"Types"
msgstr ""

#: src/changelog.md:1815
msgid "Upgraded to syn 0.14 which means much better error messages :tada:"
msgstr ""

#: src/changelog.md:1816
msgid ""
"128 bit integer support by [kngwyu](https://github.com/kngwyu) ([\\#137]"
"(https://github.com/PyO3/pyo3/pull/173))"
msgstr ""

#: src/changelog.md:1817
msgid ""
"`proc_macro` has been stabilized on nightly ([rust-lang/rust#52081](https://"
"github.com/rust-lang/rust/pull/52081)). This means that we can remove the "
"`proc_macro` feature, but now we need the `use_extern_macros` from the 2018 "
"edition instead."
msgstr ""

#: src/changelog.md:1818
msgid ""
"All proc macro are now prefixed with `py` and live in the prelude. This "
"means you can use `#[pyclass]`, `#[pymethods]`, `#[pyproto]`, "
"`#[pyfunction]` and `#[pymodinit]` directly, at least after a `use pyo3::"
"prelude::*`. They were also moved into a module called `proc_macro`. You "
"shouldn't use `#[pyo3::proc_macro::pyclass]` or other longer paths in "
"attributes because `proc_macro_path_invoc` isn't going to be stabilized soon."
msgstr ""

#: src/changelog.md:1819
msgid "Renamed the `base` option in the `pyclass` macro to `extends`."
msgstr ""

#: src/changelog.md:1820
msgid ""
"`#[pymodinit]` uses the function name as module name, unless the name is "
"overrriden with `#[pymodinit(name)]`"
msgstr ""

#: src/changelog.md:1821
msgid "The guide is now properly versioned."
msgstr ""

#: src/changelog.md:1823
msgid ""
"[0.2.7](https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7) - 2018-05-18"
msgstr ""

#: src/changelog.md:1827
msgid "Fix nightly breakage with proc_macro_path"
msgstr ""

#: src/changelog.md:1829
msgid ""
"[0.2.6](https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6) - 2018-04-03"
msgstr ""

#: src/changelog.md:1833
msgid "Fix compatibility with TryFrom trait #137"
msgstr ""

#: src/changelog.md:1835
msgid ""
"[0.2.5](https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5) - 2018-02-21"
msgstr ""

#: src/changelog.md:1839
msgid "CPython 3.7 support"
msgstr ""

#: src/changelog.md:1843
msgid "Embedded CPython 3.7b1 crashes on initialization #110"
msgstr ""

#: src/changelog.md:1844
msgid "Generated extension functions are weakly typed #108"
msgstr ""

#: src/changelog.md:1845
msgid "call_method\\* crashes when the method does not exist #113"
msgstr ""

#: src/changelog.md:1846
msgid "Allow importing exceptions from nested modules #116"
msgstr ""

#: src/changelog.md:1848
msgid ""
"[0.2.4](https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4) - 2018-01-19"
msgstr ""

#: src/changelog.md:1852
msgid "Allow to get mutable ref from PyObject #106"
msgstr ""

#: src/changelog.md:1853
msgid "Drop `RefFromPyObject` trait"
msgstr ""

#: src/changelog.md:1854
msgid "Add Python::register_any method"
msgstr ""

#: src/changelog.md:1858
msgid "Fix impl `FromPyObject` for `Py<T>`"
msgstr ""

#: src/changelog.md:1859
msgid "Mark method that work with raw pointers as unsafe #95"
msgstr ""

#: src/changelog.md:1861
msgid ""
"[0.2.3](https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3) - 11-27-2017"
msgstr ""

#: src/changelog.md:1865
msgid "Rustup to 1.23.0-nightly 2017-11-07"
msgstr ""

#: src/changelog.md:1869
msgid "Proper `c_char` usage #93"
msgstr ""

#: src/changelog.md:1873
msgid "Remove use of now unneeded 'AsciiExt' trait"
msgstr ""

#: src/changelog.md:1875
msgid ""
"[0.2.2](https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2) - 09-26-2017"
msgstr ""

#: src/changelog.md:1879
msgid "Rustup to 1.22.0-nightly 2017-09-30"
msgstr ""

#: src/changelog.md:1881
msgid ""
"[0.2.1](https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1) - 09-26-2017"
msgstr ""

#: src/changelog.md:1885
msgid "Fix rustc const_fn nightly breakage"
msgstr ""

#: src/changelog.md:1887
msgid ""
"[0.2.0](https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0) - 08-12-2017"
msgstr ""

#: src/changelog.md:1891
msgid "Added inheritance support #15"
msgstr ""

#: src/changelog.md:1892
msgid "Added weakref support #56"
msgstr ""

#: src/changelog.md:1893
msgid "Added subclass support #64"
msgstr ""

#: src/changelog.md:1894
msgid "Added `self.__dict__` supoort #68"
msgstr ""

#: src/changelog.md:1895
msgid "Added `pyo3::prelude` module #70"
msgstr ""

#: src/changelog.md:1896
msgid "Better `Iterator` support for PyTuple, PyList, PyDict #75"
msgstr ""

#: src/changelog.md:1897
msgid "Introduce IntoPyDictPointer similar to IntoPyTuple #69"
msgstr ""

#: src/changelog.md:1901
msgid "Allow to add gc support without implementing PyGCProtocol #57"
msgstr ""

#: src/changelog.md:1902
msgid "Refactor `PyErr` implementation. Drop `py` parameter from constructor."
msgstr ""

#: src/changelog.md:1904
msgid "[0.1.0](https://github.com/PyO3/pyo3/tree/0.1.0) - 07-23-2017"
msgstr ""

#: src/changelog.md:1908
msgid "Initial release"
msgstr ""

#: src/contributing.md:1
msgid "Contributing"
msgstr ""

#: src/contributing.md:3
msgid ""
"Thank you for your interest in contributing to PyO3! All are welcome - "
"please consider reading our [Code of Conduct](https://github.com/PyO3/pyo3/"
"blob/main/Code-of-Conduct.md) to keep our community positive and inclusive."
msgstr ""

#: src/contributing.md:5
msgid ""
"If you are searching for ideas how to contribute, proceed to the [\"Getting "
"started contributing\"](#getting-started-contributing) section. If you have "
"found a specific issue to contribute to and need information about the "
"development process, you may find the section [\"Writing pull requests\"]"
"(#writing-pull-requests) helpful."
msgstr ""

#: src/contributing.md:7
msgid ""
"If you want to become familiar with the codebase, see [Architecture.md]"
"(https://github.com/PyO3/pyo3/blob/main/Architecture.md)."
msgstr ""

#: src/contributing.md:10
msgid "Getting started contributing"
msgstr ""

#: src/contributing.md:12
msgid ""
"Please join in with any part of PyO3 which interests you. We use GitHub "
"issues to record all bugs and ideas. Feel free to request an issue to be "
"assigned to you if you want to work on it."
msgstr ""

#: src/contributing.md:14
msgid ""
"You can browse the API of the non-public parts of PyO3 [here](https://pyo3."
"netlify.app/internal/doc/pyo3/index.html)."
msgstr ""

#: src/contributing.md:16
msgid ""
"The following sections also contain specific ideas on where to start "
"contributing to PyO3."
msgstr ""

#: src/contributing.md:18
msgid "Setting up a development environment"
msgstr ""

#: src/contributing.md:20
msgid ""
"To work and develop PyO3, you need Python & Rust installed on your system."
msgstr ""

#: src/contributing.md:21
msgid ""
"We encourage the use of [rustup](https://rustup.rs/) to be able to select "
"and choose specific toolchains based on the project."
msgstr ""

#: src/contributing.md:22
msgid ""
"[Pyenv](https://github.com/pyenv/pyenv) is also highly recommended for being "
"able to choose a specific Python version."
msgstr ""

#: src/contributing.md:23
msgid ""
"[virtualenv](https://virtualenv.pypa.io/en/latest/) can also be used with or "
"without Pyenv to use specific installed Python versions."
msgstr ""

#: src/contributing.md:24
msgid ""
"[`nox`](https://github.com/theacodes/nox) is used to automate many of our CI "
"tasks."
msgstr ""

#: src/contributing.md:26
msgid "Help users identify bugs"
msgstr ""

#: src/contributing.md:28
msgid ""
"The [PyO3 Discord server](https://discord.gg/33kcChzH7f) is very active with "
"users who are new to PyO3, and often completely new to Rust. Helping them "
"debug is a great way to get experience with the PyO3 codebase."
msgstr ""

#: src/contributing.md:30
msgid ""
"Helping others often reveals bugs, documentation weaknesses, and missing "
"APIs. It's a good idea to open GitHub issues for these immediately so the "
"resolution can be designed and implemented!"
msgstr ""

#: src/contributing.md:32
msgid "Implement issues ready for development"
msgstr ""

#: src/contributing.md:34
msgid ""
"Issues where the solution is clear and work is not in progress use the "
"[needs-implementer](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Aneeds-implementer) label."
msgstr ""

#: src/contributing.md:36
msgid ""
"Don't be afraid if the solution is not clear to you! The core PyO3 "
"contributors will be happy to mentor you through any questions you have to "
"help you write the solution."
msgstr ""

#: src/contributing.md:38
msgid "Help write great docs"
msgstr ""

#: src/contributing.md:40
msgid ""
"PyO3 has a user guide (using mdbook) as well as the usual Rust API docs. The "
"aim is for both of these to be detailed, easy to understand, and up-to-date. "
"Pull requests are always welcome to fix typos, change wording, add examples, "
"etc."
msgstr ""

#: src/contributing.md:42
msgid ""
"There are some specific areas of focus where help is currently needed for "
"the documentation:"
msgstr ""

#: src/contributing.md:44
msgid ""
"Issues requesting documentation improvements are tracked with the "
"[documentation](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Adocumentation) label."
msgstr ""

#: src/contributing.md:45
msgid ""
"Not all APIs had docs or examples when they were made. The goal is to have "
"documentation on all PyO3 APIs ([\\#306](https://github.com/PyO3/pyo3/"
"issues/306)). If you see an API lacking a doc, please write one and open a "
"PR!"
msgstr ""

#: src/contributing.md:47
msgid ""
"To build the docs (including all features), install [`nox`](https://github."
"com/theacodes/nox) and then run"
msgstr ""

#: src/contributing.md:53
msgid "Doctests"
msgstr ""

#: src/contributing.md:55
msgid ""
"We use lots of code blocks in our docs. Run `cargo test --doc` when making "
"changes to check that the doctests still work, or `cargo test` to run all "
"the tests including doctests. See https://doc.rust-lang.org/rustdoc/"
"documentation-tests.html for a guide on doctests."
msgstr ""

#: src/contributing.md:59
msgid "Building the guide"
msgstr ""

#: src/contributing.md:61
msgid "You can preview the user guide by building it locally with `mdbook`."
msgstr ""

#: src/contributing.md:63
msgid ""
"First, install [`mdbook`](https://rust-lang.github.io/mdBook/cli/index.html) "
"and [`nox`](https://github.com/theacodes/nox). Then, run"
msgstr ""

#: src/contributing.md:69
msgid ""
"To check all links in the guide are valid, also install [`lychee`](https://"
"github.com/lycheeverse/lychee) and use the `check-guide` session instead:"
msgstr ""

#: src/contributing.md:75
msgid "Help design the next PyO3"
msgstr ""

#: src/contributing.md:77
msgid ""
"Issues which don't yet have a clear solution use the [needs-design](https://"
"github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design) "
"label."
msgstr ""

#: src/contributing.md:79
msgid ""
"If any of these issues interest you, please join in with the conversation on "
"the issue! All opinions are valued, and if you're interested in going "
"further with e.g. draft PRs to experiment with API designs, even better!"
msgstr ""

#: src/contributing.md:81
msgid "Review pull requests"
msgstr ""

#: src/contributing.md:83
msgid ""
"Everybody is welcome to submit comments on open PRs. Please help ensure new "
"PyO3 APIs are safe, performant, tidy, and easy to use!"
msgstr ""

#: src/contributing.md:85
msgid "Writing pull requests"
msgstr ""

#: src/contributing.md:87
msgid "Here are a few things to note when you are writing PRs."
msgstr ""

#: src/contributing.md:89
msgid "Continuous Integration"
msgstr ""

#: src/contributing.md:91
msgid ""
"The PyO3 repo uses GitHub Actions. PRs are blocked from merging if CI is not "
"successful. Formatting, linting and tests are checked for all Rust and "
"Python code. In addition, all warnings in Rust code are disallowed (using "
"`RUSTFLAGS=\"-D warnings\"`)."
msgstr ""

#: src/contributing.md:93
msgid ""
"Tests run with all supported Python versions with the latest stable Rust "
"compiler, as well as for Python 3.9 with the minimum supported Rust version."
msgstr ""

#: src/contributing.md:95
msgid ""
"If you are adding a new feature, you should add it to the `full` feature in "
"our _Cargo.toml_\\* so that it is tested in CI."
msgstr ""

#: src/contributing.md:97
msgid ""
"You can run these tests yourself with `nox`. Use  `nox -l` to list the full "
"set of subcommands you can run."
msgstr ""

#: src/contributing.md:100
msgid "Linting Python code"
msgstr ""

#: src/contributing.md:101
msgid "`nox -s ruff`"
msgstr ""

#: src/contributing.md:103
msgid "Linting Rust code"
msgstr ""

#: src/contributing.md:104
msgid "`nox -s rustfmt`"
msgstr ""

#: src/contributing.md:106
msgid "Semver checks"
msgstr ""

#: src/contributing.md:107
msgid "`cargo semver-checks check-release`"
msgstr ""

#: src/contributing.md:109
msgid "Clippy"
msgstr ""

#: src/contributing.md:110
msgid "`nox -s clippy-all`"
msgstr ""

#: src/contributing.md:112
msgid "Tests"
msgstr ""

#: src/contributing.md:113
msgid "`cargo test --features full`"
msgstr ""

#: src/contributing.md:115
msgid "Check all conditional compilation"
msgstr ""

#: src/contributing.md:116
msgid "`nox -s check-feature-powerset`"
msgstr ""

#: src/contributing.md:118
msgid "UI Tests"
msgstr ""

#: src/contributing.md:120
msgid ""
"PyO3 uses [`trybuild`](https://github.com/dtolnay/trybuild) to develop UI "
"tests to capture error messages from the Rust compiler for some of the macro "
"functionality."
msgstr ""

#: src/contributing.md:122
msgid ""
"Because there are several feature combinations for these UI tests, when "
"updating them all (e.g. for a new Rust compiler version) it may be helpful "
"to use the `update-ui-tests` nox session:"
msgstr ""

#: src/contributing.md:128
msgid "Documenting changes"
msgstr ""

#: src/contributing.md:130
msgid ""
"We use [towncrier](https://towncrier.readthedocs.io/en/stable/index.html) to "
"generate a CHANGELOG for each release."
msgstr ""

#: src/contributing.md:132
msgid ""
"To include your changes in the release notes, you should create one (or "
"more) news items in the `newsfragments` directory. Valid news items should "
"be saved as `<PR>.<CATEGORY>.md` where `<PR>` is the pull request number and "
"`<CATEGORY>` is one of the following:"
msgstr ""

#: src/contributing.md:133
msgid ""
"`packaging` - for dependency changes and Python / Rust version compatibility "
"changes"
msgstr ""

#: src/contributing.md:134
msgid "`added` - for new features"
msgstr ""

#: src/contributing.md:135
msgid ""
"`changed` - for features which already existed but have been altered or "
"deprecated"
msgstr ""

#: src/contributing.md:136
msgid "`removed` - for features which have been removed"
msgstr ""

#: src/contributing.md:137
msgid "`fixed` - for \"changed\" features which were classed as a bugfix"
msgstr ""

#: src/contributing.md:139
msgid ""
"Docs-only PRs do not need news items; start your PR title with `docs:` to "
"skip the check."
msgstr ""

#: src/contributing.md:141
msgid "Style guide"
msgstr ""

#: src/contributing.md:143
msgid "Generic code"
msgstr ""

#: src/contributing.md:145
msgid ""
"PyO3 has a lot of generic APIs to increase usability. These can come at the "
"cost of generic code bloat. Where reasonable, try to implement a concrete "
"sub-portion of generic functions. There are two forms of this:"
msgstr ""

#: src/contributing.md:147
msgid ""
"If the concrete sub-portion doesn't benefit from re-use by other functions, "
"name it `inner` and keep it as a local to the function."
msgstr ""

#: src/contributing.md:148
msgid ""
"If the concrete sub-portion is re-used by other functions, preferably name "
"it `_foo` and place it directly below `foo` in the source code (where `foo` "
"is the original generic function)."
msgstr ""

#: src/contributing.md:150
msgid "FFI calls"
msgstr ""

#: src/contributing.md:152
msgid ""
"PyO3 makes a lot of FFI calls to Python's C API using raw pointers. Where "
"possible try to avoid using pointers-to-temporaries in expressions:"
msgstr ""

#: src/contributing.md:155
msgid "// dangerous\n"
msgstr ""

#: src/contributing.md:157
msgid "// because the following refactoring is a use-after-free error:\n"
msgstr ""

#: src/contributing.md:163
msgid ""
"Instead, prefer to bind the safe owned `PyObject` wrapper before passing to "
"ffi functions:"
msgstr ""

#: src/contributing.md:167
msgid "// name will automatically be freed when it falls out of scope\n"
msgstr ""

#: src/contributing.md:171
msgid "Python and Rust version support policy"
msgstr ""

#: src/contributing.md:173
msgid ""
"PyO3 aims to keep sufficient compatibility to make packaging Python "
"extensions built with PyO3 feasible on most common package managers."
msgstr ""

#: src/contributing.md:175
msgid ""
"To keep package maintainers' lives simpler, PyO3 will commit, wherever "
"possible, to only adjust minimum supported Rust and Python versions at the "
"same time. This bump will only come in an `0.x` release, roughly once per "
"year, after the oldest supported Python version reaches its end-of-life. "
"(Check https://endoflife.date/python for a clear timetable on these.)"
msgstr ""

#: src/contributing.md:177
msgid ""
"Below are guidelines on what compatibility all PRs are expected to deliver "
"for each language."
msgstr ""

#: src/contributing.md:179
msgid "Python"
msgstr ""

#: src/contributing.md:181
msgid ""
"PyO3 supports all officially supported Python versions, as well as the "
"latest PyPy3 release. All of these versions are tested in CI."
msgstr ""

#: src/contributing.md:183
msgid "Rust"
msgstr ""

#: src/contributing.md:185
msgid ""
"PyO3 aims to make use of up-to-date Rust language features to keep the "
"implementation as efficient as possible."
msgstr ""

#: src/contributing.md:187
msgid ""
"The minimum Rust version supported will be decided when the release which "
"bumps Python and Rust versions is made. At the time, the minimum Rust "
"version will be set no higher than the lowest Rust version shipped in the "
"current Debian, RHEL and Alpine Linux distributions."
msgstr ""

#: src/contributing.md:189
msgid ""
"CI tests both the most recent stable Rust version and the minimum supported "
"Rust version. Because of Rust's stability guarantees this is sufficient to "
"confirm support for all Rust versions in between."
msgstr ""

#: src/contributing.md:191
msgid "Benchmarking"
msgstr ""

#: src/contributing.md:193
msgid ""
"PyO3 has two sets of benchmarks for evaluating some aspects of its "
"performance. The benchmark suite is currently very small - please open PRs "
"with new benchmarks if you're interested in helping to expand it!"
msgstr ""

#: src/contributing.md:195
msgid ""
"First, there are Rust-based benchmarks located in the `pyo3-benches` "
"subdirectory. You can run these benchmarks with:"
msgstr ""

#: src/contributing.md:199
msgid ""
"Second, there is a Python-based benchmark contained in the `pytests` "
"subdirectory. You can read more about it [here](https://github.com/PyO3/pyo3/"
"tree/main/pytests)."
msgstr ""

#: src/contributing.md:201
msgid "Code coverage"
msgstr ""

#: src/contributing.md:203
msgid ""
"You can view what code is and isn't covered by PyO3's tests. We aim to have "
"100% coverage - please check coverage and add tests if you notice a lack of "
"coverage!"
msgstr ""

#: src/contributing.md:205
msgid ""
"First, ensure the llvm-cov cargo plugin is installed. You may need to run "
"the plugin through cargo once before using it with `nox`."
msgstr ""

#: src/contributing.md:210
msgid "Then, generate an `lcov.info` file with"
msgstr ""

#: src/contributing.md:214
msgid ""
"You can install an IDE plugin to view the coverage. For example, if you use "
"VSCode:"
msgstr ""

#: src/contributing.md:215
msgid ""
"Add the [coverage-gutters](https://marketplace.visualstudio.com/items?"
"itemName=ryanluker.vscode-coverage-gutters) plugin."
msgstr ""

#: src/contributing.md:216
msgid "Add these settings to VSCode's `settings.json`:"
msgstr ""

#: src/contributing.md:219
msgid "\"coverage-gutters.coverageFileNames\""
msgstr ""

#: src/contributing.md:220
msgid "\"lcov.info\""
msgstr ""

#: src/contributing.md:221
msgid "\"cov.xml\""
msgstr ""

#: src/contributing.md:222
msgid "\"coverage.xml\""
msgstr ""

#: src/contributing.md:224
msgid "\"coverage-gutters.showLineCoverage\""
msgstr ""

#: src/contributing.md:227
msgid ""
"You should now be able to see green highlights for code that is tested, and "
"red highlights for code that is not tested."
msgstr ""

#: src/contributing.md:229
msgid "Sponsor this project"
msgstr ""

#: src/contributing.md:231
msgid ""
"At the moment there is no official organisation that accepts sponsorship on "
"PyO3's behalf. If you're seeking to provide significant funding to the PyO3 "
"ecosystem, please reach out to us on [GitHub](https://github.com/PyO3/pyo3/"
"issues/new) or [Discord](https://discord.gg/33kcChzH7f) and we can discuss."
msgstr ""

#: src/contributing.md:233
msgid ""
"In the meanwhile, some of our maintainers have personal GitHub sponsorship "
"pages and would be grateful for your support:"
msgstr ""

#: src/contributing.md:235
msgid "[davidhewitt](https://github.com/sponsors/davidhewitt)"
msgstr ""

#: src/contributing.md:236
msgid "[messense](https://github.com/sponsors/messense)"
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/debugging.md:3
msgid "Macros"
msgstr ""

#: src/debugging.md:5
msgid ""
"PyO3's attributes (`#[pyclass]`, `#[pymodule]`, etc.) are [procedural macros]"
"(https://doc.rust-lang.org/reference/procedural-macros.html), which means "
"that they rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding `-Z trace-macros`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"Note that those commands require using the nightly build of rust and may "
"occasionally have bugs. See [cargo expand](https://github.com/dtolnay/cargo-"
"expand) for a more elaborate and stable version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of Python, otherwise Valgrind won't "
"produce usable results. In Ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on Linux, use `ldd` with the name of your binary and check that you're "
"linking e.g. `libpython3.7d.so.1.0` instead of `libpython3.7.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for CPython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run Valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace. You can set `RUST_BACKTRACE=1` as an environment variable to get "
"the stack trace on a `panic!`. Alternatively you can use a debugger such as "
"`gdb` to explore the issue. Rust provides a wrapper, `rust-gdb`, which has "
"pretty-printers for inspecting Rust variables. Since PyO3 uses `cdylib` for "
"Python shared objects, it does not receive the pretty-print debug hooks in "
"`rust-gdb` ([rust-lang/rust#96365](https://github.com/rust-lang/rust/"
"issues/96365)). The mentioned issue contains a workaround for enabling "
"pretty-printers in this case."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `rust-gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid ""
"Set a breakpoint (`b`) on `rust_panic` if you are investigating a `panic!`"
msgstr ""

#: src/debugging.md:40
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:41
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/debugging.md:43
msgid ""
"Often it is helpful to run a small piece of Python code to exercise a "
"section of Rust."
msgstr ""

#: src/debugging.md:45
msgid ""
"```console\n"
"rust-gdb --args python -c \"import my_package; my_package.sum_to_string(1, "
"2)\"\n"
"```"
msgstr ""

#: src/faq.md:1
msgid "Frequently Asked Questions and troubleshooting"
msgstr ""

#: src/faq.md:3
msgid ""
"Sorry that you're having trouble using PyO3. If you can't find the answer to "
"your problem in the list below, you can also reach out for help on [GitHub "
"Discussions](https://github.com/PyO3/pyo3/discussions) and on [Discord]"
"(https://discord.gg/33kcChzH7f)."
msgstr ""

#: src/faq.md:5
msgid "I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!"
msgstr ""

#: src/faq.md:7
msgid ""
"`lazy_static` and `once_cell::sync` both use locks to ensure that "
"initialization is performed only by a single thread. Because the Python GIL "
"is an additional lock this can lead to deadlocks in the following way:"
msgstr ""

#: src/faq.md:9
msgid ""
"A thread (thread A) which has acquired the Python GIL starts initialization "
"of a `lazy_static` value."
msgstr ""

#: src/faq.md:10
msgid ""
"The initialization code calls some Python API which temporarily releases the "
"GIL e.g. `Python::import`."
msgstr ""

#: src/faq.md:11
msgid ""
"Another thread (thread B) acquires the Python GIL and attempts to access the "
"same `lazy_static` value."
msgstr ""

#: src/faq.md:12
msgid ""
"Thread B is blocked, because it waits for `lazy_static`'s initialization to "
"lock to release."
msgstr ""

#: src/faq.md:13
msgid ""
"Thread A is blocked, because it waits to re-acquire the GIL which thread B "
"still holds."
msgstr ""

#: src/faq.md:14
msgid "Deadlock."
msgstr ""

#: src/faq.md:16
msgid ""
"PyO3 provides a struct [`GILOnceCell`](https://pyo3.rs/main/doc/pyo3/sync/"
"struct.GILOnceCell.html) which works equivalently to `OnceCell` but relies "
"solely on the Python GIL for thread safety. This means it can be used in "
"place of `lazy_static` or `once_cell` where you are experiencing the "
"deadlock described above. See the documentation for [`GILOnceCell`](https://"
"pyo3.rs/main/doc/pyo3/sync/struct.GILOnceCell.html) for an example how to "
"use it."
msgstr ""

#: src/faq.md:20
msgid ""
"I can't run `cargo test`; or I can't build in a Cargo workspace: I'm having "
"linker issues like \"Symbol not found\" or \"Undefined reference to "
"\\_PyExc_SystemError\"!"
msgstr ""

#: src/faq.md:22
msgid ""
"Currently, [\\#340](https://github.com/PyO3/pyo3/issues/340) causes `cargo "
"test` to fail with linking errors when the `extension-module` feature is "
"activated. Linking errors can also happen when building in a cargo workspace "
"where a different crate also uses PyO3 (see [\\#2521](https://github.com/"
"PyO3/pyo3/issues/2521)). For now, there are three ways we can work around "
"these issues."
msgstr ""

#: src/faq.md:24
msgid ""
"Make the `extension-module` feature optional. Build with `maturin develop --"
"features \"extension-module\"`"
msgstr ""

#: src/faq.md:26
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:34
msgid ""
"Make the `extension-module` feature optional and default. Run tests with "
"`cargo test --no-default-features`:"
msgstr ""

#: src/faq.md:36
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:45
msgid ""
"If you are using a [`pyproject.toml`](https://maturin.rs/metadata.html) file "
"to control maturin settings, add the following section:"
msgstr ""

#: src/faq.md:47
msgid ""
"```toml\n"
"[tool.maturin]\n"
"features = [\"pyo3/extension-module\"]\n"
"# Or for maturin 0.12:\n"
"# cargo-extra-args = [\"--features\", \"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:54
msgid ""
"I can't run `cargo test`: my crate cannot be found for tests in `tests/` "
"directory!"
msgstr ""

#: src/faq.md:56
msgid ""
"The Rust book suggests to [put integration tests inside a `tests/` directory]"
"(https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-"
"tests)."
msgstr ""

#: src/faq.md:58
msgid ""
"For a PyO3 `extension-module` project where the `crate-type` is set to "
"`\"cdylib\"` in your `Cargo.toml`, the compiler won't be able to find your "
"crate and will display errors such as `E0432` or `E0463`:"
msgstr ""

#: src/faq.md:69
msgid ""
"The best solution is to make your crate types include both `rlib` and "
"`cdylib`:"
msgstr ""

#: src/faq.md:71
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[lib]\n"
"crate-type = [\"cdylib\", \"rlib\"]\n"
"```"
msgstr ""

#: src/faq.md:77
msgid "Ctrl-C doesn't do anything while my Rust code is executing!"
msgstr ""

#: src/faq.md:79
msgid ""
"This is because Ctrl-C raises a SIGINT signal, which is handled by the "
"calling Python process by simply setting a flag to action upon later. This "
"flag isn't checked while Rust code called from Python is executing, only "
"once control returns to the Python interpreter."
msgstr ""

#: src/faq.md:81
msgid ""
"You can give the Python interpreter a chance to process the signal properly "
"by calling `Python::check_signals`. It's good practice to call this function "
"regularly if you have a long-running Rust function so that your users can "
"cancel it."
msgstr ""

#: src/faq.md:83
msgid "`#[pyo3(get)]` clones my field!"
msgstr ""

#: src/faq.md:85
msgid "You may have a nested struct similar to this:"
msgstr ""

#: src/faq.md:91 src/faq.md:130
msgid "/* fields omitted */"
msgstr ""

#: src/faq.md:108
msgid ""
"When Python code accesses `Outer`'s field, PyO3 will return a new object on "
"every access (note that their addresses are different):"
msgstr ""

#: src/faq.md:116 src/faq.md:159 src/faq.md:160
msgid "\"a: "
msgstr ""

#: src/faq.md:116 src/faq.md:159 src/faq.md:160
msgid "\\nb: "
msgstr ""

#: src/faq.md:116 src/faq.md:159 src/faq.md:160
msgid "\""
msgstr ""

#: src/faq.md:124
msgid ""
"This can be especially confusing if the field is mutable, as getting the "
"field and then mutating it won't persist - you'll just get a fresh clone of "
"the original on the next access. Unfortunately Python and Rust don't agree "
"about ownership - if PyO3 gave out references to (possibly) temporary Rust "
"objects to Python code, Python code could then keep that reference alive "
"indefinitely. Therefore returning Rust objects requires cloning."
msgstr ""

#: src/faq.md:126
msgid ""
"If you don't want that cloning to happen, a workaround is to allocate the "
"field on the Python heap and store a reference to that, by using [`Py<...>`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html):"
msgstr ""

#: src/faq.md:152
msgid "This time `a` and `b` _are_ the same object:"
msgstr ""

#: src/faq.md:167
msgid ""
"The downside to this approach is that any Rust code working on the `Outer` "
"struct now has to acquire the GIL to do anything with its field."
msgstr ""

#: src/faq.md:169
msgid ""
"I want to use the `pyo3` crate re-exported from dependency but the proc-"
"macros fail!"
msgstr ""

#: src/faq.md:171
msgid ""
"All PyO3 proc-macros (`#[pyclass]`, `#[pyfunction]`, "
"`#[derive(FromPyObject)]` and so on) expect the `pyo3` crate to be available "
"under that name in your crate root, which is the normal situation when "
"`pyo3` is a direct dependency of your crate."
msgstr ""

#: src/faq.md:176
msgid ""
"However, when the dependency is renamed, or your crate only indirectly "
"depends on `pyo3`, you need to let the macro code know where to find the "
"crate.  This is done with the `crate` attribute:"
msgstr ""

#: src/faq.md:186
msgid "\"reexported::pyo3\""
msgstr ""

#: src/faq.md:190
msgid ""
"I'm trying to call Python from Rust but I get `STATUS_DLL_NOT_FOUND` or "
"`STATUS_ENTRYPOINT_NOT_FOUND`!"
msgstr ""

#: src/faq.md:192
msgid ""
"This happens on Windows when linking to the python DLL fails or the wrong "
"one is linked. The Python DLL on Windows will usually be called something "
"like:"
msgstr ""

#: src/faq.md:193
msgid "`python3X.dll` for Python 3.X, e.g. `python310.dll` for Python 3.10"
msgstr ""

#: src/faq.md:194
msgid "`python3.dll` when using PyO3's `abi3` feature"
msgstr ""

#: src/faq.md:196
msgid ""
"The DLL needs to be locatable using the [Windows DLL search order](https://"
"learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-"
"order#standard-search-order-for-unpackaged-apps). Some ways to achieve this "
"are:"
msgstr ""

#: src/faq.md:197
msgid "Put the Python DLL in the same folder as your build artifacts"
msgstr ""

#: src/faq.md:198
msgid ""
"Add the directory containing the Python DLL to your `PATH` environment "
"variable, for example `C:"
"\\Users\\<You>\\AppData\\Local\\Programs\\Python\\Python310`"
msgstr ""

#: src/faq.md:199
msgid ""
"If this happens when you are _distributing_ your program, consider using "
"[PyOxidizer](https://github.com/indygreg/PyOxidizer) to package it with your "
"binary."
msgstr ""

#: src/faq.md:201
msgid ""
"If the wrong DLL is linked it is possible that this happened because another "
"program added itself and its own Python DLLs to `PATH`. Rearrange your "
"`PATH` variables to give the correct DLL priority."
msgstr ""

#: src/faq.md:203
msgid ""
"**Note**: Changes to `PATH` (or any other environment variable) are not "
"visible to existing shells. Restart it for changes to take effect."
msgstr ""

#: src/faq.md:205
msgid ""
"For advanced troubleshooting, [Dependency Walker](https://www."
"dependencywalker.com/) can be used to diagnose linking errors."
msgstr ""

#: src/features.md:1
msgid "Features reference"
msgstr ""

#: src/features.md:3
msgid ""
"PyO3 provides a number of Cargo features to customize functionality. This "
"chapter of the guide provides detail on each of them."
msgstr ""

#: src/features.md:5
msgid "By default, only the `macros` feature is enabled."
msgstr ""

#: src/features.md:7
msgid "Features for extension module authors"
msgstr ""

#: src/features.md:9
msgid "`extension-module`"
msgstr ""

#: src/features.md:11
msgid ""
"This feature is required when building a Python extension module using PyO3."
msgstr ""

#: src/features.md:13
msgid ""
"It tells PyO3's build script to skip linking against `libpython.so` on Unix "
"platforms, where this must not be done."
msgstr ""

#: src/features.md:15
msgid ""
"See the [building and distribution](building-and-distribution.md#the-"
"extension-module-feature) section for further detail."
msgstr ""

#: src/features.md:17
msgid "`abi3`"
msgstr ""

#: src/features.md:19
msgid ""
"This feature is used when building Python extension modules to create wheels "
"which are compatible with multiple Python versions."
msgstr ""

#: src/features.md:21
msgid ""
"It restricts PyO3's API to a subset of the full Python API which is "
"guaranteed by [PEP 384](https://www.python.org/dev/peps/pep-0384/) to be "
"forwards-compatible with future Python versions."
msgstr ""

#: src/features.md:23
msgid ""
"See the [building and distribution](building-and-distribution."
"md#py_limited_apiabi3) section for further detail."
msgstr ""

#: src/features.md:25
msgid "The `abi3-pyXY` features"
msgstr ""

#: src/features.md:27
msgid "(`abi3-py37`, `abi3-py38`, `abi3-py39`, `abi3-py310` and `abi3-py311`)"
msgstr ""

#: src/features.md:29
msgid ""
"These features are extensions of the `abi3` feature to specify the exact "
"minimum Python version which the multiple-version-wheel will support."
msgstr ""

#: src/features.md:31
msgid ""
"See the [building and distribution](building-and-distribution.md#minimum-"
"python-version-for-abi3) section for further detail."
msgstr ""

#: src/features.md:33
msgid "`generate-import-lib`"
msgstr ""

#: src/features.md:35
msgid ""
"This experimental feature is used to generate import libraries for Python "
"DLL for MinGW-w64 and MSVC (cross-)compile targets."
msgstr ""

#: src/features.md:38
msgid ""
"Enabling it allows to (cross-)compile extension modules to any Windows "
"targets without having to install the Windows Python distribution files for "
"the target."
msgstr ""

#: src/features.md:41
msgid ""
"See the [building and distribution](building-and-distribution.md#building-"
"abi3-extensions-without-a-python-interpreter) section for further detail."
msgstr ""

#: src/features.md:44
msgid "Features for embedding Python in Rust"
msgstr ""

#: src/features.md:46
msgid "`auto-initialize`"
msgstr ""

#: src/features.md:48
msgid ""
"This feature changes [`Python::with_gil`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.with_gil) to automatically initialize a "
"Python interpreter (by calling [`prepare_freethreaded_python`](https://pyo3."
"rs/main/doc/pyo3/fn.prepare_freethreaded_python.html)) if needed."
msgstr ""

#: src/features.md:50
msgid ""
"If you do not enable this feature, you should call `pyo3::"
"prepare_freethreaded_python()` before attempting to call any other Python "
"APIs."
msgstr ""

#: src/features.md:52
msgid "Advanced Features"
msgstr ""

#: src/features.md:54
msgid "`experimental-async`"
msgstr ""

#: src/features.md:56
msgid ""
"This feature adds support for `async fn` in `#[pyfunction]` and "
"`#[pymethods]`."
msgstr ""

#: src/features.md:58
msgid ""
"The feature has some unfinished refinements and performance improvements. To "
"help finish this off, see [issue #1632](https://github.com/PyO3/pyo3/"
"issues/1632) and its associated draft PRs."
msgstr ""

#: src/features.md:60
msgid "`experimental-inspect`"
msgstr ""

#: src/features.md:62
msgid ""
"This feature adds the `pyo3::inspect` module, as well as `IntoPy::"
"type_output` and `FromPyObject::type_input` APIs to produce Python type "
"\"annotations\" for Rust types."
msgstr ""

#: src/features.md:64
msgid ""
"This is a first step towards adding first-class support for generating type "
"annotations automatically in PyO3, however work is needed to finish this "
"off. All feedback and offers of help welcome on [issue #2454](https://github."
"com/PyO3/pyo3/issues/2454)."
msgstr ""

#: src/features.md:66
msgid "`gil-refs`"
msgstr ""

#: src/features.md:68
msgid ""
"This feature is a backwards-compatibility feature to allow continued use of "
"the \"GIL Refs\" APIs deprecated in PyO3 0.21. These APIs have performance "
"drawbacks and soundness edge cases which the newer `Bound<T>` smart pointer "
"and accompanying APIs resolve."
msgstr ""

#: src/features.md:70
msgid ""
"This feature and the APIs it enables is expected to be removed in a future "
"PyO3 version."
msgstr ""

#: src/features.md:72
msgid "`py-clone`"
msgstr ""

#: src/features.md:74
msgid ""
"This feature was introduced to ease migration. It was found that delayed "
"reference counts cannot be made sound and hence `Clon`ing an instance of "
"`Py<T>` must panic without the GIL being held. To avoid migrations "
"introducing new panics without warning, the `Clone` implementation itself is "
"now gated behind this feature."
msgstr ""

#: src/features.md:76
msgid "`pyo3_disable_reference_pool`"
msgstr ""

#: src/features.md:78
msgid ""
"This is a performance-oriented conditional compilation flag, e.g. [set via "
"`$RUSTFLAGS`](https://doc.rust-lang.org/reference/conditional-compilation."
"html#set-configuration-options), which disabled the global reference pool "
"and the assocaited overhead for the crossing the Python-Rust boundary. "
"However, if enabled, `Drop`ping an instance of `Py<T>` without the GIL being "
"held will abort the process."
msgstr ""

#: src/features.md:80
msgid "`macros`"
msgstr ""

#: src/features.md:82
msgid ""
"This feature enables a dependency on the `pyo3-macros` crate, which provides "
"the procedural macros portion of PyO3's API:"
msgstr ""

#: src/features.md:84
msgid "`#[pymodule]`"
msgstr ""

#: src/features.md:85
msgid "`#[pyfunction]`"
msgstr ""

#: src/features.md:86
msgid "`#[pyclass]`"
msgstr ""

#: src/features.md:87
msgid "`#[pymethods]`"
msgstr ""

#: src/features.md:88
msgid "`#[derive(FromPyObject)]`"
msgstr ""

#: src/features.md:90
msgid "It also provides the `py_run!` macro."
msgstr ""

#: src/features.md:92
msgid ""
"These macros require a number of dependencies which may not be needed by "
"users who just need PyO3 for Python FFI. Disabling this feature enables "
"faster builds for those users, as these dependencies will not be built if "
"this feature is disabled."
msgstr ""

#: src/features.md:94
msgid ""
"This feature is enabled by default. To disable it, set `default-features = "
"false` for the `pyo3` entry in your Cargo.toml."
msgstr ""

#: src/features.md:96
msgid "`multiple-pymethods`"
msgstr ""

#: src/features.md:98
msgid ""
"This feature enables each `#[pyclass]` to have more than one `#[pymethods]` "
"block."
msgstr ""

#: src/features.md:100
msgid ""
"Most users should only need a single `#[pymethods]` per `#[pyclass]`. In "
"addition, not all platforms (e.g. Wasm) are supported by `inventory`, which "
"is used in the implementation of the feature. For this reason this feature "
"is not enabled by default, meaning fewer dependencies and faster compilation "
"for the majority of users."
msgstr ""

#: src/features.md:102
msgid ""
"See [the `#[pyclass]` implementation details](class.md#implementation-"
"details) for more information."
msgstr ""

#: src/features.md:104
msgid "`nightly`"
msgstr ""

#: src/features.md:106
msgid ""
"The `nightly` feature needs the nightly Rust compiler. This allows PyO3 to "
"use the `auto_traits` and `negative_impls` features to fix the `Python::"
"allow_threads` function."
msgstr ""

#: src/features.md:108
msgid "`resolve-config`"
msgstr ""

#: src/features.md:110
msgid ""
"The `resolve-config` feature of the `pyo3-build-config` crate controls "
"whether that crate's build script automatically resolves a Python "
"interpreter / build configuration. This feature is primarily useful when "
"building PyO3 itself. By default this feature is not enabled, meaning you "
"can freely use `pyo3-build-config` as a standalone library to read or write "
"PyO3 build configuration files or resolve metadata about a Python "
"interpreter."
msgstr ""

#: src/features.md:114
msgid "Optional Dependencies"
msgstr ""

#: src/features.md:116
msgid ""
"These features enable conversions between Python types and types from other "
"Rust crates, enabling easy access to the rest of the Rust ecosystem."
msgstr ""

#: src/features.md:118
msgid "`anyhow`"
msgstr ""

#: src/features.md:120
msgid ""
"Adds a dependency on [anyhow](https://docs.rs/anyhow). Enables a conversion "
"from [anyhow](https://docs.rs/anyhow)‚Äôs [`Error`](https://docs.rs/anyhow/"
"latest/anyhow/struct.Error.html) type to [`PyErr`](https://pyo3.rs/main/doc/"
"pyo3/struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:122
msgid "`chrono`"
msgstr ""

#: src/features.md:124
msgid ""
"Adds a dependency on [chrono](https://docs.rs/chrono). Enables a conversion "
"from [chrono](https://docs.rs/chrono)'s types to python:"
msgstr ""

#: src/features.md:125
msgid ""
"[TimeDelta](https://docs.rs/chrono/latest/chrono/struct.TimeDelta.html) -> "
"[`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:126
msgid ""
"[FixedOffset](https://docs.rs/chrono/latest/chrono/offset/struct.FixedOffset."
"html) -> [`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:127
msgid ""
"[Utc](https://docs.rs/chrono/latest/chrono/offset/struct.Utc.html) -> "
"[`PyTzInfo`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:128
msgid ""
"[NaiveDate](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDate."
"html) -> [`PyDate`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:129
msgid ""
"[NaiveTime](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveTime."
"html) -> [`PyTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTime.html)"
msgstr ""

#: src/features.md:130
msgid ""
"[DateTime](https://docs.rs/chrono/latest/chrono/struct.DateTime.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:132
msgid "`chrono-tz`"
msgstr ""

#: src/features.md:134
msgid ""
"Adds a dependency on [chrono-tz](https://docs.rs/chrono-tz). Enables "
"conversion from and to [`Tz`](https://docs.rs/chrono-tz/latest/chrono_tz/"
"enum.Tz.html). It requires at least Python 3.9."
msgstr ""

#: src/features.md:138
msgid "`either`"
msgstr ""

#: src/features.md:140
msgid ""
"Adds a dependency on [either](https://docs.rs/either). Enables a conversions "
"into [either](https://docs.rs/either)‚Äôs [`Either`](https://docs.rs/either/"
"latest/either/enum.Either.html) type."
msgstr ""

#: src/features.md:142
msgid "`eyre`"
msgstr ""

#: src/features.md:144
msgid ""
"Adds a dependency on [eyre](https://docs.rs/eyre). Enables a conversion from "
"[eyre](https://docs.rs/eyre)‚Äôs [`Report`](https://docs.rs/eyre/latest/eyre/"
"struct.Report.html) type to [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct."
"PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:146
msgid "`hashbrown`"
msgstr ""

#: src/features.md:148
msgid ""
"Adds a dependency on [hashbrown](https://docs.rs/hashbrown) and enables "
"conversions into its [`HashMap`](https://docs.rs/hashbrown/latest/hashbrown/"
"struct.HashMap.html) and [`HashSet`](https://docs.rs/hashbrown/latest/"
"hashbrown/struct.HashSet.html) types."
msgstr ""

#: src/features.md:150
msgid "`indexmap`"
msgstr ""

#: src/features.md:152
msgid ""
"Adds a dependency on [indexmap](https://docs.rs/indexmap) and enables "
"conversions into its [`IndexMap`](https://docs.rs/indexmap/latest/indexmap/"
"map/struct.IndexMap.html) type."
msgstr ""

#: src/features.md:154
msgid "`num-bigint`"
msgstr ""

#: src/features.md:156
msgid ""
"Adds a dependency on [num-bigint](https://docs.rs/num-bigint) and enables "
"conversions into its [`BigInt`](https://docs.rs/num-bigint/latest/num_bigint/"
"struct.BigInt.html) and [`BigUint`](https://docs.rs/num-bigint/latest/"
"num_bigint/struct.BigUint.html) types."
msgstr ""

#: src/features.md:158
msgid "`num-complex`"
msgstr ""

#: src/features.md:160
msgid ""
"Adds a dependency on [num-complex](https://docs.rs/num-complex) and enables "
"conversions into its [`Complex`](https://docs.rs/num-complex/latest/"
"num_complex/struct.Complex.html) type."
msgstr ""

#: src/features.md:162
msgid "`num-rational`"
msgstr ""

#: src/features.md:164
msgid ""
"Adds a dependency on [num-rational](https://docs.rs/num-rational) and "
"enables conversions into its [`Ratio`](https://docs.rs/num-rational/latest/"
"num_rational/struct.Ratio.html) type."
msgstr ""

#: src/features.md:166
msgid "`rust_decimal`"
msgstr ""

#: src/features.md:168
msgid ""
"Adds a dependency on [rust_decimal](https://docs.rs/rust_decimal) and "
"enables conversions into its [`Decimal`](https://docs.rs/rust_decimal/latest/"
"rust_decimal/struct.Decimal.html) type."
msgstr ""

#: src/features.md:170
msgid "`serde`"
msgstr ""

#: src/features.md:172
msgid ""
"Enables (de)serialization of `Py<T>` objects via [serde](https://serde.rs/). "
"This allows to use [`#[derive(Serialize, Deserialize)`](https://serde.rs/"
"derive.html) on structs that hold references to `#[pyclass]` instances"
msgstr ""

#: src/features.md:176
msgid "\"serde\""
msgstr ""

#: src/features.md:197
msgid "`smallvec`"
msgstr ""

#: src/features.md:199
msgid ""
"Adds a dependency on [smallvec](https://docs.rs/smallvec) and enables "
"conversions into its [`SmallVec`](https://docs.rs/smallvec/latest/smallvec/"
"struct.SmallVec.html) type."
msgstr ""

#: src/getting-started.md:1
msgid "Installation"
msgstr ""

#: src/getting-started.md:3
msgid ""
"To get started using PyO3 you will need three things: a Rust toolchain, a "
"Python environment, and a way to build. We'll cover each of these below."
msgstr ""

#: src/getting-started.md:5
msgid ""
"If you'd like to chat to the PyO3 maintainers and other PyO3 users, consider "
"joining the [PyO3 Discord server](https://discord.gg/33kcChzH7f). We're keen "
"to hear about your experience getting started, so we can make PyO3 as "
"accessible as possible for everyone!"
msgstr ""

#: src/getting-started.md:9
msgid ""
"First, make sure you have Rust installed on your system. If you haven't "
"already done so, try following the instructions [here](https://www.rust-lang."
"org/tools/install). PyO3 runs on both the `stable` and `nightly` versions so "
"you can choose whichever one fits you best. The minimum required Rust "
"version is 1.63."
msgstr ""

#: src/getting-started.md:11
msgid ""
"If you can run `rustc --version` and the version is new enough you're good "
"to go!"
msgstr ""

#: src/getting-started.md:15
msgid ""
"To use PyO3, you need at least Python 3.7. While you can simply use the "
"default Python interpreter on your system, it is recommended to use a "
"virtual environment."
msgstr ""

#: src/getting-started.md:17
msgid "Virtualenvs"
msgstr ""

#: src/getting-started.md:19
msgid ""
"While you can use any virtualenv manager you like, we recommend the use of "
"`pyenv` in particular if you want to develop or test for multiple different "
"Python versions, so that is what the examples in this book will use. The "
"installation instructions for `pyenv` can be found [here](https://github.com/"
"pyenv/pyenv#getting-pyenv). (Note: To get the `pyenv activate` and `pyenv "
"virtualenv` commands, you will also need to install the [`pyenv-virtualenv`]"
"(https://github.com/pyenv/pyenv-virtualenv) plugin. The [pyenv installer]"
"(https://github.com/pyenv/pyenv-installer#installation--update--"
"uninstallation) will install both together.)"
msgstr ""

#: src/getting-started.md:21
msgid ""
"It can be useful to keep the sources used when installing using `pyenv` so "
"that future debugging can see the original source files. This can be done by "
"passing the `--keep` flag as part of the `pyenv install` command."
msgstr ""

#: src/getting-started.md:29
msgid "Building"
msgstr ""

#: src/getting-started.md:31
msgid ""
"There are a number of build and Python package management systems such as "
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) or [manually](./"
"building-and-distribution.md#manual-builds). We recommend the use of "
"`maturin`, which you can install [here](https://maturin.rs/installation."
"html). It is developed to work with PyO3 and provides the most \"batteries "
"included\" experience, especially if you are aiming to publish to PyPI. "
"`maturin` is just a Python package, so you can add it in the same way you "
"already install Python packages."
msgstr ""

#: src/getting-started.md:33
msgid "System Python:"
msgstr ""

#: src/getting-started.md:38
msgid "pipx:"
msgstr ""

#: src/getting-started.md:43
msgid "pyenv:"
msgstr ""

#: src/getting-started.md:49
msgid "poetry:"
msgstr ""

#: src/getting-started.md:54
msgid ""
"After installation, you can run `maturin --version` to check that you have "
"correctly installed it."
msgstr ""

#: src/getting-started.md:56
msgid "Starting a new project"
msgstr ""

#: src/getting-started.md:58
msgid ""
"First you should create the folder and virtual environment that are going to "
"contain your new project. Here we will use the recommended `pyenv`:"
msgstr ""

#: src/getting-started.md:67
msgid ""
"After this, you should install your build manager. In this example, we will "
"use `maturin`. After you've activated your virtualenv, add `maturin` to it:"
msgstr ""

#: src/getting-started.md:73
msgid "Now you can initialize the new project:"
msgstr ""

#: src/getting-started.md:79
msgid ""
"If `maturin` is already installed, you can create a new project using that "
"directly as well:"
msgstr ""

#: src/getting-started.md:88
msgid "Adding to an existing project"
msgstr ""

#: src/getting-started.md:90
msgid ""
"Sadly, `maturin` cannot currently be run in existing projects, so if you "
"want to use Python in an existing project you basically have two options:"
msgstr ""

#: src/getting-started.md:92
msgid ""
"Create a new project as above and move your existing code into that project"
msgstr ""

#: src/getting-started.md:93
msgid "Manually edit your project configuration as necessary"
msgstr ""

#: src/getting-started.md:95
msgid ""
"If you opt for the second option, here are the things you need to pay "
"attention to:"
msgstr ""

#: src/getting-started.md:97
msgid "Cargo.toml"
msgstr ""

#: src/getting-started.md:99
msgid ""
"Make sure that the Rust crate you want to be able to access from Python is "
"compiled into a library. You can have a binary output as well, but the code "
"you want to access from Python has to be in the library part. Also, make "
"sure that the crate type is `cdylib` and add PyO3 as a dependency as so:"
msgstr ""

#: src/getting-started.md:102
msgid ""
"```toml\n"
"# If you already have [package] information in `Cargo.toml`, you can ignore\n"
"# this section!\n"
"[package]\n"
"# `name` here is name of the package.\n"
"name = \"pyo3_start\"\n"
"# these are good defaults:\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"pyo3_example\"\n"
"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"extension-"
"module\"] }\n"
"```"
msgstr ""

#: src/getting-started.md:125
msgid "pyproject.toml"
msgstr ""

#: src/getting-started.md:127
msgid "You should also create a `pyproject.toml` with the following contents:"
msgstr ""

#: src/getting-started.md:129
msgid ""
"```toml\n"
"[build-system]\n"
"requires = [\"maturin>=1,<2\"]\n"
"build-backend = \"maturin\"\n"
"\n"
"[project]\n"
"name = \"pyo3_example\"\n"
"requires-python = \">=3.7\"\n"
"classifiers = [\n"
"    \"Programming Language :: Rust\",\n"
"    \"Programming Language :: Python :: Implementation :: CPython\",\n"
"    \"Programming Language :: Python :: Implementation :: PyPy\",\n"
"]\n"
"```"
msgstr ""

#: src/getting-started.md:144
msgid "Running code"
msgstr ""

#: src/getting-started.md:146
msgid ""
"After this you can setup Rust code to be available in Python as below; for "
"example, you can place this code in `src/lib.rs`:"
msgstr ""

#: src/getting-started.md:150
msgid "/// Formats the sum of two numbers as string.\n"
msgstr ""

#: src/getting-started.md:156
msgid ""
"/// A Python module implemented in Rust. The name of this function must "
"match\n"
"/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able "
"to\n"
"/// import the module.\n"
msgstr ""

#: src/getting-started.md:166
msgid ""
"Now you can run `maturin develop` to prepare the Python package, after which "
"you can use it like so:"
msgstr ""

#: src/getting-started.md:169
msgid "# lots of progress output as maturin runs the compilation...\n"
msgstr ""

#: src/getting-started.md:173
msgid "'25'"
msgstr ""

#: src/getting-started.md:177
msgid ""
"For more instructions on how to use Python code from Rust, see the [Python "
"from Rust](python-from-rust.md) page."
msgstr ""

#: src/getting-started.md:179
msgid "Maturin Import Hook"
msgstr ""

#: src/getting-started.md:181
msgid ""
"In development, any changes in the code would require running `maturin "
"develop` before testing. To streamline the development process, you may want "
"to install [Maturin Import Hook](https://github.com/PyO3/maturin-import-"
"hook) which will run `maturin develop` automatically when the library with "
"code changes is being imported."
msgstr ""

#: src/index.md:1
msgid "The PyO3 user guide"
msgstr ""

#: src/index.md:3
msgid ""
"Welcome to the PyO3 user guide! This book is a companion to [PyO3's API docs]"
"(https://docs.rs/pyo3). It contains examples and documentation to explain "
"all of PyO3's use cases in detail."
msgstr ""

#: src/index.md:5
msgid "The rough order of material in this user guide is as follows:"
msgstr ""

#: src/index.md:6
msgid "Getting started"
msgstr ""

#: src/index.md:7
msgid "Wrapping Rust code for use from Python"
msgstr ""

#: src/index.md:8
msgid "How to use Python code from Rust"
msgstr ""

#: src/index.md:9
msgid "Remaining topics which go into advanced concepts in detail"
msgstr ""

#: src/index.md:11
msgid ""
"Please choose from the chapters on the left to jump to individual topics, or "
"continue below to start with PyO3's README."
msgstr ""

#: src/index.md:15
msgid "‚ö†Ô∏è Warning: API update in progress üõ†Ô∏è"
msgstr ""

#: src/index.md:17
msgid ""
"PyO3 0.21 has introduced a significant new API, termed the \"Bound\" API "
"after the new smart pointer `Bound<T>`."
msgstr ""

#: src/index.md:19
msgid ""
"While most of this guide has been updated to the new API, it is possible "
"some stray references to the older \"GIL Refs\" API such as `&PyAny` remain."
msgstr ""

#: src/index.md:24
msgid "PyO3"
msgstr ""

#: src/index.md:26
msgid ""
"[![actions status](https://img.shields.io/github/actions/workflow/status/"
"PyO3/pyo3/ci.yml?branch=main&logo=github&style=)](https://github.com/PyO3/"
"pyo3/actions) [![benchmark](https://img.shields.io/endpoint?url=https://"
"codspeed.io/badge.json)](https://codspeed.io/PyO3/pyo3) [![codecov](https://"
"img.shields.io/codecov/c/gh/PyO3/pyo3?logo=codecov)](https://codecov.io/gh/"
"PyO3/pyo3) [![crates.io](https://img.shields.io/crates/v/pyo3?logo=rust)]"
"(https://crates.io/crates/pyo3) [![minimum rustc 1.63](https://img.shields."
"io/badge/rustc-1.63+-blue?logo=rust)](https://rust-lang.github.io/rfcs/2495-"
"min-rust-version.html) [![discord server](https://img.shields.io/"
"discord/1209263839632424990?logo=discord)](https://discord.gg/33kcChzH7f) [!"
"[contributing notes](https://img.shields.io/badge/contribute-on%20github-"
"Green?logo=github)](https://github.com/PyO3/pyo3/blob/main/Contributing.md)"
msgstr ""

#: src/index.md:34
msgid ""
"[Rust](https://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/), including tools for creating native Python extension modules. Running "
"and interacting with Python code from a Rust binary is also supported."
msgstr ""

#: src/index.md:36
msgid "User Guide: [stable](https://pyo3.rs) | [main](https://pyo3.rs/main)"
msgstr ""

#: src/index.md:38
msgid ""
"API Documentation: [stable](https://docs.rs/pyo3/) | [main](https://pyo3.rs/"
"main/doc)"
msgstr ""

#: src/index.md:40
msgid "Usage"
msgstr ""

#: src/index.md:42
msgid "PyO3 supports the following software versions:"
msgstr ""

#: src/index.md:43
msgid "Python 3.7 and up (CPython, PyPy, and GraalPy)"
msgstr ""

#: src/index.md:44
msgid "Rust 1.63 and up"
msgstr ""

#: src/index.md:46
msgid ""
"You can use PyO3 to write a native Python module in Rust, or to embed Python "
"in a Rust binary. The following sections explain each of these in turn."
msgstr ""

#: src/index.md:48
msgid "Using Rust from Python"
msgstr ""

#: src/index.md:50
msgid ""
"PyO3 can be used to generate a native Python module. The easiest way to try "
"this out for the first time is to use [`maturin`](https://github.com/PyO3/"
"maturin). `maturin` is a tool for building and publishing Rust-based Python "
"packages with minimal configuration. The following steps install `maturin`, "
"use it to generate and build a new Python package, and then launch Python to "
"import and execute a function from the package."
msgstr ""

#: src/index.md:52
msgid ""
"First, follow the commands below to create a new directory containing a new "
"Python `virtualenv`, and install `maturin` into the virtualenv using "
"Python's package manager, `pip`:"
msgstr ""

#: src/index.md:55
msgid "# (replace string_sum with the desired package name)\n"
msgstr ""

#: src/index.md:63
msgid ""
"Still inside this `string_sum` directory, now run `maturin init`. This will "
"generate the new package source. When given the choice of bindings to use, "
"select pyo3 bindings:"
msgstr ""

#: src/index.md:71
msgid ""
"The most important files generated by this command are `Cargo.toml` and `lib."
"rs`, which will look roughly like the following:"
msgstr ""

#: src/index.md:73
msgid "**`Cargo.toml`**"
msgstr ""

#: src/index.md:75
msgid ""
"```toml\n"
"[package]\n"
"name = \"string_sum\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"string_sum\"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"#\n"
"# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) "
"will not be able\n"
"# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also "
"included, e.g.:\n"
"# crate-type = [\"cdylib\", \"rlib\"]\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.22.6\", features = [\"extension-module\"] }\n"
"```"
msgstr ""

#: src/index.md:97
msgid "**`src/lib.rs`**"
msgstr ""

#: src/index.md:118
msgid ""
"Finally, run `maturin develop`. This will build the package and install it "
"into the Python virtualenv previously created and activated. The package is "
"then ready to be used from `python`:"
msgstr ""

#: src/index.md:129
msgid ""
"To make changes to the package, just edit the Rust source code and then re-"
"run `maturin develop` to recompile."
msgstr ""

#: src/index.md:131
msgid ""
"To run this all as a single copy-and-paste, use the bash script below "
"(replace `string_sum` in the first command with the desired package name):"
msgstr ""

#: src/index.md:134
msgid "\"$_\""
msgstr ""

#: src/index.md:142
msgid ""
"If you want to be able to run `cargo test` or use this project in a Cargo "
"workspace and are running into linker issues, there are some workarounds in "
"[the FAQ](https://pyo3.rs/latest/faq.html#i-cant-run-cargo-test-or-i-cant-"
"build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-"
"undefined-reference-to-_pyexc_systemerror)."
msgstr ""

#: src/index.md:144
msgid ""
"As well as with `maturin`, it is possible to build using [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) or [manually](https://pyo3.rs/"
"latest/building-and-distribution.html#manual-builds). Both offer more "
"flexibility than `maturin` but require more configuration to get started."
msgstr ""

#: src/index.md:146
msgid "Using Python from Rust"
msgstr ""

#: src/index.md:148
msgid ""
"To embed Python into a Rust binary, you need to ensure that your Python "
"installation contains a shared library. The following steps demonstrate how "
"to ensure this (for Ubuntu), and then give some example code which runs an "
"embedded Python interpreter."
msgstr ""

#: src/index.md:150
msgid "To install the Python shared library on Ubuntu:"
msgstr ""

#: src/index.md:156
msgid ""
"To install the Python shared library on RPM based distributions (e.g. "
"Fedora, Red Hat, SuSE), install the `python3-devel` package."
msgstr ""

#: src/index.md:159
msgid ""
"Start a new project with `cargo new` and add  `pyo3` to the `Cargo.toml` "
"like this:"
msgstr ""

#: src/index.md:161
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.22.6\"\n"
"features = [\"auto-initialize\"]\n"
"```"
msgstr ""

#: src/index.md:167
msgid ""
"Example program displaying the value of `sys.version` and the current user "
"name:"
msgstr ""

#: src/index.md:176
msgid "\"version\""
msgstr ""

#: src/index.md:178
msgid "\"os\""
msgstr ""

#: src/index.md:179
msgid "\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\""
msgstr ""

#: src/index.md:182
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/index.md:188
msgid ""
"The guide has [a section](https://pyo3.rs/latest/python-from-rust.html) with "
"lots of examples about this topic."
msgstr ""

#: src/index.md:191
msgid "Tools and libraries"
msgstr ""

#: src/index.md:193
msgid ""
"[maturin](https://github.com/PyO3/maturin) _Build and publish crates with "
"pyo3, rust-cpython or cffi bindings as well as rust binaries as python "
"packages_"
msgstr ""

#: src/index.md:194
msgid ""
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) _Setuptools "
"plugin for Rust support_."
msgstr ""

#: src/index.md:195
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html)_"
msgstr ""

#: src/index.md:196
msgid ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _Rust binding of NumPy C-"
"API_"
msgstr ""

#: src/index.md:197
msgid ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject to automatically transform Python dicts into Rust structs_"
msgstr ""

#: src/index.md:198
msgid ""
"[pyo3-log](https://github.com/vorner/pyo3-log) _Bridge from Rust to Python "
"logging_"
msgstr ""

#: src/index.md:199
msgid ""
"[pythonize](https://github.com/davidhewitt/pythonize) _Serde serializer for "
"converting Rust objects to JSON-compatible Python objects_"
msgstr ""

#: src/index.md:200
msgid ""
"[pyo3-asyncio](https://github.com/awestlake87/pyo3-asyncio) _Utilities for "
"working with Python's Asyncio library and async functions_"
msgstr ""

#: src/index.md:201
msgid ""
"[rustimport](https://github.com/mityax/rustimport) _Directly import Rust "
"files or crates from Python, without manual compilation step. Provides pyo3 "
"integration by default and generates pyo3 binding code automatically._"
msgstr ""

#: src/index.md:202
msgid ""
"[pyo3-arrow](https://crates.io/crates/pyo3-arrow) _Lightweight [Apache Arrow]"
"(https://arrow.apache.org/) integration for pyo3._"
msgstr ""

#: src/index.md:204
msgid "Examples"
msgstr ""

#: src/index.md:206
msgid ""
"[autopy](https://github.com/autopilot-rs/autopy) _A simple, cross-platform "
"GUI automation library for Python and Rust._"
msgstr ""

#: src/index.md:207
msgid ""
"Contains an example of building wheels on TravisCI and appveyor using "
"[cibuildwheel](https://github.com/pypa/cibuildwheel)"
msgstr ""

#: src/index.md:208
msgid ""
"[ballista-python](https://github.com/apache/arrow-ballista-python) _A Python "
"library that binds to Apache Arrow distributed query engine Ballista._"
msgstr ""

#: src/index.md:209
msgid ""
"[bed-reader](https://github.com/fastlmm/bed-reader) _Read and write the "
"PLINK BED format, simply and efficiently._"
msgstr ""

#: src/index.md:210
msgid ""
"Shows Rayon/ndarray::parallel (including capturing errors, controlling "
"thread num), Python types to Rust generics, Github Actions"
msgstr ""

#: src/index.md:211
msgid ""
"[cryptography](https://github.com/pyca/cryptography/tree/main/src/rust) "
"_Python cryptography library with some functionality in Rust._"
msgstr ""

#: src/index.md:212
msgid ""
"[css-inline](https://github.com/Stranger6667/css-inline/tree/master/bindings/"
"python) _CSS inlining for Python implemented in Rust._"
msgstr ""

#: src/index.md:213
msgid ""
"[datafusion-python](https://github.com/apache/arrow-datafusion-python) _A "
"Python library that binds to Apache Arrow in-memory query engine DataFusion._"
msgstr ""

#: src/index.md:214
msgid ""
"[deltalake-python](https://github.com/delta-io/delta-rs/tree/main/python) "
"_Native Delta Lake Python binding based on delta-rs with Pandas integration._"
msgstr ""

#: src/index.md:215
msgid ""
"[fastbloom](https://github.com/yankun1992/fastbloom) _A fast [bloom filter]"
"(https://github.com/yankun1992/fastbloom#BloomFilter) | [counting bloom "
"filter](https://github.com/yankun1992/fastbloom#countingbloomfilter) "
"implemented by Rust for Rust and Python!_"
msgstr ""

#: src/index.md:216
msgid ""
"[fastuuid](https://github.com/thedrow/fastuuid/) _Python bindings to Rust's "
"UUID library._"
msgstr ""

#: src/index.md:217
msgid ""
"[feos](https://github.com/feos-org/feos) _Lightning fast thermodynamic "
"modeling in Rust with fully developed Python interface._"
msgstr ""

#: src/index.md:218
msgid ""
"[forust](https://github.com/jinlow/forust) _A lightweight gradient boosted "
"decision tree library written in Rust._"
msgstr ""

#: src/index.md:219
msgid ""
"[granian](https://github.com/emmett-framework/granian) _A Rust HTTP server "
"for Python applications._"
msgstr ""

#: src/index.md:220
msgid ""
"[greptimedb](https://github.com/GreptimeTeam/greptimedb/tree/main/src/"
"script) _Support [Python scripting](https://docs.greptime.com/user-guide/"
"python-scripts/overview) in the database_"
msgstr ""

#: src/index.md:221
msgid ""
"[haem](https://github.com/BooleanCat/haem) _A Python library for working on "
"Bioinformatics problems._"
msgstr ""

#: src/index.md:222
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/main/examples/"
"html-py-ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""

#: src/index.md:223
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json._"
msgstr ""

#: src/index.md:224
msgid ""
"[inline-python](https://github.com/fusion-engineering/inline-python) _Inline "
"Python code directly in your Rust code._"
msgstr ""

#: src/index.md:225
msgid ""
"[johnnycanencrypt](https://github.com/kushaldas/johnnycanencrypt) OpenPGP "
"library with Yubikey support."
msgstr ""

#: src/index.md:226
msgid ""
"[jsonschema-rs](https://github.com/Stranger6667/jsonschema-rs/tree/master/"
"bindings/python) _Fast JSON Schema validation library._"
msgstr ""

#: src/index.md:227
msgid ""
"[mocpy](https://github.com/cds-astro/mocpy) _Astronomical Python library "
"offering data structures for describing any arbitrary coverage regions on "
"the unit sphere._"
msgstr ""

#: src/index.md:228
msgid ""
"[opendal](https://github.com/apache/opendal/tree/main/bindings/python) _A "
"data access layer that allows users to easily and efficiently retrieve data "
"from various storage services in a unified way._"
msgstr ""

#: src/index.md:229
msgid "[orjson](https://github.com/ijl/orjson) _Fast Python JSON library._"
msgstr ""

#: src/index.md:230
msgid ""
"[ormsgpack](https://github.com/aviramha/ormsgpack) _Fast Python msgpack "
"library._"
msgstr ""

#: src/index.md:231
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library._"
msgstr ""

#: src/index.md:232
msgid ""
"[polaroid](https://github.com/daggy1234/polaroid) _Hyper Fast and safe image "
"manipulation library for Python written in Rust._"
msgstr ""

#: src/index.md:233
msgid ""
"[polars](https://github.com/pola-rs/polars) _Fast multi-threaded DataFrame "
"library in Rust | Python | Node.js._"
msgstr ""

#: src/index.md:234
msgid ""
"[pydantic-core](https://github.com/pydantic/pydantic-core) _Core validation "
"logic for pydantic written in Rust._"
msgstr ""

#: src/index.md:235
msgid ""
"[pyheck](https://github.com/kevinheavey/pyheck) _Fast case conversion "
"library, built by wrapping [heck](https://github.com/withoutboats/heck)._"
msgstr ""

#: src/index.md:236
msgid "Quite easy to follow as there's not much code."
msgstr ""

#: src/index.md:237
msgid ""
"[pyre](https://github.com/Project-Dream-Weaver/pyre-http) _Fast Python HTTP "
"server written in Rust._"
msgstr ""

#: src/index.md:238
msgid ""
"[pyreqwest_impersonate](https://github.com/deedy5/pyreqwest_impersonate) "
"_The fastest python HTTP client that can impersonate web browsers by "
"mimicking their headers and TLS/JA3/JA4/HTTP2 fingerprints._"
msgstr ""

#: src/index.md:239
msgid ""
"[ril-py](https://github.com/Cryptex-github/ril-py) _A performant and high-"
"level image processing library for Python written in Rust._"
msgstr ""

#: src/index.md:240
msgid ""
"[river](https://github.com/online-ml/river) _Online machine learning in "
"python, the computationally heavy statistics algorithms are implemented in "
"Rust._"
msgstr ""

#: src/index.md:241
msgid ""
"[rust-python-coverage](https://github.com/cjermain/rust-python-coverage) "
"_Example PyO3 project with automated test coverage for Rust and Python._"
msgstr ""

#: src/index.md:242
msgid ""
"[tiktoken](https://github.com/openai/tiktoken) _A fast BPE tokeniser for use "
"with OpenAI's models._"
msgstr ""

#: src/index.md:243
msgid ""
"[tokenizers](https://github.com/huggingface/tokenizers/tree/main/bindings/"
"python) _Python bindings to the Hugging Face tokenizers (NLP) written in "
"Rust._"
msgstr ""

#: src/index.md:244
msgid ""
"[tzfpy](http://github.com/ringsaturn/tzfpy) _A fast package to convert "
"longitude/latitude to timezone name._"
msgstr ""

#: src/index.md:245
msgid ""
"[utiles](https://github.com/jessekrubin/utiles) _Fast Python web-map tile "
"utilities_"
msgstr ""

#: src/index.md:246
msgid ""
"[wasmer-python](https://github.com/wasmerio/wasmer-python) _Python library "
"to run WebAssembly binaries._"
msgstr ""

#: src/index.md:248
msgid "Articles and other media"
msgstr ""

#: src/index.md:250
msgid ""
"[(Video) Extending Python with Rust using PyO3](https://www.youtube.com/"
"watch?v=T45ZEmSR1-s) - Dec 16, 2023"
msgstr ""

#: src/index.md:251
msgid ""
"[A Week of PyO3 + rust-numpy (How to Speed Up Your Data Pipeline X Times)]"
"(https://terencezl.github.io/blog/2023/06/06/a-week-of-pyo3-rust-numpy/) - "
"Jun 6, 2023"
msgstr ""

#: src/index.md:252
msgid ""
"[(Podcast) PyO3 with David Hewitt](https://rustacean-station.org/episode/"
"david-hewitt/) - May 19, 2023"
msgstr ""

#: src/index.md:253
msgid ""
"[Making Python 100x faster with less than 100 lines of Rust](https://"
"ohadravid.github.io/posts/2023-03-rusty-python/) - Mar 28, 2023"
msgstr ""

#: src/index.md:254
msgid ""
"[How Pydantic V2 leverages Rust's Superpowers](https://fosdem.org/2023/"
"schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/) - Feb 4, "
"2023"
msgstr ""

#: src/index.md:255
msgid ""
"[How we extended the River stats module with Rust using PyO3](https://boring-"
"guy.sh/posts/river-rust/) - Dec 23, 2022"
msgstr ""

#: src/index.md:256
msgid ""
"[Nine Rules for Writing Python Extensions in Rust](https://"
"towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-"
"d35ea3a4ec29?sk=f8d808d5f414154fdb811e4137011437) - Dec 31, 2021"
msgstr ""

#: src/index.md:257
msgid ""
"[Calling Rust from Python using PyO3](https://saidvandeklundert.net/"
"learn/2021-11-18-calling-rust-from-python-using-pyo3/) - Nov 18, 2021"
msgstr ""

#: src/index.md:258
msgid ""
"[davidhewitt's 2021 talk at Rust Manchester meetup](https://www.youtube.com/"
"watch?v=-XyWG_klSAw&t=320s) - Aug 19, 2021"
msgstr ""

#: src/index.md:259
msgid ""
"[Incrementally porting a small Python project to Rust](https://blog."
"waleedkhan.name/port-python-to-rust/) - Apr 29, 2021"
msgstr ""

#: src/index.md:260
msgid ""
"[Vortexa - Integrating Rust into Python](https://www.vortexa.com/insight/"
"integrating-rust-into-python) - Apr 12, 2021"
msgstr ""

#: src/index.md:261
msgid ""
"[Writing and publishing a Python module in Rust](https://blog.yossarian."
"net/2020/08/02/Writing-and-publishing-a-python-module-in-rust) - Aug 2, 2020"
msgstr ""

#: src/index.md:265
msgid ""
"Everyone is welcomed to contribute to PyO3! There are many ways to support "
"the project, such as:"
msgstr ""

#: src/index.md:267
msgid ""
"help PyO3 users with issues on GitHub and [Discord](https://discord."
"gg/33kcChzH7f)"
msgstr ""

#: src/index.md:268
msgid "improve documentation"
msgstr ""

#: src/index.md:269
msgid "write features and bugfixes"
msgstr ""

#: src/index.md:270
msgid "publish blogs and examples of how to use PyO3"
msgstr ""

#: src/index.md:272
msgid ""
"Our [contributing notes](https://github.com/PyO3/pyo3/blob/main/Contributing."
"md) and [architecture guide](https://github.com/PyO3/pyo3/blob/main/"
"Architecture.md) have more resources if you wish to volunteer time for PyO3 "
"and are searching where to start."
msgstr ""

#: src/index.md:274
msgid ""
"If you don't have time to contribute yourself but still wish to support the "
"project's future success, some of our maintainers have GitHub sponsorship "
"pages:"
msgstr ""

#: src/index.md:279
msgid "License"
msgstr ""

#: src/index.md:281
msgid ""
"PyO3 is licensed under the [Apache-2.0 license](LICENSE-APACHE) or the [MIT "
"license](LICENSE-MIT), at your option."
msgstr ""

#: src/index.md:283
msgid ""
"Python is licensed under the [Python License](https://docs.python.org/3/"
"license.html)."
msgstr ""

#: src/index.md:285
msgid ""
"Unless you explicitly state otherwise, any contribution intentionally "
"submitted for inclusion in PyO3 by you, as defined in the Apache License, "
"shall be dual-licensed as above, without any additional terms or conditions."
msgstr ""

#: src/index.md:287
msgid ""
"<a href=\"https://www.netlify.com\"> <img src=\"https://www.netlify.com/v3/"
"img/components/netlify-color-accent.svg\" alt=\"Deploys by Netlify\" /> </a>"
msgstr ""

#: src/memory.md:1
msgid "Memory management"
msgstr ""

#: src/memory.md:9
msgid ""
"This section on memory management is heavily weighted towards the now-"
"deprecated \"GIL Refs\" API, which suffered from the drawbacks detailed here "
"as well as CPU overheads."
msgstr ""

#: src/memory.md:11
msgid ""
"See [the smart pointer types](./types.md#pyo3s-smart-pointers) for "
"description on the new, simplified, memory model of the Bound API, which is "
"built as a thin wrapper on Python reference counting."
msgstr ""

#: src/memory.md:14
msgid ""
"Rust and Python have very different notions of memory management.  Rust has "
"a strict memory model with concepts of ownership, borrowing, and lifetimes, "
"where memory is freed at predictable points in program execution.  Python "
"has a looser memory model in which variables are reference-counted with "
"shared, mutable state by default. A global interpreter lock (GIL) is needed "
"to prevent race conditions, and a garbage collector is needed to break "
"reference cycles. Memory in Python is freed eventually by the garbage "
"collector, but not usually in a predictable way."
msgstr ""

#: src/memory.md:23
msgid ""
"PyO3 bridges the Rust and Python memory models with two different strategies "
"for accessing memory allocated on Python's heap from inside Rust. These are "
"GIL Refs such as `&'py PyAny`, and GIL-independent `Py<Any>` smart pointers."
msgstr ""

#: src/memory.md:27
msgid "GIL-bound memory"
msgstr ""

#: src/memory.md:29
msgid ""
"PyO3's GIL Refs such as `&'py PyAny` make PyO3 more ergonomic to use by "
"ensuring that their lifetime can never be longer than the duration the "
"Python GIL is held.  This means that most of PyO3's API can assume the GIL "
"is held. (If PyO3 could not assume this, every PyO3 API would need to take a "
"`Python` GIL token to prove that the GIL is held.)  This allows us to write "
"very simple and easy-to-understand programs like this:"
msgstr ""

#: src/memory.md:43 src/memory.md:69 src/memory.md:110 src/memory.md:137
#: src/memory.md:193 src/memory.md:223 src/memory.md:262 src/memory.md:292
msgid "// py.eval() is part of the GIL Refs API\n"
msgstr ""

#: src/memory.md:45 src/memory.md:71 src/memory.md:112 src/memory.md:139
#: src/memory.md:194 src/memory.md:224 src/memory.md:264 src/memory.md:294
msgid "\"\\\"Hello World!\\\"\""
msgstr ""

#: src/memory.md:47 src/memory.md:73 src/memory.md:114 src/memory.md:141
#: src/memory.md:197 src/memory.md:231 src/memory.md:270 src/memory.md:300
msgid "\"Python says: {}\""
msgstr ""

#: src/memory.md:54
msgid ""
"Internally, calling `Python::with_gil()` creates a `GILPool` which owns the "
"memory pointed to by the reference.  In the example above, the lifetime of "
"the reference `hello` is bound to the `GILPool`.  When the `with_gil()` "
"closure ends the `GILPool` is also dropped and the Python reference counts "
"of the variables it owns are decreased, releasing them to the Python garbage "
"collector.  Most of the time we don't have to think about this, but consider "
"the following:"
msgstr ""

#: src/memory.md:75
msgid "// There are 10 copies of `hello` on Python's heap here.\n"
msgstr ""

#: src/memory.md:82
msgid ""
"We might assume that the `hello` variable's memory is freed at the end of "
"each loop iteration, but in fact we create 10 copies of `hello` on Python's "
"heap. This may seem surprising at first, but it is completely consistent "
"with Rust's memory model.  The `hello` variable is dropped at the end of "
"each loop, but it is only a reference to the memory owned by the `GILPool`, "
"and its lifetime is bound to the `GILPool`, not the for loop.  The `GILPool` "
"isn't dropped until the end of the `with_gil()` closure, at which point the "
"10 copies of `hello` are finally released to the Python garbage collector."
msgstr ""

#: src/memory.md:93 src/memory.md:168
msgid ""
"‚ö†Ô∏è Warning: `GILPool` is no longer the preferred way to manage memory with "
"PyO3 üõ†Ô∏è"
msgstr ""

#: src/memory.md:95 src/memory.md:170
msgid ""
"PyO3 0.21 has introduced a new API known as the Bound API, which doesn't "
"have the same surprising results. Instead, each `Bound<T>` smart pointer "
"releases the Python reference immediately on drop. See [the smart pointer "
"types](./types.md#pyo3s-smart-pointers) for more details."
msgstr ""

#: src/memory.md:99
msgid ""
"In general we don't want unbounded memory growth during loops!  One "
"workaround is to acquire and release the GIL with each iteration of the loop."
msgstr ""

#: src/memory.md:116
msgid "// only one copy of `hello` at a time\n"
msgstr ""

#: src/memory.md:122
msgid ""
"It might not be practical or performant to acquire and release the GIL so "
"many times.  Another workaround is to work with the `GILPool` object "
"directly, but this is unsafe."
msgstr ""

#: src/memory.md:134
msgid "// `new_pool` is not needed in code not using the GIL Refs API\n"
msgstr ""

#: src/memory.md:149
msgid ""
"The unsafe method `Python::new_pool` allows you to create a nested `GILPool` "
"from which you can retrieve a new `py: Python` GIL token.  Variables created "
"with this new GIL token are bound to the nested `GILPool` and will be "
"released when the nested `GILPool` is dropped.  Here, the nested `GILPool` "
"is dropped at the end of each loop iteration, before the `with_gil()` "
"closure ends."
msgstr ""

#: src/memory.md:155
msgid ""
"When doing this, you must be very careful to ensure that once the `GILPool` "
"is dropped you do not retain access to any owned references created after "
"the `GILPool` was created.  Read the documentation for `Python::new_pool()` "
"for more information on safety."
msgstr ""

#: src/memory.md:160
msgid ""
"This memory management can also be applicable when writing extension "
"modules. `#[pyfunction]` and `#[pymethods]` will create a `GILPool` which "
"lasts the entire function call, releasing objects when the function returns. "
"Most functions only create a few objects, meaning this doesn't have a "
"significant impact. Occasionally functions with long complex loops may need "
"to use `Python::new_pool` as shown above."
msgstr ""

#: src/memory.md:173
msgid "GIL-independent memory"
msgstr ""

#: src/memory.md:175
msgid ""
"Sometimes we need a reference to memory on Python's heap that can outlive "
"the GIL.  Python's `Py<PyAny>` is analogous to `Arc<T>`, but for variables "
"whose memory is allocated on Python's heap.  Cloning a `Py<PyAny>` increases "
"its internal reference count just like cloning `Arc<T>`.  The smart pointer "
"can outlive the \"GIL is held\" period in which it was created.  It isn't "
"magic, though.  We need to reacquire the GIL to access the memory pointed to "
"by the `Py<PyAny>`."
msgstr ""

#: src/memory.md:183
msgid ""
"What happens to the memory when the last `Py<PyAny>` is dropped and its "
"reference count reaches zero?  It depends whether or not we are holding the "
"GIL."
msgstr ""

#: src/memory.md:195 src/memory.md:268
msgid "// as_ref is part of the GIL Refs API\n"
msgstr ""

#: src/memory.md:205
msgid ""
"At the end of the `Python::with_gil()` closure `hello` is dropped, and then "
"the GIL is dropped.  Since `hello` is dropped while the GIL is still held by "
"the current thread, its memory is released to the Python garbage collector "
"immediately."
msgstr ""

#: src/memory.md:210
msgid ""
"This example wasn't very interesting.  We could have just used a GIL-bound "
"`&PyString` reference.  What happens when the last `Py<Any>` is dropped "
"while we are _not_ holding the GIL?"
msgstr ""

#: src/memory.md:225
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program we want to access `hello`.\n"
msgstr ""

#: src/memory.md:232
msgid "// Now we're done with `hello`.\n"
msgstr ""

#: src/memory.md:234
msgid ""
"// Memory *not* released here.\n"
"// Sometime later we need the GIL again for something...\n"
msgstr ""

#: src/memory.md:237
msgid "// Memory for `hello` is released here.\n"
msgstr ""

#: src/memory.md:246
msgid ""
"When `hello` is dropped _nothing_ happens to the pointed-to memory on "
"Python's heap because nothing _can_ happen if we're not holding the GIL.  "
"Fortunately, the memory isn't leaked. If the `pyo3_disable_reference_pool` "
"conditional compilation flag is not enabled, PyO3 keeps track of the memory "
"internally and will release it the next time we acquire the GIL."
msgstr ""

#: src/memory.md:252
msgid ""
"We can avoid the delay in releasing memory if we are careful to drop the "
"`Py<Any>` while the GIL is held."
msgstr ""

#: src/memory.md:264 src/memory.md:294
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program:\n"
msgstr ""

#: src/memory.md:272
msgid "// Memory released here.\n"
msgstr ""

#: src/memory.md:279
msgid ""
"We could also have used `Py::into_ref()`, which consumes `self`, instead of "
"`Py::as_ref()`.  But note that in addition to being slower than `as_ref()`, "
"`into_ref()` binds the memory to the lifetime of the `GILPool`, which means "
"that rather than being released immediately, the memory will not be released "
"until the GIL is dropped."
msgstr ""

#: src/memory.md:298
msgid "// into_ref is part of the GIL Refs API\n"
msgstr ""

#: src/memory.md:302
msgid ""
"// Memory not released yet.\n"
"    // Do more stuff...\n"
"    // Memory released here at end of `with_gil()` closure.\n"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"CPython has the infamous [Global Interpreter Lock](https://docs.python.org/3/"
"glossary.html#term-global-interpreter-lock), which prevents several threads "
"from executing Python bytecode in parallel. This makes threading in Python a "
"bad fit for [CPU-bound](https://en.wikipedia.org/wiki/CPU-bound) tasks and "
"often forces developers to accept the overhead of multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a "
"look at our [word-count](https://github.com/PyO3/pyo3/blob/main/examples/"
"word-count/src/lib.rs) example, where we have a `search` function that "
"utilizes the [rayon](https://github.com/rayon-rs/rayon) crate to count words "
"in parallel."
msgstr ""

#: src/parallelism.md:9
msgid "// These traits let us use `par_lines` and `map`.\n"
msgstr ""

#: src/parallelism.md:13
msgid "/// Count the occurrences of needle in line, case insensitive\n"
msgstr ""

#: src/parallelism.md:17 src/parallelism.md:39 src/parallelism.md:59
msgid "' '"
msgstr ""

#: src/parallelism.md:34
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""

#: src/parallelism.md:52
msgid ""
"To enable parallel execution of this function, the [`Python::allow_threads`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method."
"allow_threads) method can be used to temporarily release the GIL, thus "
"allowing other Python threads to run. We then have a function exposed to the "
"Python runtime which calls `search_sequential` inside a closure passed to "
"[`Python::allow_threads`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:76
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""

#: src/parallelism.md:93
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:95
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr ""

#: src/parallelism.md:97
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr ""

#: src/parallelism.md:99
msgid "Pure Python version"
msgstr ""

#: src/parallelism.md:100
msgid "Rust parallel version"
msgstr ""

#: src/parallelism.md:101
msgid "Rust sequential version"
msgstr ""

#: src/parallelism.md:102
msgid "Rust sequential version executed twice with two Python threads"
msgstr ""

#: src/parallelism.md:104
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `nox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""

#: src/parallelism.md:106
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr ""

#: src/parallelism.md:118
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""

#: src/performance.md:1
msgid "Performance"
msgstr ""

#: src/performance.md:3
msgid ""
"To achieve the best possible performance, it is useful to be aware of "
"several tricks and sharp edges concerning PyO3's API."
msgstr ""

#: src/performance.md:5
msgid "`extract` versus `downcast`"
msgstr ""

#: src/performance.md:7
msgid ""
"Pythonic API implemented using PyO3 are often polymorphic, i.e. they will "
"accept `&Bound<'_, PyAny>` and try to turn this into multiple more concrete "
"types to which the requested operation is applied. This often leads to "
"chains of calls to `extract`, e.g."
msgstr ""

#: src/performance.md:29 src/performance.md:51
msgid "\"Cannot frobnicate that type.\""
msgstr ""

#: src/performance.md:34
msgid ""
"This suboptimal as the `FromPyObject<T>` trait requires `extract` to have a "
"`Result<T, PyErr>` return type. For native types like `PyList`, it faster to "
"use `downcast` (which `extract` calls internally) when the error value is "
"ignored. This avoids the costly conversion of a `PyDowncastError` to a "
"`PyErr` required to fulfil the `FromPyObject` contract, i.e."
msgstr ""

#: src/performance.md:45
msgid ""
"// Use `downcast` instead of `extract` as turning `PyDowncastError` into "
"`PyErr` is quite costly.\n"
msgstr ""

#: src/performance.md:56
msgid "Access to Bound implies access to GIL token"
msgstr ""

#: src/performance.md:58
msgid ""
"Calling `Python::with_gil` is effectively a no-op when the GIL is already "
"held, but checking that this is the case still has a cost. If an existing "
"GIL token can not be accessed, for example when implementing a pre-existing "
"trait, but a GIL-bound reference is available, this cost can be avoided by "
"exploiting that access to GIL-bound reference gives zero-cost access to a "
"GIL token via `Bound::py`."
msgstr ""

#: src/performance.md:60
msgid "For example, instead of writing"
msgstr ""

#: src/performance.md:81
msgid "use the more efficient"
msgstr ""

#: src/performance.md:92
msgid "// Access to `&Bound<'py, PyAny>` implies access to `Python<'py>`.\n"
msgstr ""

#: src/performance.md:100
msgid "Disable the global reference pool"
msgstr ""

#: src/performance.md:102
msgid ""
"PyO3 uses global mutable state to keep track of deferred reference count "
"updates implied by `impl<T> Drop for Py<T>` being called without the GIL "
"being held. The necessary synchronization to obtain and apply these "
"reference count updates when PyO3-based code next acquires the GIL is "
"somewhat expensive and can become a significant part of the cost of crossing "
"the Python-Rust boundary."
msgstr ""

#: src/performance.md:104
msgid ""
"This functionality can be avoided by setting the "
"`pyo3_disable_reference_pool` conditional compilation flag. This removes the "
"global reference pool and the associated costs completely. However, it does "
"_not_ remove the `Drop` implementation for `Py<T>` which is necessary to "
"interoperate with existing Rust code written without PyO3-based code in "
"mind. To stay compatible with the wider Rust ecosystem in these cases, we "
"keep the implementation but abort when `Drop` is called without the GIL "
"being held. If `pyo3_leak_on_drop_without_reference_pool` is additionally "
"enabled, objects dropped without the GIL being held will be leaked instead "
"which is always sound but might have determinal effects like resource "
"exhaustion in the long term."
msgstr ""

#: src/performance.md:106
msgid ""
"This limitation is important to keep in mind when this setting is used, "
"especially when embedding Python code into a Rust application as it is quite "
"easy to accidentally drop a `Py<T>` (or types containing it like `PyErr`, "
"`PyBackedStr` or `PyBackedBytes`) returned from `Python::with_gil` without "
"making sure to re-acquire the GIL beforehand. For example, the following code"
msgstr ""

#: src/performance.md:122
msgid "will abort if the list not explicitly disposed via"
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:9
msgid "Python modules"
msgstr ""

#: src/SUMMARY.md:10
msgid "Python functions"
msgstr ""

#: src/SUMMARY.md:11
msgid "Function signatures"
msgstr ""

#: src/SUMMARY.md:12
msgid "Error handling"
msgstr ""

#: src/SUMMARY.md:13
msgid "Python classes"
msgstr ""

#: src/SUMMARY.md:14
msgid "Class customizations"
msgstr ""

#: src/SUMMARY.md:15
msgid "Basic object customization"
msgstr ""

#: src/SUMMARY.md:16
msgid "Emulating numeric types"
msgstr ""

#: src/SUMMARY.md:17
msgid "Emulating callable objects"
msgstr ""

#: src/SUMMARY.md:18
msgid "Calling Python from Rust"
msgstr ""

#: src/SUMMARY.md:23
msgid "Type conversions"
msgstr ""

#: src/SUMMARY.md:24
msgid "Mapping of Rust types to Python types"
msgstr ""

#: src/SUMMARY.md:25
msgid "Conversion traits"
msgstr ""

#: src/SUMMARY.md:26 src/SUMMARY.md:37
msgid "Using `async` and `await`"
msgstr ""

#: src/SUMMARY.md:35
msgid "Useful crates"
msgstr ""

#: src/SUMMARY.md:36
msgid "Logging"
msgstr ""

#: src/SUMMARY.md:38
msgid "FAQ and troubleshooting"
msgstr ""

#: src/SUMMARY.md:42
msgid ""
"Appendix A: Migration guide Appendix B: Trait bounds Appendix C: Python "
"typing hints CHANGELOG"
msgstr ""

#: src/conversions.md:3
msgid ""
"In this portion of the guide we'll talk about the mapping of Python types to "
"Rust types offered by PyO3, as well as the traits available to perform "
"conversions between them."
msgstr ""

#: src/conversions/traits.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions/traits.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr ""

#: src/conversions/traits.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions/traits.md:16 src/conversions/traits.md:453
msgid "b\"foo\""
msgstr ""

#: src/conversions/traits.md:24
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)."
msgstr ""

#: src/conversions/traits.md:28
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](../class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions/traits.md:35
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"
msgstr ""

#: src/conversions/traits.md:37
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) can be automatically derived for many kinds of structs and enums if "
"the member types themselves implement `FromPyObject`. This even includes "
"members with a generic type `T: FromPyObject`. Derivation for empty enums, "
"enum variants and structs is not supported."
msgstr ""

#: src/conversions/traits.md:42
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for structs"
msgstr ""

#: src/conversions/traits.md:44
msgid ""
"The derivation generates code that will attempt to access the attribute  "
"`my_string` on the Python object, i.e. `obj.getattr(\"my_string\")`, and "
"call `extract()` on the attribute."
msgstr ""

#: src/conversions/traits.md:59
msgid ""
"\"class Foo:\n"
"#             def __init__(self):\n"
"#                 self.my_string = 'test'\""
msgstr ""

#: src/conversions/traits.md:66 src/conversions/traits.md:124
#: src/conversions/traits.md:353 src/conversions/traits.md:377
msgid "\"Foo\""
msgstr ""

#: src/conversions/traits.md:75
msgid ""
"By setting the `#[pyo3(item)]` attribute on the field, PyO3 will attempt to "
"extract the value by calling the `get_item` method on the Python object."
msgstr ""

#: src/conversions/traits.md:90
msgid "\"my_string\""
msgstr ""

#: src/conversions/traits.md:99
msgid "The argument passed to `getattr` and `get_item` can also be configured:"
msgstr ""

#: src/conversions/traits.md:116
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.name = 'test'\n"
"#                 self['key'] = 'test2'\""
msgstr ""

#: src/conversions/traits.md:128 src/conversions/traits.md:184
#: src/conversions/traits.md:188
msgid "\"test2\""
msgstr ""

#: src/conversions/traits.md:135
msgid ""
"This tries to extract `string_attr` from the attribute `name` and "
"`string_in_mapping` from a mapping with the key `\"key\"`. The arguments for "
"`attribute` are restricted to non-empty string literals while `item` can "
"take any valid literal that implements `ToBorrowedObject`."
msgstr ""

#: src/conversions/traits.md:140
msgid ""
"You can use `#[pyo3(from_item_all)]` on a struct to extract every field with "
"`get_item` method. In this case, you can't use `#[pyo3(attribute)]` or "
"barely use `#[pyo3(item)]` on any field. However, using "
"`#[pyo3(item(\"key\"))]` to specify the key for a field is still allowed."
msgstr ""

#: src/conversions/traits.md:158
msgid "\"{'foo': 'foo', 'bar': 'bar', 'foobar': 'foobar'}\""
msgstr ""

#: src/conversions/traits.md:161
msgid "\"bar\""
msgstr ""

#: src/conversions/traits.md:162
msgid "\"foobar\""
msgstr ""

#: src/conversions/traits.md:169
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for tuple structs"
msgstr ""

#: src/conversions/traits.md:171
msgid ""
"Tuple structs are also supported but do not allow customizing the "
"extraction. The input is always assumed to be a Python tuple with the same "
"length as the Rust type, the `n`th field is extracted from the `n`th item in "
"the Python tuple."
msgstr ""

#: src/conversions/traits.md:195
msgid ""
"Tuple structs with a single field are treated as wrapper types which are "
"described in the following section. To override this behaviour and ensure "
"that the input is in fact a tuple, specify the struct as"
msgstr ""

#: src/conversions/traits.md:217
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for wrapper types"
msgstr ""

#: src/conversions/traits.md:219
msgid ""
"The `pyo3(transparent)` attribute can be used on structs with exactly one "
"field. This results in extracting directly from the input object, i.e. `obj."
"extract()`, rather than trying to access an item or attribute. This "
"behaviour is enabled per default for newtype structs and tuple-variants with "
"a single field."
msgstr ""

#: src/conversions/traits.md:252
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for enums"
msgstr ""

#: src/conversions/traits.md:254
msgid ""
"The `FromPyObject` derivation for enums generates code that tries to extract "
"the variants in the order of the fields. As soon as a variant can be "
"extracted successfully, that variant is returned. This makes it possible to "
"extract Python union types like `str | int`."
msgstr ""

#: src/conversions/traits.md:258
msgid ""
"The same customizations and restrictions described for struct derivations "
"apply to enum variants, i.e. a tuple variant assumes that the input is a "
"Python tuple, and a struct variant defaults to extracting fields as "
"attributes but can be configured in the same manner. The `transparent` "
"attribute can be applied to single-field-variants."
msgstr ""

#: src/conversions/traits.md:269
msgid "// input is a positive int\n"
msgstr ""

#: src/conversions/traits.md:270
msgid "// input is a string\n"
msgstr ""

#: src/conversions/traits.md:271
msgid "// input is a 2-tuple with positive ints\n"
msgstr ""

#: src/conversions/traits.md:272
msgid "// input is a 2-tuple with String and int\n"
msgstr ""

#: src/conversions/traits.md:274
msgid "// needs to be in front of 2d\n"
msgstr ""

#: src/conversions/traits.md:280
msgid "// only gets checked if the input did not have `z`\n"
msgstr ""

#: src/conversions/traits.md:281
msgid "\"x\""
msgstr ""

#: src/conversions/traits.md:283
msgid "\"y\""
msgstr ""

#: src/conversions/traits.md:287
msgid "// This extraction never fails\n"
msgstr ""

#: src/conversions/traits.md:301 src/conversions/traits.md:313
#: src/conversions/traits.md:325 src/conversions/traits.md:337
#: src/conversions/traits.md:361 src/conversions/traits.md:385
#: src/conversions/traits.md:398 src/conversions/traits.md:434
#: src/conversions/traits.md:447
msgid "\"Error extracting: {:?}\""
msgstr ""

#: src/conversions/traits.md:306 src/conversions/traits.md:310
msgid "\"text\""
msgstr ""

#: src/conversions/traits.md:344
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 0\n"
"#                 self.y = 1\n"
"#                 self.z = 2\""
msgstr ""

#: src/conversions/traits.md:369
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 3\n"
"#                 self.y = 4\""
msgstr ""

#: src/conversions/traits.md:391 src/conversions/traits.md:395
msgid "b\"text\""
msgstr ""

#: src/conversions/traits.md:407
msgid ""
"If none of the enum variants match, a `PyTypeError` containing the names of "
"the tested variants is returned. The names reported in the error message can "
"be customized through the `#[pyo3(annotation = \"name\")]` attribute, e.g. "
"to use conventional Python type names:"
msgstr ""

#: src/conversions/traits.md:418
msgid "\"str\""
msgstr ""

#: src/conversions/traits.md:420
msgid "\"int\""
msgstr ""

#: src/conversions/traits.md:463
msgid ""
"If the input is neither a string nor an integer, the error message will be: "
"`\"'<INPUT_TYPE>' cannot be converted to 'str | int'\"`."
msgstr ""

#: src/conversions/traits.md:466
msgid "`#[derive(FromPyObject)]` Container Attributes"
msgstr ""

#: src/conversions/traits.md:467
msgid "`pyo3(transparent)`"
msgstr ""

#: src/conversions/traits.md:468
msgid ""
"extract the field directly from the object as `obj.extract()` instead of "
"`get_item()` or `getattr()`"
msgstr ""

#: src/conversions/traits.md:470
msgid ""
"Newtype structs and tuple-variants are treated as transparent per default."
msgstr ""

#: src/conversions/traits.md:471
msgid "only supported for single-field structs and enum variants"
msgstr ""

#: src/conversions/traits.md:472
msgid "`pyo3(annotation = \"name\")`"
msgstr ""

#: src/conversions/traits.md:473
msgid ""
"changes the name of the failed variant in the generated error message in "
"case of failure."
msgstr ""

#: src/conversions/traits.md:474
msgid "e.g. `pyo3(\"int\")` reports the variant's type as `int`."
msgstr ""

#: src/conversions/traits.md:475
msgid "only supported for enum variants"
msgstr ""

#: src/conversions/traits.md:477
msgid "`#[derive(FromPyObject)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:478
msgid "`pyo3(attribute)`, `pyo3(attribute(\"name\"))`"
msgstr ""

#: src/conversions/traits.md:479
msgid ""
"retrieve the field from an attribute, possibly with a custom name specified "
"as an argument"
msgstr ""

#: src/conversions/traits.md:480
msgid "argument must be a string-literal."
msgstr ""

#: src/conversions/traits.md:481
msgid "`pyo3(item)`, `pyo3(item(\"key\"))`"
msgstr ""

#: src/conversions/traits.md:482
msgid ""
"retrieve the field from a mapping, possibly with the custom key specified as "
"an argument."
msgstr ""

#: src/conversions/traits.md:483
msgid "can be any literal that implements `ToBorrowedObject`"
msgstr ""

#: src/conversions/traits.md:484
msgid "`pyo3(from_py_with = \"...\")`"
msgstr ""

#: src/conversions/traits.md:485
msgid ""
"apply a custom function to convert the field from Python the desired Rust "
"type."
msgstr ""

#: src/conversions/traits.md:486
msgid "the argument must be the name of the function as a string."
msgstr ""

#: src/conversions/traits.md:487
msgid ""
"the function signature must be `fn(&Bound<PyAny>) -> PyResult<T>` where `T` "
"is the Rust type of the argument."
msgstr ""

#: src/conversions/traits.md:489
msgid "`IntoPy<T>`"
msgstr ""

#: src/conversions/traits.md:491
msgid ""
"This trait defines the to-python conversion for a Rust type. It is usually "
"implemented as `IntoPy<PyObject>`, which is the trait needed for returning a "
"value from `#[pyfunction]` and `#[pymethods]`."
msgstr ""

#: src/conversions/traits.md:495
msgid ""
"All types in PyO3 implement this trait, as does a `#[pyclass]` which doesn't "
"use `extends`."
msgstr ""

#: src/conversions/traits.md:497
msgid ""
"Occasionally you may choose to implement this for custom types which are "
"mapped to Python types _without_ having a unique python type."
msgstr ""

#: src/conversions/traits.md:512
msgid "The `ToPyObject` trait"
msgstr ""

#: src/conversions/traits.md:514
msgid ""
"[`ToPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.ToPyObject."
"html) is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://pyo3.rs/main/doc/pyo3/type.PyObject.html). "
"`IntoPy<PyObject>` serves the same purpose, except that it consumes `self`."
msgstr ""

#: src/conversions/tables.md:3
msgid ""
"When writing functions callable from Python (such as a `#[pyfunction]` or in "
"a `#[pymethods]` block), the trait `FromPyObject` is required for function "
"arguments, and `IntoPy<PyObject>` is required for function return values."
msgstr ""

#: src/conversions/tables.md:5
msgid ""
"Consult the tables in the following section to find the Rust types provided "
"by PyO3 which implement these traits."
msgstr ""

#: src/conversions/tables.md:7
msgid "Argument Types"
msgstr ""

#: src/conversions/tables.md:9
msgid ""
"When accepting a function argument, it is possible to either use Rust "
"library types or PyO3's Python-native types. (See the next section for "
"discussion on when to use each.)"
msgstr ""

#: src/conversions/tables.md:11
msgid ""
"The table below contains the Python type and the corresponding function "
"argument types that will accept them:"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust (Python-native)"
msgstr ""

#: src/conversions/tables.md:15
msgid "`object`"
msgstr ""

#: src/conversions/tables.md:15 src/conversions/tables.md:22
#: src/conversions/tables.md:29 src/conversions/tables.md:30
#: src/conversions/tables.md:31 src/conversions/tables.md:32
#: src/conversions/tables.md:38 src/conversions/tables.md:39
#: src/conversions/tables.md:40 src/conversions/tables.md:43
#: src/conversions/tables.md:46 src/conversions/tables.md:47
msgid "\\-"
msgstr ""

#: src/conversions/tables.md:15
msgid "`PyAny`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:86
#: src/conversions/tables.md:87
msgid "`str`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`String`, `Cow<str>`, `&str`, `char`, `OsString`, `PathBuf`, `Path`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:41
#: src/conversions/tables.md:42
msgid "`PyString`, `PyUnicode`"
msgstr ""

#: src/conversions/tables.md:17 src/conversions/tables.md:94
msgid "`bytes`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`Vec<u8>`, `&[u8]`, `Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`PyBytes`"
msgstr ""

#: src/conversions/tables.md:18 src/conversions/tables.md:88
msgid "`bool`"
msgstr ""

#: src/conversions/tables.md:18
msgid "`PyBool`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:89
msgid "`int`"
msgstr ""

#: src/conversions/tables.md:19
msgid ""
"`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, "
"`isize`, `usize`, `num_bigint::BigInt`[^1], `num_bigint::BigUint`[^1]"
msgstr ""

#: src/conversions/tables.md:19
msgid "`PyLong`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:90
msgid "`float`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:90
msgid "`f32`, `f64`"
msgstr ""

#: src/conversions/tables.md:20
msgid "`PyFloat`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`complex`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`num_complex::Complex`[^2]"
msgstr ""

#: src/conversions/tables.md:21
msgid "`PyComplex`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`fractions.Fraction`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`num_rational::Ratio`[^8]"
msgstr ""

#: src/conversions/tables.md:23
msgid "`list[T]`"
msgstr ""

#: src/conversions/tables.md:23 src/conversions/tables.md:44
#: src/conversions/tables.md:93
msgid "`Vec<T>`"
msgstr ""

#: src/conversions/tables.md:23
msgid "`PyList`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:24 src/conversions/tables.md:45
msgid ""
"`HashMap<K, V>`, `BTreeMap<K, V>`, `hashbrown::HashMap<K, V>`[^3], "
"`indexmap::IndexMap<K, V>`[^4]"
msgstr ""

#: src/conversions/tables.md:24
msgid "`PyDict`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`(T, U)`, `Vec<T>`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`PyTuple`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`set[T]`"
msgstr ""

#: src/conversions/tables.md:26 src/conversions/tables.md:27
msgid "`HashSet<T>`, `BTreeSet<T>`, `hashbrown::HashSet<T>`[^3]"
msgstr ""

#: src/conversions/tables.md:26
msgid "`PySet`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`frozenset[T]`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`PyFrozenSet`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`bytearray`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`Vec<u8>`, `Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`PyByteArray`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`slice`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`PySlice`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`type`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`PyType`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`module`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`PyModule`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`collections.abc.Buffer`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`PyBuffer<T>`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`datetime.datetime`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`SystemTime`, `chrono::DateTime<Tz>`[^5], `chrono::NaiveDateTime`[^5]"
msgstr ""

#: src/conversions/tables.md:33
msgid "`PyDateTime`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`datetime.date`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`chrono::NaiveDate`[^5]"
msgstr ""

#: src/conversions/tables.md:34
msgid "`PyDate`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`datetime.time`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`chrono::NaiveTime`[^5]"
msgstr ""

#: src/conversions/tables.md:35
msgid "`PyTime`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`datetime.tzinfo`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`chrono::FixedOffset`[^5], `chrono::Utc`[^5], `chrono_tz::TimeZone`[^6]"
msgstr ""

#: src/conversions/tables.md:36
msgid "`PyTzInfo`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`datetime.timedelta`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`Duration`, `chrono::Duration`[^5]"
msgstr ""

#: src/conversions/tables.md:37
msgid "`PyDelta`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`decimal.Decimal`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`rust_decimal::Decimal`[^7]"
msgstr ""

#: src/conversions/tables.md:39
msgid "`ipaddress.IPv4Address`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`std::net::IpAddr`, `std::net::IpV4Addr`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`ipaddress.IPv6Address`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`std::net::IpAddr`, `std::net::IpV6Addr`"
msgstr ""

#: src/conversions/tables.md:41
msgid "`os.PathLike `"
msgstr ""

#: src/conversions/tables.md:41 src/conversions/tables.md:42
msgid "`PathBuf`, `Path`"
msgstr ""

#: src/conversions/tables.md:42
msgid "`pathlib.Path`"
msgstr ""

#: src/conversions/tables.md:43
msgid "`typing.Optional[T]`"
msgstr ""

#: src/conversions/tables.md:43 src/conversions/tables.md:91
msgid "`Option<T>`"
msgstr ""

#: src/conversions/tables.md:44
msgid "`typing.Sequence[T]`"
msgstr ""

#: src/conversions/tables.md:44
msgid "`PySequence`"
msgstr ""

#: src/conversions/tables.md:45
msgid "`typing.Mapping[K, V]`"
msgstr ""

#: src/conversions/tables.md:45
msgid "`&PyMapping`"
msgstr ""

#: src/conversions/tables.md:46
msgid "`typing.Iterator[Any]`"
msgstr ""

#: src/conversions/tables.md:46
msgid "`PyIterator`"
msgstr ""

#: src/conversions/tables.md:47
msgid "`typing.Union[...]`"
msgstr ""

#: src/conversions/tables.md:47
msgid ""
"See [`#[derive(FromPyObject)]`](traits.md#deriving-frompyobject-for-enums)"
msgstr ""

#: src/conversions/tables.md:49
msgid "It is also worth remembering the following special types:"
msgstr ""

#: src/conversions/tables.md:51
msgid "What"
msgstr ""

#: src/conversions/tables.md:51
msgid "Description"
msgstr ""

#: src/conversions/tables.md:53
msgid "`Python<'py>`"
msgstr ""

#: src/conversions/tables.md:53
msgid ""
"A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL."
msgstr ""

#: src/conversions/tables.md:54
msgid ""
"A Python object connected to the GIL lifetime. This provides access to most "
"of PyO3's APIs."
msgstr ""

#: src/conversions/tables.md:55 src/conversions/tables.md:99
msgid "`Py<T>`"
msgstr ""

#: src/conversions/tables.md:55
msgid ""
"A Python object isolated from the GIL lifetime. This can be sent to other "
"threads."
msgstr ""

#: src/conversions/tables.md:56
msgid "`PyObject`"
msgstr ""

#: src/conversions/tables.md:56
msgid "An alias for `Py<PyAny>`"
msgstr ""

#: src/conversions/tables.md:57
msgid "`PyRef<T>`"
msgstr ""

#: src/conversions/tables.md:57
msgid "A `#[pyclass]` borrowed immutably."
msgstr ""

#: src/conversions/tables.md:58
msgid "`PyRefMut<T>`"
msgstr ""

#: src/conversions/tables.md:58
msgid "A `#[pyclass]` borrowed mutably."
msgstr ""

#: src/conversions/tables.md:60
msgid ""
"For more detail on accepting `#[pyclass]` values as function arguments, see "
"[the section of this guide on Python Classes](../class.md)."
msgstr ""

#: src/conversions/tables.md:62
msgid "Using Rust library types vs Python-native types"
msgstr ""

#: src/conversions/tables.md:64
msgid ""
"Using Rust library types as function arguments will incur a conversion cost "
"compared to using the Python-native types. Using the Python-native types is "
"almost zero-cost (they just require a type check similar to the Python "
"builtin function `isinstance()`)."
msgstr ""

#: src/conversions/tables.md:66
msgid ""
"However, once that conversion cost has been paid, the Rust standard library "
"types offer a number of benefits:"
msgstr ""

#: src/conversions/tables.md:67
msgid ""
"You can write functionality in native-speed Rust code (free of Python's "
"runtime costs)."
msgstr ""

#: src/conversions/tables.md:68
msgid "You get better interoperability with the rest of the Rust ecosystem."
msgstr ""

#: src/conversions/tables.md:69
msgid ""
"You can use `Python::allow_threads` to release the Python GIL and let other "
"Python threads make progress while your Rust code is executing."
msgstr ""

#: src/conversions/tables.md:70
msgid ""
"You also benefit from stricter type checking. For example you can specify "
"`Vec<i32>`, which will only accept a Python `list` containing integers. The "
"Python-native equivalent, `&PyList`, would accept a Python `list` containing "
"Python objects of any type."
msgstr ""

#: src/conversions/tables.md:72
msgid ""
"For most PyO3 usage the conversion cost is worth paying to get these "
"benefits. As always, if you're not sure it's worth it in your case, "
"benchmark it!"
msgstr ""

#: src/conversions/tables.md:74
msgid "Returning Rust values to Python"
msgstr ""

#: src/conversions/tables.md:76
msgid ""
"When returning values from functions callable from Python, [PyO3's smart "
"pointers](../types.md#pyo3s-smart-pointers) (`Py<T>`, `Bound<'py, T>`, and "
"`Borrowed<'a, 'py, T>`) can be used with zero cost."
msgstr ""

#: src/conversions/tables.md:78
msgid ""
"Because `Bound<'py, T>` and `Borrowed<'a, 'py, T>` have lifetime parameters, "
"the Rust compiler may ask for lifetime annotations to be added to your "
"function. See the [section of the guide dedicated to this](../types."
"md#function-argument-lifetimes)."
msgstr ""

#: src/conversions/tables.md:80
msgid ""
"If your function is fallible, it should return `PyResult<T>` or `Result<T, "
"E>` where `E` implements `From<E> for PyErr`. This will raise a `Python` "
"exception if the `Err` variant is returned."
msgstr ""

#: src/conversions/tables.md:82
msgid ""
"Finally, the following Rust types are also able to convert to Python as "
"return values:"
msgstr ""

#: src/conversions/tables.md:84
msgid "Rust type"
msgstr ""

#: src/conversions/tables.md:84
msgid "Resulting Python Type"
msgstr ""

#: src/conversions/tables.md:86
msgid "`String`"
msgstr ""

#: src/conversions/tables.md:87
msgid "`&str`"
msgstr ""

#: src/conversions/tables.md:89
msgid "Any integer type (`i32`, `u32`, `usize`, etc)"
msgstr ""

#: src/conversions/tables.md:91
msgid "`Optional[T]`"
msgstr ""

#: src/conversions/tables.md:92
msgid "`(T, U)`"
msgstr ""

#: src/conversions/tables.md:92
msgid "`Tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:93
msgid "`List[T]`"
msgstr ""

#: src/conversions/tables.md:94
msgid "`Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:95
msgid "`HashMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:95 src/conversions/tables.md:96
msgid "`Dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:96
msgid "`BTreeMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:97
msgid "`HashSet<T>`"
msgstr ""

#: src/conversions/tables.md:97 src/conversions/tables.md:98
msgid "`Set[T]`"
msgstr ""

#: src/conversions/tables.md:98
msgid "`BTreeSet<T>`"
msgstr ""

#: src/conversions/tables.md:99 src/conversions/tables.md:100
#: src/conversions/tables.md:101 src/conversions/tables.md:102
msgid "`T`"
msgstr ""

#: src/conversions/tables.md:100
msgid "`Bound<T>`"
msgstr ""

#: src/conversions/tables.md:101
msgid "`PyRef<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:102
msgid "`PyRefMut<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:104
msgid "Requires the `num-bigint` optional feature."
msgstr ""

#: src/conversions/tables.md:106
msgid "Requires the `num-complex` optional feature."
msgstr ""

#: src/conversions/tables.md:108
msgid "Requires the `hashbrown` optional feature."
msgstr ""

#: src/conversions/tables.md:110
msgid "Requires the `indexmap` optional feature."
msgstr ""

#: src/conversions/tables.md:112
msgid "Requires the `chrono` optional feature."
msgstr ""

#: src/conversions/tables.md:114
msgid "Requires the `chrono-tz` optional feature."
msgstr ""

#: src/conversions/tables.md:116
msgid "Requires the `rust_decimal` optional feature."
msgstr ""

#: src/conversions/tables.md:118
msgid "Requires the `num-rational` optional feature."
msgstr ""

#: src/ecosystem.md:1
msgid "The PyO3 ecosystem"
msgstr ""

#: src/ecosystem.md:3
msgid ""
"This portion of the guide is dedicated to crates which are external to the "
"main PyO3 project and provide additional functionality you might find useful."
msgstr ""

#: src/ecosystem.md:5
msgid ""
"Because these projects evolve independently of the PyO3 repository the "
"content of these articles may fall out of date over time; please file issues "
"on the PyO3 GitHub to alert maintainers when this is the case."
msgstr ""

#: src/ecosystem/logging.md:3
msgid ""
"It is desirable if both the Python and Rust parts of the application end up "
"logging using the same configuration into the same place."
msgstr ""

#: src/ecosystem/logging.md:6
msgid ""
"This section of the guide briefly discusses how to connect the two "
"languages' logging ecosystems together. The recommended way for Python "
"extension modules is to configure Rust's logger to send log messages to "
"Python using the `pyo3-log` crate. For users who want to do the opposite and "
"send Python log messages to Rust, see the note at the end of this guide."
msgstr ""

#: src/ecosystem/logging.md:12
msgid "Using `pyo3-log` to send Rust log messages to Python"
msgstr ""

#: src/ecosystem/logging.md:14
msgid ""
"The [pyo3-log](https://crates.io/crates/pyo3-log) crate allows sending the "
"messages from the Rust side to Python's [logging](https://docs.python.org/3/"
"library/logging.html) system. This is mostly suitable for writing native "
"extensions for Python programs."
msgstr ""

#: src/ecosystem/logging.md:18
msgid ""
"Use [`pyo3_log::init`](https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html) to "
"install the logger in its default configuration. It's also possible to tweak "
"its configuration (mostly to tune its performance)."
msgstr ""

#: src/ecosystem/logging.md:27
msgid ""
"// This will use the logger installed in `my_module` to send the `info`\n"
"    // message to the Python logging facilities.\n"
msgstr ""

#: src/ecosystem/logging.md:29
msgid "\"Something!\""
msgstr ""

#: src/ecosystem/logging.md:34
msgid "// A good place to install the Rust -> Python logger.\n"
msgstr ""

#: src/ecosystem/logging.md:42
msgid ""
"Then it is up to the Python side to actually output the messages somewhere."
msgstr ""

#: src/ecosystem/logging.md:48
msgid ""
"'%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'"
msgstr ""

#: src/ecosystem/logging.md:54
msgid ""
"It is important to initialize the Python loggers first, before calling any "
"Rust functions that may log. This limitation can be worked around if it is "
"not possible to satisfy, read the documentation about [caching](https://docs."
"rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching)."
msgstr ""

#: src/ecosystem/logging.md:58
msgid "The Python to Rust direction"
msgstr ""

#: src/ecosystem/logging.md:60
msgid ""
"To have python logs be handled by Rust, one need only register a rust "
"function to handle logs emitted from the core python logging module."
msgstr ""

#: src/ecosystem/logging.md:62
msgid ""
"This has been implemented within the [pyo3-pylogger](https://crates.io/"
"crates/pyo3-pylogger) crate."
msgstr ""

#: src/ecosystem/logging.md:69
msgid ""
"// register the host handler with python logger, providing a logger target\n"
"    // set the name here to something appropriate for your application\n"
msgstr ""

#: src/ecosystem/logging.md:71
msgid "\"example_application_py_logger\""
msgstr ""

#: src/ecosystem/logging.md:73
msgid "// initialize up a logger\n"
msgstr ""

#: src/ecosystem/logging.md:74
msgid "\"trace\""
msgstr ""

#: src/ecosystem/logging.md:76
msgid "// Log some messages from Rust.\n"
msgstr ""

#: src/ecosystem/logging.md:77
msgid "\"Just some normal information!\""
msgstr ""

#: src/ecosystem/logging.md:78
msgid "\"Something spooky happened!\""
msgstr ""

#: src/ecosystem/logging.md:80
msgid "// Log some messages from Python\n"
msgstr ""

#: src/ecosystem/logging.md:83
msgid ""
"\"\n"
"import logging\n"
"logging.error('Something bad happened')\n"
"\""
msgstr ""

#: src/ecosystem/async-await.md:3
msgid ""
"_`async`/`await` support is currently being integrated in PyO3. See the "
"[dedicated documentation](../async-await.md)_"
msgstr ""

#: src/ecosystem/async-await.md:5
msgid ""
"If you are working with a Python library that makes use of async functions "
"or wish to provide Python bindings for an async Rust library, [`pyo3-"
"asyncio`](https://github.com/awestlake87/pyo3-asyncio) likely has the tools "
"you need. It provides conversions between async functions in both Python and "
"Rust and was designed with first-class support for popular Rust runtimes "
"such as [`tokio`](https://tokio.rs/) and [`async-std`](https://async.rs/). "
"In addition, all async Python code runs on the default `asyncio` event loop, "
"so `pyo3-asyncio` should work just fine with existing Python libraries."
msgstr ""

#: src/ecosystem/async-await.md:13
msgid ""
"In the following sections, we'll give a general overview of `pyo3-asyncio` "
"explaining how to call async Python functions with PyO3, how to call async "
"Rust functions from Python, and how to configure your codebase to manage the "
"runtimes of both."
msgstr ""

#: src/ecosystem/async-await.md:17
msgid "Quickstart"
msgstr ""

#: src/ecosystem/async-await.md:19
msgid ""
"Here are some examples to get you started right away! A more detailed "
"breakdown of the concepts in these examples can be found in the following "
"sections."
msgstr ""

#: src/ecosystem/async-await.md:22
msgid "Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:23
msgid ""
"Here we initialize the runtime, import Python's `asyncio` library and run "
"the given future to completion using Python's default `EventLoop` and `async-"
"std`. Inside the future, we convert `asyncio` sleep into a Rust future and "
"await it."
msgstr ""

#: src/ecosystem/async-await.md:26
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"async-std-"
"runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:35 src/ecosystem/async-await.md:65
#: src/ecosystem/async-await.md:520
msgid "//! main.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:42 src/ecosystem/async-await.md:72
#: src/ecosystem/async-await.md:381
msgid "\"asyncio\""
msgstr ""

#: src/ecosystem/async-await.md:43 src/ecosystem/async-await.md:73
#: src/ecosystem/async-await.md:383
msgid "// convert asyncio.sleep into a Rust Future\n"
msgstr ""

#: src/ecosystem/async-await.md:44 src/ecosystem/async-await.md:74
#: src/ecosystem/async-await.md:385
msgid "\"sleep\""
msgstr ""

#: src/ecosystem/async-await.md:53
msgid ""
"The same application can be written to use `tokio` instead using the "
"`#[pyo3_asyncio::tokio::main]` attribute."
msgstr ""

#: src/ecosystem/async-await.md:56
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"tokio-"
"runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:83
msgid ""
"More details on the usage of this library can be found in the [API docs]"
"(https://awestlake87.github.io/pyo3-asyncio/master/doc) and the primer below."
msgstr ""

#: src/ecosystem/async-await.md:85
msgid "PyO3 Native Rust Modules"
msgstr ""

#: src/ecosystem/async-await.md:87
msgid ""
"PyO3 Asyncio can also be used to write native modules with async functions."
msgstr ""

#: src/ecosystem/async-await.md:89
msgid ""
"Add the `[lib]` section to `Cargo.toml` to make your library a `cdylib` that "
"Python can import."
msgstr ""

#: src/ecosystem/async-await.md:90
msgid ""
"```toml\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:96
msgid ""
"Make your project depend on `pyo3` with the `extension-module` feature "
"enabled and select your `pyo3-asyncio` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:99
msgid "For `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:100
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:107
msgid "For `tokio`:"
msgstr ""

#: src/ecosystem/async-await.md:108
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:115
msgid "Export an async function that makes use of `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:118 src/ecosystem/async-await.md:139
#: src/ecosystem/async-await.md:462
msgid "//! lib.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:136
msgid ""
"If you want to use `tokio` instead, here's what your module should look like:"
msgstr ""

#: src/ecosystem/async-await.md:157
msgid ""
"You can build your module with maturin (see the [Using Rust in Python]"
"(https://pyo3.rs/main/#using-rust-from-python) section in the PyO3 guide for "
"setup instructions). After that you should be able to run the Python REPL to "
"try it out."
msgstr ""

#: src/ecosystem/async-await.md:166 src/ecosystem/async-await.md:489
msgid "\"help\""
msgstr ""

#: src/ecosystem/async-await.md:166 src/ecosystem/async-await.md:489
msgid "\"copyright\""
msgstr ""

#: src/ecosystem/async-await.md:166 src/ecosystem/async-await.md:489
msgid "\"credits\""
msgstr ""

#: src/ecosystem/async-await.md:166 src/ecosystem/async-await.md:489
msgid "\"license\""
msgstr ""

#: src/ecosystem/async-await.md:179
msgid "Awaiting an Async Python Function in Rust"
msgstr ""

#: src/ecosystem/async-await.md:181
msgid "Let's take a look at a dead simple async Python function:"
msgstr ""

#: src/ecosystem/async-await.md:184
msgid "# Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:189
msgid ""
"**Async functions in Python are simply functions that return a `coroutine` "
"object**. For our purposes, we really don't need to know much about these "
"`coroutine` objects. The key factor here is that calling an `async` function "
"is _just like calling a regular function_, the only difference is that we "
"have to do something special with the object that it returns."
msgstr ""

#: src/ecosystem/async-await.md:194
msgid ""
"Normally in Python, that something special is the `await` keyword, but in "
"order to await this coroutine in Rust, we first need to convert it into "
"Rust's version of a `coroutine`: a `Future`. That's where `pyo3-asyncio` "
"comes in. [`pyo3_asyncio::async_std::into_future`](https://docs.rs/pyo3-"
"asyncio/latest/pyo3_asyncio/async_std/fn.into_future.html) performs this "
"conversion for us."
msgstr ""

#: src/ecosystem/async-await.md:200
msgid ""
"The following example uses `into_future` to call the `py_sleep` function "
"shown above and then await the coroutine object returned from the call:"
msgstr ""

#: src/ecosystem/async-await.md:209
msgid "// import the module containing the py_sleep function\n"
msgstr ""

#: src/ecosystem/async-await.md:212
msgid ""
"// calling the py_sleep method like a normal function\n"
"        // returns a coroutine\n"
msgstr ""

#: src/ecosystem/async-await.md:214
msgid "\"py_sleep\""
msgstr ""

#: src/ecosystem/async-await.md:216
msgid ""
"// convert the coroutine into a Rust future using the\n"
"        // tokio runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:221 src/ecosystem/async-await.md:239
#: src/ecosystem/async-await.md:270
msgid "// await the future\n"
msgstr ""

#: src/ecosystem/async-await.md:228
msgid ""
"Alternatively, the below example shows how to write a `#[pyfunction]` which "
"uses `into_future` to receive and await a coroutine argument:"
msgstr ""

#: src/ecosystem/async-await.md:234 src/ecosystem/async-await.md:265
msgid ""
"// convert the coroutine into a Rust future using the\n"
"    // async_std runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:246
msgid "This could be called from Python as:"
msgstr ""

#: src/ecosystem/async-await.md:257
msgid ""
"If you wanted to pass a callable function to the `#[pyfunction]` instead, (i."
"e. the last line becomes `await_coro(py_sleep))`, then the above example "
"needs to be tweaked to first call the callable to get the coroutine:"
msgstr ""

#: src/ecosystem/async-await.md:262
msgid "// get the coroutine by calling the callable\n"
msgstr ""

#: src/ecosystem/async-await.md:277
msgid ""
"This can be particularly helpful where you need to repeatedly create and "
"await a coroutine. Trying to await the same coroutine multiple times will "
"raise an error:"
msgstr ""

#: src/ecosystem/async-await.md:283
msgid ""
"If you're interested in learning more about `coroutines` and `awaitables` in "
"general, check out the [Python 3 `asyncio` docs](https://docs.python.org/3/"
"library/asyncio-task.html) for more information."
msgstr ""

#: src/ecosystem/async-await.md:286
msgid "Awaiting a Rust Future in Python"
msgstr ""

#: src/ecosystem/async-await.md:288
msgid ""
"Here we have the same async function as before written in Rust using the "
"[`async-std`](https://async.rs/) runtime:"
msgstr ""

#: src/ecosystem/async-await.md:292
msgid "/// Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:298
msgid ""
"Similar to Python, Rust's async functions also return a special object "
"called a `Future`:"
msgstr ""

#: src/ecosystem/async-await.md:305
msgid ""
"We can convert this `Future` object into Python to make it `awaitable`. This "
"tells Python that you can use the `await` keyword with it. In order to do "
"this, we'll call [`pyo3_asyncio::async_std::future_into_py`](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html):"
msgstr ""

#: src/ecosystem/async-await.md:325
msgid ""
"In Python, we can call this pyo3 function just like any other async function:"
msgstr ""

#: src/ecosystem/async-await.md:334
msgid "Managing Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:336
msgid ""
"Python's event loop requires some special treatment, especially regarding "
"the main thread. Some of Python's `asyncio` features, like proper signal "
"handling, require control over the main thread, which doesn't always play "
"well with Rust."
msgstr ""

#: src/ecosystem/async-await.md:340
msgid ""
"Luckily, Rust's event loops are pretty flexible and don't _need_ control "
"over the main thread, so in `pyo3-asyncio`, we decided the best way to "
"handle Rust/Python interop was to just surrender the main thread to Python "
"and run Rust's event loops in the background. Unfortunately, since most "
"event loop implementations _prefer_ control over the main thread, this can "
"still make some things awkward."
msgstr ""

#: src/ecosystem/async-await.md:345
msgid "PyO3 Asyncio Initialization"
msgstr ""

#: src/ecosystem/async-await.md:347
msgid ""
"Because Python needs to control the main thread, we can't use the convenient "
"proc macros from Rust runtimes to handle the `main` function or `#[test]` "
"functions. Instead, the initialization for PyO3 has to be done from the "
"`main` function and the main thread must block on [`pyo3_asyncio::async_std::"
"run_until_complete`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/"
"async_std/fn.run_until_complete.html)."
msgstr ""

#: src/ecosystem/async-await.md:351
msgid ""
"Because we have to block on one of those functions, we can't use "
"[`#[async_std::main]`](https://docs.rs/async-std/latest/async_std/attr.main."
"html) or [`#[tokio::main]`](https://docs.rs/tokio/1.1.0/tokio/attr.main."
"html) since it's not a good idea to make long blocking calls during an async "
"function."
msgstr ""

#: src/ecosystem/async-await.md:354
msgid ""
"Internally, these `#[main]` proc macros are expanded to something like this:"
msgstr ""

#: src/ecosystem/async-await.md:357
msgid "// your async main fn\n"
msgstr ""

#: src/ecosystem/async-await.md:362
msgid ""
"Making a long blocking call inside the `Future` that's being driven by "
"`block_on` prevents that thread from doing anything else and can spell "
"trouble for some runtimes (also this will actually deadlock a single-"
"threaded runtime!). Many runtimes have some sort of `spawn_blocking` "
"mechanism that can avoid this problem, but again that's not something we can "
"use here since we need it to block on the _main_ thread."
msgstr ""

#: src/ecosystem/async-await.md:368
msgid ""
"For this reason, `pyo3-asyncio` provides its own set of proc macros to "
"provide you with this initialization. These macros are intended to mirror "
"the initialization of `async-std` and `tokio` while also satisfying the "
"Python runtime's needs."
msgstr ""

#: src/ecosystem/async-await.md:372
msgid ""
"Here's a full example of PyO3 initialization with the `async-std` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:378
msgid "// PyO3 is initialized - Ready to go\n"
msgstr ""

#: src/ecosystem/async-await.md:395
msgid "A Note About `asyncio.run`"
msgstr ""

#: src/ecosystem/async-await.md:397
msgid ""
"In Python 3.7+, the recommended way to run a top-level coroutine with "
"`asyncio` is with `asyncio.run`. In `v0.13` we recommended against using "
"this function due to initialization issues, but in `v0.14` it's perfectly "
"valid to use this function... with a caveat."
msgstr ""

#: src/ecosystem/async-await.md:400
msgid ""
"Since our Rust \\<\\--> Python conversions require a reference to the Python "
"event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that "
"defines a `rust_sleep` function like in previous examples. You might "
"rightfully assume that you can call pass this directly into `asyncio.run` "
"like this:"
msgstr ""

#: src/ecosystem/async-await.md:411
msgid "You might be surprised to find out that this throws an error:"
msgstr ""

#: src/ecosystem/async-await.md:414
msgid "\"example.py\""
msgstr ""

#: src/ecosystem/async-await.md:419
msgid ""
"What's happening here is that we are calling `rust_sleep` _before_ the "
"future is actually running on the event loop created by `asyncio.run`. This "
"is counter-intuitive, but expected behaviour, and unfortunately there "
"doesn't seem to be a good way of solving this problem within PyO3 Asyncio "
"itself."
msgstr ""

#: src/ecosystem/async-await.md:422
msgid "However, we can make this example work with a simple workaround:"
msgstr ""

#: src/ecosystem/async-await.md:428
msgid ""
"# Calling main will just construct the coroutine that later calls "
"rust_sleep.\n"
"# - This ensures that rust_sleep will be called when the event loop is "
"running,\n"
"#   not before.\n"
msgstr ""

#: src/ecosystem/async-await.md:434
msgid "# Run the main() coroutine at the top-level instead\n"
msgstr ""

#: src/ecosystem/async-await.md:439
msgid "Non-standard Python Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:441
msgid ""
"Python allows you to use alternatives to the default `asyncio` event loop. "
"One popular alternative is `uvloop`. In `v0.13` using non-standard event "
"loops was a bit of an ordeal, but in `v0.14` it's trivial."
msgstr ""

#: src/ecosystem/async-await.md:445
msgid "Using `uvloop` in a PyO3 Asyncio Native Extensions"
msgstr ""

#: src/ecosystem/async-await.md:447
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"async-std = \"1.9\"\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:504
msgid "Using `uvloop` in Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:506
msgid ""
"Using `uvloop` in Rust applications is a bit trickier, but it's still "
"possible with relatively few modifications."
msgstr ""

#: src/ecosystem/async-await.md:509
msgid ""
"Unfortunately, we can't make use of the `#[pyo3_asyncio::<runtime>::main]` "
"attribute with non-standard event loops. This is because the "
"`#[pyo3_asyncio::<runtime>::main]` proc macro has to interact with the "
"Python event loop before we can install the `uvloop` policy."
msgstr ""

#: src/ecosystem/async-await.md:512
msgid ""
"```toml\n"
"[dependencies]\n"
"async-std = \"1.9\"\n"
"pyo3 = \"0.14\"\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:528
msgid "\"uvloop\""
msgstr ""

#: src/ecosystem/async-await.md:529
msgid "\"install\""
msgstr ""

#: src/ecosystem/async-await.md:531
msgid "// store a reference for the assertion\n"
msgstr ""

#: src/ecosystem/async-await.md:535
msgid "// verify that we are on a uvloop.Loop\n"
msgstr ""

#: src/ecosystem/async-await.md:540
msgid "\"Loop\""
msgstr ""

#: src/ecosystem/async-await.md:553
msgid "Additional Information"
msgstr ""

#: src/ecosystem/async-await.md:554
msgid ""
"Managing event loop references can be tricky with pyo3-asyncio. See [Event "
"Loop References](https://docs.rs/pyo3-asyncio/#event-loop-references) in the "
"API docs to get a better intuition for how event loop references are managed "
"in this library."
msgstr ""

#: src/ecosystem/async-await.md:555
msgid ""
"Testing pyo3-asyncio libraries and applications requires a custom test "
"harness since Python requires control over the main thread. You can find a "
"testing guide in the [API docs for the `testing` module](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/testing)"
msgstr ""

#: src/async-await.md:3
msgid ""
"_This feature is still in active development. See [the related issue]"
"(https://github.com/PyO3/pyo3/issues/1632)._"
msgstr ""

#: src/async-await.md:5
msgid "`#[pyfunction]` and `#[pymethods]` attributes also support `async fn`."
msgstr ""

#: src/async-await.md:9 src/async-await.md:82
msgid "\"experimental-async\""
msgstr ""

#: src/async-await.md:28
msgid ""
"_Python awaitables instantiated with this method can only be awaited in "
"_asyncio_ context. Other Python async runtime may be supported in the future."
"_"
msgstr ""

#: src/async-await.md:30
msgid "`Send + 'static` constraint"
msgstr ""

#: src/async-await.md:32
msgid ""
"Resulting future of an `async fn` decorated by `#[pyfunction]` must be `Send "
"+ 'static` to be embedded in a Python object."
msgstr ""

#: src/async-await.md:34
msgid ""
"As a consequence, `async fn` parameters and return types must also be `Send "
"+ 'static`, so it is not possible to have a signature like `async fn "
"does_not_compile<'py>(arg: Bound<'py, PyAny>) -> Bound<'py, PyAny>`."
msgstr ""

#: src/async-await.md:36
msgid ""
"However, there is an exception for method receivers, so async methods can "
"accept `&self`/`&mut self`. Note that this means that the class instance is "
"borrowed for as long as the returned future is not completed, even across "
"yield points and while waiting for I/O operations to complete. Hence, other "
"methods cannot obtain exclusive borrows while the future is still being "
"polled. This is the same as how async methods in Rust generally work but it "
"is more problematic for Rust code interfacing with Python code due to "
"pervasive shared mutability. This strongly suggests to prefer shared borrows "
"`&self` over exclusive ones `&mut self` to avoid racy borrow check failures "
"at runtime."
msgstr ""

#: src/async-await.md:38
msgid "Implicit GIL holding"
msgstr ""

#: src/async-await.md:40
msgid ""
"Even if it is not possible to pass a `py: Python<'py>` parameter to `async "
"fn`, the GIL is still held during the execution of the future ‚Äì it's also "
"the case for regular `fn` without `Python<'py>`/`Bound<'py, PyAny>` "
"parameter, yet the GIL is held."
msgstr ""

#: src/async-await.md:42
msgid ""
"It is still possible to get a `Python` marker using [`Python::with_gil`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.with_gil); "
"because `with_gil` is reentrant and optimized, the cost will be negligible."
msgstr ""

#: src/async-await.md:44
msgid "Release the GIL across `.await`"
msgstr ""

#: src/async-await.md:46
msgid ""
"There is currently no simple way to release the GIL when awaiting a future, "
"_but solutions are currently in development_."
msgstr ""

#: src/async-await.md:48
msgid "Here is the advised workaround for now:"
msgstr ""

#: src/async-await.md:76
msgid "Cancellation"
msgstr ""

#: src/async-await.md:78
msgid ""
"Cancellation on the Python side can be caught using [`CancelHandle`](https://"
"pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html) type, by "
"annotating a function parameter with `#[pyo3(cancel_handle)]`."
msgstr ""

#: src/async-await.md:90
msgid "/* _ = ... => println!(\"done\"), */"
msgstr ""

#: src/async-await.md:91
msgid "\"cancelled\""
msgstr ""

#: src/async-await.md:97
msgid "The `Coroutine` type"
msgstr ""

#: src/async-await.md:99
msgid ""
"To make a Rust future awaitable in Python, PyO3 defines a [`Coroutine`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.Coroutine.html) type, which "
"implements the Python [coroutine protocol](https://docs.python.org/3/library/"
"collections.abc.html#collections.abc.Coroutine)."
msgstr ""

#: src/async-await.md:101
msgid ""
"Each `coroutine.send` call is translated to a `Future::poll` call. If a "
"[`CancelHandle`](https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle."
"html) parameter is declared, the exception passed to `coroutine.throw` call "
"is stored in it and can be retrieved with [`CancelHandle::cancelled`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html#method."
"cancelled); otherwise, it cancels the Rust future, and the exception is "
"reraised;"
msgstr ""

#: src/async-await.md:103
msgid ""
"_The type does not yet have a public constructor until the design is "
"finalized._"
msgstr ""

#: src/rust-from-python.md:3
msgid ""
"This chapter of the guide is dedicated to explaining how to wrap Rust code "
"into Python objects."
msgstr ""

#: src/rust-from-python.md:5
msgid ""
"PyO3 uses Rust's \"procedural macros\" to provide a powerful yet simple API "
"to denote what Rust code should map into Python objects."
msgstr ""

#: src/rust-from-python.md:7
msgid "The three types of Python objects which PyO3 can produce are:"
msgstr ""

#: src/rust-from-python.md:9
msgid "Python modules, via the `#[pymodule]` macro"
msgstr ""

#: src/rust-from-python.md:10
msgid "Python functions, via the `#[pyfunction]` macro"
msgstr ""

#: src/rust-from-python.md:11
msgid ""
"Python classes, via the `#[pyclass]` macro (plus `#[pymethods]` to define "
"methods for those clases)"
msgstr ""

#: src/rust-from-python.md:13
msgid "The following subchapters go through each of these in turn."
msgstr ""

#: src/class.md:3
msgid ""
"PyO3 exposes a group of attributes powered by Rust's proc macro system for "
"defining Python classes as Rust structs."
msgstr ""

#: src/class.md:5
msgid ""
"The main attribute is `#[pyclass]`, which is placed upon a Rust `struct` or "
"`enum` to generate a Python type for it. They will usually also have _one_ "
"`#[pymethods]`\\-annotated `impl` block for the struct, which is used to "
"define Python methods and constants for the generated Python type. (If the "
"[`multiple-pymethods`](features.md#multiple-pymethods) feature is enabled, "
"each `#[pyclass]` is allowed to have multiple `#[pymethods]` blocks.) "
"`#[pymethods]` may also have implementations for Python magic methods such "
"as `__str__`."
msgstr ""

#: src/class.md:7
msgid ""
"This chapter will discuss the functionality and configuration these "
"attributes offer. Below is a list of links to the relevant section of this "
"chapter for each:"
msgstr ""

#: src/class.md:9
msgid "[`#[pyclass]`](#defining-a-new-class)"
msgstr ""

#: src/class.md:10
msgid "[`#[pyo3(get, set)]`](#object-properties-using-pyo3get-set)"
msgstr ""

#: src/class.md:11
msgid "[`#[pymethods]`](#instance-methods)"
msgstr ""

#: src/class.md:12
msgid "[`#[new]`](#constructor)"
msgstr ""

#: src/class.md:13
msgid "[`#[getter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:14
msgid "[`#[setter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:15
msgid "[`#[staticmethod]`](#static-methods)"
msgstr ""

#: src/class.md:16
msgid "[`#[classmethod]`](#class-methods)"
msgstr ""

#: src/class.md:17
msgid "[`#[classattr]`](#class-attributes)"
msgstr ""

#: src/class.md:18
msgid "[`#[args]`](#method-arguments)"
msgstr ""

#: src/class.md:19
msgid "[Magic methods and slots](class/protocols.md)"
msgstr ""

#: src/class.md:20
msgid "[Classes as function arguments](#classes-as-function-arguments)"
msgstr ""

#: src/class.md:22
msgid "Defining a new class"
msgstr ""

#: src/class.md:24
msgid ""
"To define a custom Python class, add the `#[pyclass]` attribute to a Rust "
"struct or enum."
msgstr ""

#: src/class.md:33
msgid "// A \"tuple\" struct\n"
msgstr ""

#: src/class.md:37
msgid ""
"// PyO3 supports unit-only enums (which contain only unit variants)\n"
"// These simple enums behave similarly to Python's enumerations (enum.Enum)\n"
msgstr ""

#: src/class.md:44
msgid "// PyO3 supports custom discriminants.\n"
msgstr ""

#: src/class.md:46
msgid "// PyO3 supports custom discriminants in unit-only enums\n"
msgstr ""

#: src/class.md:54
msgid "// ...\n"
msgstr ""

#: src/class.md:56
msgid ""
"// PyO3 also supports enums with Struct and Tuple variants\n"
"// These complex enums have sligtly different behavior from the simple enums "
"above\n"
"// They are meant to work with instance checks and match statement patterns\n"
"// The variants can be mixed and matched\n"
"// Struct variants have named fields while tuple enums generate generic "
"names for fields in order _0, _1, _2, ...\n"
"// Apart from this both types are functionally identical\n"
msgstr ""

#: src/class.md:72
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html) and [`PyClass`](https://"
"pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html) for `MyClass`, `Number`, "
"`MyEnum`, `HttpResponse`, and `Shape`. To see these generated "
"implementations, refer to the [implementation details](#implementation-"
"details) at the end of this chapter."
msgstr ""

#: src/class.md:74
msgid "Restrictions"
msgstr ""

#: src/class.md:76
msgid ""
"To integrate Rust types with Python, PyO3 needs to place some restrictions "
"on the types which can be annotated with `#[pyclass]`. In particular, they "
"must have no lifetime parameters, no generic parameters, and must implement "
"`Send`. The reason for each of these is explained below."
msgstr ""

#: src/class.md:78
msgid "No lifetime parameters"
msgstr ""

#: src/class.md:80
msgid ""
"Rust lifetimes are used by the Rust compiler to reason about a program's "
"memory safety. They are a compile-time only concept; there is no way to "
"access Rust lifetimes at runtime from a dynamic language like Python."
msgstr ""

#: src/class.md:82
msgid ""
"As soon as Rust data is exposed to Python, there is no guarantee that the "
"Rust compiler can make on how long the data will live. Python is a reference-"
"counted language and those references can be held for an arbitrarily long "
"time which is untraceable by the Rust compiler. The only possible way to "
"express this correctly is to require that any `#[pyclass]` does not borrow "
"data for any lifetime shorter than the `'static` lifetime, i.e. the "
"`#[pyclass]` cannot have any lifetime parameters."
msgstr ""

#: src/class.md:84
msgid ""
"When you need to share ownership of data between Python and Rust, instead of "
"using borrowed references with lifetimes consider using reference-counted "
"smart pointers such as [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc."
"html) or [`Py`](https://pyo3.rs/main/doc/pyo3/struct.Py.html)."
msgstr ""

#: src/class.md:86
msgid "No generic parameters"
msgstr ""

#: src/class.md:88
msgid ""
"A Rust `struct Foo<T>` with a generic parameter `T` generates new compiled "
"implementations each time it is used with a different concrete type for `T`. "
"These new implementations are generated by the compiler at each usage site. "
"This is incompatible with wrapping `Foo` in Python, where there needs to be "
"a single compiled implementation of `Foo` which is integrated with the "
"Python interpreter."
msgstr ""

#: src/class.md:90
msgid ""
"Currently, the best alternative is to write a macro which expands to a new "
"`#[pyclass]` for each instantiation you want:"
msgstr ""

#: src/class.md:122
msgid "Must be Send"
msgstr ""

#: src/class.md:124
msgid ""
"Because Python objects are freely shared between threads by the Python "
"interpreter, there is no guarantee which thread will eventually drop the "
"object. Therefore all types annotated with `#[pyclass]` must implement "
"`Send` (unless annotated with [`#[pyclass(unsendable)]`](#customizing-the-"
"class))."
msgstr ""

#: src/class.md:126
msgid "Constructor"
msgstr ""

#: src/class.md:128
msgid ""
"By default, it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:147
msgid ""
"Alternatively, if your `new` method may fail you can return `PyResult<Self>`."
msgstr ""

#: src/class.md:161
msgid "\"cannot be zero\""
msgstr ""

#: src/class.md:169
msgid ""
"If you want to return an existing object (for example, because your `new` "
"method caches the values it returns), `new` can return `pyo3::Py<Self>`."
msgstr ""

#: src/class.md:172
msgid ""
"As you can see, the Rust method name is not important here; this way you can "
"still, use `new()` for a Rust-level constructor."
msgstr ""

#: src/class.md:175
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:178
msgid ""
"For arguments, see the [`Method arguments`](#method-arguments) section below."
msgstr ""

#: src/class.md:180
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:182
msgid ""
"The next step is to create the module initializer and add our class to it:"
msgstr ""

#: src/class.md:197
msgid "Bound<T> and interior mutability"
msgstr ""

#: src/class.md:199
msgid ""
"Often is useful to turn a `#[pyclass]` type `T` into a Python object and "
"access it from Rust code. The \\[`Py<T>`\\] and \\[`Bound<'py, T>`\\] smart "
"pointers are the ways to represent a Python object in PyO3's API. More "
"detail can be found about them [in the Python objects](./types.md#pyo3s-"
"smart-pointers) section of the guide."
msgstr ""

#: src/class.md:201
msgid ""
"Most Python objects do not offer exclusive (`&mut`) access (see the [section "
"on Python's memory model](./python-from-rust.md#pythons-memory-model)). "
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"often _do_ need `&mut` access. Due to the GIL, PyO3 _can_ guarantee "
"exclusive access to them."
msgstr ""

#: src/class.md:203
msgid ""
"The Rust borrow checker cannot reason about `&mut` references once an "
"object's ownership has been passed to the Python interpreter. This means "
"that borrow checking is done at runtime using with a scheme very similar to "
"`std::cell::RefCell<T>`. This is known as [interior mutability](https://doc."
"rust-lang.org/book/ch15-05-interior-mutability.html)."
msgstr ""

#: src/class.md:205
msgid ""
"Users who are familiar with `RefCell<T>` can use `Py<T>` and `Bound<'py, T>` "
"just like `RefCell<T>`."
msgstr ""

#: src/class.md:207
msgid ""
"For users who are not very familiar with `RefCell<T>`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:208
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:209
msgid "References can never outlast the data they refer to."
msgstr ""

#: src/class.md:211
msgid ""
"`Py<T>` and `Bound<'py, T>`, like `RefCell<T>`, ensure these borrowing rules "
"by tracking references at runtime."
msgstr ""

#: src/class.md:223
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:225
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:229
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:231
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:236
msgid "// You can convert `Bound` to a Python object\n"
msgstr ""

#: src/class.md:237
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:241
msgid ""
"A `Bound<'py, T>` is restricted to the GIL lifetime `'py`. To make the "
"object longer lived (for example, to store it in a struct on the Rust side), "
"use `Py<T>`. `Py<T>` needs a `Python<'_>` token to allow access:"
msgstr ""

#: src/class.md:258
msgid "// Py<MyClass>::bind returns &Bound<'py, MyClass>\n"
msgstr ""

#: src/class.md:259
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:264
msgid "frozen classes: Opting out of interior mutability"
msgstr ""

#: src/class.md:266
msgid ""
"As detailed above, runtime borrow checking is currently enabled by default. "
"But a class can opt of out it by declaring itself `frozen`. It can still use "
"interior mutability via standard Rust types like `RefCell` or `Mutex`, but "
"it is not bound to the implementation provided by PyO3 and can choose the "
"most appropriate strategy on field-by-field basis."
msgstr ""

#: src/class.md:268
msgid ""
"Classes which are `frozen` and also `Sync`, e.g. they do use `Mutex` but not "
"`RefCell`, can be accessed without needing the Python GIL via the `Bound::"
"get` and `Py::get` methods:"
msgstr ""

#: src/class.md:292
msgid ""
"Frozen classes are likely to become the default thereby guiding the PyO3 "
"ecosystem towards a more deliberate application of interior mutability. "
"Eventually, this should enable further optimizations of PyO3's internals and "
"avoid downstream code paying the cost of interior mutability when it is not "
"actually required."
msgstr ""

#: src/class.md:294
msgid "Customizing the class"
msgstr ""

#: src/class.md:296
msgid "`#[pyclass]` can be used with the following parameters:"
msgstr ""

#: src/class.md:298
msgid "Parameter"
msgstr ""

#: src/class.md:300
msgid "`constructor`"
msgstr ""

#: src/class.md:300
msgid ""
"This is currently only allowed on [variants of complex enums](https://pyo3."
"rs/latest/class.html#complex-enums). It allows customization of the "
"generated class constructor for each variant. It uses the same syntax and "
"supports the same options as the `signature` attribute of functions and "
"methods."
msgstr ""

#: src/class.md:301
msgid "<span style=\"white-space: pre\">`crate = \"some::path\"`</span>"
msgstr ""

#: src/class.md:301
msgid "Path to import the `pyo3` crate, if it's not accessible at `::pyo3`."
msgstr ""

#: src/class.md:302
msgid "`dict`"
msgstr ""

#: src/class.md:302
msgid ""
"Gives instances of this class an empty `__dict__` to store custom attributes."
msgstr ""

#: src/class.md:303
msgid "`eq`"
msgstr ""

#: src/class.md:303
msgid ""
"Implements `__eq__` using the `PartialEq` implementation of the underlying "
"Rust datatype."
msgstr ""

#: src/class.md:304
msgid "`eq_int`"
msgstr ""

#: src/class.md:304
msgid "Implements `__eq__` using `__int__` for simple enums."
msgstr ""

#: src/class.md:305
msgid "<span style=\"white-space: pre\">`extends = BaseType`</span>"
msgstr ""

#: src/class.md:305
msgid ""
"Use a custom baseclass. Defaults to [`PyAny`](https://docs.rs/pyo3/latest/"
"pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/class.md:306
msgid "<span style=\"white-space: pre\">`freelist = N`</span>"
msgstr ""

#: src/class.md:306
msgid ""
"Implements a [free list](https://en.wikipedia.org/wiki/Free_list) of size N. "
"This can improve performance for types that are often created and deleted in "
"quick succession. Profile your code to see whether `freelist` is right for "
"you."
msgstr ""

#: src/class.md:307
msgid "<span style=\"white-space: pre\">`frozen`</span>"
msgstr ""

#: src/class.md:307
msgid ""
"Declares that your pyclass is immutable. It removes the borrow checker "
"overhead when retrieving a shared reference to the Rust struct, but disables "
"the ability to get a mutable reference."
msgstr ""

#: src/class.md:308
msgid "`get_all`"
msgstr ""

#: src/class.md:308
msgid "Generates getters for all fields of the pyclass."
msgstr ""

#: src/class.md:309
msgid "`hash`"
msgstr ""

#: src/class.md:309
msgid ""
"Implements `__hash__` using the `Hash` implementation of the underlying Rust "
"datatype."
msgstr ""

#: src/class.md:310
msgid "`mapping`"
msgstr ""

#: src/class.md:310
msgid ""
"Inform PyO3 that this class is a [`Mapping`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its implementation of "
"sequence C-API slots empty."
msgstr ""

#: src/class.md:311
msgid "<span style=\"white-space: pre\">`module = \"module_name\"`</span>"
msgstr ""

#: src/class.md:311
msgid ""
"Python code will see the class as being defined in this module. Defaults to "
"`builtins`."
msgstr ""

#: src/class.md:312
msgid "<span style=\"white-space: pre\">`name = \"python_name\"`</span>"
msgstr ""

#: src/class.md:312
msgid ""
"Sets the name that Python sees this class as. Defaults to the name of the "
"Rust struct."
msgstr ""

#: src/class.md:313
msgid "`ord`"
msgstr ""

#: src/class.md:313
msgid ""
"Implements `__lt__`, `__gt__`, `__le__`, & `__ge__` using the `PartialOrd` "
"implementation of the underlying Rust datatype. _Requires `eq`_"
msgstr ""

#: src/class.md:314
msgid "`rename_all = \"renaming_rule\"`"
msgstr ""

#: src/class.md:314
msgid ""
"Applies renaming rules to every getters and setters of a struct, or every "
"variants of an enum. Possible values are: \"camelCase\", \"kebab-case\", "
"\"lowercase\", \"PascalCase\", \"SCREAMING-KEBAB-CASE\", "
"\"SCREAMING_SNAKE_CASE\", \"snake_case\", \"UPPERCASE\"."
msgstr ""

#: src/class.md:315
msgid "`sequence`"
msgstr ""

#: src/class.md:315
msgid ""
"Inform PyO3 that this class is a [`Sequence`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its C-API mapping "
"length slot empty."
msgstr ""

#: src/class.md:316
msgid "`set_all`"
msgstr ""

#: src/class.md:316
msgid "Generates setters for all fields of the pyclass."
msgstr ""

#: src/class.md:317
msgid "`subclass`"
msgstr ""

#: src/class.md:317
msgid ""
"Allows other Python classes and `#[pyclass]` to inherit from this class. "
"Enums cannot be subclassed."
msgstr ""

#: src/class.md:318
msgid ""
"<span style=\"white-space: pre\">`text_signature = \"(arg1, arg2, ...)\"`</"
"span>"
msgstr ""

#: src/class.md:318
msgid "Sets the text signature for the Python class' `__new__` method."
msgstr ""

#: src/class.md:319
msgid "`unsendable`"
msgstr ""

#: src/class.md:319
msgid ""
"Required if your struct is not [`Send`](https://doc.rust-lang.org/std/marker/"
"trait.Send.html). Rather than using `unsendable`, consider implementing your "
"struct in a threadsafe way by e.g. substituting [`Rc`](https://doc.rust-lang."
"org/std/rc/struct.Rc.html) with [`Arc`](https://doc.rust-lang.org/std/sync/"
"struct.Arc.html). By using `unsendable`, your class will panic when accessed "
"by another thread. Also note the Python's GC is multi-threaded and while "
"unsendable classes will not be traversed on foreign threads to avoid UB, "
"this can lead to memory leaks."
msgstr ""

#: src/class.md:320
msgid "`weakref`"
msgstr ""

#: src/class.md:320
msgid ""
"Allows this class to be [weakly referenceable](https://docs.python.org/3/"
"library/weakref.html)."
msgstr ""

#: src/class.md:322
msgid ""
"All of these parameters can either be passed directly on the "
"`#[pyclass(...)]` annotation, or as one or more accompanying `#[pyo3(...)]` "
"annotations, e.g.:"
msgstr ""

#: src/class.md:326
msgid "// Argument supplied directly to the `#[pyclass]` annotation.\n"
msgstr ""

#: src/class.md:327 src/class.md:332
msgid "\"SomeName\""
msgstr ""

#: src/class.md:329
msgid "// Argument supplied as a separate annotation.\n"
msgstr ""

#: src/class.md:346
msgid "These parameters are covered in various sections of this guide."
msgstr ""

#: src/class.md:348
msgid "Return type"
msgstr ""

#: src/class.md:350
msgid ""
"Generally, `#[new]` methods have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:353
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:356
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:356
msgid "**May fail**"
msgstr ""

#: src/class.md:358
msgid "**No inheritance**"
msgstr ""

#: src/class.md:358
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:359
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:359
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:360
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:360
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/main/doc/pyo3/pyclass_init/struct."
"PyClassInitializer.html)"
msgstr ""

#: src/class.md:360
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:362
msgid "Inheritance"
msgstr ""

#: src/class.md:364
msgid ""
"By default, `object`, i.e. `PyAny` is used as the base class. To override "
"this default, use the `extends` parameter for `pyclass` with the full path "
"to the base class. Currently, only classes defined in Rust and builtins "
"provided by PyO3 can be inherited from; inheriting from other classes "
"defined in Python is not yet supported ([\\#991](https://github.com/PyO3/"
"pyo3/issues/991))."
msgstr ""

#: src/class.md:371
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the base class of `T`. But for a more deeply nested inheritance, you have "
"to return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:376
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/main/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_super()` as `&PyRef<Self::BaseClass>`, or by `self_.into_super()` as "
"`PyRef<Self::BaseClass>` (and similar for the `PyRefMut` case). For "
"convenience, `self_.as_ref()` can also be used to get `&Self::BaseClass` "
"directly; however, this approach does not let you access base clases higher "
"in the inheritance hierarchy, for which you would need to chain multiple "
"`as_super` or `into_super` calls."
msgstr ""

#: src/class.md:418
msgid "// Get &PyRef<BaseClass>\n"
msgstr ""

#: src/class.md:436
msgid "// Get &PyRef<'_, BaseClass>\n"
msgstr ""

#: src/class.md:442
msgid "// Get PyRef<'_, SubClass>\n"
msgstr ""

#: src/class.md:472
msgid "\"assert subsub.method1() == 10\""
msgstr ""

#: src/class.md:473
msgid "\"assert subsub.method2() == 150\""
msgstr ""

#: src/class.md:474
msgid "\"assert subsub.method3() == 200\""
msgstr ""

#: src/class.md:475
msgid "\"assert subsub.method4() == 3000\""
msgstr ""

#: src/class.md:476
msgid "\"assert subsub.get_values() == (10, 15, 20)\""
msgstr ""

#: src/class.md:477
msgid "\"assert subsub.double_values() == None\""
msgstr ""

#: src/class.md:478
msgid "\"assert subsub.get_values() == (20, 30, 40)\""
msgstr ""

#: src/class.md:482
msgid "\"assert not isinstance(subsub, cls)\""
msgstr ""

#: src/class.md:483
msgid "\"assert isinstance(subsubsub, cls)\""
msgstr ""

#: src/class.md:487
msgid ""
"You can inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/main/doc/pyo3/type_object/trait."
"PySizedLayout.html). This is not supported when building for the Python "
"limited API (aka the `abi3` feature of PyO3)."
msgstr ""

#: src/class.md:491
msgid ""
"To convert between the Rust type and its native base class, you can take "
"`slf` as a Python object. To access the Rust fields use `slf.borrow()` or "
"`slf.borrow_mut()`, and to access the base class use `slf.downcast::"
"<BaseClass>()`."
msgstr ""

#: src/class.md:522
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:527
msgid ""
"If `SubClass` does not provide a base class initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:550
msgid ""
"The `__new__` constructor of a native base class is called implicitly when "
"creating a new instance from Python.  Be sure to accept arguments in the "
"`#[new]` method that you want the base class to get, even if they are not "
"used in that `fn`:"
msgstr ""

#: src/class.md:574
msgid "// some custom methods that use `private` here...\n"
msgstr ""

#: src/class.md:578
msgid "\"cls(a=1, b=2)\""
msgstr ""

#: src/class.md:583
msgid ""
"Here, the `args` and `kwargs` allow creating instances of the subclass "
"passing initial items, such as `MyDict(item_sequence)` or `MyDict(a=1, b=2)`."
msgstr ""

#: src/class.md:586
msgid "Object properties"
msgstr ""

#: src/class.md:588
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:589
msgid ""
"For simple struct fields with no side effects, a `#[pyo3(get, set)]` "
"attribute can be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:590
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the [`#[pymethods]`](#instance-methods) block."
msgstr ""

#: src/class.md:592
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:594
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:596
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:608
msgid ""
"The above would make the `num` field available for reading and writing as a "
"`self.num` Python property. To expose the property with a different name to "
"the field, specify this alongside the rest of the options, e.g. `#[pyo3(get, "
"set, name = \"custom_name\")]`."
msgstr ""

#: src/class.md:610
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:612
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:613
msgid ""
"For `get` the field type must implement both `IntoPy<PyObject>` and `Clone`."
msgstr ""

#: src/class.md:614
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:616
msgid ""
"For example, implementations of those traits are provided for the `Cell` "
"type, if the inner type also implements the trait. This means you can use "
"`#[pyo3(get, set)]` on fields wrapped in a `Cell`."
msgstr ""

#: src/class.md:618
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:620
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:622
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:640
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:643
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:670
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:672
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:696
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:698
msgid ""
"Attributes defined by `#[setter]` or `#[pyo3(set)]` will always raise "
"`AttributeError` on `del` operations. Support for defining custom `del` "
"behavior is tracked in [\\#1778](https://github.com/PyO3/pyo3/issues/1778)."
msgstr ""

#: src/class.md:702
msgid "Instance methods"
msgstr ""

#: src/class.md:704
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:708
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust. However to have multiple `#[pymethods]`\\-annotated `impl` blocks for "
"the same struct you must enable the [`multiple-pymethods`](features."
"md#multiple-pymethods) feature of PyO3."
msgstr ""

#: src/class.md:731
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:735
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:753
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:755
msgid "Class methods"
msgstr ""

#: src/class.md:757
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:778
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:780
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:782
msgid "The first parameter implicitly has type `&Bound<'_, PyType>`."
msgstr ""

#: src/class.md:783
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:784
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:786
msgid "Constructors which accept a class argument"
msgstr ""

#: src/class.md:788
msgid ""
"To create a constructor which takes a positional class argument, you can "
"combine the `#[classmethod]` and `#[new]` modifiers:"
msgstr ""

#: src/class.md:801
msgid ""
"// Get an abstract attribute (presumably) declared on a subclass of this "
"class.\n"
msgstr ""

#: src/class.md:802
msgid "\"a_class_attr\""
msgstr ""

#: src/class.md:808
msgid "Static methods"
msgstr ""

#: src/class.md:810
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:830
msgid "Class attributes"
msgstr ""

#: src/class.md:832
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute."
msgstr ""

#: src/class.md:843
msgid "\"hello\""
msgstr ""

#: src/class.md:849
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:853
msgid ""
"Note: if the method has a `Result` return type and returns an `Err`, PyO3 "
"will panic during class creation."
msgstr ""

#: src/class.md:856
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:870
msgid "Classes as function arguments"
msgstr ""

#: src/class.md:872
msgid ""
"Free functions defined using `#[pyfunction]` interact with classes through "
"the same mechanisms as the self parameters of instance methods, i.e. they "
"can take GIL-bound references, GIL-bound reference wrappers or GIL-"
"indepedent references:"
msgstr ""

#: src/class.md:881
msgid "// Take a reference when the underlying `Bound` is irrelevant.\n"
msgstr ""

#: src/class.md:887
msgid ""
"// Take a reference wrapper when borrowing should be automatic,\n"
"// but interaction with the underlying `Bound` is desired.\n"
msgstr ""

#: src/class.md:892 src/class.md:901 src/class.md:907
msgid "\"{}\""
msgstr ""

#: src/class.md:894
msgid ""
"// Take a reference to the underlying Bound\n"
"// when borrowing needs to be managed manually.\n"
msgstr ""

#: src/class.md:903
msgid ""
"// Take a GIL-indepedent reference when you want to store the reference "
"elsewhere.\n"
msgstr ""

#: src/class.md:911
msgid ""
"Classes can also be passed by value if they can be cloned, i.e. they "
"automatically implement `FromPyObject` if they implement `Clone`, e.g. via "
"`#[derive(Clone)]`:"
msgstr ""

#: src/class.md:929
msgid ""
"Note that `#[derive(FromPyObject)]` on a class is usually not useful as it "
"tries to construct a new Rust value by filling in the fields by looking up "
"attributes of any given Python value."
msgstr ""

#: src/class.md:931
msgid "Method arguments"
msgstr ""

#: src/class.md:933
msgid ""
"Similar to `#[pyfunction]`, the `#[pyo3(signature = (...))]` attribute can "
"be used to specify the way that `#[pymethods]` accept arguments. Consult the "
"documentation for [`function signatures`](./function/signature.md) to see "
"the parameters this attribute accepts."
msgstr ""

#: src/class.md:935
msgid ""
"The following example defines a class `MyClass` with a method `method`. This "
"method has a signature that sets default values for `num` and `name`, and "
"indicates that `py_args` should collect all extra positional arguments and "
"`py_kwargs` all extra keyword arguments:"
msgstr ""

#: src/class.md:953
msgid "\"Hello\""
msgstr ""

#: src/class.md:964
msgid "\"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \""
msgstr ""

#: src/class.md:971
msgid "In Python, this might be used like:"
msgstr ""

#: src/class.md:976 src/class.md:978
msgid "\"World\""
msgstr ""

#: src/class.md:977
msgid "'World'"
msgstr ""

#: src/class.md:977
msgid "'x'"
msgstr ""

#: src/class.md:977
msgid "'y'"
msgstr ""

#: src/class.md:982
msgid ""
"The [`#[pyo3(text_signature = \"...\")`](./function/signature.md#overriding-"
"the-generated-signature) option for `#[pyfunction]` also works for "
"`#[pymethods]`."
msgstr ""

#: src/class.md:995 src/class.md:1032
msgid "\"(c, d)\""
msgstr ""

#: src/class.md:999
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/class.md:1000
msgid "\"($self, e, f)\""
msgstr ""

#: src/class.md:1004
msgid "// similarly for classmethod arguments, use $cls\n"
msgstr ""

#: src/class.md:1006
msgid "\"($cls, e, f)\""
msgstr ""

#: src/class.md:1011 src/class.md:1061 src/class.md:1073
msgid "\"(e, f)\""
msgstr ""

#: src/class.md:1019
msgid "\"inspect\""
msgstr ""

#: src/class.md:1019
msgid "\"signature\""
msgstr ""

#: src/class.md:1020
msgid "\"my_module\""
msgstr ""

#: src/class.md:1022 src/class.md:1426
msgid "\"MyClass\""
msgstr ""

#: src/class.md:1025 src/class.md:1034 src/class.md:1043 src/class.md:1055
#: src/class.md:1067
msgid "\"__doc__\""
msgstr ""

#: src/class.md:1030 src/class.md:1047 src/class.md:1059 src/class.md:1071
msgid "\"__str__\""
msgstr ""

#: src/class.md:1037
msgid ""
"\"`text_signature` on classes is not compatible with compilation in `abi3` "
"mode until Python 3.10 or greater\""
msgstr ""

#: src/class.md:1041
msgid "\"my_method\""
msgstr ""

#: src/class.md:1049
msgid "\"(self, /, e, f)\""
msgstr ""

#: src/class.md:1053
msgid "\"my_class_method\""
msgstr ""

#: src/class.md:1061
msgid "// inspect.signature skips the $cls arg\n"
msgstr ""

#: src/class.md:1065
msgid "\"my_static_method\""
msgstr ""

#: src/class.md:1081
msgid ""
"Note that `text_signature` on `#[new]` is not compatible with compilation in "
"`abi3` mode until Python 3.10 or greater."
msgstr ""

#: src/class.md:1084
msgid "Method receivers and lifetime elision"
msgstr ""

#: src/class.md:1086
msgid ""
"PyO3 supports writing instance methods using the normal method receivers for "
"shared `&self` and unique `&mut self` references. This interacts with "
"[lifetime elision](https://doc.rust-lang.org/reference/lifetime-elision."
"html) insofar as the lifetime of a such a receiver is assigned to all elided "
"output lifetime parameters."
msgstr ""

#: src/class.md:1088
msgid ""
"This is a good default for general Rust code where return values are more "
"likely to borrow from the receiver than from the other arguments, if they "
"contain any lifetimes at all. However, when returning bound references "
"`Bound<'py, T>` in PyO3-based code, the GIL lifetime `'py` should usually be "
"derived from a GIL token `py: Python<'py>` passed as an argument instead of "
"the receiver."
msgstr ""

#: src/class.md:1090
msgid "Specifically, signatures like"
msgstr ""

#: src/class.md:1096
msgid "will not work as they are inferred as"
msgstr ""

#: src/class.md:1102
msgid "instead of the intended"
msgstr ""

#: src/class.md:1108
msgid "and should usually be written as"
msgstr ""

#: src/class.md:1114
msgid ""
"The same problem does not exist for `#[pyfunction]`s as the special case for "
"receiver lifetimes does not apply and indeed a signature like"
msgstr ""

#: src/class.md:1120
msgid ""
"will yield compiler error [E0106 \"missing lifetime specifier\"](https://doc."
"rust-lang.org/error_codes/E0106.html)."
msgstr ""

#: src/class.md:1122
msgid "`#[pyclass]` enums"
msgstr ""

#: src/class.md:1124
msgid ""
"Enum support in PyO3 comes in two flavors, depending on what kind of "
"variants the enum has: simple and complex."
msgstr ""

#: src/class.md:1126
msgid "Simple enums"
msgstr ""

#: src/class.md:1128
msgid "A simple enum (a.k.a. C-like enum) has only unit variants."
msgstr ""

#: src/class.md:1130
msgid ""
"PyO3 adds a class attribute for each variant, so you can access them in "
"Python without defining `#[new]`. PyO3 also provides default implementations "
"of `__richcmp__` and `__int__`, so they can be compared using `==`:"
msgstr ""

#: src/class.md:1145
msgid ""
"r#\"\n"
"        assert x == cls.Variant\n"
"        assert y == cls.OtherVariant\n"
"        assert x != y\n"
"    \"#"
msgstr ""

#: src/class.md:1153
msgid "You can also convert your simple enums into `int`:"
msgstr ""

#: src/class.md:1166
msgid "// The exact value is assigned by the compiler.\n"
msgstr ""

#: src/class.md:1167
msgid ""
"r#\"\n"
"        assert int(cls.Variant) == x\n"
"        assert int(cls.OtherVariant) == 10\n"
"    \"#"
msgstr ""

#: src/class.md:1174
msgid "PyO3 also provides `__repr__` for enums:"
msgstr ""

#: src/class.md:1188
msgid ""
"r#\"\n"
"        assert repr(x) == 'MyEnum.Variant'\n"
"        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'\n"
"    \"#"
msgstr ""

#: src/class.md:1195
msgid ""
"All methods defined by PyO3 can be overridden. For example here's how you "
"override `__repr__`:"
msgstr ""

#: src/class.md:1208
msgid "\"42\""
msgstr ""

#: src/class.md:1214
msgid "\"assert repr(cls.Answer) == '42'\""
msgstr ""

#: src/class.md:1218
msgid "Enums and their variants can also be renamed using `#[pyo3(name)]`."
msgstr ""

#: src/class.md:1222
msgid "\"RenamedEnum\""
msgstr ""

#: src/class.md:1225
msgid "\"UPPERCASE\""
msgstr ""

#: src/class.md:1232
msgid ""
"r#\"\n"
"        assert repr(x) == 'RenamedEnum.UPPERCASE'\n"
"        assert x == cls.UPPERCASE\n"
"    \"#"
msgstr ""

#: src/class.md:1239
msgid ""
"Ordering of enum variants is optionally added using `#[pyo3(ord)]`. _Note: "
"Implementation of the `PartialOrd` trait is required when passing the `ord` "
"argument.  If not implemented, a compile time error is raised._"
msgstr ""

#: src/class.md:1257
msgid ""
"r#\"\n"
"        assert (a < b) == True\n"
"        assert (c <= b) == False\n"
"        assert (c > a) == True\n"
"    \"#"
msgstr ""

#: src/class.md:1265
msgid ""
"You may not use enums as a base class or let enums inherit from other "
"classes."
msgstr ""

#: src/class.md:1287
msgid ""
"`#[pyclass]` enums are currently not interoperable with `IntEnum` in Python."
msgstr ""

#: src/class.md:1289
msgid "Complex enums"
msgstr ""

#: src/class.md:1291
msgid "An enum is complex if it has any non-unit (struct or tuple) variants."
msgstr ""

#: src/class.md:1293
msgid ""
"PyO3 supports only struct and tuple variants in a complex enum. Unit "
"variants aren't supported at present (the recommendation is to use an empty "
"tuple enum instead)."
msgstr ""

#: src/class.md:1295
msgid ""
"PyO3 adds a class attribute for each variant, which may be used to construct "
"values and in match patterns. PyO3 also provides getter methods for all "
"fields of each variant."
msgstr ""

#: src/class.md:1312
msgid ""
"r#\"\n"
"        assert isinstance(circle, cls)\n"
"        assert isinstance(circle, cls.Circle)\n"
"        assert circle.radius == 10.0\n"
"\n"
"        assert isinstance(square, cls)\n"
"        assert isinstance(square, cls.RegularPolygon)\n"
"        assert square[0] == 4 # Gets _0 field\n"
"        assert square[1] == 10.0 # Gets _1 field\n"
"\n"
"        def count_vertices(cls, shape):\n"
"            match shape:\n"
"                case cls.Circle():\n"
"                    return 0\n"
"                case cls.Rectangle():\n"
"                    return 4\n"
"                case cls.RegularPolygon(n):\n"
"                    return n\n"
"                case cls.Nothing():\n"
"                    return 0\n"
"\n"
"        assert count_vertices(cls, circle) == 0\n"
"        assert count_vertices(cls, square) == 4\n"
"    \"#"
msgstr ""

#: src/class.md:1339
msgid ""
"WARNING: `Py::new` and `.into_py` are currently inconsistent. Note how the "
"constructed value is _not_ an instance of the specific variant. For this "
"reason, constructing values is only recommended using `.into_py`."
msgstr ""

#: src/class.md:1351
msgid ""
"r#\"\n"
"        assert isinstance(x, cls)\n"
"        assert not isinstance(x, cls.Variant)\n"
"    \"#"
msgstr ""

#: src/class.md:1358
msgid ""
"The constructor of each generated class can be customized using the "
"`#[pyo3(constructor = (...))]` attribute. This uses the same syntax as the "
"[`#[pyo3(signature = (...))]`](function/signature.md) attribute on function "
"and methods and supports the same options. To apply this attribute simply "
"place it on top of a variant in a `#[pyclass]` complex enum as shown below:"
msgstr ""

#: src/class.md:1377
msgid ""
"r#\"\n"
"        circle = cls.Circle()\n"
"        assert isinstance(circle, cls)\n"
"        assert isinstance(circle, cls.Circle)\n"
"        assert circle.radius == 1.0\n"
"\n"
"        square = cls.Rectangle(width = 1, height = 1)\n"
"        assert isinstance(square, cls)\n"
"        assert isinstance(square, cls.Rectangle)\n"
"        assert square.width == 1\n"
"        assert square.height == 1\n"
"\n"
"        hexagon = cls.RegularPolygon(6)\n"
"        assert isinstance(hexagon, cls)\n"
"        assert isinstance(hexagon, cls.RegularPolygon)\n"
"        assert hexagon.side_count == 6\n"
"        assert hexagon.radius == 1\n"
"    \"#"
msgstr ""

#: src/class.md:1398
msgid "Implementation details"
msgstr ""

#: src/class.md:1400
msgid ""
"The `#[pyclass]` macros rely on a lot of conditional code generation: each "
"`#[pyclass]` can optionally have a `#[pymethods]` block."
msgstr ""

#: src/class.md:1402
msgid ""
"To support this flexibility the `#[pyclass]` macro expands to a blob of "
"boilerplate code which sets up the structure for [\"dtolnay specialization\"]"
"(https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/"
"README.md). This implementation pattern enables the Rust compiler to use "
"`#[pymethods]` implementations when they are present, and fall back to "
"default (empty) definitions when they are not."
msgstr ""

#: src/class.md:1404
msgid ""
"This simple technique works for the case when there is zero or one "
"implementations. To support multiple `#[pymethods]` for a `#[pyclass]` (in "
"the [`multiple-pymethods`](features.md#multiple-pymethods) feature), a "
"registry mechanism provided by the [`inventory`](https://github.com/dtolnay/"
"inventory) crate is used instead. This collects `impl`s at library load "
"time, but isn't supported on all platforms. See [inventory: how it works]"
"(https://github.com/dtolnay/inventory#how-it-works) for more details."
msgstr ""

#: src/class.md:1406
msgid ""
"The `#[pyclass]` macro expands to roughly the code seen below. The "
"`PyClassImplCollector` is the type used internally by PyO3 for dtolnay "
"specialization:"
msgstr ""

#: src/class.md:1409
msgid "\"multiple-pymethods\""
msgstr ""

#: src/class.md:1410
msgid ""
"// Note: the implementation differs slightly with the `multiple-pymethods` "
"feature enabled.\n"
msgstr ""

#: src/class.md:1503
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. Python "
"classes support these protocols by implementing \"magic\" methods, such as "
"`__str__` or `__repr__`. Because of the double-underscores surrounding their "
"name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"PyO3 makes it possible for every magic method to be implemented in "
"`#[pymethods]` just as they would be done in a regular Python class, with a "
"few notable differences:"
msgstr ""

#: src/class/protocols.md:6
msgid ""
"`__new__` and `__init__` are replaced by the [`#[new]` attribute](../class."
"md#constructor)."
msgstr ""

#: src/class/protocols.md:7
msgid "`__del__` is not yet supported, but may be in the future."
msgstr ""

#: src/class/protocols.md:8
msgid ""
"`__buffer__` and `__release_buffer__` are currently not supported and "
"instead PyO3 supports [`__getbuffer__` and `__releasebuffer__`](#buffer-"
"objects) methods (these predate [PEP 688](https://peps.python.org/pep-0688/"
"#python-level-buffer-protocol)), again this may change in the future."
msgstr ""

#: src/class/protocols.md:9
msgid ""
"PyO3 adds [`__traverse__` and `__clear__`](#garbage-collector-integration) "
"methods for controlling garbage collection."
msgstr ""

#: src/class/protocols.md:10
msgid ""
"The Python C-API which PyO3 is implemented upon requires many magic methods "
"to have a specific function signature in C and be placed into special "
"\"slots\" on the class type object. This limits the allowed argument and "
"return types for these methods. They are listed in detail in the section "
"below."
msgstr ""

#: src/class/protocols.md:12
msgid ""
"If a magic method is not on the list above (for example "
"`__init_subclass__`), then it should just work in PyO3. If this is not the "
"case, please file a bug report."
msgstr ""

#: src/class/protocols.md:14
msgid "Magic Methods handled by PyO3"
msgstr ""

#: src/class/protocols.md:16
msgid ""
"If a function name in `#[pymethods]` is a magic method which is known to "
"need special handling, it will be automatically placed into the correct slot "
"in the Python type object. The function name is taken from the usual rules "
"for naming `#[pymethods]`: the `#[pyo3(name = \"...\")]` attribute is used "
"if present, otherwise the Rust function name is used."
msgstr ""

#: src/class/protocols.md:18
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the subset which have "
"slots as [defined here](https://docs.python.org/3/c-api/typeobj.html)."
msgstr ""

#: src/class/protocols.md:20
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:21
msgid "The Rust function signature is restricted to match the magic method."
msgstr ""

#: src/class/protocols.md:22
msgid ""
"The `#[pyo3(signature = (...)]` and `#[pyo3(text_signature = \"...\")]` "
"attributes are not allowed."
msgstr ""

#: src/class/protocols.md:24
msgid ""
"The following sections list all magic methods for which PyO3 implements the "
"necessary special handling.  The given signatures should be interpreted as "
"follows:"
msgstr ""

#: src/class/protocols.md:26
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `Bound` reference like `self_: PyRef<'_, Self>` "
"and `self_: PyRefMut<'_, Self>`, as described [here](../class."
"md#inheritance)."
msgstr ""

#: src/class/protocols.md:29
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:30
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:31
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:33
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:35
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:37
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:43
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:44
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:46
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:48
msgid ""
"Objects that compare equal must have the same hash value. Any type up to 64 "
"bits may be returned instead of `isize`, PyO3 will convert to an isize "
"automatically (wrapping unsigned types like `u64` and `usize`)."
msgstr ""

#: src/class/protocols.md:67
msgid "`__lt__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:68
msgid "`__le__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:69
msgid "`__eq__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:70
msgid "`__ne__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:71
msgid "`__gt__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:72
msgid "`__ge__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:74
msgid ""
"The implementations of Python's \"rich comparison\" operators `<`, `<=`, "
"`==`, `!=`, `>` and `>=` respectively."
msgstr ""

#: src/class/protocols.md:76
msgid ""
"_Note that implementing any of these methods will cause Python not to "
"generate a default `__hash__` implementation, so consider also implementing "
"`__hash__`._"
msgstr ""

#: src/class/protocols.md:82
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:84
msgid ""
"Implements Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`) in a single method. The `CompareOp` argument indicates the comparison "
"operation being performed. You can use [`CompareOp::matches`](https://pyo3."
"rs/main/doc/pyo3/pyclass/enum.CompareOp.html#method.matches) to adapt a Rust "
"`std::cmp::Ordering` result to the requested comparison."
msgstr ""

#: src/class/protocols.md:88
msgid ""
"_This method cannot be implemented in combination with any of `__lt__`, "
"`__le__`, `__eq__`, `__ne__`, `__gt__`, or `__ge__`._"
msgstr ""

#: src/class/protocols.md:90
msgid ""
"_Note that implementing `__richcmp__` will cause Python not to generate a "
"default `__hash__` implementation, so consider implementing `__hash__` when "
"implementing `__richcmp__`._"
msgstr ""

#: src/class/protocols.md:95
msgid ""
"If you want to leave some operations unimplemented, you can return `py."
"NotImplemented()` for some of the operations:"
msgstr ""

#: src/class/protocols.md:118
msgid ""
"If the second argument `object` is not of the type specified in the "
"signature, the generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class/protocols.md:122
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:123
msgid "`__getattribute__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:133
msgid "`__setattr__(<self>, value: object) -> ()`"
msgstr ""

#: src/class/protocols.md:134
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:136
msgid "Overrides attribute access."
msgstr ""

#: src/class/protocols.md:138
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:140
msgid "Determines the \"truthyness\" of an object."
msgstr ""

#: src/class/protocols.md:142
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:145
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:147
msgid "Iterators can be defined using these methods:"
msgstr ""

#: src/class/protocols.md:149
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:150
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:152
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items."
msgstr ""

#: src/class/protocols.md:154 src/class/protocols.md:427
msgid "Example:"
msgstr ""

#: src/class/protocols.md:175
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, the "
"iterable only needs to implement `__iter__()` while the iterator must "
"implement both `__iter__()` and `__next__()`. For example:"
msgstr ""

#: src/class/protocols.md:217
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:218
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:222
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:225
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:227
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration.  In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://pyo3.rs/"
"main/doc/pyo3/pyclass/enum.IterNextOutput.html) enum to both `Yield` values "
"and `Return` a final value - see its docs for further details and an example."
msgstr ""

#: src/class/protocols.md:232
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:234
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:235
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:236
msgid "`__anext__(<self>) -> Option<object> or IterANextOutput`"
msgstr ""

#: src/class/protocols.md:238
msgid "Mapping & Sequence types"
msgstr ""

#: src/class/protocols.md:240
msgid ""
"The magic methods in this section can be used to implement Python container "
"types. They are two main categories of container in Python: \"mappings\" "
"such as `dict`, with arbitrary keys, and \"sequences\" such as `list` and "
"`tuple`, with integer keys."
msgstr ""

#: src/class/protocols.md:242
msgid ""
"The Python C-API which PyO3 is built upon has separate \"slots\" for "
"sequences and mappings. When writing a `class` in pure Python, there is no "
"such distinction in the implementation - a `__getitem__` implementation will "
"fill the slots for both the mapping and sequence forms, for example."
msgstr ""

#: src/class/protocols.md:244
msgid ""
"By default PyO3 reproduces the Python behaviour of filling both mapping and "
"sequence slots. This makes sense for the \"simple\" case which matches "
"Python, and also for sequences, where the mapping slot is used anyway to "
"implement slice indexing."
msgstr ""

#: src/class/protocols.md:246
msgid ""
"Mapping types usually will not want the sequence slots filled. Having them "
"filled will lead to outcomes which may be unwanted, such as:"
msgstr ""

#: src/class/protocols.md:247
msgid ""
"The mapping type will successfully cast to [`PySequence`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PySequence.html). This may lead to consumers of "
"the type handling it incorrectly."
msgstr ""

#: src/class/protocols.md:248
msgid ""
"Python provides a default implementation of `__iter__` for sequences, which "
"calls `__getitem__` with consecutive positive integers starting from 0 until "
"an `IndexError` is returned. Unless the mapping only contains consecutive "
"positive integer keys, this `__iter__` implementation will likely not be the "
"intended behavior."
msgstr ""

#: src/class/protocols.md:250
msgid ""
"Use the `#[pyclass(mapping)]` annotation to instruct PyO3 to only fill the "
"mapping slots, leaving the sequence ones empty. This will apply to "
"`__getitem__`, `__setitem__`, and `__delitem__`."
msgstr ""

#: src/class/protocols.md:252
msgid ""
"Use the `#[pyclass(sequence)]` annotation to instruct PyO3 to fill the "
"`sq_length` slot instead of the `mp_length` slot for `__len__`. This will "
"help libraries such as `numpy` recognise the class as a sequence, however "
"will also cause CPython to automatically add the sequence length to any "
"negative indices before passing them to `__getitem__`. (`__getitem__`, "
"`__setitem__` and `__delitem__` mapping slots are still used for sequences, "
"for slice operations.)"
msgstr ""

#: src/class/protocols.md:254
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:256
msgid "Implements the built-in function `len()`."
msgstr ""

#: src/class/protocols.md:258
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:260
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that don‚Äôt define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:268
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:287
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:289
msgid "Implements retrieval of the `self[a]` element."
msgstr ""

#: src/class/protocols.md:291
msgid ""
"_Note:_ Negative integer indexes are not handled specially by PyO3. However, "
"for classes with `#[pyclass(sequence)]`, when a negative index is accessed "
"via `PySequence::get_item`, the underlying C API already adjusts the index "
"to be positive."
msgstr ""

#: src/class/protocols.md:296
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:298
msgid ""
"Implements assignment to the `self[a]` element. Should only be implemented "
"if elements can be replaced."
msgstr ""

#: src/class/protocols.md:301 src/class/protocols.md:308
msgid "Same behavior regarding negative indices as for `__getitem__`."
msgstr ""

#: src/class/protocols.md:303
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:305
msgid ""
"Implements deletion of the `self[a]` element. Should only be implemented if "
"elements can be deleted."
msgstr ""

#: src/class/protocols.md:310
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:312
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `__add__` and `__radd__` methods."
msgstr ""

#: src/class/protocols.md:316
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:318
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `__mul__` and `__rmul__` methods."
msgstr ""

#: src/class/protocols.md:322
msgid ""
"`fn __inplace_concat__(&self, other: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:324
msgid ""
"Concatenates two sequences. Used by the `+=` operator, after trying the "
"numeric addition via the `__iadd__` method."
msgstr ""

#: src/class/protocols.md:328
msgid ""
"`fn __inplace_repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:330
msgid ""
"Concatenates two sequences. Used by the `*=` operator, after trying the "
"numeric multiplication via the `__imul__` method."
msgstr ""

#: src/class/protocols.md:334
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:336
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:337
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:338
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:340
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:342
msgid ""
"Binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, "
"`divmod()`, `pow()` and `**`, `<<`, `>>`, `&`, `^`, and `|`) and their "
"reflected versions:"
msgstr ""

#: src/class/protocols.md:345
msgid ""
"(If the `object` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`.)"
msgstr ""

#: src/class/protocols.md:348
msgid "`__add__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:349
msgid "`__radd__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:350
msgid "`__sub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:351
msgid "`__rsub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:352
msgid "`__mul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:353
msgid "`__rmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:354
msgid "`__matmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:355
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:356
msgid "`__floordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:357
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:358
msgid "`__truediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:359
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:360
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:361
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:362
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:363
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:364
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:365
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:366
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:367
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:368
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:369
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:370
msgid "`__xor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:371
msgid "`__rxor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:372
msgid "`__or__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:373
msgid "`__ror__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:374
msgid "`__pow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:375
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:377
msgid ""
"In-place assignment operations (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, "
"`**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:380
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:381
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:382
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:383
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:384
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:385
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:386
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:387
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:388
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:389
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:390
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:391
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:392
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:394
msgid "Unary operations (`-`, `+`, `abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:396
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:397
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:398
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:399
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:401
msgid "Coercions:"
msgstr ""

#: src/class/protocols.md:403
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:404
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:405
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:407
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:409
msgid "`__getbuffer__(<self>, *mut ffi::Py_buffer, flags) -> ()`"
msgstr ""

#: src/class/protocols.md:410
msgid ""
"`__releasebuffer__(<self>, *mut ffi::Py_buffer) -> ()` Errors returned from "
"`__releasebuffer__` will be sent to `sys.unraiseablehook`. It is strongly "
"advised to never return an error from `__releasebuffer__`, and if it really "
"is necessary, to make best effort to perform any required freeing operations "
"before returning. `__releasebuffer__` will not be called a second time; "
"anything not freed will be leaked."
msgstr ""

#: src/class/protocols.md:413
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:415
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references.  To do this, implement the two methods `__traverse__` and "
"`__clear__`.  These correspond to the slots `tp_traverse` and `tp_clear` in "
"the Python C API. `__traverse__` must call `visit.call()` for each reference "
"to another Python object.  `__clear__` must clear out any mutable references "
"to other Python objects (thus breaking reference cycles). Immutable "
"references do not have to be cleared, as every cycle must contain at least "
"one mutable reference."
msgstr ""

#: src/class/protocols.md:424
msgid ""
"`__traverse__(<self>, pyo3::class::gc::PyVisit<'_>) -> Result<(), pyo3::"
"class::gc::PyTraverseError>`"
msgstr ""

#: src/class/protocols.md:425
msgid "`__clear__(<self>) -> ()`"
msgstr ""

#: src/class/protocols.md:449
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:455
msgid ""
"Usually, an implementation of `__traverse__` should do nothing but calls to "
"`visit.call`. Most importantly, safe access to the GIL is prohibited inside "
"implementations of `__traverse__`, i.e. `Python::with_gil` will panic."
msgstr ""

#: src/class/protocols.md:459
msgid ""
"Note: these methods are part of the C API, PyPy does not necessarily honor "
"them. If you are building for PyPy you should measure memory consumption to "
"make sure you do not have runaway memory growth. See [this issue on the PyPy "
"bug tracker](https://github.com/pypy/pypy/issues/3848)."
msgstr ""

#: src/class/object.md:3
msgid "Recall the `Number` class from the previous chapter:"
msgstr ""

#: src/class/object.md:27
msgid ""
"At this point Python code can import the module, access the class and create "
"class instances - but nothing else."
msgstr ""

#: src/class/object.md:41
msgid "String representations"
msgstr ""

#: src/class/object.md:43
msgid ""
"It can't even print an user-readable representation of itself! We can fix "
"that by defining the `__repr__` and `__str__` methods inside a "
"`#[pymethods]` block. We do this by accessing the value contained inside "
"`Number`."
msgstr ""

#: src/class/object.md:55
msgid ""
"// For `__repr__` we want to return a string that Python code could use to "
"recreate\n"
"    // the `Number`, like `Number(5)` for example.\n"
msgstr ""

#: src/class/object.md:58
msgid ""
"// We use the `format!` macro to create a string. Its first argument is a\n"
"        // format string, followed by any number of parameters which replace "
"the\n"
"        // `{}`'s in the format string.\n"
"        //\n"
"        //                       üëá Tuple field access in Rust uses a dot\n"
msgstr ""

#: src/class/object.md:63
msgid "\"Number({})\""
msgstr ""

#: src/class/object.md:65
msgid ""
"// `__str__` is generally used to create an \"informal\" representation, so "
"we\n"
"    // just forward to `i32`'s `ToString` trait implementation to print a "
"bare number.\n"
msgstr ""

#: src/class/object.md:73
msgid "Accessing the class name"
msgstr ""

#: src/class/object.md:75
msgid ""
"In the `__repr__`, we used a hard-coded class name. This is sometimes not "
"ideal, because if the class is subclassed in Python, we would like the repr "
"to reflect the subclass name. This is typically done in Python code by "
"accessing `self.__class__.__name__`. In order to be able to access the "
"Python type information _and_ the Rust struct, we need to use a `Bound` as "
"the `self` argument."
msgstr ""

#: src/class/object.md:92
msgid "// This is the equivalent of `self.__class__.__name__` in Python.\n"
msgstr ""

#: src/class/object.md:94
msgid ""
"// To access fields of the Rust struct, we need to borrow the `PyCell`.\n"
msgstr ""

#: src/class/object.md:95 src/class/object.md:311
msgid "\"{}({})\""
msgstr ""

#: src/class/object.md:100
msgid "Hashing"
msgstr ""

#: src/class/object.md:103
msgid ""
"Let's also implement hashing. We'll just hash the `i32`. For that we need a "
"[`Hasher`](https://doc.rust-lang.org/std/hash/trait.Hasher.html). The one "
"provided by `std` is [`DefaultHasher`](https://doc.rust-lang.org/std/"
"collections/hash_map/struct.DefaultHasher.html), which uses the [SipHash]"
"(https://en.wikipedia.org/wiki/SipHash) algorithm."
msgstr ""

#: src/class/object.md:108
msgid ""
"// Required to call the `.hash` and `.finish` methods, which are defined on "
"traits.\n"
msgstr ""

#: src/class/object.md:127
msgid ""
"To implement `__hash__` using the Rust [`Hash`](https://doc.rust-lang.org/"
"std/hash/trait.Hash.html) trait implementation, the `hash` option can be "
"used. This option is only available for `frozen` classes to prevent "
"accidental hash changes from mutating the object. If you need an `__hash__` "
"implementation for a mutable class, use the manual method from above. This "
"option also requires `eq`: According to the [Python docs](https://docs."
"python.org/3/reference/datamodel.html#object.__hash__) \"If a class does not "
"define an `__eq__()` method it should not define a `__hash__()` operation "
"either\""
msgstr ""

#: src/class/object.md:142
msgid ""
"**Note**: When implementing `__hash__` and comparisons, it is important that "
"the following property holds:"
msgstr ""

#: src/class/object.md:148
msgid ""
"In other words, if two keys are equal, their hashes must also be equal. In "
"addition you must take care that your classes' hash doesn't change during "
"its lifetime. In this tutorial we do that by not letting Python code change "
"our `Number` class. In other words, it is immutable."
msgstr ""

#: src/class/object.md:152
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to None. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/object.md:168
msgid "Comparisons"
msgstr ""

#: src/class/object.md:170
msgid ""
"PyO3 supports the usual magic comparison methods available in Python such as "
"`__eq__`, `__lt__` and so on. It is also possible to support all six "
"operations at once with `__richcmp__`. This method will be called with a "
"value of `CompareOp` depending on the operation."
msgstr ""

#: src/class/object.md:198
msgid ""
"If you obtain the result by comparing two Rust values, as in this example, "
"you can take a shortcut using `CompareOp::matches`:"
msgstr ""

#: src/class/object.md:218
msgid ""
"It checks that the `std::cmp::Ordering` obtained from Rust's `Ord` matches "
"the given `CompareOp`."
msgstr ""

#: src/class/object.md:221
msgid "Alternatively, you can implement just equality using `__eq__`:"
msgstr ""

#: src/class/object.md:248
msgid ""
"To implement `__eq__` using the Rust [`PartialEq`](https://doc.rust-lang.org/"
"stable/std/cmp/trait.PartialEq.html) trait implementation, the `eq` option "
"can be used."
msgstr ""

#: src/class/object.md:259
msgid ""
"To implement `__lt__`, `__le__`, `__gt__`, & `__ge__` using the Rust "
"`PartialOrd` trait implementation, the `ord` option can be used. _Note: "
"Requires `eq`._"
msgstr ""

#: src/class/object.md:270
msgid "Truthyness"
msgstr ""

#: src/class/object.md:272
msgid "We'll consider `Number` to be `True` if it is nonzero:"
msgstr ""

#: src/class/object.md:289
msgid "Final code"
msgstr ""

#: src/class/call.md:3
msgid ""
"Classes can be callable if they have a `#[pymethod]` named `__call__`. This "
"allows instances of a class to behave similar to functions."
msgstr ""

#: src/class/call.md:6
msgid ""
"This method's signature must look like `__call__(<self>, ...) -> object` - "
"here, any argument list can be defined as for normal pymethods"
msgstr ""

#: src/class/call.md:9
msgid "Example: Implementing a call counter"
msgstr ""

#: src/class/call.md:11
msgid ""
"The following pyclass is a basic decorator - its constructor takes a Python "
"object as argument and calls that object when called. An equivalent Python "
"implementation is linked at the end."
msgstr ""

#: src/class/call.md:15
msgid ""
"An example crate containing this pyclass can be found [here](https://github."
"com/PyO3/pyo3/tree/main/examples/decorator)"
msgstr ""

#: src/class/call.md:21
msgid ""
"/// A function decorator that keeps track how often it is called.\n"
"///\n"
"/// It otherwise doesn't do anything special.\n"
msgstr ""

#: src/class/call.md:25
msgid "\"Counter\""
msgstr ""

#: src/class/call.md:27
msgid ""
"// Keeps track of how many calls have gone through.\n"
"    //\n"
"    // See the discussion at the end for why `Cell` is used.\n"
msgstr ""

#: src/class/call.md:32
msgid "// This is the actual function being wrapped.\n"
msgstr ""

#: src/class/call.md:38
msgid ""
"// Note that we don't validate whether `wraps` is actually callable.\n"
"    //\n"
"    // While we could use `PyAny::is_callable` for that, it has some flaws:\n"
"    //    1. It doesn't guarantee the object can actually be called "
"successfully\n"
"    //    2. We still need to handle any exceptions that the function might "
"raise\n"
msgstr ""

#: src/class/call.md:68 src/class/call.md:162
msgid "\"{} has been called {} time(s).\""
msgstr ""

#: src/class/call.md:70 src/class/call.md:164
msgid ""
"// After doing something, we finally forward the call to the wrapped "
"function\n"
msgstr ""

#: src/class/call.md:73
msgid ""
"// We could do something with the return value of\n"
"        // the function before returning it\n"
msgstr ""

#: src/class/call.md:86
msgid "Python code:"
msgstr ""

#: src/class/call.md:105
msgid "Output:"
msgstr ""

#: src/class/call.md:118
msgid "Pure Python implementation"
msgstr ""

#: src/class/call.md:120
msgid "A Python implementation of this looks similar to the Rust version:"
msgstr ""

#: src/class/call.md:130 src/class/call.md:142
msgid " has been called "
msgstr ""

#: src/class/call.md:130 src/class/call.md:142
msgid " time(s)\""
msgstr ""

#: src/class/call.md:134
msgid "Note that it can also be implemented as a higher order function:"
msgstr ""

#: src/class/call.md:147
msgid "What is the `Cell` for?"
msgstr ""

#: src/class/call.md:149
msgid ""
"A [previous implementation](https://github.com/PyO3/pyo3/discussions/2598 "
"\"Thread Safe Decorator <Help Wanted> ¬∑ Discussion #2598 ¬∑ PyO3/pyo3\") used "
"a normal `u64`, which meant it required a `&mut self` receiver to update the "
"count:"
msgstr ""

#: src/class/call.md:167
msgid ""
"// We could do something with the return value of\n"
"    // the function before returning it\n"
msgstr ""

#: src/class/call.md:173
msgid ""
"The problem with this is that the `&mut self` receiver means PyO3 has to "
"borrow it exclusively, and hold this borrow across the`self.wraps.call(py, "
"args, kwargs)` call. This call returns control to the user's Python code "
"which is free to call arbitrary things, _including_ the decorated function. "
"If that happens PyO3 is unable to create a second unique borrow and will be "
"forced to raise an exception."
msgstr ""

#: src/class/call.md:177
msgid "As a result, something innocent like this will raise an exception:"
msgstr ""

#: src/class/call.md:183
msgid "\"hello from decorator\""
msgstr ""

#: src/class/call.md:185
msgid "# RuntimeError: Already borrowed\n"
msgstr ""

#: src/class/call.md:189
msgid ""
"The implementation in this chapter fixes that by never borrowing "
"exclusively; all the methods take `&self` as receivers, of which multiple "
"may exist simultaneously. This requires a shared counter and the easiest way "
"to do that is to use [`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell."
"html \"Cell in std::cell - Rust\"), so that's what is used here."
msgstr ""

#: src/class/call.md:191
msgid ""
"This shows the dangers of running arbitrary Python code - note that "
"\"running arbitrary Python code\" can be far more subtle than the example "
"above:"
msgstr ""

#: src/class/call.md:192
msgid ""
"Python's asynchronous executor may park the current thread in the middle of "
"Python code, even in Python code that _you_ control, and let other Python "
"code run."
msgstr ""

#: src/class/call.md:193
msgid ""
"Dropping arbitrary Python objects may invoke destructors defined in Python "
"(`__del__` methods)."
msgstr ""

#: src/class/call.md:194
msgid ""
"Calling Python's C-api (most PyO3 apis call C-api functions internally) may "
"raise exceptions, which may allow Python code in signal handlers to run."
msgstr ""

#: src/class/call.md:196
msgid ""
"This is especially important if you are writing unsafe code; Python code "
"must never be able to cause undefined behavior. You must ensure that your "
"Rust code is in a consistent state before doing any of the above things."
msgstr ""

#: src/class/numeric.md:3
msgid ""
"At this point we have a `Number` class that we can't actually do any math on!"
msgstr ""

#: src/class/numeric.md:5
msgid ""
"Before proceeding, we should think about how we want to handle overflows. "
"There are three obvious solutions:"
msgstr ""

#: src/class/numeric.md:6
msgid ""
"We can have infinite precision just like Python's `int`. However that would "
"be quite boring - we'd be reinventing the wheel."
msgstr ""

#: src/class/numeric.md:8
msgid ""
"We can raise exceptions whenever `Number` overflows, but that makes the API "
"painful to use."
msgstr ""

#: src/class/numeric.md:9
msgid ""
"We can wrap around the boundary of `i32`. This is the approach we'll take "
"here. To do that we'll just forward to `i32`'s `wrapping_*` methods."
msgstr ""

#: src/class/numeric.md:12
msgid "Fixing our constructor"
msgstr ""

#: src/class/numeric.md:14
msgid "Let's address the first overflow, in `Number`'s constructor:"
msgstr ""

#: src/class/numeric.md:22
msgid ""
"```text\n"
"Traceback (most recent call last):\n"
"  File \"example.py\", line 3, in <module>\n"
"    n = Number(1 << 1337)\n"
"OverflowError: Python int too large to convert to C long\n"
"```"
msgstr ""

#: src/class/numeric.md:29
msgid ""
"Instead of relying on the default [`FromPyObject`](https://pyo3.rs/main/doc/"
"pyo3/conversion/trait.FromPyObject.html) extraction to parse arguments, we "
"can specify our own extraction function, using the `#[pyo3(from_py_with = "
"\"...\")]` attribute. Unfortunately PyO3 doesn't provide a way to wrap "
"Python integers out of the box, but we can do a Python call to mask it and "
"cast it to an `i32`."
msgstr ""

#: src/class/numeric.md:39 src/class/numeric.md:52 src/class/numeric.md:216
msgid "\"__and__\""
msgstr ""

#: src/class/numeric.md:41
msgid "//     üëá This intentionally overflows!\n"
msgstr ""

#: src/class/numeric.md:45
msgid ""
"We also add documentation, via `///` comments, which are visible to Python "
"users."
msgstr ""

#: src/class/numeric.md:56 src/class/numeric.md:219
msgid ""
"/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought "
"not.\n"
"/// It's not a story C would tell you. It's a Rust legend.\n"
msgstr ""

#: src/class/numeric.md:72
msgid "With that out of the way, let's implement some operators:"
msgstr ""

#: src/class/numeric.md:98 src/class/numeric.md:105 src/class/numeric.md:278
#: src/class/numeric.md:285
msgid "\"division by zero\""
msgstr ""

#: src/class/numeric.md:112 src/class/numeric.md:119 src/class/numeric.md:292
#: src/class/numeric.md:299
msgid "\"negative shift count\""
msgstr ""

#: src/class/numeric.md:125
msgid "Unary arithmetic operations"
msgstr ""

#: src/class/numeric.md:153
msgid "Support for the `complex()`, `int()` and `float()` built-in functions."
msgstr ""

#: src/class/numeric.md:179
msgid ""
"We do not implement the in-place operations like `__iadd__` because we do "
"not wish to mutate `Number`. Similarly we're not interested in supporting "
"operations with different types, so we do not implement the reflected "
"operations like `__radd__` either."
msgstr ""

#: src/class/numeric.md:183
msgid "Now Python can use our `Number` class:"
msgstr ""

#: src/class/numeric.md:189
msgid ""
"'''\n"
"\tA version of Daniel J. Bernstein's djb2 string hashing algorithm\n"
"\tLike many hashing algorithms, it relies on integer wrapping.\n"
"\t'''"
msgstr ""

#: src/class/numeric.md:201
msgid "'l50_50'"
msgstr ""

#: src/class/numeric.md:233
msgid "// Get the class name dynamically in case `Number` is subclassed\n"
msgstr ""

#: src/class/numeric.md:333
msgid ""
"r#\"\n"
"# def hash_djb2(s: str):\n"
"#     n = Number(0)\n"
"#     five = Number(5)\n"
"#\n"
"#     for x in s:\n"
"#         n = Number(ord(x)) + ((n << five) - n)\n"
"#     return n\n"
"#\n"
"# assert hash_djb2('l50_50') == Number(-1152549421)\n"
"# assert hash_djb2('logo') == Number(3327403)\n"
"# assert hash_djb2('horizon') == Number(1097468315)\n"
"#\n"
"#\n"
"# assert Number(2) + Number(2) == Number(4)\n"
"# assert Number(2) + Number(2) != Number(5)\n"
"#\n"
"# assert Number(13) - Number(7) == Number(6)\n"
"# assert Number(13) - Number(-7) == Number(20)\n"
"#\n"
"# assert Number(13) / Number(7) == Number(1)\n"
"# assert Number(13) // Number(7) == Number(1)\n"
"#\n"
"# assert Number(13) * Number(7) == Number(13*7)\n"
"#\n"
"# assert Number(13) > Number(7)\n"
"# assert Number(13) < Number(20)\n"
"# assert Number(13) == Number(13)\n"
"# assert Number(13) >= Number(7)\n"
"# assert Number(13) <= Number(20)\n"
"# assert Number(13) == Number(13)\n"
"#\n"
"#\n"
"# assert (True if Number(1) else False)\n"
"# assert (False if Number(0) else True)\n"
"#\n"
"#\n"
"# assert int(Number(13)) == 13\n"
"# assert float(Number(13)) == 13\n"
"# assert Number.__doc__ == \"Did you ever hear the tragedy of Darth Signed "
"The Overfloweth? I thought not.\\nIt's not a story C would tell you. It's a "
"Rust legend.\"\n"
"# assert Number(12345234523452) == Number(1498514748)\n"
"# try:\n"
"#     import inspect\n"
"#     assert inspect.signature(Number).__str__() == '(value)'\n"
"# except ValueError:\n"
"#     # Not supported with `abi3` before Python 3.10\n"
"#     pass\n"
"# assert Number(1337).__str__() == '1337'\n"
"# assert Number(1337).__repr__() == 'Number(1337)'\n"
"\"#"
msgstr ""

#: src/class/numeric.md:390
msgid "\"Number\""
msgstr ""

#: src/class/numeric.md:398
msgid "Appendix: Writing some unsafe code"
msgstr ""

#: src/class/numeric.md:400
msgid ""
"At the beginning of this chapter we said that PyO3 doesn't provide a way to "
"wrap Python integers out of the box but that's a half truth. There's not a "
"PyO3 API for it, but there's a Python C API function that does:"
msgstr ""

#: src/class/numeric.md:408
msgid ""
"We can call this function from Rust by using [`pyo3::ffi::"
"PyLong_AsUnsignedLongMask`](https://pyo3.rs/main/doc/pyo3/ffi/fn."
"PyLong_AsUnsignedLongMask.html). This is an _unsafe_ function, which means "
"we have to use an unsafe block to call it and take responsibility for "
"upholding the contracts of this function. Let's review those contracts:"
msgstr ""

#: src/class/numeric.md:411
msgid ""
"The GIL must be held. If it's not, calling this function causes a data race."
msgstr ""

#: src/class/numeric.md:412
msgid ""
"The pointer must be valid, i.e. it must be properly aligned and point to a "
"valid Python object."
msgstr ""

#: src/class/numeric.md:414
msgid ""
"Let's create that helper function. The signature has to be `fn(&Bound<'_, "
"PyAny>) -> PyResult<T>`."
msgstr ""

#: src/class/numeric.md:415
msgid ""
"`&Bound<'_, PyAny>` represents a checked borrowed reference, so the pointer "
"derived from it is valid (and not null)."
msgstr ""

#: src/class/numeric.md:416
msgid ""
"Whenever we have borrowed references to Python objects in scope, it is "
"guaranteed that the GIL is held. This reference is also where we can get a "
"[`Python`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html) token to "
"use in our call to [`PyErr::take`](https://pyo3.rs/main/doc/pyo3/prelude/"
"struct.PyErr.html#method.take)."
msgstr ""

#: src/function.md:3
msgid ""
"The `#[pyfunction]` attribute is used to define a Python function from a "
"Rust function. Once defined, the function needs to be added to a [module](./"
"module.md) using the `wrap_pyfunction!` macro."
msgstr ""

#: src/function.md:5
msgid ""
"The following example defines a function called `double` in a Python module "
"called `my_extension`:"
msgstr ""

#: src/function.md:21
msgid ""
"This chapter of the guide explains full usage of the `#[pyfunction]` "
"attribute. In this first section, the following topics are covered:"
msgstr ""

#: src/function.md:23
msgid "[Function options](#function-options)"
msgstr ""

#: src/function.md:24
msgid "[`#[pyo3(name = \"...\")]`](#name)"
msgstr ""

#: src/function.md:25
msgid "[`#[pyo3(signature = (...))]`](#signature)"
msgstr ""

#: src/function.md:26
msgid "[`#[pyo3(text_signature = \"...\")]`](#text_signature)"
msgstr ""

#: src/function.md:27
msgid "[`#[pyo3(pass_module)]`](#pass_module)"
msgstr ""

#: src/function.md:28
msgid "[Per-argument options](#per-argument-options)"
msgstr ""

#: src/function.md:29
msgid "[Advanced function patterns](#advanced-function-patterns)"
msgstr ""

#: src/function.md:30
msgid "[`#[pyfn]` shorthand](#pyfn-shorthand)"
msgstr ""

#: src/function.md:32
msgid "There are also additional sections on the following topics:"
msgstr ""

#: src/function.md:34
msgid "[Function Signatures](./function/signature.md)"
msgstr ""

#: src/function.md:36
msgid "Function options"
msgstr ""

#: src/function.md:38
msgid ""
"The `#[pyo3]` attribute can be used to modify properties of the generated "
"Python function. It can take any combination of the following options:"
msgstr ""

#: src/function.md:40
msgid "<a id=\"name\"></a> `#[pyo3(name = \"...\")]`"
msgstr ""

#: src/function.md:42
msgid "Overrides the name exposed to Python."
msgstr ""

#: src/function.md:44
msgid ""
"In the following example, the Rust function `no_args_py` will be added to "
"the Python module `module_with_functions` as the Python function `no_args`:"
msgstr ""

#: src/function.md:51 src/function.md:63
msgid "\"no_args\""
msgstr ""

#: src/function.md:64
msgid "\"no_args_py\""
msgstr ""

#: src/function.md:68
msgid "<a id=\"signature\"></a> `#[pyo3(signature = (...))]`"
msgstr ""

#: src/function.md:70
msgid ""
"Defines the function signature in Python. See [Function Signatures](./"
"function/signature.md)."
msgstr ""

#: src/function.md:72
msgid "<a id=\"text_signature\"></a> `#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function.md:74
msgid ""
"Overrides the PyO3-generated function signature visible in Python tooling "
"(such as via [`inspect.signature`](https://docs.python.org/3/library/inspect."
"html#inspect.signature)). See the [corresponding topic in the Function "
"Signatures subchapter](./function/signature.md#making-the-function-signature-"
"available-to-python)."
msgstr ""

#: src/function.md:76
msgid "<a id=\"pass_module\" ></a> `#[pyo3(pass_module)]`"
msgstr ""

#: src/function.md:78
msgid ""
"Set this option to make PyO3 pass the containing module as the first "
"argument to the function. It is then possible to use the module in the "
"function body. The first argument **must** be of type `&Bound<'_, "
"PyModule>`, `Bound<'_, PyModule>`, or `Py<PyModule>`."
msgstr ""

#: src/function.md:80
msgid ""
"The following example creates a function `pyfunction_with_module` which "
"returns the containing module's name (i.e. `module_with_fn`):"
msgstr ""

#: src/function.md:100
msgid "Per-argument options"
msgstr ""

#: src/function.md:102
msgid ""
"The `#[pyo3]` attribute can be used on individual arguments to modify "
"properties of them in the generated function. It can take any combination of "
"the following options:"
msgstr ""

#: src/function.md:104
msgid "<a id=\"from_py_with\"></a> `#[pyo3(from_py_with = \"...\")]`"
msgstr ""

#: src/function.md:106
msgid ""
"Set this on an option to specify a custom function to convert the function "
"argument from Python to the desired Rust type, instead of using the default "
"`FromPyObject` extraction. The function signature must be `fn(&Bound<'_, "
"PyAny>) -> PyResult<T>` where `T` is the Rust type of the argument."
msgstr ""

#: src/function.md:108
msgid ""
"The following example uses `from_py_with` to convert the input Python object "
"to its length:"
msgstr ""

#: src/function.md:128
msgid "Advanced function patterns"
msgstr ""

#: src/function.md:130
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:132
msgid ""
"You can pass Python `def`'d functions and built-in functions to Rust "
"functions [`PyFunction`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFunction.html) corresponds to regular Python functions while "
"[`PyCFunction`](https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html) "
"describes built-ins such as `repr()`."
msgstr ""

#: src/function.md:136
msgid ""
"You can also use [`Bound<'_, PyAny>::is_callable`](https://pyo3.rs/main/doc/"
"pyo3/prelude/trait.PyAnyMethods.html#tymethod.is_callable) to check if you "
"have a callable object. `is_callable` will return `true` for functions "
"(including lambdas), methods and objects with a `__call__` method. You can "
"call the object with [`Bound<'_, PyAny>::call`](https://pyo3.rs/main/doc/"
"pyo3/prelude/trait.PyAnyMethods.html#tymethod.call) with the args as first "
"parameter and the kwargs (or `None`) as second parameter. There are also "
"[`Bound<'_, PyAny>::call0`](https://pyo3.rs/main/doc/pyo3/prelude/trait."
"PyAnyMethods.html#tymethod.call0) with no args and [`Bound<'_, PyAny>::"
"call1`](https://pyo3.rs/main/doc/pyo3/prelude/trait.PyAnyMethods."
"html#tymethod.call1) with only positional args."
msgstr ""

#: src/function.md:142
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:144
msgid ""
"The ways to convert a Rust function into a Python object vary depending on "
"the function:"
msgstr ""

#: src/function.md:146
msgid ""
"Named functions, e.g. `fn foo()`: add `#[pyfunction]` and then use "
"[`wrap_pyfunction!`](https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction."
"html) to get the corresponding [`PyCFunction`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyCFunction.html)."
msgstr ""

#: src/function.md:147
msgid "Anonymous functions (or closures), e.g. `foo: fn()` either:"
msgstr ""

#: src/function.md:148
msgid ""
"use a `#[pyclass]` struct which stores the function as a field and implement "
"`__call__` to call the stored function."
msgstr ""

#: src/function.md:149
msgid ""
"use `PyCFunction::new_closure` to create an object directly from the "
"function."
msgstr ""

#: src/function.md:159
msgid "Accessing the FFI functions"
msgstr ""

#: src/function.md:161
msgid ""
"In order to make Rust functions callable from Python, PyO3 generates an "
"`extern \"C\"` function whose exact signature depends on the Rust "
"signature.  (PyO3 chooses the optimal Python argument passing convention.) "
"It then embeds the call to the Rust function inside this FFI-wrapper "
"function. This wrapper handles extraction of the regular arguments and the "
"keyword arguments from the input `PyObject`s."
msgstr ""

#: src/function.md:167
msgid ""
"The `wrap_pyfunction` macro can be used to directly get a "
"`Bound<PyCFunction>` given a `#[pyfunction]` and a `Bound<PyModule>`: "
"`wrap_pyfunction!(rust_fun, module)`."
msgstr ""

#: src/function.md:170
msgid "`#[pyfn]` shorthand"
msgstr ""

#: src/function.md:172
msgid ""
"There is a shorthand to `#[pyfunction]` and `wrap_pymodule!`: the function "
"can be placed inside the module definition and annotated with `#[pyfn]`. To "
"simplify PyO3, it is expected that `#[pyfn]` may be removed in a future "
"release (See [\\#694](https://github.com/PyO3/pyo3/issues/694))."
msgstr ""

#: src/function.md:175
msgid "An example of `#[pyfn]` is below:"
msgstr ""

#: src/function.md:191
msgid ""
"`#[pyfn(m)]` is just syntactic sugar for `#[pyfunction]`, and takes all the "
"same options documented in the rest of this chapter. The code above is "
"expanded to the following:"
msgstr ""

#: src/function/error-handling.md:3
msgid ""
"This chapter contains a little background of error handling in Rust and how "
"PyO3 integrates this with Python exceptions."
msgstr ""

#: src/function/error-handling.md:5
msgid ""
"This covers enough detail to create a `#[pyfunction]` which raises Python "
"exceptions from errors originating in Rust."
msgstr ""

#: src/function/error-handling.md:7
msgid ""
"There is a later section of the guide on [Python exceptions](../exception."
"md) which covers exception types in more detail."
msgstr ""

#: src/function/error-handling.md:9
msgid "Representing Python exceptions"
msgstr ""

#: src/function/error-handling.md:11
msgid ""
"Rust code uses the generic [`Result<T, E>`](https://doc.rust-lang.org/stable/"
"std/result/enum.Result.html) enum to propagate errors. The error type `E` is "
"chosen by the code author to describe the possible errors which can happen."
msgstr ""

#: src/function/error-handling.md:13
msgid ""
"PyO3 has the [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct.PyErr.html) type "
"which represents a Python exception. If a PyO3 API could result in a Python "
"exception being raised, the return type of that `API` will be [`PyResult<T>`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/function/error-handling.md:15
msgid "In summary:"
msgstr ""

#: src/function/error-handling.md:16
msgid ""
"When Python exceptions are raised and caught by PyO3, the exception will be "
"stored in the `Err` variant of the `PyResult`."
msgstr ""

#: src/function/error-handling.md:17
msgid ""
"Passing Python exceptions through Rust code then uses all the \"normal\" "
"techniques such as the `?` operator, with `PyErr` as the error type."
msgstr ""

#: src/function/error-handling.md:18
msgid ""
"Finally, when a `PyResult` crosses from Rust back to Python via PyO3, if the "
"result is an `Err` variant the contained exception will be raised."
msgstr ""

#: src/function/error-handling.md:20
msgid ""
"(There are many great tutorials on Rust error handling and the `?` operator, "
"so this guide will not go into detail on Rust-specific topics.)"
msgstr ""

#: src/function/error-handling.md:22
msgid "Raising an exception from a function"
msgstr ""

#: src/function/error-handling.md:24
msgid ""
"As indicated in the previous section, when a `PyResult` containing an `Err` "
"crosses from Rust to Python, PyO3 will raise the exception contained within."
msgstr ""

#: src/function/error-handling.md:26
msgid ""
"Accordingly, to raise an exception from a `#[pyfunction]`, change the return "
"type `T` to `PyResult<T>`. When the function returns an `Err` it will raise "
"a Python exception. (Other `Result<T, E>` types can be used as long as the "
"error `E` has a `From` conversion for `PyErr`, see [custom Rust error types]"
"(#custom-rust-error-types) below.)"
msgstr ""

#: src/function/error-handling.md:28
msgid "This also works for functions in `#[pymethods]`."
msgstr ""

#: src/function/error-handling.md:30
msgid ""
"For example, the following `check_positive` function raises a `ValueError` "
"when the input is negative:"
msgstr ""

#: src/function/error-handling.md:39
msgid "\"x is negative\""
msgstr ""

#: src/function/error-handling.md:54
msgid ""
"All built-in Python exception types are defined in the [`pyo3::exceptions`]"
"(https://pyo3.rs/main/doc/pyo3/exceptions/index.html) module. They have a "
"`new_err` constructor to directly build a `PyErr`, as seen in the example "
"above."
msgstr ""

#: src/function/error-handling.md:56
msgid "Custom Rust error types"
msgstr ""

#: src/function/error-handling.md:58
msgid ""
"PyO3 will automatically convert a `Result<T, E>` returned by a "
"`#[pyfunction]` into a `PyResult<T>` as long as there is an implementation "
"of `std::from::From<E> for PyErr`. Many error types in the Rust standard "
"library have a [`From`](https://doc.rust-lang.org/stable/std/convert/trait."
"From.html) conversion defined in this way."
msgstr ""

#: src/function/error-handling.md:60
msgid ""
"If the type `E` you are handling is defined in a third-party crate, see the "
"section on [foreign rust error types](#foreign-rust-error-types) below for "
"ways to work with this error."
msgstr ""

#: src/function/error-handling.md:62
msgid ""
"The following example makes use of the implementation of "
"`From<ParseIntError> for PyErr` to raise exceptions encountered when parsing "
"strings as integers:"
msgstr ""

#: src/function/error-handling.md:76
msgid "\"5\""
msgstr ""

#: src/function/error-handling.md:82
msgid ""
"When passed a string which doesn't contain a floating-point number, the "
"exception raised will look like the below:"
msgstr ""

#: src/function/error-handling.md:87
msgid "\"<stdin>\""
msgstr ""

#: src/function/error-handling.md:91
msgid ""
"As a more complete example, the following snippet defines a Rust error named "
"`CustomIOError`. It then defines a `From<CustomIOError> for PyErr`, which "
"returns a `PyErr` representing Python's `OSError`. Therefore, it can use "
"this error in the result of a `#[pyfunction]` directly, relying on the "
"conversion if it has to be propagated into a Python exception."
msgstr ""

#: src/function/error-handling.md:106
msgid "\"Oh no!\""
msgstr ""

#: src/function/error-handling.md:119 src/function/error-handling.md:136
msgid "\"0.0.0.0\""
msgstr ""

#: src/function/error-handling.md:129
msgid "// etc.\n"
msgstr ""

#: src/function/error-handling.md:142
msgid ""
"If lazy construction of the Python exception instance is desired, the "
"[`PyErrArguments`](https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html) "
"trait can be implemented instead of `From`. In that case, actual exception "
"argument creation is delayed until the `PyErr` is needed."
msgstr ""

#: src/function/error-handling.md:147
msgid ""
"A final note is that any errors `E` which have a `From` conversion can be "
"used with the `?` (\"try\") operator with them. An alternative "
"implementation of the above `parse_int` which instead returns `PyResult` is "
"below:"
msgstr ""

#: src/function/error-handling.md:162
msgid "\"1\""
msgstr ""

#: src/function/error-handling.md:163
msgid "\"1337\""
msgstr ""

#: src/function/error-handling.md:165
msgid "\"-1\""
msgstr ""

#: src/function/error-handling.md:171
msgid "\"13.37\""
msgstr ""

#: src/function/error-handling.md:178
msgid "Foreign Rust error types"
msgstr ""

#: src/function/error-handling.md:180
msgid ""
"The Rust compiler will not permit implementation of traits for types outside "
"of the crate where the type is defined. (This is known as the \"orphan "
"rule\".)"
msgstr ""

#: src/function/error-handling.md:182
msgid ""
"Given a type `OtherError` which is defined in third-party code, there are "
"two main strategies available to integrate it with PyO3:"
msgstr ""

#: src/function/error-handling.md:184
msgid ""
"Create a newtype wrapper, e.g. `MyOtherError`. Then implement "
"`From<MyOtherError> for PyErr` (or `PyErrArguments`), as well as "
"`From<OtherError>` for `MyOtherError`."
msgstr ""

#: src/function/error-handling.md:185
msgid ""
"Use Rust's Result combinators such as `map_err` to write code freely to "
"convert `OtherError` into whatever is needed. This requires boilerplate at "
"every usage however gives unlimited flexibility."
msgstr ""

#: src/function/error-handling.md:187
msgid ""
"To detail the newtype strategy a little further, the key trick is to return "
"`Result<T, MyOtherError>` from the `#[pyfunction]`. This means that PyO3 "
"will make use of `From<MyOtherError> for PyErr` to create Python exceptions "
"while the `#[pyfunction]` implementation can use `?` to convert `OtherError` "
"to `MyOtherError` automatically."
msgstr ""

#: src/function/error-handling.md:189
msgid ""
"The following example demonstrates this for some imaginary third-party crate "
"`some_crate` with a function `get_x` returning `Result<i32, OtherError>`:"
msgstr ""

#: src/function/error-handling.md:195
msgid "\"some error occurred\""
msgstr ""

#: src/function/error-handling.md:220
msgid "// get_x is a function returning Result<i32, OtherError>\n"
msgstr ""

#: src/function/signature.md:3
msgid ""
"The `#[pyfunction]` attribute also accepts parameters to control how the "
"generated Python function accepts arguments. Just like in Python, arguments "
"can be positional-only, keyword-only, or accept either. `*args` lists and "
"`**kwargs` dicts can also be accepted. These parameters also work for "
"`#[pymethods]` which will be introduced in the [Python Classes](../class.md) "
"section of the guide."
msgstr ""

#: src/function/signature.md:5
msgid ""
"Like Python, by default PyO3 accepts all arguments as either positional or "
"keyword arguments. Most arguments are required by default, except for "
"trailing `Option<_>` arguments, which are [implicitly given a default of "
"`None`](#trailing-optional-arguments). This behaviour can be configured by "
"the `#[pyo3(signature = (...))]` option which allows writing a signature in "
"Python syntax."
msgstr ""

#: src/function/signature.md:7
msgid ""
"This section of the guide goes into detail about use of the "
"`#[pyo3(signature = (...))]` option and its related option "
"`#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function/signature.md:9
msgid "Using `#[pyo3(signature = (...))]`"
msgstr ""

#: src/function/signature.md:11
msgid ""
"For example, below is a function that accepts arbitrary keyword arguments "
"(`**kwargs` in Python syntax) and returns the number that was passed:"
msgstr ""

#: src/function/signature.md:29
msgid ""
"Just like in Python, the following constructs can be part of the signature::"
msgstr ""

#: src/function/signature.md:31
msgid ""
"`/`: positional-only arguments separator, each parameter defined before `/` "
"is a positional-only parameter."
msgstr ""

#: src/function/signature.md:32
msgid ""
"`*`: var arguments separator, each parameter defined after `*` is a keyword-"
"only parameter."
msgstr ""

#: src/function/signature.md:33
msgid ""
"`*args`: \"args\" is var args. Type of the `args` parameter has to be "
"`&Bound<'_, PyTuple>`."
msgstr ""

#: src/function/signature.md:34
msgid ""
"`**kwargs`: \"kwargs\" receives keyword arguments. The type of the `kwargs` "
"parameter has to be `Option<&Bound<'_, PyDict>>`."
msgstr ""

#: src/function/signature.md:35
msgid ""
"`arg=Value`: arguments with default value. If the `arg` argument is defined "
"after var arguments, it is treated as a keyword-only argument. Note that "
"`Value` has to be valid rust code, PyO3 just inserts it into the generated "
"code unmodified."
msgstr ""

#: src/function/signature.md:75
msgid "\"num={}\""
msgstr ""

#: src/function/signature.md:80
msgid "Arguments of type `Python` must not be part of the signature:"
msgstr ""

#: src/function/signature.md:92
msgid ""
"N.B. the position of the `/` and `*` arguments (if included) control the "
"system of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/function/signature.md:101
msgid "Produces output:"
msgstr ""

#: src/function/signature.md:109
msgid ""
"Note: to use keywords like `struct` as a function argument, use \"raw "
"identifier\" syntax `r#struct` in both the signature and the function "
"definition:"
msgstr ""

#: src/function/signature.md:121
msgid "Trailing optional arguments"
msgstr ""

#: src/function/signature.md:125
msgid "‚ö†Ô∏è Warning: This behaviour is being phased out üõ†Ô∏è"
msgstr ""

#: src/function/signature.md:127
msgid ""
"The special casing of trailing optional arguments is deprecated. In a future "
"`pyo3` version, arguments of type `Option<..>` will share the same behaviour "
"as other arguments, they are required unless a default is set using "
"`#[pyo3(signature = (...))]`."
msgstr ""

#: src/function/signature.md:129
msgid ""
"This is done to better align the Python and Rust definition of such "
"functions and make it more intuitive to rewrite them from Python in Rust. "
"Specifically `def some_fn(a: int, b: Optional[int]): ...` will not "
"automatically default `b` to `none`, but requires an explicit default if "
"desired, where as in current `pyo3` it is handled the other way around."
msgstr ""

#: src/function/signature.md:131
msgid ""
"During the migration window a `#[pyo3(signature = (...))]` will be required "
"to silence the deprecation warning. After support for trailing optional "
"arguments is fully removed, the signature attribute can be removed if all "
"arguments should be required."
msgstr ""

#: src/function/signature.md:135
msgid ""
"As a convenience, functions without a `#[pyo3(signature = (...))]` option "
"will treat trailing `Option<T>` arguments as having a default of `None`. In "
"the example below, PyO3 will create `increment` with a signature of "
"`increment(x, amount=None)`."
msgstr ""

#: src/function/signature.md:140
msgid ""
"/// Returns a copy of `x` increased by `amount`.\n"
"///\n"
"/// If `amount` is unspecified or `None`, equivalent to `x + 1`.\n"
msgstr ""

#: src/function/signature.md:159 src/function/signature.md:187
#: src/function/signature.md:230
msgid "// on 3.7 the signature doesn't render b, upstream bug?\n"
msgstr ""

#: src/function/signature.md:160
msgid "\"(x, amount=None)\""
msgstr ""

#: src/function/signature.md:167
msgid ""
"To make trailing `Option<T>` arguments required, but still accept `None`, "
"add a `#[pyo3(signature = (...))]` annotation. For the example above, this "
"would be `#[pyo3(signature = (x, amount))]`:"
msgstr ""

#: src/function/signature.md:188
msgid "\"(x, amount)\""
msgstr ""

#: src/function/signature.md:195
msgid ""
"To help avoid confusion, PyO3 requires `#[pyo3(signature = (...))]` when an "
"`Option<T>` argument is surrounded by arguments which aren't `Option<T>`."
msgstr ""

#: src/function/signature.md:197
msgid "Making the function signature available to Python"
msgstr ""

#: src/function/signature.md:199
msgid ""
"The function signature is exposed to Python via the `__text_signature__` "
"attribute. PyO3 automatically generates this for every `#[pyfunction]` and "
"all `#[pymethods]` directly from the Rust function, taking into account any "
"override done with the `#[pyo3(signature = (...))]` option."
msgstr ""

#: src/function/signature.md:201
msgid ""
"This automatic generation can only display the value of default arguments "
"for strings, integers, boolean types, and `None`. Any other default "
"arguments will be displayed as `...`. (`.pyi` type stub files commonly also "
"use `...` for default arguments in the same way.)"
msgstr ""

#: src/function/signature.md:203
msgid ""
"In cases where the automatically-generated signature needs adjusting, it can "
"[be overridden](#overriding-the-generated-signature) using the "
"`#[pyo3(text_signature)]` option.)"
msgstr ""

#: src/function/signature.md:205
msgid ""
"The example below creates a function `add` which accepts two positional-only "
"arguments `a` and `b`, where `b` has a default value of zero."
msgstr ""

#: src/function/signature.md:209 src/function/signature.md:257
#: src/function/signature.md:299
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function/signature.md:222 src/function/signature.md:270
#: src/function/signature.md:312
msgid "\"This function adds two unsigned 64-bit integers.\""
msgstr ""

#: src/function/signature.md:231 src/function/signature.md:260
#: src/function/signature.md:277
msgid "\"(a, b=0, /)\""
msgstr ""

#: src/function/signature.md:238
msgid ""
"The following IPython output demonstrates how this generated signature will "
"be seen from Python tooling:"
msgstr ""

#: src/function/signature.md:249
msgid "Overriding the generated signature"
msgstr ""

#: src/function/signature.md:251
msgid ""
"The `#[pyo3(text_signature = \"(<some signature>)\")]` attribute can be used "
"to override the default generated signature."
msgstr ""

#: src/function/signature.md:253
msgid ""
"In the snippet below, the text signature attribute is used to include the "
"default value of `0` for the argument `b`, instead of the automatically-"
"generated default value of `...`:"
msgstr ""

#: src/function/signature.md:284
msgid ""
"PyO3 will include the contents of the annotation unmodified as the "
"`__text_signature__`. Below shows how IPython will now present this (see the "
"default value of 0 for b):"
msgstr ""

#: src/function/signature.md:295
msgid ""
"If no signature is wanted at all, `#[pyo3(text_signature = None)]` will "
"disable the built-in signature. The snippet below demonstrates use of this:"
msgstr ""

#: src/function/signature.md:320
msgid ""
"Now the function's `__text_signature__` will be set to `None`, and IPython "
"will not display any signature in the help:"
msgstr ""

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr ""

#: src/module.md:12
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:20
msgid ""
"The `#[pymodule]` procedural macro takes care of exporting the "
"initialization function of your module to Python."
msgstr ""

#: src/module.md:23
msgid ""
"The module's name defaults to the name of the Rust function. You can "
"override the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:34
msgid "\"custom_name\""
msgstr ""

#: src/module.md:40
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:44
msgid "To import the module, either:"
msgstr ""

#: src/module.md:45
msgid ""
"copy the shared library as described in [Manual builds](building-and-"
"distribution.md#manual-builds), or"
msgstr ""

#: src/module.md:46
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:49
msgid "Documentation"
msgstr ""

#: src/module.md:51
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the module initialization function will be applied "
"automatically as the Python docstring of your module."
msgstr ""

#: src/module.md:54
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:62
msgid "Python submodules"
msgstr ""

#: src/module.md:64
msgid ""
"You can create a module hierarchy within a single extension module by using "
"[`Bound<'_, PyModule>::add_submodule()`](https://pyo3.rs/main/doc/pyo3/"
"prelude/trait.PyModuleMethods.html#tymethod.add_submodule). For example, you "
"could define the modules `parent_module` and `parent_module.child_module`."
msgstr ""

#: src/module.md:78
msgid "\"child_module\""
msgstr ""

#: src/module.md:85
msgid "\"func\""
msgstr ""

#: src/module.md:92
msgid "\"parent_module\""
msgstr ""

#: src/module.md:94
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:98
msgid ""
"Note that this does not define a package, so this won‚Äôt allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:103
msgid ""
"It is not necessary to add `#[pymodule]` on nested modules, which is only "
"required on the top-level module."
msgstr ""

#: src/module.md:105
msgid "Declarative modules"
msgstr ""

#: src/module.md:107
msgid ""
"Another syntax based on Rust inline modules is also available to declare "
"modules."
msgstr ""

#: src/module.md:124
msgid "// Exports the double function as part of the module\n"
msgstr ""

#: src/module.md:126 src/module.md:131 src/module.md:173
msgid "// This will be part of the module\n"
msgstr ""

#: src/module.md:136 src/module.md:171
msgid "// This is a submodule\n"
msgstr ""

#: src/module.md:141
msgid "// Arbitrary code to run at the module initialization\n"
msgstr ""

#: src/module.md:142
msgid "\"double2\""
msgstr ""

#: src/module.md:142
msgid "\"double\""
msgstr ""

#: src/module.md:148
msgid ""
"The `#[pymodule]` macro automatically sets the `module` attribute of the "
"`#[pyclass]` macros declared inside of it with its name. For nested modules, "
"the name of the parent module is automatically added. In the following "
"example, the `Unit` class will have for `module` `my_extension.submodule` "
"because it is properly nested but the `Ext` class will have for `module` the "
"default `builtins` because it not nested."
msgstr ""

#: src/module.md:153
msgid ""
"You can provide the `submodule` argument to `pymodule()` for modules that "
"are not top-level modules."
msgstr ""

#: src/module.md:179
msgid ""
"It is possible to customize the `module` value for a `#[pymodule]` with the "
"`#[pyo3(module = \"MY_MODULE\")]` option."
msgstr ""
