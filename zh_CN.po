msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:17Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr ""

#: src/advanced.md:3
msgid "FFI"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of Python's C API through the `ffi` module."
msgstr ""

#: src/advanced.md:7
msgid ""
"The C API is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that API."
msgstr ""

#: src/migration.md:1
msgid "Migrating from older PyO3 versions"
msgstr ""

#: src/migration.md:3
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see the [CHANGELOG]"
"(changelog.md)."
msgstr ""

#: src/migration.md:6
msgid "from 0.26.\\* to 0.27"
msgstr ""

#: src/migration.md:8
msgid "`FromPyObject` reworked for flexibility and efficiency"
msgstr ""

#: src/migration.md:13
msgid ""
"With the removal of the `gil-ref` API in PyO3 0.23 it is now possible to "
"fully split the Python lifetime `'py` and the input lifetime `'a`. This "
"allows borrowing from the input data without extending the lifetime of being "
"attached to the interpreter."
msgstr ""

#: src/migration.md:17
msgid ""
"`FromPyObject` now takes an additional lifetime `'a` describing the input "
"lifetime. The argument type of the `extract` method changed from "
"`&Bound<'py, PyAny>` to `Borrowed<'a, 'py, PyAny>`. This was done because "
"`&'a Bound<'py, PyAny>` would have an implicit restriction `'py: 'a` due to "
"the reference type."
msgstr ""

#: src/migration.md:21
msgid ""
"This new form was partly implemented already in 0.22 using the internal "
"`FromPyObjectBound` trait and is now extended to all types."
msgstr ""

#: src/migration.md:24
msgid "Most implementations can just add an elided lifetime to migrate."
msgstr ""

#: src/migration.md:26
msgid ""
"Additionally `FromPyObject` gained an associated type `Error`. This is the "
"error type that can be used in case of a conversion error. During migration "
"using `PyErr` is a good default, later a custom error type can be introduced "
"to prevent unneccessary creation of Python exception objects and improved "
"type safety."
msgstr ""

#: src/migration.md:30 src/migration.md:59 src/migration.md:97
#: src/migration.md:192 src/migration.md:232 src/migration.md:387
#: src/migration.md:489 src/migration.md:522 src/migration.md:595
#: src/migration.md:642 src/migration.md:682 src/migration.md:758
#: src/migration.md:787 src/migration.md:1029 src/migration.md:1078
#: src/migration.md:1152 src/migration.md:1211 src/migration.md:1242
#: src/migration.md:1577 src/migration.md:1622 src/migration.md:1690
#: src/migration.md:1912 src/migration.md:2026 src/migration.md:2091
#: src/migration.md:2121 src/migration.md:2163 src/migration.md:2211
#: src/migration.md:2248 src/migration.md:2282 src/migration.md:2312
#: src/migration.md:2355 src/migration.md:2451 src/migration.md:2481
#: src/migration.md:2518
msgid "Before:"
msgstr ""

#: src/migration.md:40 src/migration.md:1634 src/migration.md:1715
#: src/migration.md:2104
msgid "After"
msgstr ""

#: src/migration.md:48
msgid ""
"// since `Borrowed` derefs to `&Bound`, the body often\n"
"        // needs no changes, or adding an occasional `&`\n"
msgstr ""

#: src/migration.md:54
msgid ""
"Occasionally, more steps are necessary. For generic types, the bounds need "
"to be adjusted. The correct bound depends on how the type is used."
msgstr ""

#: src/migration.md:57
msgid ""
"For simple wrapper types usually it's possible to just forward the bound."
msgstr ""

#: src/migration.md:74 src/migration.md:115 src/migration.md:208
#: src/migration.md:251 src/migration.md:407 src/migration.md:503
#: src/migration.md:547 src/migration.md:606 src/migration.md:654
#: src/migration.md:703 src/migration.md:766 src/migration.md:802
#: src/migration.md:1039 src/migration.md:1095 src/migration.md:1176
#: src/migration.md:1220 src/migration.md:1252 src/migration.md:1929
#: src/migration.md:2056 src/migration.md:2130 src/migration.md:2173
#: src/migration.md:2225 src/migration.md:2259 src/migration.md:2290
#: src/migration.md:2324 src/migration.md:2370 src/migration.md:2462
#: src/migration.md:2489 src/migration.md:2537
msgid "After:"
msgstr ""

#: src/migration.md:92
msgid ""
"Container types that need to create temporary Python references during "
"extraction, for example extracing from a `PyList`, requires a stronger "
"bound. For these the `FromPyObjectOwned` trait was introduced. It is "
"automatically implemented for any type that implements `FromPyObject` and "
"does not borrow from the input. It is intended to be used as a trait bound "
"in these situations."
msgstr ""

#: src/migration.md:123
msgid ""
"// üëà can only extract owned values, because each `item` below\n"
"                              //    is a temporary short lived owned "
"reference\n"
msgstr ""

#: src/migration.md:131
msgid "// `map_err` is needed because `?` uses `From`, not `Into` üôÅ\n"
msgstr ""

#: src/migration.md:138
msgid ""
"This is very similar to `serde`s [`Deserialize`](https://docs.rs/serde/"
"latest/serde/trait.Deserialize.html) and [`DeserializeOwned`](https://docs."
"rs/serde/latest/serde/de/trait.DeserializeOwned.html) traits, see [here]"
"(https://serde.rs/lifetimes.html)."
msgstr ""

#: src/migration.md:144
msgid ""
"`.downcast()` and `DowncastError` replaced with `.cast()` and `CastError`"
msgstr ""

#: src/migration.md:146
msgid ""
"The `.downcast()` family of functions were only available on `Bound<PyAny>`. "
"In corner cases (particularly related to `.downcast_into()`) this would "
"require use of `.as_any().downcast()` or `.into_any().downcast_into()` "
"chains. Additionally, `DowncastError` produced Python exception messages "
"which are not very Pythonic due to use of Rust type names in the error "
"messages."
msgstr ""

#: src/migration.md:148
msgid ""
"The `.cast()` family of functions are available on all `Bound` and "
"`Borrowed` smart pointers, whatever the type, and have error messages "
"derived from the actual type at runtime. This produces a nicer experience "
"for both PyO3 module authors and consumers."
msgstr ""

#: src/migration.md:150
msgid ""
"To migrate, replace `.downcast()` with `.cast()` and `DowncastError` with "
"`CastError` (and similar with `.downcast_into()` / `DowncastIntoError` etc)."
msgstr ""

#: src/migration.md:152
msgid ""
"`CastError` requires a Python `type` object (or other \"classinfo\" object "
"compatible with `isinstance()`) as the second object, so in the rare case "
"where `DowncastError` was manually constructed, small adjustments to code "
"may apply."
msgstr ""

#: src/migration.md:154
msgid "`PyTypeCheck` is now an `unsafe trait`"
msgstr ""

#: src/migration.md:156
msgid ""
"Because `PyTypeCheck` is the trait used to guard the `.cast()` functions to "
"treat Python objects as specific concrete types, the trait is `unsafe` to "
"implement."
msgstr ""

#: src/migration.md:158
msgid ""
"This should always have been the case, it was an unfortunate omission from "
"its original implementation which is being corrected in this release."
msgstr ""

#: src/migration.md:160
msgid "from 0.25.\\* to 0.26"
msgstr ""

#: src/migration.md:162
msgid ""
"Rename of `Python::with_gil`, `Python::allow_threads`, and `pyo3::"
"prepare_freethreaded_python`"
msgstr ""

#: src/migration.md:167
msgid ""
"The names for these APIs were created when the global interpreter lock (GIL) "
"was mandatory. With the introduction of free-threading in Python 3.13 this "
"is no longer the case, and the naming has no universal meaning anymore. For "
"this reason, we chose to rename these to more modern terminology introduced "
"in free-threading:"
msgstr ""

#: src/migration.md:170
msgid ""
"`Python::with_gil` is now called `Python::attach`, it attaches a Python "
"thread-state to the current thread. In GIL enabled builds there can only be "
"1 thread attached to the interpreter, in free-threading there can be more."
msgstr ""

#: src/migration.md:171
msgid ""
"`Python::allow_threads` is now called `Python::detach`, it detaches a "
"previously attached thread-state."
msgstr ""

#: src/migration.md:172
msgid "`pyo3::prepare_freethreaded_python` is now called `Python::initialize`."
msgstr ""

#: src/migration.md:175
msgid "Deprecation of `PyObject` type alias"
msgstr ""

#: src/migration.md:180
msgid ""
"The type alias `PyObject` (aka `Py<PyAny>`) is often confused with the "
"identically named FFI definition `pyo3::ffi::PyObject`. For this reason we "
"are deprecating its usage. To migrate simply replace its usage by the target "
"type `Py<PyAny>`."
msgstr ""

#: src/migration.md:183
msgid "Replacement of `GILOnceCell` with `PyOnceLock`"
msgstr ""

#: src/migration.md:188
msgid ""
"Similar to the above renaming of `Python::with_gil` and related APIs, the "
"`GILOnceCell` type was designed for a Python interpreter which was limited "
"by the GIL. Aside from its name, it allowed for the \"once\" initialization "
"to race because the racing was mediated by the GIL and was extremely "
"unlikely to manifest in practice."
msgstr ""

#: src/migration.md:190
msgid ""
"With the introduction of free-threaded Python the racy initialization "
"behavior is more likely to be problematic and so a new type `PyOnceLock` has "
"been introduced which performs true single-initialization correctly while "
"attached to the Python interpreter. It exposes the same API as "
"`GILOnceCell`, so should be a drop-in replacement with the notable exception "
"that if the racy initialization of `GILOnceCell` was inadvertently relied on "
"(e.g. due to circular references) then the stronger once-ever guarantee of "
"`PyOnceLock` may lead to deadlocking which requires refactoring."
msgstr ""

#: src/migration.md:202 src/migration.md:217
msgid "\"decimal\""
msgstr ""

#: src/migration.md:202 src/migration.md:217
msgid "\"Decimal\""
msgstr ""

#: src/migration.md:225
msgid "Deprecation of `GILProtected`"
msgstr ""

#: src/migration.md:230
msgid ""
"As another cleanup related to concurrency primitives designed for a Python "
"constrained by the GIL, the `GILProtected` type is now deprecated. Prefer to "
"use concurrency primitives which are compatible with free-threaded Python, "
"such as [`std::sync::Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex."
"html) (in combination with PyO3's [`MutexExt`](https://pyo3.rs/main/doc/pyo3/"
"sync/trait.MutexExt.html) trait)."
msgstr ""

#: src/migration.md:261
msgid "\"no poisoning\""
msgstr ""

#: src/migration.md:269
msgid ""
"`PyMemoryError` now maps to `io::ErrorKind::OutOfMemory` when converted to "
"`io::Error`"
msgstr ""

#: src/migration.md:274
msgid ""
"Previously, converting a `PyMemoryError` into a Rust `io::Error` would "
"result in an error with kind `Other`. Now, it produces an error with kind "
"`OutOfMemory`. Similarly, converting an `io::Error` with kind `OutOfMemory` "
"back into a Python error would previously yield a generic `PyOSError`. Now, "
"it yields a `PyMemoryError`."
msgstr ""

#: src/migration.md:277
msgid ""
"This change makes error conversions more precise and matches the semantics "
"of out-of-memory errors between Python and Rust."
msgstr ""

#: src/migration.md:280
msgid "from 0.24.\\* to 0.25"
msgstr ""

#: src/migration.md:282
msgid "`AsPyPointer` removal"
msgstr ""

#: src/migration.md:288
msgid ""
"`PyVisit::call` has been updated to take `T: Into<Option<&Py<T>>>`, which "
"allows for arguments of type `&Py<T>`, `&Option<Py<T>>` and "
"`Option<&Py<T>>`. It is unlikely any changes are needed here to migrate."
msgstr ""

#: src/migration.md:290
msgid ""
"`PyAnyMethods::is`/`Py::is` has been updated to take `T: AsRef<Py<PyAny>>>`. "
"Additionally `AsRef<Py<PyAny>>>` implementations were added for `Py`, "
"`Bound` and `Borrowed`. Because of the existing `AsRef<Bound<PyAny>> for "
"Bound<T>` implementation this may cause inference issues in non-generic "
"code. This can be easily migrated by switching to `as_any` instead of "
"`as_ref` for these calls."
msgstr ""

#: src/migration.md:293
msgid "from 0.23.\\* to 0.24"
msgstr ""

#: src/migration.md:300
msgid "from 0.22.\\* to 0.23"
msgstr ""

#: src/migration.md:305
msgid ""
"PyO3 0.23 is a significant rework of PyO3's internals for two major "
"improvements:"
msgstr ""

#: src/migration.md:307
msgid "Support of Python 3.13's new freethreaded build (aka \"3.13t\")"
msgstr ""

#: src/migration.md:308
msgid "Rework of to-Python conversions with a new `IntoPyObject` trait."
msgstr ""

#: src/migration.md:310
msgid ""
"These changes are both substantial and reasonable efforts have been made to "
"allow as much code as possible to continue to work as-is despite the "
"changes. The impacts are likely to be seen in three places when upgrading:"
msgstr ""

#: src/migration.md:312
msgid ""
"PyO3's data structures [are now thread-safe](#free-threaded-python-support) "
"instead of reliant on the GIL for synchronization. In particular, "
"`#[pyclass]` types are [now required to be `Sync`](./class/thread-safety.md)."
msgstr ""

#: src/migration.md:313
msgid ""
"The [`IntoPyObject` trait](#new-intopyobject-trait-unifies-to-python-"
"conversions) may need to be implemented for types in your codebase. In most "
"cases this can simply be done with [`#[derive(IntoPyObject)]`](#intopyobject-"
"and-intopyobjectref-derive-macros). There will be many deprecation warnings "
"from the replacement of `IntoPy` and `ToPyObject` traits."
msgstr ""

#: src/migration.md:314
msgid ""
"There will be many deprecation warnings from the [final removal of the `gil-"
"refs` feature](#gil-refs-feature-removed), which opened up API space for a "
"cleanup and simplification to PyO3's \"Bound\" API."
msgstr ""

#: src/migration.md:316
msgid ""
"The sections below discuss the rationale and details of each change in more "
"depth."
msgstr ""

#: src/migration.md:319
msgid "Free-threaded Python Support"
msgstr ""

#: src/migration.md:324
msgid ""
"PyO3 0.23 introduces initial support for the new free-threaded build of "
"CPython 3.13, aka \"3.13t\"."
msgstr ""

#: src/migration.md:327
msgid ""
"Because this build allows multiple Python threads to operate simultaneously "
"on underlying Rust data, the `#[pyclass]` macro now requires that types it "
"operates on implement `Sync`."
msgstr ""

#: src/migration.md:329
msgid ""
"Aside from the change to `#[pyclass]`, most features of PyO3 work unchanged, "
"as the changes have been to the internal data structures to make them thread-"
"safe. An example of this is the `GILOnceCell` type, which used the GIL to "
"synchronize single-initialization. It now uses internal locks to guarantee "
"that only one write ever succeeds, however it allows for multiple racing "
"runs of the initialization closure. It may be preferable to instead use "
"`std::sync::OnceLock` in combination with the `pyo3::sync::OnceLockExt` "
"trait which adds `OnceLock::get_or_init_py_attached` for single-"
"initialization where the initialization closure is guaranteed only ever to "
"run once and without deadlocking with the GIL."
msgstr ""

#: src/migration.md:331
msgid ""
"Future PyO3 versions will likely add more traits and data structures to make "
"working with free-threaded Python easier."
msgstr ""

#: src/migration.md:333
msgid "Some features are unaccessible on the free-threaded build:"
msgstr ""

#: src/migration.md:335
msgid ""
"The `GILProtected` type, which relied on the GIL to expose synchronized "
"access to inner contents"
msgstr ""

#: src/migration.md:336
msgid ""
"`PyList::get_item_unchecked`, which cannot soundly be used due to races "
"between time-of-check and time-of-use"
msgstr ""

#: src/migration.md:338
msgid ""
"If you make use of these features then you will need to account for the "
"unavailability of the API in the free-threaded build. One way to handle it "
"is via conditional compilation -- extensions can use `pyo3-build-config` to "
"get access to a `#[cfg(Py_GIL_DISABLED)]` guard."
msgstr ""

#: src/migration.md:341
msgid ""
"See [the guide section on free-threaded Python](free-threading.md) for more "
"details about supporting free-threaded Python in your PyO3 extensions."
msgstr ""

#: src/migration.md:344
msgid "New `IntoPyObject` trait unifies to-Python conversions"
msgstr ""

#: src/migration.md:349
msgid ""
"PyO3 0.23 introduces a new `IntoPyObject` trait to convert Rust types into "
"Python objects which replaces both `IntoPy` and `ToPyObject`. Notable "
"features of this new trait include:"
msgstr ""

#: src/migration.md:352
msgid "conversions can now return an error"
msgstr ""

#: src/migration.md:353
msgid ""
"it is designed to work efficiently for both `T` owned types and `&T` "
"references"
msgstr ""

#: src/migration.md:354
msgid ""
"compared to `IntoPy<T>` the generic `T` moved into an associated type, so"
msgstr ""

#: src/migration.md:355
msgid "there is now only one way to convert a given type"
msgstr ""

#: src/migration.md:356
msgid ""
"the output type is stronger typed and may return any Python type instead of "
"just `PyAny`"
msgstr ""

#: src/migration.md:357
msgid ""
"byte collections are specialized to convert into `PyBytes` now, see [below]"
"(#to-python-conversions-changed-for-byte-collections-vecu8-u8-n-and-"
"smallvecu8-n)"
msgstr ""

#: src/migration.md:358
msgid ""
"`()` (unit) is now only specialized in return position of `#[pyfunction]` "
"and `#[pymethods]` to return `None`, in normal usage it converts into an "
"empty `PyTuple`"
msgstr ""

#: src/migration.md:360
msgid ""
"All PyO3 provided types as well as `#[pyclass]`es already implement "
"`IntoPyObject`. Other types will need to adapt an implementation of "
"`IntoPyObject` to stay compatible with the Python APIs. In many cases the "
"new [`#[derive(IntoPyObject)]`](#intopyobject-and-intopyobjectref-derive-"
"macros) macro can be used instead of [manual implementations](#intopyobject-"
"manual-implementation)."
msgstr ""

#: src/migration.md:365
msgid ""
"Since `IntoPyObject::into_pyobject` may return either a `Bound` or "
"`Borrowed`, you may find the [`BoundObject`](conversions/traits."
"md#boundobject-for-conversions-that-may-be-bound-or-borrowed) trait to be "
"useful to write code that generically handles either type of smart pointer."
msgstr ""

#: src/migration.md:367
msgid ""
"Together with the introduction of `IntoPyObject` the old conversion traits "
"`ToPyObject` and `IntoPy` are deprecated and will be removed in a future "
"PyO3 version."
msgstr ""

#: src/migration.md:370
msgid "`IntoPyObject` and `IntoPyObjectRef` derive macros"
msgstr ""

#: src/migration.md:372
msgid ""
"To implement the new trait you may use the new `IntoPyObject` and "
"`IntoPyObjectRef` derive macros as below."
msgstr ""

#: src/migration.md:383
msgid ""
"The `IntoPyObjectRef` derive macro derives implementations for references (e."
"g. for `&Struct` in the example above), which is a replacement for the "
"`ToPyObject` trait."
msgstr ""

#: src/migration.md:385
msgid "`IntoPyObject` manual implementation"
msgstr ""

#: src/migration.md:416
msgid "// the Python type\n"
msgstr ""

#: src/migration.md:417
msgid "// in most cases this will be `Bound`\n"
msgstr ""

#: src/migration.md:424
msgid ""
"// `ToPyObject` implementations should be converted to implementations on "
"reference types\n"
msgstr ""

#: src/migration.md:428
msgid "// `Borrowed` can be used to optimized reference counting\n"
msgstr ""

#: src/migration.md:439
msgid ""
"To-Python conversions changed for byte collections (`Vec<u8>`, `[u8; N]` and "
"`SmallVec<[u8; N]>`)"
msgstr ""

#: src/migration.md:444
msgid ""
"With the introduction of the `IntoPyObject` trait, PyO3's macros now prefer "
"`IntoPyObject` implementations over `IntoPy<PyObject>` when producing Python "
"values. This applies to `#[pyfunction]` and `#[pymethods]` return values and "
"also fields accessed via `#[pyo3(get)]`."
msgstr ""

#: src/migration.md:446
msgid ""
"This change has an effect on functions and methods returning _byte_ "
"collections like"
msgstr ""

#: src/migration.md:448
msgid "`Vec<u8>`"
msgstr ""

#: src/migration.md:449
msgid "`[u8; N]`"
msgstr ""

#: src/migration.md:450
msgid "`SmallVec<[u8; N]>`"
msgstr ""

#: src/migration.md:452
msgid ""
"In their new `IntoPyObject` implementation these will now turn into "
"`PyBytes` rather than a `PyList`. All other `T`s are unaffected and still "
"convert into a `PyList`."
msgstr ""

#: src/migration.md:459
msgid "// would previously turn into a `PyList`, now `PyBytes`\n"
msgstr ""

#: src/migration.md:464
msgid "// unaffected, returns `PyList`\n"
msgstr ""

#: src/migration.md:469
msgid ""
"If this conversion is _not_ desired, consider building a list manually using "
"`PyList::new`."
msgstr ""

#: src/migration.md:471
msgid ""
"The following types were previously _only_ implemented for `u8` and now "
"allow other `T`s turn into `PyList`:"
msgstr ""

#: src/migration.md:473
msgid "`&[T]`"
msgstr ""

#: src/migration.md:474
msgid "`Cow<[T]>`"
msgstr ""

#: src/migration.md:476
msgid ""
"This is purely additional and should just extend the possible return types."
msgstr ""

#: src/migration.md:480
msgid "`gil-refs` feature removed"
msgstr ""

#: src/migration.md:485
msgid ""
"PyO3 0.23 completes the removal of the \"GIL Refs\" API in favour of the new "
"\"Bound\" API introduced in PyO3 0.21."
msgstr ""

#: src/migration.md:487
msgid ""
"With the removal of the old API, many \"Bound\" API functions which had been "
"introduced with `_bound` suffixes no longer need the suffixes as these names "
"have been freed up. For example, `PyTuple::new_bound` is now just `PyTuple::"
"new` (the existing name remains but is deprecated)."
msgstr ""

#: src/migration.md:496 src/migration.md:509
msgid "// For example, for PyTuple. Many such APIs have been changed.\n"
msgstr ""

#: src/migration.md:516
msgid "`IntoPyDict` trait adjusted for removal of `gil-refs`"
msgstr ""

#: src/migration.md:518
msgid ""
"As part of this API simplification, the `IntoPyDict` trait has had a small "
"breaking change: `IntoPyDict::into_py_dict_bound` method has been renamed to "
"`IntoPyDict::into_py_dict`. It is also now fallible as part of the "
"`IntoPyObject` trait addition."
msgstr ""

#: src/migration.md:520
msgid ""
"If you implemented `IntoPyDict` for your type, you should implement "
"`into_py_dict` instead of `into_py_dict_bound`. The old name is still "
"available for calling but deprecated."
msgstr ""

#: src/migration.md:540
msgid "\"Failed to set_item on dict\""
msgstr ""

#: src/migration.md:574
msgid "from 0.21.\\* to 0.22"
msgstr ""

#: src/migration.md:576
msgid "Deprecation of `gil-refs` feature continues"
msgstr ""

#: src/migration.md:581
msgid ""
"Following the introduction of the \"Bound\" API in PyO3 0.21 and the planned "
"removal of the \"GIL Refs\" API, all functionality related to GIL Refs is "
"now gated behind the `gil-refs` feature and emits a deprecation warning on "
"use."
msgstr ""

#: src/migration.md:583
msgid ""
"See <a href=\"#from-021-to-022\">the 0.21 migration entry</a> for help "
"upgrading."
msgstr ""

#: src/migration.md:586
msgid "Deprecation of implicit default for trailing optional arguments"
msgstr ""

#: src/migration.md:591
msgid ""
"With `pyo3` 0.22 the implicit `None` default for trailing `Option<T>` type "
"argument is deprecated. To migrate, place a `#[pyo3(signature = (...))]` "
"attribute on affected functions or methods and specify the desired behavior. "
"The migration warning specifies the corresponding signature to keep the "
"current behavior. With 0.23 the signature will be required for any function "
"containing `Option<T>` type parameters to prevent accidental and unnoticed "
"changes in behavior. With 0.24 this restriction will be lifted again and "
"`Option<T>` type arguments will be treated as any other argument _without_ "
"special handling."
msgstr ""

#: src/migration.md:620
msgid "`Py::clone` is now gated behind the `py-clone` feature"
msgstr ""

#: src/migration.md:626
msgid ""
"However, take care to note that the behaviour is different from previous "
"versions. If `Clone` was called without the GIL being held, we tried to "
"delay the application of these reference count increments until PyO3-based "
"code would re-acquire it. This turned out to be impossible to implement in a "
"sound manner and hence was removed. Now, if `Clone` is called without the "
"GIL being held, we panic instead for which calling code might not be "
"prepared."
msgstr ""

#: src/migration.md:628
msgid ""
"It is advised to migrate off the `py-clone` feature. The simplest way to "
"remove dependency on `impl<T> Clone for Py<T>` is to wrap `Py<T>` as "
"`Arc<Py<T>>` and use cloning of the arc."
msgstr ""

#: src/migration.md:630
msgid ""
"Related to this, we also added a `pyo3_disable_reference_pool` conditional "
"compilation flag which removes the infrastructure necessary to apply delayed "
"reference count decrements implied by `impl<T> Drop for Py<T>`. They do not "
"appear to be a soundness hazard as they should lead to memory leaks in the "
"worst case. However, the global synchronization adds significant overhead to "
"cross the Python-Rust boundary. Enabling this feature will remove these "
"costs and make the `Drop` implementation abort the process if called without "
"the GIL being held instead."
msgstr ""

#: src/migration.md:633
msgid "Require explicit opt-in for comparison for simple enums"
msgstr ""

#: src/migration.md:638
msgid ""
"With `pyo3` 0.22 the new `#[pyo3(eq)]` options allows automatic "
"implementation of Python equality using Rust's `PartialEq`. Previously "
"simple enums automatically implemented equality in terms of their "
"discriminants. To make PyO3 more consistent, this automatic equality "
"implementation is deprecated in favour of having opt-ins for all "
"`#[pyclass]` types. Similarly, simple enums supported comparison with "
"integers, which is not covered by Rust's `PartialEq` derive, so has been "
"split out into the `#[pyo3(eq_int)]` attribute."
msgstr ""

#: src/migration.md:640
msgid ""
"To migrate, place a `#[pyo3(eq, eq_int)]` attribute on simple enum classes."
msgstr ""

#: src/migration.md:669
msgid "`PyType::name` reworked to better match Python `__name__`"
msgstr ""

#: src/migration.md:674
msgid ""
"This function previously would try to read directly from Python type "
"objects' C API field (`tp_name`), in which case it would return a `Cow::"
"Borrowed`. However the contents of `tp_name` don't have well-defined "
"semantics."
msgstr ""

#: src/migration.md:677
msgid ""
"Instead `PyType::name()` now returns the equivalent of Python `__name__` and "
"returns `PyResult<Bound<'py, PyString>>`."
msgstr ""

#: src/migration.md:679
msgid ""
"The closest equivalent to PyO3 0.21's version of `PyType::name()` has been "
"introduced as a new function `PyType::fully_qualified_name()`, which is "
"equivalent to `__module__` and `__qualname__` joined as `module.qualname`."
msgstr ""

#: src/migration.md:692 src/migration.md:696 src/migration.md:713
#: src/migration.md:718
msgid "\"Hello, {}\""
msgstr ""

#: src/migration.md:715
msgid ""
"// (if the full dotted path was desired, switch from `name()` to "
"`fully_qualified_name()`)\n"
msgstr ""

#: src/migration.md:727
msgid "from 0.20.\\* to 0.21"
msgstr ""

#: src/migration.md:732
msgid ""
"PyO3 0.21 introduces a new `Bound<'py, T>` smart pointer which replaces the "
"existing \"GIL Refs\" API to interact with Python objects. For example, in "
"PyO3 0.20 the reference `&'py PyAny` would be used to interact with Python "
"objects. In PyO3 0.21 the updated type is `Bound<'py, PyAny>`. Making this "
"change moves Rust ownership semantics out of PyO3's internals and into user "
"code. This change fixes [a known soundness edge case of interaction with "
"gevent](https://github.com/PyO3/pyo3/issues/3668) as well as improves CPU "
"and [memory performance](https://github.com/PyO3/pyo3/issues/1056). For a "
"full history of discussion see <https://github.com/PyO3/pyo3/issues/3382>."
msgstr ""

#: src/migration.md:734
msgid ""
"The \"GIL Ref\" `&'py PyAny` and similar types such as `&'py PyDict` "
"continue to be available as a deprecated API. Due to the advantages of the "
"new API it is advised that all users make the effort to upgrade as soon as "
"possible."
msgstr ""

#: src/migration.md:736
msgid ""
"In addition to the major API type overhaul, PyO3 has needed to make a few "
"small breaking adjustments to other APIs to close correctness and soundness "
"gaps."
msgstr ""

#: src/migration.md:738
msgid "The recommended steps to update to PyO3 0.21 is as follows:"
msgstr ""

#: src/migration.md:740
msgid ""
"Enable the `gil-refs` feature to silence deprecations related to the API "
"change"
msgstr ""

#: src/migration.md:741
msgid "Fix all other PyO3 0.21 migration steps"
msgstr ""

#: src/migration.md:742
msgid "Disable the `gil-refs` feature and migrate off the deprecated APIs"
msgstr ""

#: src/migration.md:744
msgid "The following sections are laid out in this order."
msgstr ""

#: src/migration.md:747
msgid "Enable the `gil-refs` feature"
msgstr ""

#: src/migration.md:752
msgid ""
"To make the transition for the PyO3 ecosystem away from the GIL Refs API as "
"smooth as possible, in PyO3 0.21 no APIs consuming or producing GIL Refs "
"have been altered. Instead, variants using `Bound<T>` smart pointers have "
"been introduced, for example `PyTuple::new_bound` which returns "
"`Bound<PyTuple>` is the replacement form of `PyTuple::new`. The GIL Ref APIs "
"have been deprecated, but to make migration easier it is possible to disable "
"these deprecation warnings by enabling the `gil-refs` feature."
msgstr ""

#: src/migration.md:754
msgid ""
"The one single exception where an existing API was changed in-place is the "
"`pyo3::intern!` macro. Almost all uses of this macro did not need to update "
"code to account it changing to return `&Bound<PyString>` immediately, and "
"adding an `intern_bound!` replacement was perceived as adding more work for "
"users."
msgstr ""

#: src/migration.md:756
msgid ""
"It is recommended that users do this as a first step of updating to PyO3 "
"0.21 so that the deprecation warnings do not get in the way of resolving the "
"rest of the migration steps."
msgstr ""

#: src/migration.md:760
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[dependencies]\n"
"pyo3 = \"0.20\"\n"
"```"
msgstr ""

#: src/migration.md:768
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.21\", features = [\"gil-refs\"] }\n"
"```"
msgstr ""

#: src/migration.md:776
msgid "`PyTypeInfo` and `PyTryFrom` have been adjusted"
msgstr ""

#: src/migration.md:781
msgid ""
"The `PyTryFrom` trait has aged poorly, its `try_from` method now conflicts "
"with `TryFrom::try_from` in the 2021 edition prelude. A lot of its "
"functionality was also duplicated with `PyTypeInfo`."
msgstr ""

#: src/migration.md:783
msgid ""
"To tighten up the PyO3 traits as part of the deprecation of the GIL Refs API "
"the `PyTypeInfo` trait has had a simpler companion `PyTypeCheck`. The "
"methods `PyAny::downcast` and `PyAny::downcast_exact` no longer use "
"`PyTryFrom` as a bound, instead using `PyTypeCheck` and `PyTypeInfo` "
"respectively."
msgstr ""

#: src/migration.md:785
msgid ""
"To migrate, switch all type casts to use `obj.downcast()` instead of "
"`try_from(obj)` (and similar for `downcast_exact`)."
msgstr ""

#: src/migration.md:809
msgid ""
"// Note that PyList::new is deprecated for PyList::new_bound as part of the "
"GIL Refs API removal,\n"
"    // see the section below on migration to Bound<T>.\n"
msgstr ""

#: src/migration.md:821
msgid "`Iter(A)NextOutput` are deprecated"
msgstr ""

#: src/migration.md:826
msgid ""
"The `__next__` and `__anext__` magic methods can now return any type "
"convertible into Python objects directly just like all other `#[pymethods]`. "
"The `IterNextOutput` used by `__next__` and `IterANextOutput` used by "
"`__anext__` are subsequently deprecated. Most importantly, this change "
"allows returning an awaitable from `__anext__` without non-sensically "
"wrapping it into `Yield` or `Some`. Only the return types `Option<T>` and "
"`Result<Option<T>, E>` are still handled in a special manner where "
"`Some(val)` yields `val` and `None` stops iteration."
msgstr ""

#: src/migration.md:828
msgid ""
"Starting with an implementation of a Python iterator using `IterNextOutput`, "
"e.g."
msgstr ""

#: src/migration.md:846 src/migration.md:895
msgid "\"done\""
msgstr ""

#: src/migration.md:852
msgid ""
"If returning `\"done\"` via `StopIteration` is not really required, this "
"should be written as"
msgstr ""

#: src/migration.md:875
msgid ""
"This form also has additional benefits: It has already worked in previous "
"PyO3 versions, it matches the signature of Rust's [`Iterator` trait](https://"
"doc.rust-lang.org/stable/std/iter/trait.Iterator.html) and it allows using a "
"fast path in CPython which completely avoids the cost of raising a "
"`StopIteration` exception. Note that using [`Option::transpose`](https://doc."
"rust-lang.org/stable/std/option/enum.Option.html#method.transpose) and the "
"`Result<Option<T>, E>` variant, this form can also be used to wrap fallible "
"iterators."
msgstr ""

#: src/migration.md:877
msgid ""
"Alternatively, the implementation can also be done as it would in Python "
"itself, i.e. by \"raising\" a `StopIteration` exception"
msgstr ""

#: src/migration.md:901
msgid ""
"Finally, an asynchronous iterator can directly return an awaitable without "
"confusing wrapping"
msgstr ""

#: src/migration.md:944
msgid "`PyType::name` has been renamed to `PyType::qualname`"
msgstr ""

#: src/migration.md:949
msgid ""
"`PyType::name` has been renamed to `PyType::qualname` to indicate that it "
"does indeed return the [qualified name](https://docs.python.org/3/glossary."
"html#term-qualified-name), matching the `__qualname__` attribute. The newly "
"added `PyType::name` yields the full name including the module name now "
"which corresponds to `__module__.__name__` on the level of attributes."
msgstr ""

#: src/migration.md:952
msgid "`PyCell` has been deprecated"
msgstr ""

#: src/migration.md:957
msgid ""
"Interactions with Python objects implemented in Rust no longer need to go "
"though `PyCell<T>`. Instead interactions with Python object now consistently "
"go through `Bound<T>` or `Py<T>` independently of whether `T` is native "
"Python object or a `#[pyclass]` implemented in Rust. Use `Bound::new` or "
"`Py::new` respectively to create and `Bound::borrow(_mut)` / `Py::"
"borrow(_mut)` to borrow the Rust object."
msgstr ""

#: src/migration.md:960
msgid "Migrating from the GIL Refs API to `Bound<T>`"
msgstr ""

#: src/migration.md:965
msgid ""
"To minimise breakage of code using the GIL Refs API, the `Bound<T>` smart "
"pointer has been introduced by adding complements to all functions which "
"accept or return GIL Refs. This allows code to migrate by replacing the "
"deprecated APIs with the new ones."
msgstr ""

#: src/migration.md:967
msgid ""
"To identify what to migrate, temporarily switch off the `gil-refs` feature "
"to see deprecation warnings on [almost](#cases-where-pyo3-cannot-emit-gil-"
"ref-deprecation-warnings) all uses of APIs accepting and producing GIL "
"Refs . Over one or more PRs it should be possible to follow the deprecation "
"hints to update code. Depending on your development environment, switching "
"off the `gil-refs` feature may introduce [some very targeted breakages]"
"(#deactivating-the-gil-refs-feature), so you may need to fixup those first."
msgstr ""

#: src/migration.md:969
msgid "For example, the following APIs have gained updated variants:"
msgstr ""

#: src/migration.md:971
msgid ""
"`PyList::new`, `PyTuple::new` and similar constructors have replacements "
"`PyList::new_bound`, `PyTuple::new_bound` etc."
msgstr ""

#: src/migration.md:972
msgid ""
"`FromPyObject::extract` has a new `FromPyObject::extract_bound` (see the "
"section below)"
msgstr ""

#: src/migration.md:973
msgid ""
"The `PyTypeInfo` trait has had new `_bound` methods added to accept / return "
"`Bound<T>`."
msgstr ""

#: src/migration.md:975
msgid ""
"Because the new `Bound<T>` API brings ownership out of the PyO3 framework "
"and into user code, there are a few places where user code is expected to "
"need to adjust while switching to the new API:"
msgstr ""

#: src/migration.md:977
msgid ""
"Code will need to add the occasional `&` to borrow the new smart pointer as "
"`&Bound<T>` to pass these types around (or use `.clone()` at the very small "
"cost of increasing the Python reference count)"
msgstr ""

#: src/migration.md:978
msgid ""
"`Bound<PyList>` and `Bound<PyTuple>` cannot support indexing with `list[0]`, "
"you should use `list.get_item(0)` instead."
msgstr ""

#: src/migration.md:979
msgid ""
"`Bound<PyTuple>::iter_borrowed` is slightly more efficient than "
"`Bound<PyTuple>::iter`. The default iteration of `Bound<PyTuple>` cannot "
"return borrowed references because Rust does not (yet) have \"lending "
"iterators\". Similarly `Bound<PyTuple>::get_borrowed_item` is more efficient "
"than `Bound<PyTuple>::get_item` for the same reason."
msgstr ""

#: src/migration.md:980
msgid ""
"`&Bound<T>` does not implement `FromPyObject` (although it might be possible "
"to do this in the future once the GIL Refs API is completely removed). Use "
"`bound_any.downcast::<T>()` instead of `bound_any.extract::<&Bound<T>>()`."
msgstr ""

#: src/migration.md:981
msgid ""
"`Bound<PyString>::to_str` now borrows from the `Bound<PyString>` rather than "
"from the `'py` lifetime, so code will need to store the smart pointer as a "
"value in some cases where previously `&PyString` was just used as a "
"temporary. (There are some more details relating to this in [the section "
"below](#deactivating-the-gil-refs-feature).)"
msgstr ""

#: src/migration.md:982
msgid ""
"`.extract::<&str>()` now borrows from the source Python object. The simplest "
"way to update is to change to `.extract::<PyBackedStr>()`, which retains "
"ownership of the Python reference. See more information [in the section on "
"deactivating the `gil-refs` feature](#deactivating-the-gil-refs-feature)."
msgstr ""

#: src/migration.md:984
msgid ""
"To convert between `&PyAny` and `&Bound<PyAny>` use the `as_borrowed()` "
"method:"
msgstr ""

#: src/migration.md:991
msgid ""
"To convert between `Py<T>` and `Bound<T>` use the `bind()` / `into_bound()` "
"methods, and `as_unbound()` / `unbind()` to go back from `Bound<T>` to "
"`Py<T>`."
msgstr ""

#: src/migration.md:1004
msgid "‚ö†Ô∏è Warning: dangling pointer trap üí£"
msgstr ""

#: src/migration.md:1006
msgid ""
"Because of the ownership changes, code which uses `.as_ptr()` to convert "
"`&PyAny` and other GIL Refs to a `*mut pyo3_ffi::PyObject` should take care "
"to avoid creating dangling pointers now that `Bound<PyAny>` carries "
"ownership."
msgstr ""

#: src/migration.md:1008
msgid ""
"For example, the following pattern with `Option<&PyAny>` can easily create a "
"dangling pointer when migrating to the `Bound<PyAny>` smart pointer:"
msgstr ""

#: src/migration.md:1015
msgid ""
"The correct way to migrate this code is to use `.as_ref()` to avoid dropping "
"the `Bound<PyAny>` in the `map_or` closure:"
msgstr ""

#: src/migration.md:1023
msgid "Migrating `FromPyObject` implementations"
msgstr ""

#: src/migration.md:1025
msgid ""
"`FromPyObject` has had a new method `extract_bound` which takes `&Bound<'py, "
"PyAny>` as an argument instead of `&PyAny`. Both `extract` and "
"`extract_bound` have been given default implementations in terms of the "
"other, to avoid breaking code immediately on update to 0.21."
msgstr ""

#: src/migration.md:1027
msgid ""
"All implementations of `FromPyObject` should be switched from `extract` to "
"`extract_bound`."
msgstr ""

#: src/migration.md:1034 src/migration.md:1044
msgid "/* ... */"
msgstr ""

#: src/migration.md:1049
msgid ""
"The expectation is that in 0.22 `extract_bound` will have the default "
"implementation removed and in 0.23 `extract` will be removed."
msgstr ""

#: src/migration.md:1051
msgid "Cases where PyO3 cannot emit GIL Ref deprecation warnings"
msgstr ""

#: src/migration.md:1053
msgid ""
"Despite a large amount of deprecations warnings produced by PyO3 to aid with "
"the transition from GIL Refs to the Bound API, there are a few cases where "
"PyO3 cannot automatically warn on uses of GIL Refs. It is worth checking for "
"these cases manually after the deprecation warnings have all been addressed:"
msgstr ""

#: src/migration.md:1055
msgid ""
"Individual implementations of the `FromPyObject` trait cannot be deprecated, "
"so PyO3 cannot warn about uses of code patterns like `.extract<&PyAny>()` "
"which produce a GIL Ref."
msgstr ""

#: src/migration.md:1056
msgid ""
"GIL Refs in `#[pyfunction]` arguments emit a warning, but if the GIL Ref is "
"wrapped inside another container such as `Vec<&PyAny>` then PyO3 cannot warn "
"against this."
msgstr ""

#: src/migration.md:1057
msgid ""
"The `wrap_pyfunction!(function)(py)` deferred argument form of the "
"`wrap_pyfunction` macro taking `py: Python<'py>` produces a GIL Ref, and due "
"to limitations in type inference PyO3 cannot warn against this specific case."
msgstr ""

#: src/migration.md:1061
msgid "Deactivating the `gil-refs` feature"
msgstr ""

#: src/migration.md:1066
msgid ""
"As a final step of migration, deactivating the `gil-refs` feature will set "
"up code for best performance and is intended to set up a forward-compatible "
"API for PyO3 0.22."
msgstr ""

#: src/migration.md:1068
msgid ""
"At this point code that needed to manage GIL Ref memory can safely remove "
"uses of `GILPool` (which are constructed by calls to `Python::new_pool` and "
"`Python::with_pool`). Deprecation warnings will highlight these cases."
msgstr ""

#: src/migration.md:1070
msgid ""
"There is just one case of code that changes upon disabling these features: "
"`FromPyObject` trait implementations for types that borrow directly from the "
"input data cannot be implemented by PyO3 without GIL Refs (while the GIL "
"Refs API is in the process of being removed). The main types affected are "
"`&str`, `Cow<'_, str>`, `&[u8]`, `Cow<'_, u8>`."
msgstr ""

#: src/migration.md:1072
msgid ""
"To make PyO3's core functionality continue to work while the GIL Refs API is "
"in the process of being removed, disabling the `gil-refs` feature moves the "
"implementations of `FromPyObject` for `&str`, `Cow<'_, str>`, `&[u8]`, "
"`Cow<'_, u8>` to a new temporary trait `FromPyObjectBound`. This trait is "
"the expected future form of `FromPyObject` and has an additional lifetime "
"`'a` to enable these types to borrow data from Python objects."
msgstr ""

#: src/migration.md:1074
msgid ""
"PyO3 0.21 has introduced the [`PyBackedStr`](https://pyo3.rs/main/doc/pyo3/"
"pybacked/struct.PyBackedStr.html) and [`PyBackedBytes`](https://pyo3.rs/main/"
"doc/pyo3/pybacked/struct.PyBackedBytes.html) types to help with this case. "
"The easiest way to avoid lifetime challenges from extracting `&str` is to "
"use these. For more complex types like `Vec<&str>`, is now impossible to "
"extract directly from a Python object and `Vec<PyBackedStr>` is the "
"recommended upgrade path."
msgstr ""

#: src/migration.md:1076
msgid ""
"A key thing to note here is because extracting to these types now ties them "
"to the input lifetime, some extremely common patterns may need to be split "
"into multiple Rust lines. For example, the following snippet of calling `."
"extract::<&str>()` directly on the result of `.getattr()` needs to be "
"adjusted when deactivating the `gil-refs` feature."
msgstr ""

#: src/migration.md:1081
msgid "\"gil-refs\""
msgstr ""

#: src/migration.md:1085
msgid "// GIL Ref API\n"
msgstr ""

#: src/migration.md:1087 src/migration.md:1103 src/migration.md:1124
msgid "\"__name__\""
msgstr ""

#: src/migration.md:1088 src/migration.md:1107 src/migration.md:1125
msgid "\"list\""
msgstr ""

#: src/migration.md:1103
msgid ""
"// the lifetime of the data is no longer `'py` but the much shorter\n"
"// lifetime of the `name_obj` smart pointer above\n"
msgstr ""

#: src/migration.md:1114
msgid ""
"To avoid needing to worry about lifetimes at all, it is also possible to use "
"the new `PyBackedStr` type, which stores a reference to the Python `str` "
"without a lifetime attachment. In particular, `PyBackedStr` helps for `abi3` "
"builds for Python older than 3.10. Due to limitations in the `abi3` CPython "
"API for those older versions, PyO3 cannot offer a `FromPyObjectBound` "
"implementation for `&str` on those versions. The easiest way to migrate for "
"older `abi3` builds is to replace any cases of `.extract::<&str>()` with `."
"extract::<PyBackedStr>()`. Alternatively, use `.extract::<Cow<str>>()`, `."
"extract::<String>()` to copy the data into Rust."
msgstr ""

#: src/migration.md:1116
msgid ""
"The following example uses the same snippet as those just above, but this "
"time the final extracted type is `PyBackedStr`:"
msgstr ""

#: src/migration.md:1133
msgid "from 0.19.\\* to 0.20"
msgstr ""

#: src/migration.md:1135 src/migration.md:1669
msgid "Drop support for older technologies"
msgstr ""

#: src/migration.md:1140
msgid ""
"PyO3 0.20 has increased minimum Rust version to 1.56. This enables use of "
"newer language features and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:1143
msgid "`PyDict::get_item` now returns a `Result`"
msgstr ""

#: src/migration.md:1148
msgid ""
"`PyDict::get_item` in PyO3 0.19 and older was implemented using a Python API "
"which would suppress all exceptions and return `None` in those cases. This "
"included errors in `__hash__` and `__eq__` implementations of the key being "
"looked up."
msgstr ""

#: src/migration.md:1150
msgid ""
"Newer recommendations by the Python core developers advise against using "
"these APIs which suppress exceptions, instead allowing exceptions to bubble "
"upwards. `PyDict::get_item_with_error` already implemented this recommended "
"behavior, so that API has been renamed to `PyDict::get_item`."
msgstr ""

#: src/migration.md:1162 src/migration.md:1164 src/migration.md:1186
#: src/migration.md:1188
msgid "\"a\""
msgstr ""

#: src/migration.md:1163 src/migration.md:1187
msgid "// `a` is in the dictionary, with value 1\n"
msgstr ""

#: src/migration.md:1165 src/migration.md:1189
msgid "// `b` is not in the dictionary\n"
msgstr ""

#: src/migration.md:1166 src/migration.md:1190
msgid "\"b\""
msgstr ""

#: src/migration.md:1167 src/migration.md:1191
msgid "// `dict` is not hashable, so this fails with a `TypeError`\n"
msgstr ""

#: src/migration.md:1204
msgid "Required arguments are no longer accepted after optional arguments"
msgstr ""

#: src/migration.md:1209
msgid ""
"Trailing `Option<T>` arguments have an automatic default of `None`. To avoid "
"unwanted changes when modifying function signatures, in PyO3 0.18 it was "
"deprecated to have a required argument after an `Option<T>` argument without "
"using `#[pyo3(signature = (...))]` to specify the intended defaults. In PyO3 "
"0.20, this becomes a hard error."
msgstr ""

#: src/migration.md:1227
msgid "// both x and y have no defaults and are required\n"
msgstr ""

#: src/migration.md:1235
msgid "Remove deprecated function forms"
msgstr ""

#: src/migration.md:1240
msgid ""
"In PyO3 0.18 the `#[args]` attribute for `#[pymethods]`, and directly "
"specifying the function signature in `#[pyfunction]`, was deprecated. This "
"functionality has been removed in PyO3 0.20."
msgstr ""

#: src/migration.md:1246
msgid "\"0\""
msgstr ""

#: src/migration.md:1246
msgid "\"/\""
msgstr ""

#: src/migration.md:1267
msgid "`IntoPyPointer` trait removed"
msgstr ""

#: src/migration.md:1272
msgid ""
"The trait `IntoPyPointer`, which provided the `into_ptr` method on many "
"types, has been removed. `into_ptr` is now available as an inherent method "
"on all types that previously implemented this trait."
msgstr ""

#: src/migration.md:1275
msgid "`AsPyPointer` now `unsafe` trait"
msgstr ""

#: src/migration.md:1280
msgid ""
"The trait `AsPyPointer` is now `unsafe trait`, meaning any external "
"implementation of it must be marked as `unsafe impl`, and ensure that they "
"uphold the invariant of returning valid pointers."
msgstr ""

#: src/migration.md:1283
msgid "from 0.18.\\* to 0.19"
msgstr ""

#: src/migration.md:1285
msgid ""
"Access to `Python` inside `__traverse__` implementations are now forbidden"
msgstr ""

#: src/migration.md:1290
msgid ""
"During `__traverse__` implementations for Python's Garbage Collection it is "
"forbidden to do anything other than visit the members of the `#[pyclass]` "
"being traversed. This means making Python function calls or other API calls "
"are forbidden."
msgstr ""

#: src/migration.md:1292
msgid ""
"Previous versions of PyO3 would allow access to `Python` (e.g. via `Python::"
"with_gil`), which could cause the Python interpreter to crash or otherwise "
"confuse the garbage collection algorithm."
msgstr ""

#: src/migration.md:1294
msgid ""
"Attempts to acquire the GIL will now panic. See [\\#3165](https://github.com/"
"PyO3/pyo3/issues/3165) for more detail."
msgstr ""

#: src/migration.md:1304
msgid "/*...*/"
msgstr ""

#: src/migration.md:1304
msgid "// ERROR: this will panic\n"
msgstr ""

#: src/migration.md:1311
msgid ""
"Smarter `anyhow::Error` / `eyre::Report` conversion when inner error is "
"\"simple\" `PyErr`"
msgstr ""

#: src/migration.md:1316
msgid ""
"When converting from `anyhow::Error` or `eyre::Report` to `PyErr`, if the "
"inner error is a \"simple\" `PyErr` (with no source error), then the inner "
"error will be used directly as the `PyErr` instead of wrapping it in a new "
"`PyRuntimeError` with the original information converted into a string."
msgstr ""

#: src/migration.md:1319
msgid "\"anyhow\""
msgstr ""

#: src/migration.md:1326
msgid "\"original error message\""
msgstr ""

#: src/migration.md:1335
msgid ""
"r\"\n"
"        try:\n"
"            rs_func()\n"
"        except Exception as e:\n"
"            print(repr(e))\n"
"        \""
msgstr ""

#: src/migration.md:1347
msgid ""
"Before, the above code would have printed `RuntimeError('ValueError: "
"original error message')`, which might be confusing."
msgstr ""

#: src/migration.md:1349
msgid ""
"After, the same code will print `ValueError: original error message`, which "
"is more straightforward."
msgstr ""

#: src/migration.md:1351
msgid ""
"However, if the `anyhow::Error` or `eyre::Report` has a source, then the "
"original exception will still be wrapped in a `PyRuntimeError`."
msgstr ""

#: src/migration.md:1354
msgid ""
"The deprecated `Python::acquire_gil` was removed and `Python::with_gil` must "
"be used instead"
msgstr ""

#: src/migration.md:1359
msgid ""
"While the API provided by [`Python::acquire_gil`](https://docs.rs/"
"pyo3/0.18.3/pyo3/marker/struct.Python.html#method.acquire_gil) seems "
"convenient, it is somewhat brittle as the design of the [`Python`](https://"
"docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html) token relies on proper "
"nesting and panics if not used correctly, e.g."
msgstr ""

#: src/migration.md:1383
msgid "// Panics because the guard within `second` is still alive.\n"
msgstr ""

#: src/migration.md:1389
msgid ""
"The replacement is [`Python::with_gil`](https://docs.rs/pyo3/0.18.3/pyo3/"
"marker/struct.Python.html#method.with_gil) which is more cumbersome but "
"enforces the proper nesting by design, e.g."
msgstr ""

#: src/migration.md:1409
msgid "// It either forces us to release the GIL before acquiring it again.\n"
msgstr ""

#: src/migration.md:1415
msgid "// Or it ensures releasing the inner lock before the outer one.\n"
msgstr ""

#: src/migration.md:1425
msgid ""
"Furthermore, `Python::acquire_gil` provides ownership of a `GILGuard` which "
"can be freely stored and passed around. This is usually not helpful as it "
"may keep the lock held for a long time thereby blocking progress in other "
"parts of the program. Due to the generative lifetime attached to the Python "
"token supplied by `Python::with_gil`, the problem is avoided as the Python "
"token can only be passed down the call chain. Often, this issue can also be "
"avoided entirely as any GIL-bound reference `&'py PyAny` implies access to a "
"Python token `Python<'py>` via the [`PyAny::py`](https://docs.rs/pyo3/0.22.5/"
"pyo3/types/struct.PyAny.html#method.py) method."
msgstr ""

#: src/migration.md:1428
msgid "from 0.17.\\* to 0.18"
msgstr ""

#: src/migration.md:1430
msgid ""
"Required arguments after `Option<_>` arguments will no longer be "
"automatically inferred"
msgstr ""

#: src/migration.md:1435
msgid ""
"In `#[pyfunction]` and `#[pymethods]`, if a \"required\" function input such "
"as `i32` came after an `Option<_>` input, then the `Option<_>` would be "
"implicitly treated as required. (All trailing `Option<_>` arguments were "
"treated as optional with a default value of `None`)."
msgstr ""

#: src/migration.md:1437
msgid ""
"Starting with PyO3 0.18, this is deprecated and a future PyO3 version will "
"require a [`#[pyo3(signature = (...))]` option](./function/signature.md) to "
"explicitly declare the programmer's intention."
msgstr ""

#: src/migration.md:1439
msgid ""
"Before, x in the below example would be required to be passed from Python "
"code:"
msgstr ""

#: src/migration.md:1449
msgid "After, specify the intended Python signature explicitly:"
msgstr ""

#: src/migration.md:1454
msgid "// If x really was intended to be required\n"
msgstr ""

#: src/migration.md:1458
msgid "// If x was intended to be optional, y needs a default too\n"
msgstr ""

#: src/migration.md:1466
msgid ""
"`__text_signature__` is now automatically generated for `#[pyfunction]` and "
"`#[pymethods]`"
msgstr ""

#: src/migration.md:1471
msgid ""
"The [`#[pyo3(text_signature = \"...\")]` option](./function/signature."
"md#making-the-function-signature-available-to-python) was previously the "
"only supported way to set the `__text_signature__` attribute on generated "
"Python functions."
msgstr ""

#: src/migration.md:1473
msgid ""
"PyO3 is now able to automatically populate `__text_signature__` for all "
"functions automatically based on their Rust signature (or the [new "
"`#[pyo3(signature = (...))]` option](./function/signature.md)). These "
"automatically-generated `__text_signature__` values will currently only "
"render `...` for all default values. Many `#[pyo3(text_signature = \"..."
"\")]` options can be removed from functions when updating to PyO3 0.18, "
"however in cases with default values a manual implementation may still be "
"preferred for now."
msgstr ""

#: src/migration.md:1475
msgid "As examples:"
msgstr ""

#: src/migration.md:1479
msgid ""
"// The `text_signature` option here is no longer necessary, as PyO3 will "
"automatically\n"
"// generate exactly the same value.\n"
msgstr ""

#: src/migration.md:1482 src/migration.md:1493
msgid "\"(a, b, c)\""
msgstr ""

#: src/migration.md:1484
msgid ""
"// The `text_signature` still provides value here as of PyO3 0.18, because "
"the automatically\n"
"// generated signature would be \"(a, b=..., c=...)\".\n"
msgstr ""

#: src/migration.md:1487 src/migration.md:1495
msgid "\"(a, b=1, c=2)\""
msgstr ""

#: src/migration.md:1493 src/migration.md:1495
msgid "\"__text_signature__\""
msgstr ""

#: src/migration.md:1502
msgid "from 0.16.\\* to 0.17"
msgstr ""

#: src/migration.md:1504
msgid "Type checks have been changed for `PyMapping` and `PySequence` types"
msgstr ""

#: src/migration.md:1509
msgid ""
"Previously the type checks for `PyMapping` and `PySequence` (implemented in "
"`PyTryFrom`) used the Python C-API functions `PyMapping_Check` and "
"`PySequence_Check`. Unfortunately these functions are not sufficient for "
"distinguishing such types, leading to inconsistent behavior (see [pyo3/"
"pyo3#2072](https://github.com/PyO3/pyo3/issues/2072))."
msgstr ""

#: src/migration.md:1515
msgid ""
"PyO3 0.17 changes these downcast checks to explicitly test if the type is a "
"subclass of the corresponding abstract base class `collections.abc.Mapping` "
"or `collections.abc.Sequence`. Note this requires calling into Python, which "
"may incur a performance penalty over the previous method. If this "
"performance penalty is a problem, you may be able to perform your own checks "
"and use `try_from_unchecked` (unsafe)."
msgstr ""

#: src/migration.md:1522
msgid ""
"Another side-effect is that a pyclass defined in Rust with PyO3 will need to "
"be _registered_ with the corresponding Python abstract base class for "
"downcasting to succeed. `PySequence::register` and `PyMapping:register` have "
"been added to make it easy to do this from Rust code. These are equivalent "
"to calling `collections.abc.Mapping.register(MappingPyClass)` or "
"`collections.abc.Sequence.register(SequencePyClass)` from Python."
msgstr ""

#: src/migration.md:1529
msgid "For example, for a mapping class defined in Rust:"
msgstr ""

#: src/migration.md:1544
msgid ""
"// ...\n"
"    // truncated implementation of this mapping pyclass - basically a "
"wrapper around a HashMap\n"
msgstr ""

#: src/migration.md:1549
msgid ""
"You must register the class with `collections.abc.Mapping` before the "
"downcast will work:"
msgstr ""

#: src/migration.md:1558
msgid ""
"Note that this requirement may go away in the future when a pyclass is able "
"to inherit from the abstract base class directly (see [pyo3/pyo3#991]"
"(https://github.com/PyO3/pyo3/issues/991))."
msgstr ""

#: src/migration.md:1561
msgid "The `multiple-pymethods` feature now requires Rust 1.62"
msgstr ""

#: src/migration.md:1566
msgid ""
"Due to limitations in the `inventory` crate which the `multiple-pymethods` "
"feature depends on, this feature now requires Rust 1.62. For more "
"information see [dtolnay/inventory#32](https://github.com/dtolnay/inventory/"
"issues/32)."
msgstr ""

#: src/migration.md:1570
msgid "Added `impl IntoPy<Py<PyString>> for &str`"
msgstr ""

#: src/migration.md:1575
msgid "This may cause inference errors."
msgstr ""

#: src/migration.md:1584
msgid "// Cannot infer either `Py<PyAny>` or `Py<PyString>`\n"
msgstr ""

#: src/migration.md:1585 src/migration.md:1598
msgid "\"test\""
msgstr ""

#: src/migration.md:1590
msgid "After, some type annotations may be necessary:"
msgstr ""

#: src/migration.md:1605
msgid "The `pyproto` feature is now disabled by default"
msgstr ""

#: src/migration.md:1610
msgid ""
"In preparation for removing the deprecated `#[pyproto]` attribute macro in a "
"future PyO3 version, it is now gated behind an opt-in feature flag. This "
"also gives a slight saving to compile times for code which does not use the "
"deprecated macro."
msgstr ""

#: src/migration.md:1613
msgid "`PyTypeObject` trait has been deprecated"
msgstr ""

#: src/migration.md:1618
msgid ""
"The `PyTypeObject` trait already was near-useless; almost all functionality "
"was already on the `PyTypeInfo` trait, which `PyTypeObject` had a blanket "
"implementation based upon. In PyO3 0.17 the final method, `PyTypeObject::"
"type_object` was moved to `PyTypeInfo::type_object`."
msgstr ""

#: src/migration.md:1620
msgid ""
"To migrate, update trait bounds and imports from `PyTypeObject` to "
"`PyTypeInfo`."
msgstr ""

#: src/migration.md:1649
msgid ""
"`impl<T, const N: usize> IntoPy<PyObject> for [T; N]` now requires `T: "
"IntoPy` rather than `T: ToPyObject`"
msgstr ""

#: src/migration.md:1654
msgid ""
"If this leads to errors, simply implement `IntoPy`. Because pyclasses "
"already implement `IntoPy`, you probably don't need to worry about this."
msgstr ""

#: src/migration.md:1657
msgid "Each `#[pymodule]` can now only be initialized once per process"
msgstr ""

#: src/migration.md:1662
msgid ""
"To make PyO3 modules sound in the presence of Python sub-interpreters, for "
"now it has been necessary to explicitly disable the ability to initialize a "
"`#[pymodule]` more than once in the same process. Attempting to do this will "
"now raise an `ImportError`."
msgstr ""

#: src/migration.md:1665
msgid "from 0.15.\\* to 0.16"
msgstr ""

#: src/migration.md:1676
msgid ""
"PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python "
"version to 3.7. This enables use of newer language features (enabling some "
"of the other additions in 0.16) and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:1679
msgid "`#[pyproto]` has been deprecated"
msgstr ""

#: src/migration.md:1684
msgid ""
"In PyO3 0.15, the `#[pymethods]` attribute macro gained support for "
"implementing \"magic methods\" such as `__str__` (aka \"dunder\" methods). "
"This implementation was not quite finalized at the time, with a few edge "
"cases to be decided upon. The existing `#[pyproto]` attribute macro was left "
"untouched, because it covered these edge cases."
msgstr ""

#: src/migration.md:1686
msgid ""
"In PyO3 0.16, the `#[pymethods]` implementation has been completed and is "
"now the preferred way to implement magic methods. To allow the PyO3 project "
"to move forward, `#[pyproto]` has been deprecated (with expected removal in "
"PyO3 0.18)."
msgstr ""

#: src/migration.md:1688
msgid ""
"Migration from `#[pyproto]` to `#[pymethods]` is straightforward; copying "
"the existing methods directly from the `#[pyproto]` trait implementation is "
"all that is needed in most cases."
msgstr ""

#: src/migration.md:1703 src/migration.md:1727 src/migration.md:1924
#: src/migration.md:1940
msgid "b\"hello, world\""
msgstr ""

#: src/migration.md:1710 src/migration.md:1731
msgid "\"hello, world\""
msgstr ""

#: src/migration.md:1738
msgid "Removed `PartialEq` for object wrappers"
msgstr ""

#: src/migration.md:1743
msgid ""
"The Python object wrappers `Py` and `PyAny` had implementations of "
"`PartialEq` so that `object_a == object_b` would compare the Python objects "
"for pointer equality, which corresponds to the `is` operator, not the `==` "
"operator in Python.  This has been removed in favor of a new method: use "
"`object_a.is(object_b)`.  This also has the advantage of not requiring the "
"same wrapper type for `object_a` and `object_b`; you can now directly "
"compare a `Py<T>` with a `&PyAny` without having to convert."
msgstr ""

#: src/migration.md:1751
msgid ""
"To check for Python object equality (the Python `==` operator), use the new "
"method `eq()`."
msgstr ""

#: src/migration.md:1755
msgid "Container magic methods now match Python behavior"
msgstr ""

#: src/migration.md:1760
msgid ""
"In PyO3 0.15, `__getitem__`, `__setitem__` and `__delitem__` in "
"`#[pymethods]` would generate only the _mapping_ implementation for a "
"`#[pyclass]`. To match the Python behavior, these methods now generate both "
"the _mapping_ **and** _sequence_ implementations."
msgstr ""

#: src/migration.md:1762
msgid ""
"This means that classes implementing these `#[pymethods]` will now also be "
"treated as sequences, same as a Python `class` would be. Small differences "
"in behavior may result:"
msgstr ""

#: src/migration.md:1764
msgid ""
"PyO3 will allow instances of these classes to be cast to `PySequence` as "
"well as `PyMapping`."
msgstr ""

#: src/migration.md:1765
msgid ""
"Python will provide a default implementation of `__iter__` (if the class did "
"not have one) which repeatedly calls `__getitem__` with integers (starting "
"at 0) until an `IndexError` is raised."
msgstr ""

#: src/migration.md:1767
msgid "To explain this in detail, consider the following Python class:"
msgstr ""

#: src/migration.md:1781
msgid ""
"This class implements a Python [sequence](https://docs.python.org/3/glossary."
"html#term-sequence)."
msgstr ""

#: src/migration.md:1783
msgid ""
"The `__len__` and `__getitem__` methods are also used to implement a Python "
"[mapping](https://docs.python.org/3/glossary.html#term-mapping). In the "
"Python C-API, these methods are not shared: the sequence `__len__` and "
"`__getitem__` are defined by the `sq_length` and `sq_item` slots, and the "
"mapping equivalents are `mp_length` and `mp_subscript`. There are similar "
"distinctions for `__setitem__` and `__delitem__`."
msgstr ""

#: src/migration.md:1785
msgid ""
"Because there is no such distinction from Python, implementing these methods "
"will fill the mapping and sequence slots simultaneously. A Python class with "
"`__len__` implemented, for example, will have both the `sq_length` and "
"`mp_length` slots filled."
msgstr ""

#: src/migration.md:1787
msgid ""
"The PyO3 behavior in 0.16 has been changed to be closer to this Python "
"behavior by default."
msgstr ""

#: src/migration.md:1790
msgid "`wrap_pymodule!` and `wrap_pyfunction!` now respect privacy correctly"
msgstr ""

#: src/migration.md:1795
msgid ""
"Prior to PyO3 0.16 the `wrap_pymodule!` and `wrap_pyfunction!` macros could "
"use modules and functions whose defining `fn` was not reachable according "
"Rust privacy rules."
msgstr ""

#: src/migration.md:1797
msgid ""
"For example, the following code was legal before 0.16, but in 0.16 is "
"rejected because the `wrap_pymodule!` macro cannot access the "
"`private_submodule` function:"
msgstr ""

#: src/migration.md:1819
msgid ""
"To fix it, make the private submodule visible, e.g. with `pub` or "
"`pub(crate)`."
msgstr ""

#: src/migration.md:1844
msgid "from 0.14.\\* to 0.15"
msgstr ""

#: src/migration.md:1846
msgid "Changes in sequence indexing"
msgstr ""

#: src/migration.md:1851
msgid ""
"For all types that take sequence indices (`PyList`, `PyTuple` and "
"`PySequence`), the API has been made consistent to only take `usize` "
"indices, for consistency with Rust's indexing conventions.  Negative "
"indices, which were only sporadically supported even in APIs that took "
"`isize`, now aren't supported anywhere."
msgstr ""

#: src/migration.md:1857
msgid ""
"Further, the `get_item` methods now always return a `PyResult` instead of "
"panicking on invalid indices.  The `Index` trait has been implemented "
"instead, and provides the same panic behavior as on Rust vectors."
msgstr ""

#: src/migration.md:1861
msgid ""
"Note that _slice_ indices (accepted by `PySequence::get_slice` and other) "
"still inherit the Python behavior of clamping the indices to the actual "
"length, and not panicking/returning an error on out of range indices."
msgstr ""

#: src/migration.md:1865
msgid ""
"An additional advantage of using Rust's indexing conventions for these types "
"is that these types can now also support Rust's indexing operators as part "
"of a consistent API:"
msgstr ""

#: src/migration.md:1875
msgid "\"[1, 2]\""
msgstr ""

#: src/migration.md:1881
msgid "from 0.13.\\* to 0.14"
msgstr ""

#: src/migration.md:1883
msgid "`auto-initialize` feature is now opt-in"
msgstr ""

#: src/migration.md:1888
msgid ""
"For projects embedding Python in Rust, PyO3 no longer automatically "
"initializes a Python interpreter on the first call to `Python::with_gil` (or "
"`Python::acquire_gil`) unless the [`auto-initialize` feature](features."
"md#auto-initialize) is enabled."
msgstr ""

#: src/migration.md:1891
msgid "New `multiple-pymethods` feature"
msgstr ""

#: src/migration.md:1896
msgid ""
"`#[pymethods]` have been reworked with a simpler default implementation "
"which removes the dependency on the `inventory` crate. This reduces "
"dependencies and compile times for the majority of users."
msgstr ""

#: src/migration.md:1898
msgid ""
"The limitation of the new default implementation is that it cannot support "
"multiple `#[pymethods]` blocks for the same `#[pyclass]`. If you need this "
"functionality, you must enable the `multiple-pymethods` feature which will "
"switch `#[pymethods]` to the inventory-based implementation."
msgstr ""

#: src/migration.md:1901
msgid "Deprecated `#[pyproto]` methods"
msgstr ""

#: src/migration.md:1906
msgid ""
"Some protocol (aka `__dunder__`) methods such as `__bytes__` and "
"`__format__` have been possible to implement two ways in PyO3 for some time: "
"via a `#[pyproto]` (e.g. `PyObjectProtocol` for the methods listed here), or "
"by writing them directly in `#[pymethods]`. This is only true for a handful "
"of the `#[pyproto]` methods (for technical reasons to do with the way PyO3 "
"currently interacts with the Python C-API)."
msgstr ""

#: src/migration.md:1908
msgid ""
"In the interest of having only one way to do things, the `#[pyproto]` forms "
"of these methods have been deprecated."
msgstr ""

#: src/migration.md:1910
msgid ""
"To migrate just move the affected methods from a `#[pyproto]` to a "
"`#[pymethods]` block."
msgstr ""

#: src/migration.md:1947
msgid "from 0.12.\\* to 0.13"
msgstr ""

#: src/migration.md:1949
msgid "Minimum Rust version increased to Rust 1.45"
msgstr ""

#: src/migration.md:1954
msgid ""
"PyO3 `0.13` makes use of new Rust language features stabilized between Rust "
"1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, "
"you will need to update your toolchain to be able to continue using PyO3."
msgstr ""

#: src/migration.md:1957
msgid "Runtime changes to support the CPython limited API"
msgstr ""

#: src/migration.md:1962
msgid ""
"In PyO3 `0.13` support was added for compiling against the CPython limited "
"API. This had a number of implications for _all_ PyO3 users, described here."
msgstr ""

#: src/migration.md:1964
msgid ""
"The largest of these is that all types created from PyO3 are what CPython "
"calls \"heap\" types. The specific implications of this are:"
msgstr ""

#: src/migration.md:1966
msgid ""
"If you wish to subclass one of these types _from Rust_ you must mark it "
"`#[pyclass(subclass)]`, as you would if you wished to allow subclassing it "
"from Python code."
msgstr ""

#: src/migration.md:1967
msgid "Type objects are now mutable - Python code can set attributes on them."
msgstr ""

#: src/migration.md:1968
msgid ""
"`__module__` on types without `#[pyclass(module=\"mymodule\")]` no longer "
"returns `builtins`, it now raises `AttributeError`."
msgstr ""

#: src/migration.md:1971
msgid "from 0.11.\\* to 0.12"
msgstr ""

#: src/migration.md:1973
msgid "`PyErr` has been reworked"
msgstr ""

#: src/migration.md:1978
msgid ""
"In PyO3 `0.12` the `PyErr` type has been re-implemented to be significantly "
"more compatible with the standard Rust error handling ecosystem. "
"Specifically `PyErr` now implements `Error + Send + Sync`, which are the "
"standard traits used for error types."
msgstr ""

#: src/migration.md:1982
msgid ""
"While this has necessitated the removal of a number of APIs, the resulting "
"`PyErr` type should now be much more easier to work with. The following "
"sections list the changes in detail and how to migrate to the new APIs."
msgstr ""

#: src/migration.md:1987
msgid ""
"`PyErr::new` and `PyErr::from_type` now require `Send + Sync` for their "
"argument"
msgstr ""

#: src/migration.md:1992
msgid ""
"For most uses no change will be needed. If you are trying to construct "
"`PyErr` from a value that is not `Send + Sync`, you will need to first "
"create the Python object and then use `PyErr::from_instance`."
msgstr ""

#: src/migration.md:1996
msgid ""
"Similarly, any types which implemented `PyErrArguments` will now need to be "
"`Send + Sync`."
msgstr ""

#: src/migration.md:1999
msgid "`PyErr`'s contents are now private"
msgstr ""

#: src/migration.md:2004
msgid ""
"It is no longer possible to access the fields `.ptype`, `.pvalue` and `."
"ptraceback` of a `PyErr`. You should instead now use the new methods `PyErr::"
"ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/migration.md:2008
msgid "`PyErrValue` and `PyErr::from_value` have been removed"
msgstr ""

#: src/migration.md:2013
msgid ""
"As these were part the internals of `PyErr` which have been reworked, these "
"APIs no longer exist."
msgstr ""

#: src/migration.md:2015
msgid ""
"If you used this API, it is recommended to use `PyException::new_err` (see "
"[the section on Exception types](#exception-types-have-been-reworked))."
msgstr ""

#: src/migration.md:2019
msgid "`Into<PyResult<T>>` for `PyErr` has been removed"
msgstr ""

#: src/migration.md:2024
msgid ""
"This implementation was redundant. Just construct the `Result::Err` variant "
"directly."
msgstr ""

#: src/migration.md:2029 src/migration.md:2036 src/migration.md:2053
#: src/migration.md:2062
msgid "\"error message\""
msgstr ""

#: src/migration.md:2032
msgid ""
"After (also using the new reworked exception types; see the following "
"section):"
msgstr ""

#: src/migration.md:2041
msgid "Exception types have been reworked"
msgstr ""

#: src/migration.md:2046
msgid ""
"Previously exception types were zero-sized marker types purely used to "
"construct `PyErr`. In PyO3 0.12, these types have been replaced with full "
"definitions and are usable in the same way as `PyAny`, `PyDict` etc. This "
"makes it possible to interact with Python exception objects."
msgstr ""

#: src/migration.md:2050
msgid ""
"The new types also have names starting with the \"Py\" prefix. For example, "
"before:"
msgstr ""

#: src/migration.md:2063
msgid "// Uses Display for PyErr, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:2065
msgid "\"TypeError: error message\""
msgstr ""

#: src/migration.md:2066
msgid ""
"// Now possible to interact with exception instances, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:2070
msgid "\"__class__\""
msgstr ""

#: src/migration.md:2079
msgid "`FromPy` has been removed"
msgstr ""

#: src/migration.md:2084
msgid ""
"To simplify the PyO3 conversion traits, the `FromPy` trait has been removed. "
"Previously there were two ways to define the to-Python conversion for a "
"type: `FromPy<T> for PyObject` and `IntoPy<PyObject> for T`."
msgstr ""

#: src/migration.md:2088
msgid ""
"Now there is only one way to define the conversion, `IntoPy`, so downstream "
"crates may need to adjust accordingly."
msgstr ""

#: src/migration.md:2119
msgid ""
"Similarly, code which was using the `FromPy` trait can be trivially "
"rewritten to use `IntoPy`."
msgstr ""

#: src/migration.md:2142
msgid "`PyObject` is now a type alias of `Py<PyAny>`"
msgstr ""

#: src/migration.md:2147
msgid ""
"This should change very little from a usage perspective. If you implemented "
"traits for both `PyObject` and `Py<T>`, you may find you can just remove the "
"`PyObject` implementation."
msgstr ""

#: src/migration.md:2151
msgid "`AsPyRef` has been removed"
msgstr ""

#: src/migration.md:2156
msgid ""
"As `PyObject` has been changed to be just a type alias, the only remaining "
"implementor of `AsPyRef` was `Py<T>`. This removed the need for a trait, so "
"the `AsPyRef::as_ref` method has been moved to `Py::as_ref`."
msgstr ""

#: src/migration.md:2160
msgid ""
"This should require no code changes except removing `use pyo3::AsPyRef` for "
"code which did not use `pyo3::prelude::*`."
msgstr ""

#: src/migration.md:2185
msgid "from 0.10.\\* to 0.11"
msgstr ""

#: src/migration.md:2187
msgid "Stable Rust"
msgstr ""

#: src/migration.md:2192
msgid ""
"PyO3 now supports the stable Rust toolchain. The minimum required version is "
"1.39.0."
msgstr ""

#: src/migration.md:2195
msgid "`#[pyclass]` structs must now be `Send` or `unsendable`"
msgstr ""

#: src/migration.md:2200
msgid ""
"Because `#[pyclass]` structs can be sent between threads by the Python "
"interpreter, they must implement `Send` or declared as `unsendable` (by "
"`#[pyclass(unsendable)]`). Note that `unsendable` is added in PyO3 `0.11.1` "
"and `Send` is always required in PyO3 `0.11.0`."
msgstr ""

#: src/migration.md:2204
msgid ""
"This may \"break\" some code which previously was accepted, even though it "
"could be unsound. There can be two fixes:"
msgstr ""

#: src/migration.md:2207
msgid ""
"If you think that your `#[pyclass]` actually must be `Send`able, then let's "
"implement `Send`. A common, safer way is using thread-safe types. E.g., "
"`Arc` instead of `Rc`, `Mutex` instead of `RefCell`, and `Box<dyn Send + T>` "
"instead of `Box<dyn T>`."
msgstr ""

#: src/migration.md:2239
msgid ""
"In situations where you cannot change your `#[pyclass]` to automatically "
"implement `Send` (e.g., when it contains a raw pointer), you can use `unsafe "
"impl Send`. In such cases, care should be taken to ensure the struct is "
"actually thread safe. See [the Rustonomicon](https://doc.rust-lang.org/"
"nomicon/send-and-sync.html) for more."
msgstr ""

#: src/migration.md:2244
msgid ""
"If you think that your `#[pyclass]` should not be accessed by another "
"thread, you can use `unsendable` flag. A class marked with `unsendable` "
"panics when accessed by another thread, making it thread-safe to expose an "
"unsendable object to the Python interpreter."
msgstr ""

#: src/migration.md:2273
msgid "All `PyObject` and `Py<T>` methods now take `Python` as an argument"
msgstr ""

#: src/migration.md:2278
msgid ""
"Previously, a few methods such as `Object::get_refcnt` did not take `Python` "
"as an argument (to ensure that the Python GIL was held by the current "
"thread). Technically, this was not sound. To migrate, just pass a `py` "
"argument to any calls to these methods."
msgstr ""

#: src/migration.md:2300
msgid "from 0.9.\\* to 0.10"
msgstr ""

#: src/migration.md:2302
msgid "`ObjectProtocol` is removed"
msgstr ""

#: src/migration.md:2307
msgid ""
"All methods are moved to [`PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html). And since now all native types (e.g., `PyList`) "
"implements `Deref<Target=PyAny>`, all you need to do is remove "
"`ObjectProtocol` from your code. Or if you use `ObjectProtocol` by `use "
"pyo3::prelude::*`, you have to do nothing."
msgstr ""

#: src/migration.md:2318 src/migration.md:2328
msgid "\"lambda: 'Hi :)'\""
msgstr ""

#: src/migration.md:2336
msgid "No `#![feature(specialization)]` in user code"
msgstr ""

#: src/migration.md:2341
msgid ""
"While PyO3 itself still requires specialization and nightly Rust, now you "
"don't have to use `#![feature(specialization)]` in your crate."
msgstr ""

#: src/migration.md:2345
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:2347
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:2352
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:2386
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](class.md#constructor) of this guide."
msgstr ""

#: src/migration.md:2390
msgid "PyCell"
msgstr ""

#: src/migration.md:2395
msgid ""
"PyO3 0.9 introduces `PyCell`, which is a [`RefCell`](https://doc.rust-lang."
"org/std/cell/struct.RefCell.html)\\-like object wrapper for ensuring Rust's "
"rules regarding aliasing of references are upheld. For more detail, see the "
"[Rust Book's section on Rust's rules of references](https://doc.rust-lang."
"org/book/ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:2400
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:2404
msgid "Here is an example."
msgstr ""

#: src/migration.md:2426
msgid ""
"r\"\n"
"#     try:\n"
"#        names.merge(names)\n"
"#        assert False, 'Unreachable'\n"
"#     except RuntimeError as e:\n"
"#        assert str(e) == 'Already borrowed'\n"
"#     \""
msgstr ""

#: src/migration.md:2436
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/main/doc/pyo3/pycell/"
"struct.PyBorrowMutError.html) exception, since it requires two mutable "
"borrows of `names`."
msgstr ""

#: src/migration.md:2440
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:2442
msgid "Object creation"
msgstr ""

#: src/migration.md:2444
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use `PyCell::new` "
"instead. If you need [`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html), just call `.borrow()` or `.borrow_mut()` on the newly-created "
"`PyCell`."
msgstr ""

#: src/migration.md:2474
msgid "Object extraction"
msgstr ""

#: src/migration.md:2476
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:2498
msgid "\"c\""
msgstr ""

#: src/migration.md:2499
msgid "\"c()\""
msgstr ""

#: src/migration.md:2502
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:2505
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:2511
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:2513
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) implementation. So if your protocol methods take `&T` or `&mut T` "
"(where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) instead."
msgstr ""

#: src/trait-bounds.md:1
msgid "Using in Python a Rust function with trait bounds"
msgstr ""

#: src/trait-bounds.md:3
msgid ""
"PyO3 allows for easy conversion from Rust to Python for certain functions "
"and classes (see the [conversion table](conversions/tables.md)). However, it "
"is not always straightforward to convert Rust code that requires a given "
"trait implementation as an argument."
msgstr ""

#: src/trait-bounds.md:6
msgid ""
"This tutorial explains how to convert a Rust function that takes a trait as "
"argument for use in Python with classes implementing the same methods as the "
"trait."
msgstr ""

#: src/trait-bounds.md:8
msgid "Why is this useful?"
msgstr ""

#: src/trait-bounds.md:10
msgid "Pros"
msgstr ""

#: src/trait-bounds.md:12
msgid "Make your Rust code available to Python users"
msgstr ""

#: src/trait-bounds.md:13
msgid "Code complex algorithms in Rust with the help of the borrow checker"
msgstr ""

#: src/trait-bounds.md:15
msgid "Cons"
msgstr ""

#: src/trait-bounds.md:17
msgid ""
"Not as fast as native Rust (type conversion has to be performed and one part "
"of the code runs in Python)"
msgstr ""

#: src/trait-bounds.md:18
msgid "You need to adapt your code to expose it"
msgstr ""

#: src/trait-bounds.md:20
msgid "Example"
msgstr ""

#: src/trait-bounds.md:22
msgid ""
"Let's work with the following basic example of an implementation of a "
"optimization solver operating on a given model."
msgstr ""

#: src/trait-bounds.md:24
msgid ""
"Let's say we have a function `solve` that operates on a model and mutates "
"its state. The argument of the function can be any model that implements the "
"`Model` trait :"
msgstr ""

#: src/trait-bounds.md:36 src/trait-bounds.md:479
msgid "\"Magic solver that mutates the model into a resolved state\""
msgstr ""

#: src/trait-bounds.md:40
msgid "Let's assume we have the following constraints:"
msgstr ""

#: src/trait-bounds.md:42
msgid "We cannot change that code as it runs on many Rust models."
msgstr ""

#: src/trait-bounds.md:43
msgid ""
"We also have many Python models that cannot be solved as this solver is not "
"available in that language."
msgstr ""

#: src/trait-bounds.md:45
msgid ""
"Rewriting it in Python would be cumbersome and error-prone, as everything is "
"already available in Rust."
msgstr ""

#: src/trait-bounds.md:47
msgid "How could we expose this solver to Python thanks to PyO3 ?"
msgstr ""

#: src/trait-bounds.md:49
msgid "Implementation of the trait bounds for the Python class"
msgstr ""

#: src/trait-bounds.md:51
msgid ""
"If a Python class implements the same three methods as the `Model` trait, it "
"seems logical it could be adapted to use the solver. However, it is not "
"possible to pass a `Py<PyAny>` to it as it does not implement the Rust trait "
"(even if the Python model has the required methods)."
msgstr ""

#: src/trait-bounds.md:54
msgid ""
"In order to implement the trait, we must write a wrapper around the calls in "
"Rust to the Python model. The method signatures must be the same as the "
"trait, keeping in mind that the Rust trait cannot be changed for the purpose "
"of making the code available in Python."
msgstr ""

#: src/trait-bounds.md:57
msgid ""
"The Python model we want to expose is the following one, which already "
"contains all the required methods:"
msgstr ""

#: src/trait-bounds.md:69
msgid ""
"The following wrapper will call the Python model from Rust, using a struct "
"to hold the model as a `PyAny` object:"
msgstr ""

#: src/trait-bounds.md:88 src/trait-bounds.md:188 src/trait-bounds.md:367
#: src/trait-bounds.md:426 src/trait-bounds.md:523
msgid "\"Rust calling Python to set the variables\""
msgstr ""

#: src/trait-bounds.md:92 src/trait-bounds.md:191 src/trait-bounds.md:370
#: src/trait-bounds.md:429 src/trait-bounds.md:527
msgid "\"set_variables\""
msgstr ""

#: src/trait-bounds.md:98 src/trait-bounds.md:197 src/trait-bounds.md:356
msgid "\"Rust calling Python to get the results\""
msgstr ""

#: src/trait-bounds.md:102 src/trait-bounds.md:201 src/trait-bounds.md:360
#: src/trait-bounds.md:412 src/trait-bounds.md:538
msgid "\"get_results\""
msgstr ""

#: src/trait-bounds.md:110 src/trait-bounds.md:209 src/trait-bounds.md:376
#: src/trait-bounds.md:435 src/trait-bounds.md:553
msgid "\"Rust calling Python to perform the computation\""
msgstr ""

#: src/trait-bounds.md:114 src/trait-bounds.md:213 src/trait-bounds.md:380
#: src/trait-bounds.md:439 src/trait-bounds.md:557
msgid "\"compute\""
msgstr ""

#: src/trait-bounds.md:121
msgid ""
"Now that this bit is implemented, let's expose the model wrapper to Python. "
"Let's add the PyO3 annotations and add a constructor:"
msgstr ""

#: src/trait-bounds.md:154
msgid "Now we add the PyO3 annotations to the trait implementation:"
msgstr ""

#: src/trait-bounds.md:159
msgid "// the previous trait implementation\n"
msgstr ""

#: src/trait-bounds.md:163
msgid ""
"However, the previous code will not compile. The compilation error is the "
"following one: `error: #[pymethods] cannot be used on trait impl blocks`"
msgstr ""

#: src/trait-bounds.md:166
msgid ""
"That's a bummer! However, we can write a second wrapper around these "
"functions to call them directly. This wrapper will also perform the type "
"conversions between Python and Rust."
msgstr ""

#: src/trait-bounds.md:223 src/trait-bounds.md:501
msgid "\"Set variables from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:228 src/trait-bounds.md:506
msgid "\"Get results from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:233
msgid "\"Compute from Python calling Rust\""
msgstr ""

#: src/trait-bounds.md:239
msgid ""
"This wrapper handles the type conversion between the PyO3 requirements and "
"the trait. In order to meet PyO3 requirements, this wrapper must:"
msgstr ""

#: src/trait-bounds.md:242
msgid "return an object of type `PyResult`"
msgstr ""

#: src/trait-bounds.md:243
msgid "use only values, not references in the method signatures"
msgstr ""

#: src/trait-bounds.md:245
msgid "Let's run the file python file:"
msgstr ""

#: src/trait-bounds.md:256
msgid "\"__main__\""
msgstr ""

#: src/trait-bounds.md:262
msgid "\"Print value from Python: \""
msgstr ""

#: src/trait-bounds.md:264
msgid "\"Print value from Python through Rust: \""
msgstr ""

#: src/trait-bounds.md:265
msgid "\"Print value directly from Python: \""
msgstr ""

#: src/trait-bounds.md:268
msgid "This outputs:"
msgstr ""

#: src/trait-bounds.md:282
msgid ""
"We have now successfully exposed a Rust model that implements the `Model` "
"trait to Python!"
msgstr ""

#: src/trait-bounds.md:284
msgid ""
"We will now expose the `solve` function, but before, let's talk about types "
"errors."
msgstr ""

#: src/trait-bounds.md:286
msgid "Type errors in Python"
msgstr ""

#: src/trait-bounds.md:288
msgid ""
"What happens if you have type errors when using Python and how can you "
"improve the error messages?"
msgstr ""

#: src/trait-bounds.md:290
msgid "Wrong types in Python function arguments"
msgstr ""

#: src/trait-bounds.md:292
msgid ""
"Let's assume in the first case that you will use in your Python file "
"`my_rust_model.set_variables(2.0)` instead of `my_rust_model."
"set_variables([2.0])`."
msgstr ""

#: src/trait-bounds.md:294
msgid ""
"The Rust signature expects a vector, which corresponds to a list in Python. "
"What happens if instead of a vector, we pass a single value ?"
msgstr ""

#: src/trait-bounds.md:297
msgid "At the execution of Python, we get :"
msgstr ""

#: src/trait-bounds.md:299
msgid ""
"```block\n"
"File \"main.py\", line 15, in <module>\n"
"   my_rust_model.set_variables(2)\n"
"TypeError\n"
"```"
msgstr ""

#: src/trait-bounds.md:305
msgid ""
"It is a type error and Python points to it, so it's easy to identify and "
"solve."
msgstr ""

#: src/trait-bounds.md:307
msgid "Wrong types in Python method signatures"
msgstr ""

#: src/trait-bounds.md:309
msgid ""
"Let's assume now that the return type of one of the methods of our Model "
"class is wrong, for example the `get_results` method that is expected to "
"return a `Vec<f64>` in Rust, a list in Python."
msgstr ""

#: src/trait-bounds.md:319
msgid "#return self.results <-- this is the expected output\n"
msgstr ""

#: src/trait-bounds.md:322
msgid "This call results in the following panic:"
msgstr ""

#: src/trait-bounds.md:328
msgid ""
"This error code is not helpful for a Python user that does not know anything "
"about Rust, or someone that does not know PyO3 was used to interface the "
"Rust code."
msgstr ""

#: src/trait-bounds.md:330
msgid ""
"However, as we are responsible for making the Rust code available to Python, "
"we can do something about it."
msgstr ""

#: src/trait-bounds.md:332
msgid ""
"The issue is that we called `unwrap` anywhere we could, and therefore any "
"panic from PyO3 will be directly forwarded to the end user."
msgstr ""

#: src/trait-bounds.md:334
msgid ""
"Let's modify the code performing the type conversion to give a helpful error "
"message to the Python user:"
msgstr ""

#: src/trait-bounds.md:336
msgid ""
"We used in our `get_results` method the following call that performs the "
"type conversion:"
msgstr ""

#: src/trait-bounds.md:387
msgid "Let's break it down in order to perform better error handling:"
msgstr ""

#: src/trait-bounds.md:407 src/trait-bounds.md:533
msgid "\"Get results from Rust calling Python\""
msgstr ""

#: src/trait-bounds.md:417 src/trait-bounds.md:543
msgid "\"Expected a list for the get_results() method signature, got {}\""
msgstr ""

#: src/trait-bounds.md:446
msgid ""
"By doing so, you catch the result of the Python computation and check its "
"type in order to be able to deliver a better error message before performing "
"the unwrapping."
msgstr ""

#: src/trait-bounds.md:448
msgid ""
"Of course, it does not cover all the possible wrong outputs: the user could "
"return a list of strings instead of a list of floats. In this case, a "
"runtime panic would still occur due to PyO3, but with an error message much "
"more difficult to decipher for non-rust user."
msgstr ""

#: src/trait-bounds.md:452
msgid ""
"It is up to the developer exposing the rust code to decide how much effort "
"to invest into Python type error handling and improved error messages."
msgstr ""

#: src/trait-bounds.md:454
msgid "The final code"
msgstr ""

#: src/trait-bounds.md:456
msgid ""
"Now let's expose the `solve()` function to make it available from Python."
msgstr ""

#: src/trait-bounds.md:458
msgid ""
"It is not possible to directly expose the `solve` function to Python, as the "
"type conversion cannot be performed. It requires an object implementing the "
"`Model` trait as input."
msgstr ""

#: src/trait-bounds.md:461
msgid ""
"However, the `UserModel` already implements this trait. Because of this, we "
"can write a function wrapper that takes the `UserModel`\\--which has already "
"been exposed to Python--as an argument in order to call the core function "
"`solve`."
msgstr ""

#: src/trait-bounds.md:464
msgid "It is also required to make the struct public."
msgstr ""

#: src/trait-bounds.md:483
msgid "\"solve\""
msgstr ""

#: src/python-typing-hints.md:1
msgid "Typing and IDE hints for your Python package"
msgstr ""

#: src/python-typing-hints.md:3
msgid ""
"PyO3 provides an easy to use interface to code native Python libraries in "
"Rust. The accompanying Maturin allows you to build and publish them as a "
"package. Yet, for a better user experience, Python libraries should provide "
"typing hints and documentation for all public entities, so that IDEs can "
"show them during development and type analyzing tools such as `mypy` can use "
"them to properly verify the code."
msgstr ""

#: src/python-typing-hints.md:5
msgid ""
"Currently the best solution for the problem is to manually maintain `*.pyi` "
"files and ship them along with the package."
msgstr ""

#: src/python-typing-hints.md:7
msgid ""
"PyO3 is working on automated their generation. See the [type stub generation]"
"(type-stub.md) documentation for a description of the current state of "
"automated generation."
msgstr ""

#: src/python-typing-hints.md:9
msgid "Introduction to `pyi` files"
msgstr ""

#: src/python-typing-hints.md:11
msgid ""
"`pyi` files (an abbreviation for `Python Interface`) are called \"stub "
"files\" in most of the documentation related to them. A very good definition "
"of what it is can be found in [old MyPy documentation](https://github.com/"
"python/mypy/wiki/Creating-Stubs-For-Python-Modules):"
msgstr ""

#: src/python-typing-hints.md:13
msgid ""
"A stubs file only contains a description of the public interface of the "
"module without any implementations."
msgstr ""

#: src/python-typing-hints.md:15
msgid ""
"There is also [extensive documentation on type stubs on the official Python "
"typing documentation](https://typing.readthedocs.io/en/latest/source/stubs."
"html)."
msgstr ""

#: src/python-typing-hints.md:17
msgid ""
"Most Python developers probably already encountered them when trying to use "
"their IDE's \"Go to Definition\" function on any builtin type. For example, "
"the definitions of a few standard exceptions look like this:"
msgstr ""

#: src/python-typing-hints.md:40
msgid ""
"As we can see, those are not full definitions containing implementation, but "
"just a description of the interface. It is usually all that the user of the "
"library needs."
msgstr ""

#: src/python-typing-hints.md:42
msgid "What do the PEPs say?"
msgstr ""

#: src/python-typing-hints.md:44
msgid ""
"At the time of writing this documentation, the `pyi` files are referenced in "
"four PEPs."
msgstr ""

#: src/python-typing-hints.md:46
msgid ""
"[PEP8 - Style Guide for Python Code - #Function Annotations](https://www."
"python.org/dev/peps/pep-0008/#function-annotations) (last point) recommends "
"all third party library creators to provide stub files as the source of "
"knowledge about the package for type checker tools."
msgstr ""

#: src/python-typing-hints.md:48
msgid ""
"(...) it is expected that users of third party library packages may want to "
"run type checkers over those packages. For this purpose [PEP 484](https://"
"www.python.org/dev/peps/pep-0484) recommends the use of stub files: .pyi "
"files that are read by the type checker in preference of the corresponding ."
"py files. (...)"
msgstr ""

#: src/python-typing-hints.md:50
msgid ""
"[PEP484 - Type Hints - #Stub Files](https://www.python.org/dev/peps/pep-0484/"
"#stub-files) defines stub files as follows."
msgstr ""

#: src/python-typing-hints.md:52
msgid ""
"Stub files are files containing type hints that are only for use by the type "
"checker, not at runtime."
msgstr ""

#: src/python-typing-hints.md:54
msgid ""
"It contains a specification for them (highly recommended reading, since it "
"contains at least one thing that is not used in normal Python code) and also "
"some general information about where to store the stub files."
msgstr ""

#: src/python-typing-hints.md:56
msgid ""
"[PEP561 - Distributing and Packaging Type Information](https://www.python."
"org/dev/peps/pep-0561/) describes in detail how to build packages that will "
"enable type checking. In particular it contains information about how the "
"stub files must be distributed in order for type checkers to use them."
msgstr ""

#: src/python-typing-hints.md:58
msgid ""
"[PEP560 - Core support for typing module and generic types](https://www."
"python.org/dev/peps/pep-0560/) describes the details on how Python's type "
"system internally supports generics, including both runtime behavior and "
"integration with static type checkers."
msgstr ""

#: src/python-typing-hints.md:60
msgid "How to do it?"
msgstr ""

#: src/python-typing-hints.md:62
msgid ""
"[PEP561](https://www.python.org/dev/peps/pep-0561/) recognizes three ways of "
"distributing type information:"
msgstr ""

#: src/python-typing-hints.md:64
msgid "`inline` - the typing is placed directly in source (`py`) files;"
msgstr ""

#: src/python-typing-hints.md:65
msgid ""
"`separate package with stub files` - the typing is placed in `pyi` files "
"distributed in their own, separate package;"
msgstr ""

#: src/python-typing-hints.md:66
msgid ""
"`in-package stub files` - the typing is placed in `pyi` files distributed in "
"the same package as source files."
msgstr ""

#: src/python-typing-hints.md:68
msgid ""
"The first way is tricky with PyO3 since we do not have `py` files. When it "
"has been investigated and necessary changes are implemented, this document "
"will be updated."
msgstr ""

#: src/python-typing-hints.md:70
msgid ""
"The second way is easy to do, and the whole work can be fully separated from "
"the main library code. The example repo for the package with stub files can "
"be found in [PEP561 references section](https://www.python.org/dev/peps/"
"pep-0561/#references): [Stub package repository](https://github.com/ethanhs/"
"stub-package)"
msgstr ""

#: src/python-typing-hints.md:72
msgid "The third way is described below."
msgstr ""

#: src/python-typing-hints.md:74
msgid "Including `pyi` files in your PyO3/Maturin build package"
msgstr ""

#: src/python-typing-hints.md:76
msgid ""
"When source files are in the same package as stub files, they should be "
"placed next to each other. We need a way to do that with Maturin. Also, in "
"order to mark our package as typing-enabled we need to add an empty file "
"named `py.typed` to the package."
msgstr ""

#: src/python-typing-hints.md:78
msgid "If you do not have other Python files"
msgstr ""

#: src/python-typing-hints.md:80
msgid ""
"If you do not need to add any other Python files apart from `pyi` to the "
"package, Maturin provides a way to do most of the work for you. As "
"documented in the [Maturin Guide](https://github.com/PyO3/maturin/#mixed-"
"rustpython-projects), the only thing you need to do is to create a stub file "
"for your module named `<module_name>.pyi` in your project root and Maturin "
"will do the rest."
msgstr ""

#: src/python-typing-hints.md:91
msgid ""
"For an example `pyi` file see the [`my_project.pyi` content](#my_projectpyi-"
"content) section."
msgstr ""

#: src/python-typing-hints.md:93
msgid "If you need other Python files"
msgstr ""

#: src/python-typing-hints.md:95
msgid ""
"If you need to add other Python files apart from `pyi` to the package, you "
"can do it also, but that requires some more work. Maturin provides an easy "
"way to add files to a package ([documentation](https://github.com/PyO3/"
"maturin/blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-"
"rustpython-projects)). You just need to create a folder with the name of "
"your module next to the `Cargo.toml` file (for customization see "
"documentation linked above)."
msgstr ""

#: src/python-typing-hints.md:97
msgid "The folder structure would be:"
msgstr ""

#: src/python-typing-hints.md:113
msgid ""
"Let's go a little bit more into detail regarding the files inside the "
"package folder."
msgstr ""

#: src/python-typing-hints.md:115
msgid "`__init__.py` content"
msgstr ""

#: src/python-typing-hints.md:117
msgid ""
"As we now specify our own package content, we have to provide the `__init__."
"py` file, so the folder is treated as a package and we can import things "
"from it. We can always use the same content that Maturin creates for us if "
"we do not specify a Python source folder. For PyO3 bindings it would be:"
msgstr ""

#: src/python-typing-hints.md:123
msgid ""
"That way everything that is exposed by our native module can be imported "
"directly from the package."
msgstr ""

#: src/python-typing-hints.md:125
msgid "`py.typed` requirement"
msgstr ""

#: src/python-typing-hints.md:127
msgid "As stated in [PEP561](https://www.python.org/dev/peps/pep-0561/):"
msgstr ""

#: src/python-typing-hints.md:128
msgid ""
"Package maintainers who wish to support type checking of their code MUST add "
"a marker file named py.typed to their package supporting typing. This marker "
"applies recursively: if a top-level package includes it, all its sub-"
"packages MUST support type checking as well."
msgstr ""

#: src/python-typing-hints.md:130
msgid ""
"If we do not include that file, some IDEs might still use our `pyi` files to "
"show hints, but the type checkers might not. MyPy will raise an error in "
"this situation:"
msgstr ""

#: src/python-typing-hints.md:132
msgid ""
"```text\n"
"error: Skipping analyzing \"my_project\": found module but no type hints or "
"library stubs\n"
"```"
msgstr ""

#: src/python-typing-hints.md:136
msgid "The file is just a marker file, so it should be empty."
msgstr ""

#: src/python-typing-hints.md:138
msgid "`my_project.pyi` content"
msgstr ""

#: src/python-typing-hints.md:140
msgid ""
"Our module stub file. This document does not aim at describing how to write "
"them, since you can find a lot of documentation on it, starting from the "
"already quoted [PEP484](https://www.python.org/dev/peps/pep-0484/#stub-"
"files)."
msgstr ""

#: src/python-typing-hints.md:142
msgid "The example can look like this:"
msgstr ""

#: src/python-typing-hints.md:146
msgid ""
"\"\"\"\n"
"    A class representing a car.\n"
"\n"
"    :param body_type: the name of body type, e.g. hatchback, sedan\n"
"    :param horsepower: power of the engine in horsepower\n"
"    \"\"\""
msgstr ""

#: src/python-typing-hints.md:155
msgid "'Car'"
msgstr ""

#: src/python-typing-hints.md:156
msgid ""
"\"\"\"\n"
"        Creates a Car based on unique name\n"
"\n"
"        :param name: model name of a car to be created\n"
"        :return: a Car instance with default data\n"
"        \"\"\""
msgstr ""

#: src/python-typing-hints.md:164
msgid ""
"\"\"\"\n"
"        Gets the best color for the car.\n"
"\n"
"        :return: the name of the color our great algorithm thinks is the "
"best for this car\n"
"        \"\"\""
msgstr ""

#: src/python-typing-hints.md:171
msgid "Supporting Generics"
msgstr ""

#: src/python-typing-hints.md:173
msgid ""
"Type annotations can also be made generic in Python. They are useful for "
"working with different types while maintaining type safety. Usually, generic "
"classes inherit from the `typing.Generic` metaclass."
msgstr ""

#: src/python-typing-hints.md:177
msgid ""
"Take for example the following `.pyi` file that specifies a `Car` that can "
"accept multiple types of wheels:"
msgstr ""

#: src/python-typing-hints.md:183
msgid "'W'"
msgstr ""

#: src/python-typing-hints.md:193
msgid ""
"This way, the end-user can specify the type with variables such as `truck: "
"Car[SteelWheel] = ...` and `f1_car: Car[AlloyWheel] = ...`."
msgstr ""

#: src/python-typing-hints.md:196
msgid ""
"There is also a special syntax for specifying generic types in Python 3.12+:"
msgstr ""

#: src/python-typing-hints.md:205
msgid "Runtime Behaviour"
msgstr ""

#: src/python-typing-hints.md:207
msgid ""
"Stub files (`pyi`) are only useful for static type checkers and ignored at "
"runtime. Therefore, PyO3 classes do not inherit from `typing.Generic` even "
"if specified in the stub files."
msgstr ""

#: src/python-typing-hints.md:210
msgid ""
"This can cause some runtime issues, as annotating a variable like `f1_car: "
"Car[AlloyWheel] = ...` can make Python call magic methods that are not "
"defined."
msgstr ""

#: src/python-typing-hints.md:213
msgid ""
"To overcome this limitation, implementers can pass the `generic` parameter "
"to `pyclass` in Rust:"
msgstr ""

#: src/python-typing-hints.md:219
msgid "Advanced Users"
msgstr ""

#: src/python-typing-hints.md:221
msgid ""
"`#[pyclass(generic)]` implements a very simple runtime behavior that accepts "
"any generic argument. Advanced users can opt to manually implement "
"[`__class_geitem__`](https://docs.python.org/3/reference/datamodel."
"html#emulating-generic-types) for the generic class to have more control."
msgstr ""

#: src/python-typing-hints.md:239
msgid ""
"Note that [`pyo3::types::PyGenericAlias`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyGenericAlias.html) can be helpful when implementing "
"`__class_getitem__` as it can create [`types.GenericAlias`](https://docs."
"python.org/3/library/types.html#types.GenericAlias) objects from Rust."
msgstr ""

#: src/building-and-distribution.md:1
msgid "Building and distribution"
msgstr ""

#: src/building-and-distribution.md:3
msgid ""
"This chapter of the guide goes into detail on how to build and distribute "
"projects using PyO3. The way to achieve this is very different depending on "
"whether the project is a Python module implemented in Rust, or a Rust binary "
"embedding Python. For both types of project there are also common problems "
"such as the Python version to build for and the [linker](https://en."
"wikipedia.org/wiki/Linker_(computing)) arguments to use."
msgstr ""

#: src/building-and-distribution.md:5
msgid ""
"The material in this chapter is intended for users who have already read the "
"PyO3 [README](./index.md). It covers in turn the choices that can be made "
"for Python modules and for Rust binaries. There is also a section at the end "
"about cross-compiling projects using PyO3."
msgstr ""

#: src/building-and-distribution.md:7
msgid ""
"There is an additional sub-chapter dedicated to [supporting multiple Python "
"versions](./building-and-distribution/multiple-python-versions.md)."
msgstr ""

#: src/building-and-distribution.md:9
msgid "Configuring the Python version"
msgstr ""

#: src/building-and-distribution.md:11
msgid ""
"PyO3 uses a build script (backed by the [`pyo3-build-config`](https://github."
"com/PyO3/pyo3/tree/main/pyo3-build-config) crate) to determine the Python "
"version and set the correct linker arguments. By default it will attempt to "
"use the following in order:"
msgstr ""

#: src/building-and-distribution.md:13
msgid "Any active Python virtualenv."
msgstr ""

#: src/building-and-distribution.md:14
msgid "The `python` executable (if it's a Python 3 interpreter)."
msgstr ""

#: src/building-and-distribution.md:15
msgid "The `python3` executable."
msgstr ""

#: src/building-and-distribution.md:17
msgid ""
"You can override the Python interpreter by setting the `PYO3_PYTHON` "
"environment variable, e.g. `PYO3_PYTHON=python3.7`, `PYO3_PYTHON=/usr/bin/"
"python3.9`, or even a PyPy interpreter `PYO3_PYTHON=pypy3`."
msgstr ""

#: src/building-and-distribution.md:19
msgid ""
"Once the Python interpreter is located, `pyo3-build-config` executes it to "
"query the information in the `sysconfig` module which is needed to configure "
"the rest of the compilation."
msgstr ""

#: src/building-and-distribution.md:21
msgid ""
"To validate the configuration which PyO3 will use, you can run a compilation "
"with the environment variable `PYO3_PRINT_CONFIG=1` set. An example output "
"of doing this is shown below:"
msgstr ""

#: src/building-and-distribution.md:49
msgid ""
"The `PYO3_ENVIRONMENT_SIGNATURE` environment variable can be used to trigger "
"rebuilds when its value changes, it has no other effect."
msgstr ""

#: src/building-and-distribution.md:51
msgid "Advanced: config files"
msgstr ""

#: src/building-and-distribution.md:53
msgid ""
"If you save the above output config from `PYO3_PRINT_CONFIG` to a file, it "
"is possible to manually override the contents and feed it back into PyO3 "
"using the `PYO3_CONFIG_FILE` env var."
msgstr ""

#: src/building-and-distribution.md:55
msgid ""
"If your build environment is unusual enough that PyO3's regular "
"configuration detection doesn't work, using a config file like this will "
"give you the flexibility to make PyO3 work for you. To see the full set of "
"options supported, see the documentation for the [`InterpreterConfig` struct]"
"(https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct."
"InterpreterConfig.html)."
msgstr ""

#: src/building-and-distribution.md:57
msgid "Building Python extension modules"
msgstr ""

#: src/building-and-distribution.md:59
msgid ""
"Python extension modules need to be compiled differently depending on the OS "
"(and architecture) that they are being compiled for. As well as multiple "
"OSes (and architectures), there are also many different Python versions "
"which are actively supported. Packages uploaded to [PyPI](https://pypi.org/) "
"usually want to upload prebuilt \"wheels\" covering many OS/arch/version "
"combinations so that users on all these different platforms don't have to "
"compile the package themselves. Package vendors can opt-in to the \"abi3\" "
"limited Python API which allows their wheels to be used on multiple Python "
"versions, reducing the number of wheels they need to compile, but restricts "
"the functionality they can use."
msgstr ""

#: src/building-and-distribution.md:61
msgid ""
"There are many ways to go about this: it is possible to use `cargo` to build "
"the extension module (along with some manual work, which varies with OS). "
"The PyO3 ecosystem has two packaging tools, [`maturin`](https://github.com/"
"PyO3/maturin) and [`setuptools-rust`](https://github.com/PyO3/setuptools-"
"rust), which abstract over the OS difference and also support building "
"wheels for PyPI upload."
msgstr ""

#: src/building-and-distribution.md:63
msgid ""
"PyO3 has some Cargo features to configure projects for building Python "
"extension modules:"
msgstr ""

#: src/building-and-distribution.md:65
msgid ""
"The `extension-module` feature, which must be enabled when building Python "
"extension modules."
msgstr ""

#: src/building-and-distribution.md:66
msgid ""
"The `abi3` feature and its version-specific `abi3-pyXY` companions, which "
"are used to opt-in to the limited Python API in order to support multiple "
"Python versions in a single wheel."
msgstr ""

#: src/building-and-distribution.md:68
msgid ""
"This section describes each of these packaging tools before describing how "
"to build manually without them. It then proceeds with an explanation of the "
"`extension-module` feature. Finally, there is a section describing PyO3's "
"`abi3` features."
msgstr ""

#: src/building-and-distribution.md:70
msgid "Packaging tools"
msgstr ""

#: src/building-and-distribution.md:72
msgid ""
"The PyO3 ecosystem has two main choices to abstract the process of "
"developing Python extension modules:"
msgstr ""

#: src/building-and-distribution.md:74
msgid ""
"[`maturin`](https://github.com/PyO3/maturin) is a command-line tool to "
"build, package and upload Python modules. It makes opinionated choices about "
"project layout meaning it needs very little configuration. This makes it a "
"great choice for users who are building a Python extension from scratch and "
"don't need flexibility."
msgstr ""

#: src/building-and-distribution.md:75
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is an add-on "
"for `setuptools` which adds extra keyword arguments to the `setup.py` "
"configuration file. It requires more configuration than `maturin`, however "
"this gives additional flexibility for users adding Rust to an existing "
"Python package that can't satisfy `maturin`'s constraints."
msgstr ""

#: src/building-and-distribution.md:77
msgid ""
"Consult each project's documentation for full details on how to get started "
"using them and how to upload wheels to PyPI. It should be noted that while "
"`maturin` is able to build [manylinux](https://github.com/pypa/manylinux)\\-"
"compliant wheels out-of-the-box, `setuptools-rust` requires a bit more "
"effort, [relying on Docker](https://setuptools-rust.readthedocs.io/en/latest/"
"building_wheels.html) for this purpose."
msgstr ""

#: src/building-and-distribution.md:79
msgid ""
"There are also [`maturin-starter`](https://github.com/PyO3/pyo3/tree/main/"
"examples/maturin-starter) and [`setuptools-rust-starter`](https://github.com/"
"PyO3/pyo3/tree/main/examples/setuptools-rust-starter) examples in the PyO3 "
"repository."
msgstr ""

#: src/building-and-distribution.md:81
msgid "Manual builds"
msgstr ""

#: src/building-and-distribution.md:83
msgid ""
"To build a PyO3-based Python extension manually, start by running `cargo "
"build` as normal in a library project which uses PyO3's `extension-module` "
"feature and has the [`cdylib` crate type](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#the-crate-type-field)."
msgstr ""

#: src/building-and-distribution.md:85
msgid ""
"Once built, symlink (or copy) and rename the shared library from Cargo's "
"`target/` directory to your desired output directory:"
msgstr ""

#: src/building-and-distribution.md:87
msgid "on macOS, rename `libyour_module.dylib` to `your_module.so`."
msgstr ""

#: src/building-and-distribution.md:88
msgid "on Windows, rename  `libyour_module.dll` to `your_module.pyd`."
msgstr ""

#: src/building-and-distribution.md:89
msgid "on Linux, rename `libyour_module.so` to `your_module.so`."
msgstr ""

#: src/building-and-distribution.md:91
msgid ""
"You can then open a Python shell in the output directory and you'll be able "
"to run `import your_module`."
msgstr ""

#: src/building-and-distribution.md:93
msgid ""
"If you're packaging your library for redistribution, you should indicate the "
"Python interpreter your library is compiled for by including the [platform "
"tag](#platform-tags) in its name. This prevents incompatible interpreters "
"from trying to import your library. If you're compiling for PyPy you _must_ "
"include the platform tag, or PyPy will ignore the module."
msgstr ""

#: src/building-and-distribution.md:95
msgid "Bazel builds"
msgstr ""

#: src/building-and-distribution.md:97
msgid ""
"To use PyO3 with bazel one needs to manually configure PyO3, PyO3-ffi and "
"PyO3-macros. In particular, one needs to make sure that it is compiled with "
"the right python flags for the version you intend to use. For example see:"
msgstr ""

#: src/building-and-distribution.md:100
msgid ""
"[github.com/abrisco/rules_pyo3](https://github.com/abrisco/rules_pyo3) -- "
"General rules for building extension modules."
msgstr ""

#: src/building-and-distribution.md:101
msgid ""
"[github.com/OliverFM/pytorch_with_gazelle](https://github.com/OliverFM/"
"pytorch_with_gazelle) -- for a minimal example of a repo that can use PyO3, "
"PyTorch and Gazelle to generate python Build files."
msgstr ""

#: src/building-and-distribution.md:102
msgid ""
"[github.com/TheButlah/rules_pyo3](https://github.com/TheButlah/rules_pyo3) "
"-- is somewhat dated."
msgstr ""

#: src/building-and-distribution.md:104
msgid "Platform tags"
msgstr ""

#: src/building-and-distribution.md:106
msgid ""
"Rather than using just the `.so` or `.pyd` extension suggested above "
"(depending on OS), you can prefix the shared library extension with a "
"platform tag to indicate the interpreter it is compatible with. You can "
"query your interpreter's platform tag from the `sysconfig` module. Some "
"example outputs of this are seen below:"
msgstr ""

#: src/building-and-distribution.md:109
msgid "# CPython 3.10 on macOS\n"
msgstr ""

#: src/building-and-distribution.md:111
msgid "# PyPy 7.3 (Python 3.9) on Linux\n"
msgstr ""

#: src/building-and-distribution.md:113
msgid "'import sysconfig; print(sysconfig.get_config_var(\"EXT_SUFFIX\"))'"
msgstr ""

#: src/building-and-distribution.md:117
msgid ""
"So, for example, a valid module library name on CPython 3.10 for macOS is "
"`your_module.cpython-310-darwin.so`, and its equivalent when compiled for "
"PyPy 7.3 on Linux would be `your_module.pypy38-pp73-x86_64-linux-gnu.so`."
msgstr ""

#: src/building-and-distribution.md:119
msgid ""
"See [PEP 3149](https://peps.python.org/pep-3149/) for more background on "
"platform tags."
msgstr ""

#: src/building-and-distribution.md:121
msgid "macOS"
msgstr ""

#: src/building-and-distribution.md:123
msgid ""
"On macOS, because the `extension-module` feature disables linking to "
"`libpython` ([see the next section](#the-extension-module-feature)), some "
"additional linker arguments need to be set. `maturin` and `setuptools-rust` "
"both pass these arguments for PyO3 automatically, but projects using manual "
"builds will need to set these directly in order to support macOS."
msgstr ""

#: src/building-and-distribution.md:125
msgid ""
"The easiest way to set the correct linker arguments is to add a [`build.rs`]"
"(https://doc.rust-lang.org/cargo/reference/build-scripts.html) with the "
"following content:"
msgstr ""

#: src/building-and-distribution.md:133
msgid ""
"Remember to also add `pyo3-build-config` to the `build-dependencies` section "
"in `Cargo.toml`."
msgstr ""

#: src/building-and-distribution.md:135
msgid ""
"An alternative to using `pyo3-build-config` is add the following to a cargo "
"configuration file (e.g. `.cargo/config.toml`):"
msgstr ""

#: src/building-and-distribution.md:137
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"\n"
"[target.aarch64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/building-and-distribution.md:151
msgid ""
"Using the MacOS system python3 (`/usr/bin/python3`, as opposed to python "
"installed via homebrew, pyenv, nix, etc.) may result in runtime errors such "
"as `Library not loaded: @rpath/Python3.framework/Versions/3.8/Python3`."
msgstr ""

#: src/building-and-distribution.md:153
msgid ""
"The easiest way to set the correct linker arguments is to add a `build.rs` "
"with the following content:"
msgstr ""

#: src/building-and-distribution.md:161
msgid ""
"Alternatively it can be resolved with another addition to `.cargo/config."
"toml`:"
msgstr ""

#: src/building-and-distribution.md:163
msgid ""
"```toml\n"
"[build]\n"
"rustflags = [\n"
"  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/"
"Frameworks\",\n"
"]\n"
"```"
msgstr ""

#: src/building-and-distribution.md:170
msgid ""
"For more discussion on and workarounds for MacOS linking problems [see this "
"issue](https://github.com/PyO3/pyo3/issues/1800#issuecomment-906786649)."
msgstr ""

#: src/building-and-distribution.md:172
msgid ""
"Finally, don't forget that on MacOS the `extension-module` feature will "
"cause `cargo test` to fail without the `--no-default-features` flag (see "
"[the FAQ](https://pyo3.rs/main/faq.html#i-cant-run-cargo-test-or-i-cant-"
"build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-"
"undefined-reference-to-_pyexc_systemerror))."
msgstr ""

#: src/building-and-distribution.md:174
msgid "The `extension-module` feature"
msgstr ""

#: src/building-and-distribution.md:176
msgid ""
"PyO3's `extension-module` feature is used to disable [linking](https://en."
"wikipedia.org/wiki/Linker_(computing)) to `libpython` on Unix targets."
msgstr ""

#: src/building-and-distribution.md:178
msgid ""
"This is necessary because by default PyO3 links to `libpython`. This makes "
"binaries, tests, and examples \"just work\". However, Python extensions on "
"Unix must not link to libpython for [manylinux](https://www.python.org/dev/"
"peps/pep-0513/) compliance."
msgstr ""

#: src/building-and-distribution.md:180
msgid ""
"The downside of not linking to `libpython` is that binaries, tests, and "
"examples (which usually embed Python) will fail to build. If you have an "
"extension module as well as other outputs in a single project, you need to "
"use optional Cargo features to disable the `extension-module` when you're "
"not building the extension module. See [the FAQ](faq.md#i-cant-run-cargo-"
"test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-"
"symbol-not-found-or-undefined-reference-to-_pyexc_systemerror) for an "
"example workaround."
msgstr ""

#: src/building-and-distribution.md:182
msgid "`Py_LIMITED_API`/`abi3`"
msgstr ""

#: src/building-and-distribution.md:184
msgid ""
"By default, Python extension modules can only be used with the same Python "
"version they were compiled against. For example, an extension module built "
"for Python 3.5 can't be imported in Python 3.8. [PEP 384](https://www.python."
"org/dev/peps/pep-0384/) introduced the idea of the limited Python API, which "
"would have a stable ABI enabling extension modules built with it to be used "
"against multiple Python versions. This is also known as `abi3`."
msgstr ""

#: src/building-and-distribution.md:186
msgid ""
"The advantage of building extension modules using the limited Python API is "
"that package vendors only need to build and distribute a single copy (for "
"each OS / architecture), and users can install it on all Python versions "
"from the [minimum version](#minimum-python-version-for-abi3) and up. The "
"downside of this is that PyO3 can't use optimizations which rely on being "
"compiled against a known exact Python version. It's up to you to decide "
"whether this matters for your extension module. It's also possible to design "
"your extension module such that you can distribute `abi3` wheels but allow "
"users compiling from source to benefit from additional optimizations - see "
"the [support for multiple python versions](./building-and-distribution/"
"multiple-python-versions.md) section of this guide, in particular the "
"`#[cfg(Py_LIMITED_API)]` flag."
msgstr ""

#: src/building-and-distribution.md:188
msgid ""
"There are three steps involved in making use of `abi3` when building Python "
"packages as wheels:"
msgstr ""

#: src/building-and-distribution.md:190
msgid ""
"Enable the `abi3` feature in `pyo3`. This ensures `pyo3` only calls Python C-"
"API functions which are part of the stable API, and on Windows also ensures "
"that the project links against the correct shared object (no special "
"behavior is required on other platforms):"
msgstr ""

#: src/building-and-distribution.md:192
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"abi3\"] }\n"
"```"
msgstr ""

#: src/building-and-distribution.md:197
msgid ""
"Ensure that the built shared objects are correctly marked as `abi3`. This is "
"accomplished by telling your build system that you're using the limited API. "
"[`maturin`](https://github.com/PyO3/maturin) >= 0.9.0 and [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) >= 0.11.4 support `abi3` wheels."
msgstr ""

#: src/building-and-distribution.md:199
msgid ""
"See the [corresponding](https://github.com/PyO3/maturin/pull/353) [PRs]"
"(https://github.com/PyO3/setuptools-rust/pull/82) for more."
msgstr ""

#: src/building-and-distribution.md:201
msgid ""
"Ensure that the `.whl` is correctly marked as `abi3`. For projects using "
"`setuptools`, this is accomplished by passing `--py-limited-api=cp3x` (where "
"`x` is the minimum Python version supported by the wheel, e.g. `--py-limited-"
"api=cp35` for Python 3.5) to `setup.py bdist_wheel`."
msgstr ""

#: src/building-and-distribution.md:203
msgid "Minimum Python version for `abi3`"
msgstr ""

#: src/building-and-distribution.md:205
msgid ""
"Because a single `abi3` wheel can be used with many different Python "
"versions, PyO3 has feature flags `abi3-py37`, `abi3-py38`, `abi3-py39` etc. "
"to set the minimum required Python version for your `abi3` wheel. For "
"example, if you set the `abi3-py37` feature, your extension wheel can be "
"used on all Python 3 versions from Python 3.7 and up. `maturin` and "
"`setuptools-rust` will give the wheel a name like `my-extension-1.0-cp37-"
"abi3-manylinux2020_x86_64.whl`."
msgstr ""

#: src/building-and-distribution.md:208
msgid ""
"As your extension module may be run with multiple different Python versions "
"you may occasionally find you need to check the Python version at runtime to "
"customize behavior. See [the relevant section of this guide](./building-and-"
"distribution/multiple-python-versions.md#checking-the-python-version-at-"
"runtime) on supporting multiple Python versions at runtime."
msgstr ""

#: src/building-and-distribution.md:210
msgid ""
"PyO3 is only able to link your extension module to abi3 version up to and "
"including your host Python version. E.g., if you set `abi3-py38` and try to "
"compile the crate with a host of Python 3.7, the build will fail."
msgstr ""

#: src/building-and-distribution.md:212
msgid ""
"Note: If you set more that one of these `abi3` version feature flags the "
"lowest version always wins. For example, with both `abi3-py37` and `abi3-"
"py38` set, PyO3 would build a wheel which supports Python 3.7 and up."
msgstr ""

#: src/building-and-distribution.md:214
msgid "Building `abi3` extensions without a Python interpreter"
msgstr ""

#: src/building-and-distribution.md:216
msgid ""
"As an advanced feature, you can build PyO3 wheel without calling Python "
"interpreter with the environment variable `PYO3_NO_PYTHON` set. Also, if the "
"build host Python interpreter is not found or is too old or otherwise "
"unusable, PyO3 will still attempt to compile `abi3` extension modules after "
"displaying a warning message. On Unix-like systems this works "
"unconditionally; on Windows you must also set the `RUSTFLAGS` environment "
"variable to contain `-L native=/path/to/python/libs` so that the linker can "
"find `python3.lib`."
msgstr ""

#: src/building-and-distribution.md:222
msgid ""
"If the `python3.dll` import library is not available, an experimental "
"`generate-import-lib` crate feature may be enabled, and the required library "
"will be created and used by PyO3 automatically."
msgstr ""

#: src/building-and-distribution.md:225
msgid ""
"_Note_: MSVC targets require LLVM binutils (`llvm-dlltool`) to be available "
"in `PATH` for the automatic import library generation feature to work."
msgstr ""

#: src/building-and-distribution.md:228
msgid "Missing features"
msgstr ""

#: src/building-and-distribution.md:230
msgid ""
"Due to limitations in the Python API, there are a few `pyo3` features that "
"do not work when compiling for `abi3`. These are:"
msgstr ""

#: src/building-and-distribution.md:233
msgid ""
"`#[pyo3(text_signature = \"...\")]` does not work on classes until Python "
"3.10 or greater."
msgstr ""

#: src/building-and-distribution.md:234
msgid ""
"The `dict` and `weakref` options on classes are not supported until Python "
"3.9 or greater."
msgstr ""

#: src/building-and-distribution.md:235
msgid "The buffer API is not supported until Python 3.11 or greater."
msgstr ""

#: src/building-and-distribution.md:236
msgid ""
"Optimizations which rely on knowledge of the exact Python version compiled "
"against."
msgstr ""

#: src/building-and-distribution.md:238
msgid "Embedding Python in Rust"
msgstr ""

#: src/building-and-distribution.md:240
msgid ""
"If you want to embed the Python interpreter inside a Rust program, there are "
"two modes in which this can be done: dynamically and statically. We'll cover "
"each of these modes in the following sections. Each of them affect how you "
"must distribute your program. Instead of learning how to do this yourself, "
"you might want to consider using a project like [PyOxidizer](https://github."
"com/indygreg/PyOxidizer) to ship your application and all of its "
"dependencies in a single file."
msgstr ""

#: src/building-and-distribution.md:242
msgid ""
"PyO3 automatically switches between the two linking modes depending on "
"whether the Python distribution you have configured PyO3 to use ([see above]"
"(#configuring-the-python-version)) contains a shared library or a static "
"library. The static library is most often seen in Python distributions "
"compiled from source without the `--enable-shared` configuration option."
msgstr ""

#: src/building-and-distribution.md:244
msgid "Dynamically embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:246
msgid ""
"Embedding the Python interpreter dynamically is much easier than doing so "
"statically. This is done by linking your program against a Python shared "
"library (such as `libpython.3.9.so` on UNIX, or `python39.dll` on Windows). "
"The implementation of the Python interpreter resides inside the shared "
"library. This means that when the OS runs your Rust program it also needs to "
"be able to find the Python shared library."
msgstr ""

#: src/building-and-distribution.md:248
msgid ""
"This mode of embedding works well for Rust tests which need access to the "
"Python interpreter. It is also great for Rust software which is installed "
"inside a Python virtualenv, because the virtualenv sets up appropriate "
"environment variables to locate the correct Python shared library."
msgstr ""

#: src/building-and-distribution.md:250
msgid ""
"For distributing your program to non-technical users, you will have to "
"consider including the Python shared library in your distribution as well as "
"setting up wrapper scripts to set the right environment variables (such as "
"`LD_LIBRARY_PATH` on UNIX, or `PATH` on Windows)."
msgstr ""

#: src/building-and-distribution.md:252
msgid ""
"Note that PyPy cannot be embedded in Rust (or any other software). Support "
"for this is tracked on the [PyPy issue tracker](https://github.com/pypy/pypy/"
"issues/3836)."
msgstr ""

#: src/building-and-distribution.md:254
msgid "Statically embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:256
msgid ""
"Embedding the Python interpreter statically means including the contents of "
"a Python static library directly inside your Rust binary. This means that to "
"distribute your program you only need to ship your binary file: it contains "
"the Python interpreter inside the binary!"
msgstr ""

#: src/building-and-distribution.md:258
msgid ""
"On Windows static linking is almost never done, so Python distributions "
"don't usually include a static library. The information below applies only "
"to UNIX."
msgstr ""

#: src/building-and-distribution.md:260
msgid "The Python static library is usually called `libpython.a`."
msgstr ""

#: src/building-and-distribution.md:262
msgid ""
"Static linking has a lot of complications, listed below. For these reasons "
"PyO3 does not yet have first-class support for this embedding mode. See "
"[issue 416 on PyO3's GitHub](https://github.com/PyO3/pyo3/issues/416) for "
"more information and to discuss any issues you encounter."
msgstr ""

#: src/building-and-distribution.md:264
msgid ""
"The [`auto-initialize`](features.md#auto-initialize) feature is deliberately "
"disabled when embedding the interpreter statically because this is often "
"unintentionally done by new users to PyO3 running test programs. Trying out "
"PyO3 is much easier using dynamic embedding."
msgstr ""

#: src/building-and-distribution.md:266
msgid "The known complications are:"
msgstr ""

#: src/building-and-distribution.md:268
msgid ""
"To import compiled extension modules (such as other Rust extension modules, "
"or those written in C), your binary must have the correct linker flags set "
"during compilation to export the original contents of `libpython.a` so that "
"extensions can use them (e.g. `-Wl,--export-dynamic`)."
msgstr ""

#: src/building-and-distribution.md:269
msgid ""
"The C compiler and flags which were used to create `libpython.a` must be "
"compatible with your Rust compiler and flags, else you will experience "
"compilation failures."
msgstr ""

#: src/building-and-distribution.md:271
msgid "Significantly different compiler versions may see errors like this:"
msgstr ""

#: src/building-and-distribution.md:277
msgid "Mismatching flags may lead to errors like this:"
msgstr ""

#: src/building-and-distribution.md:283
msgid ""
"If you encounter these or other complications when linking the interpreter "
"statically, discuss them on [issue 416 on PyO3's GitHub](https://github.com/"
"PyO3/pyo3/issues/416). It is hoped that eventually that discussion will "
"contain enough information and solutions that PyO3 can offer first-class "
"support for static embedding."
msgstr ""

#: src/building-and-distribution.md:285
msgid "Import your module when embedding the Python interpreter"
msgstr ""

#: src/building-and-distribution.md:287
msgid ""
"When you run your Rust binary with an embedded interpreter, any "
"`#[pymodule]` created modules won't be accessible to import unless added to "
"a table called `PyImport_Inittab` before the embedded interpreter is "
"initialized. This will cause Python statements in your embedded interpreter "
"such as `import your_new_module` to fail. You can call the macro "
"[`append_to_inittab`](https://pyo3.rs/main/doc/pyo3/macro.append_to_inittab."
"html) with your module before initializing the Python interpreter to add the "
"module function into that table. (The Python interpreter will be initialized "
"by calling `Python::initialize`, `with_embedded_python_interpreter`, or "
"`Python::attach` with the [`auto-initialize`](features.md#auto-initialize) "
"feature enabled.)"
msgstr ""

#: src/building-and-distribution.md:289
msgid "Cross Compiling"
msgstr ""

#: src/building-and-distribution.md:291
msgid ""
"Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 "
"is relatively straightforward. To get started, you'll need a few pieces of "
"software:"
msgstr ""

#: src/building-and-distribution.md:293
msgid "A toolchain for your target."
msgstr ""

#: src/building-and-distribution.md:294
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building-and-distribution.md:295
msgid ""
"A Python interpreter that's already been compiled for your target (optional "
"when building \"abi3\" extension modules)."
msgstr ""

#: src/building-and-distribution.md:296
msgid ""
"A Python interpreter that is built for your host and available through the "
"`PATH` or setting the [`PYO3_PYTHON`](#configuring-the-python-version) "
"variable (optional when building \"abi3\" extension modules)."
msgstr ""

#: src/building-and-distribution.md:298
msgid ""
"After you've obtained the above, you can build a cross-compiled PyO3 module "
"by using Cargo's `--target` flag. PyO3's build script will detect that you "
"are attempting a cross-compile based on your host machine and the desired "
"target."
msgstr ""

#: src/building-and-distribution.md:300
msgid ""
"When cross-compiling, PyO3's build script cannot execute the target Python "
"interpreter to query the configuration, so there are a few additional "
"environment variables you may need to set:"
msgstr ""

#: src/building-and-distribution.md:302
msgid ""
"`PYO3_CROSS`: If present this variable forces PyO3 to configure as a cross-"
"compilation."
msgstr ""

#: src/building-and-distribution.md:303
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable can be set to the directory containing "
"the target's libpython DSO and the associated `_sysconfigdata*.py` file for "
"Unix-like targets, or the Python DLL import libraries for the Windows "
"target. This variable is only needed when the output binary must link to "
"libpython explicitly (e.g. when targeting Windows and Android or embedding a "
"Python interpreter), or when it is absolutely required to get the "
"interpreter configuration from `_sysconfigdata*.py`."
msgstr ""

#: src/building-and-distribution.md:304
msgid ""
"`PYO3_CROSS_PYTHON_VERSION`: Major and minor version (e.g. 3.9) of the "
"target Python installation. This variable is only needed if PyO3 cannot "
"determine the version to target from `abi3-py3*` features, or if "
"`PYO3_CROSS_LIB_DIR` is not set, or if there are multiple versions of Python "
"present in `PYO3_CROSS_LIB_DIR`."
msgstr ""

#: src/building-and-distribution.md:305
msgid ""
"`PYO3_CROSS_PYTHON_IMPLEMENTATION`: Python implementation name (\"CPython\" "
"or \"PyPy\") of the target Python installation. CPython is assumed by "
"default when this variable is not set, unless `PYO3_CROSS_LIB_DIR` is set "
"for a Unix-like target and PyO3 can get the interpreter configuration from "
"`_sysconfigdata*.py`."
msgstr ""

#: src/building-and-distribution.md:307
msgid ""
"An experimental `pyo3` crate feature `generate-import-lib` enables the user "
"to cross-compile extension modules for Windows targets without setting the "
"`PYO3_CROSS_LIB_DIR` environment variable or providing any Windows Python "
"library files. It uses an external [`python3-dll-a`](https://docs.rs/python3-"
"dll-a/latest/python3_dll_a/) crate to generate import libraries for the "
"Python DLL for MinGW-w64 and MSVC compile targets. `python3-dll-a` uses the "
"binutils `dlltool` program to generate DLL import libraries for MinGW-w64 "
"targets. It is possible to override the default `dlltool` command name for "
"the cross target by setting `PYO3_MINGW_DLLTOOL` environment variable. "
"_Note_: MSVC targets require LLVM binutils or MSVC build tools to be "
"available on the host system. More specifically, `python3-dll-a` requires "
"`llvm-dlltool` or `lib.exe` executable to be present in `PATH` when "
"targeting `*-pc-windows-msvc`. The Zig compiler executable can be used in "
"place of `llvm-dlltool` when the `ZIG_COMMAND` environment variable is set "
"to the installed Zig program name (`\"zig\"` or `\"python -m ziglang\"`)."
msgstr ""

#: src/building-and-distribution.md:319
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building-and-distribution.md:322 src/building-and-distribution.md:331
#: src/building-and-distribution.md:340
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/building-and-distribution.md:327
msgid ""
"If there are multiple python versions at the cross lib directory and you "
"cannot set a more precise location to include both the `libpython` DSO and "
"`_sysconfigdata*.py` files, you can set the required version:"
msgstr ""

#: src/building-and-distribution.md:330
msgid "3.8"
msgstr ""

#: src/building-and-distribution.md:336
msgid "Or another example with the same sys root but building for Windows:"
msgstr ""

#: src/building-and-distribution.md:339
msgid "3.9"
msgstr ""

#: src/building-and-distribution.md:345
msgid ""
"Any of the `abi3-py3*` features can be enabled instead of setting "
"`PYO3_CROSS_PYTHON_VERSION` in the above examples."
msgstr ""

#: src/building-and-distribution.md:347
msgid ""
"`PYO3_CROSS_LIB_DIR` can often be omitted when cross compiling extension "
"modules for Unix and macOS targets, or when cross compiling extension "
"modules for Windows and the experimental `generate-import-lib` crate feature "
"is enabled."
msgstr ""

#: src/building-and-distribution.md:351
msgid "The following resources may also be useful for cross-compiling:"
msgstr ""

#: src/building-and-distribution.md:353
msgid ""
"[github.com/japaric/rust-cross](https://github.com/japaric/rust-cross) is a "
"primer on cross compiling Rust."
msgstr ""

#: src/building-and-distribution.md:354
msgid ""
"[github.com/rust-embedded/cross](https://github.com/rust-embedded/cross) "
"uses Docker to make Rust cross-compilation easier."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:1
msgid "Supporting multiple Python versions"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:3
msgid ""
"PyO3 supports all actively-supported Python 3 and PyPy versions. As much as "
"possible, this is done internally to PyO3 so that your crate's code does not "
"need to adapt to the differences between each version. However, as Python "
"features grow and change between versions, PyO3 cannot offer a completely "
"identical API for every Python version. This may require you to add "
"conditional compilation to your crate or runtime checks for the Python "
"version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:5
msgid ""
"This section of the guide first introduces the `pyo3-build-config` crate, "
"which you can use as a `build-dependency` to add additional `#[cfg]` flags "
"which allow you to support multiple Python versions at compile-time."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:7
msgid ""
"Second, we'll show how to check the Python version at runtime. This can be "
"useful when building for multiple versions with the `abi3` feature, where "
"the Python API compiled against is not always the same as the one in use."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:9
msgid "Conditional compilation for different Python versions"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:11
msgid ""
"The `pyo3-build-config` exposes multiple [`#[cfg]` flags](https://doc.rust-"
"lang.org/rust-by-example/attribute/cfg.html) which can be used to "
"conditionally compile code for a given Python version. PyO3 itself depends "
"on this crate, so by using it you can be sure that you are configured "
"correctly for the Python version PyO3 is building against."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:13
msgid "This allows us to write code like the following"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:26
msgid ""
"The following sections first show how to add these `#[cfg]` flags to your "
"build process, and then cover some common patterns flags in a little more "
"detail."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:28
msgid ""
"To see a full reference of all the `#[cfg]` flags provided, see the [`pyo3-"
"build-cfg` docs](https://docs.rs/pyo3-build-config)."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:30
msgid "Using `pyo3-build-config`"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:32
msgid "You can use the `#[cfg]` flags in just two steps:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:34
msgid ""
"Add `pyo3-build-config` with the [`resolve-config`](../features.md#resolve-"
"config) feature enabled to your crate's build dependencies in `Cargo.toml`:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:36
msgid ""
"```toml\n"
"[build-dependencies]\n"
"pyo3-build-config = { git = \"https://github.com/pyo3/pyo3\", features = "
"[\"resolve-config\"] }\n"
"```"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:41
msgid ""
"Add a [`build.rs`](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html) file to your crate with the following contents:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:45
msgid "// If you have an existing build.rs file, just add this line to it.\n"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:50
msgid "After these steps you are ready to annotate your code!"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:52
msgid "Common usages of `pyo3-build-cfg` flags"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:54
msgid ""
"The `#[cfg]` flags added by `pyo3-build-cfg` can be combined with all of "
"Rust's logic in the `#[cfg]` attribute to create very precise conditional "
"code generation. The following are some common patterns implemented using "
"these flags:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:60
msgid ""
"This `#[cfg]` marks code that will only be present on Python 3.7 and "
"upwards. There are similar options `Py_3_8`, `Py_3_9`, `Py_3_10` and so on "
"for each minor version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:66
msgid ""
"This `#[cfg]` marks code that will only be present on Python versions before "
"(but not including) Python 3.7."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:72
msgid ""
"This `#[cfg]` marks code that is only available when building for the "
"unlimited Python API (i.e. PyO3's `abi3` feature is not enabled). This might "
"be useful if you want to ship your extension module as an `abi3` wheel and "
"also allow users to compile it from source to make use of optimizations only "
"possible with the unlimited API."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:78
msgid ""
"This `#[cfg]` marks code which is available when running Python 3.9 or "
"newer, or when using the unlimited API with an older Python version. "
"Patterns like this are commonly seen on Python APIs which were added to the "
"limited Python API in a specific minor version."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:84
msgid "This `#[cfg]` marks code which is running on PyPy."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:86
msgid "Checking the Python version at runtime"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:88
msgid ""
"When building with PyO3's `abi3` feature, your extension module will be "
"compiled against a specific [minimum version](../building-and-distribution."
"md#minimum-python-version-for-abi3) of Python, but may be running on newer "
"Python versions."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:90
msgid ""
"For example with PyO3's `abi3-py38` feature, your extension will be compiled "
"as if it were for Python 3.8. If you were using `pyo3-build-config`, "
"`#[cfg(Py_3_8)]` would be present. Your user could freely install and run "
"your abi3 extension on Python 3.9."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:92
msgid ""
"There's no way to detect your user doing that at compile time, so instead "
"you need to fall back to runtime checks."
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:94
msgid ""
"PyO3 provides the APIs [`Python::version()`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.version) and [`Python::version_info()`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method."
"version_info) to query the running Python version. This allows you to do the "
"following, for example:"
msgstr ""

#: src/building-and-distribution/multiple-python-versions.md:100
msgid "// PyO3 supports Python 3.7 and up.\n"
msgstr ""

#: src/python-from-rust.md:1
msgid "Calling Python in Rust code"
msgstr ""

#: src/python-from-rust.md:3
msgid ""
"This chapter of the guide documents some ways to interact with Python code "
"from Rust."
msgstr ""

#: src/python-from-rust.md:5
msgid ""
"Below is an introduction to the `'py` lifetime and some general remarks "
"about how PyO3's API reasons about Python code."
msgstr ""

#: src/python-from-rust.md:7
msgid "The subchapters also cover the following topics:"
msgstr ""

#: src/python-from-rust.md:9
msgid "Python object types available in PyO3's API"
msgstr ""

#: src/python-from-rust.md:10
msgid "How to work with Python exceptions"
msgstr ""

#: src/python-from-rust.md:11
msgid "How to call Python functions"
msgstr ""

#: src/python-from-rust.md:12
msgid "How to execute existing Python code"
msgstr ""

#: src/python-from-rust.md:14
msgid "The `'py` lifetime"
msgstr ""

#: src/python-from-rust.md:16
msgid ""
"To safely interact with the Python interpreter a Rust thread must be "
"[attached](https://docs.python.org/3.14/glossary.html#term-attached-thread-"
"state) to the Python interpreter. PyO3 has a `Python<'py>` token that is "
"used to prove that these conditions are met. Its lifetime `'py` is a central "
"part of PyO3's API."
msgstr ""

#: src/python-from-rust.md:20
msgid "The `Python<'py>` token serves three purposes:"
msgstr ""

#: src/python-from-rust.md:22
msgid ""
"It provides global APIs for the Python interpreter, such as [`py.eval()`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.eval) and "
"[`py.import()`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.import)."
msgstr ""

#: src/python-from-rust.md:23
msgid ""
"It can be passed to functions that require a proof of attachment, such as "
"[`Py::clone_ref`](https://pyo3.rs/main/doc/pyo3/prelude/struct.Py."
"html#method.clone_ref)."
msgstr ""

#: src/python-from-rust.md:24
msgid ""
"Its lifetime `'py` is used to bind many of PyO3's types to the Python "
"interpreter, such as [`Bound<'py, T>`](https://pyo3.rs/main/doc/pyo3/struct."
"Bound.html)."
msgstr ""

#: src/python-from-rust.md:26
msgid ""
"PyO3's types that are bound to the `'py` lifetime, for example `Bound<'py, "
"T>`, all contain a `Python<'py>` token. This means they have full access to "
"the Python interpreter and offer a complete API for interacting with Python "
"objects."
msgstr ""

#: src/python-from-rust.md:28
msgid ""
"Consult [PyO3's API documentation](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#obtaining-a-python-token) to learn how to acquire one of "
"these tokens."
msgstr ""

#: src/python-from-rust.md:30
msgid "The Global Interpreter Lock"
msgstr ""

#: src/python-from-rust.md:32
msgid ""
"Prior to the introduction of free-threaded Python (first available in 3.13, "
"fully supported in 3.14), the Python interpreter was made thread-safe by the "
"[global interpreter lock](https://docs.python.org/3/c-api/init.html#thread-"
"state-and-the-global-interpreter-lock). This ensured that only one Python "
"thread can use the Python interpreter and its API at the same time. "
"Historically, Rust code was able to use the GIL as a synchronization "
"guarantee, but the introduction of free-threaded Python removed this "
"possibility."
msgstr ""

#: src/python-from-rust.md:36
msgid ""
"The [`pyo3::sync`](https://pyo3.rs/main/doc/pyo3/sync/index.html) module "
"offers synchronization tools which abstract over both Python builds."
msgstr ""

#: src/python-from-rust.md:38
msgid ""
"To enable any parallelism on the GIL-enabled build, and best throughput on "
"the free-threaded build, non-Python operations (system calls and native Rust "
"code) should consider detaching from the Python interpreter to allow other "
"work to proceed. See [the section on parallelism](parallelism.md) for how to "
"do that using PyO3's API."
msgstr ""

#: src/python-from-rust.md:40
msgid "Python's memory model"
msgstr ""

#: src/python-from-rust.md:42
msgid "Python's memory model differs from Rust's memory model in two key ways:"
msgstr ""

#: src/python-from-rust.md:44
msgid ""
"There is no concept of ownership; all Python objects are shared and usually "
"implemented via reference counting"
msgstr ""

#: src/python-from-rust.md:45
msgid ""
"There is no concept of exclusive (`&mut`) references; any reference can "
"mutate a Python object"
msgstr ""

#: src/python-from-rust.md:47
msgid ""
"PyO3's API reflects this by providing [smart pointer](https://doc.rust-lang."
"org/book/ch15-00-smart-pointers.html) types, `Py<T>`, `Bound<'py, T>`, and "
"(the very rarely used) `Borrowed<'a, 'py, T>`. These smart pointers all use "
"Python reference counting. See the [subchapter on types](./types.md) for "
"more detail on these types."
msgstr ""

#: src/python-from-rust.md:49
msgid ""
"Because of the lack of exclusive `&mut` references, PyO3's APIs for Python "
"objects, for example [`PyListMethods::append`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyListMethods.html#tymethod.append), use shared references. This "
"is safe because Python objects have internal mechanisms to prevent data "
"races (as of time of writing, the Python GIL)."
msgstr ""

#: src/python-from-rust/function-calls.md:1
msgid "Calling Python functions"
msgstr ""

#: src/python-from-rust/function-calls.md:3
msgid ""
"The `Bound<'py, T>` smart pointer (such as `Bound<'py, PyAny>`, `Bound<'py, "
"PyList>`, or `Bound<'py, MyClass>`) can be used to call Python functions."
msgstr ""

#: src/python-from-rust/function-calls.md:5
msgid "PyO3 offers two APIs to make function calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:7
msgid ""
"[`call`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call) - call any callable Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:8
msgid ""
"[`call_method`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call_method) - call a method on the Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:10
msgid ""
"Both of these APIs take `args` and `kwargs` arguments (for positional and "
"keyword arguments respectively). There are variants for less complex calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:12
msgid ""
"[`call1`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call1) and [`call_method1`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method1) to call only with "
"positional `args`."
msgstr ""

#: src/python-from-rust/function-calls.md:13
msgid ""
"[`call0`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call0) and [`call_method0`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method0) to call with no "
"arguments."
msgstr ""

#: src/python-from-rust/function-calls.md:15
msgid ""
"For convenience the [`Py<T>`](../types.md#pyt) smart pointer also exposes "
"these same six API methods, but needs a `Python` token as an additional "
"first argument to prove the thread is attached to the Python interpreter."
msgstr ""

#: src/python-from-rust/function-calls.md:17
msgid ""
"The example below calls a Python function behind a `Py<PyAny>` reference:"
msgstr ""

#: src/python-from-rust/function-calls.md:25
msgid "\"arg1\""
msgstr ""

#: src/python-from-rust/function-calls.md:26
msgid "\"arg2\""
msgstr ""

#: src/python-from-rust/function-calls.md:27
msgid "\"arg3\""
msgstr ""

#: src/python-from-rust/function-calls.md:32
#: src/python-from-rust/function-calls.md:79
msgid ""
"\"def example(*args, **kwargs):\n"
"                if args != ():\n"
"                    print('called with args', args)\n"
"                if kwargs != {}:\n"
"                    print('called with kwargs', kwargs)\n"
"                if args == () and kwargs == {}:\n"
"                    print('called with no arguments')\""
msgstr ""

#: src/python-from-rust/function-calls.md:39
#: src/python-from-rust/function-calls.md:86
msgid "\"example.py\""
msgstr ""

#: src/python-from-rust/function-calls.md:40
#: src/python-from-rust/function-calls.md:87
msgid "\"\""
msgstr ""

#: src/python-from-rust/function-calls.md:42
#: src/python-from-rust/function-calls.md:89
msgid "\"example\""
msgstr ""

#: src/python-from-rust/function-calls.md:45
msgid "// call object without any arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:48
msgid "// pass object with Rust tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:52
msgid "// call object with Python tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:60
msgid "Creating keyword arguments"
msgstr ""

#: src/python-from-rust/function-calls.md:62
msgid ""
"For the `call` and `call_method` APIs, `kwargs` are `Option<&Bound<'py, "
"PyDict>>`, so can either be `None` or `Some(&dict)`. You can use the "
"[`IntoPyDict`](https://pyo3.rs/main/doc/pyo3/types/trait.IntoPyDict.html) "
"trait to convert other dict-like containers, e.g. `HashMap` or `BTreeMap`, "
"as well as tuples with up to 10 elements and `Vec`s where each element is a "
"two-element tuple. To pass keyword arguments of different types, construct a "
"`PyDict` object."
msgstr ""

#: src/python-from-rust/function-calls.md:71
msgid "\"key1\""
msgstr ""

#: src/python-from-rust/function-calls.md:73
msgid "\"key2\""
msgstr ""

#: src/python-from-rust/function-calls.md:92
msgid "// call object with PyDict\n"
msgstr ""

#: src/python-from-rust/function-calls.md:96
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/python-from-rust/function-calls.md:100
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/python-from-rust/function-calls.md:105
msgid "// pass arguments of different types as PyDict\n"
msgstr ""

#: src/python-from-rust/function-calls.md:108
msgid "\"string\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:1
msgid "Executing existing Python code"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:3
msgid ""
"If you already have some existing Python code that you need to execute from "
"Rust, the following FAQs can help you select the right PyO3 functionality "
"for your situation:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:5
msgid "Want to access Python APIs? Then use `PyModule::import`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:7
msgid ""
"[`PyModule::import`](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.import) can be used to get handle to a Python module from Rust. "
"You can use this to import and use any Python module available in your "
"environment."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:15
msgid "\"builtins\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:17
msgid "\"sum\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:28
msgid "Want to run just an expression? Then use `eval`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:30
msgid ""
"[`Python::eval`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.eval) is a method to execute a [Python expression](https://docs."
"python.org/3/reference/expressions.html) and return the evaluated value as a "
"`Bound<'py, PyAny>` object."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:41
msgid "\"[i * 10 for i in range(5)]\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:52
msgid "Want to run statements? Then use `run`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:54
msgid ""
"[`Python::run`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.run) is a method to execute one or more [Python statements]"
"(https://docs.python.org/3/reference/simple_stmts.html). This method returns "
"nothing (like any Python statement), but you can get access to manipulated "
"objects via the `locals` dict."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:59
msgid ""
"You can also use the [`py_run!`](https://pyo3.rs/main/doc/pyo3/macro.py_run."
"html) macro, which is a shorthand for [`Python::run`](https://pyo3.rs/main/"
"doc/pyo3/marker/struct.Python.html#method.run). Since [`py_run!`](https://"
"pyo3.rs/main/doc/pyo3/macro.py_run.html) panics on exceptions, we recommend "
"you use this macro only for quickly testing your Python extensions."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:81
msgid "\"User {}(id: {})\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:88
#: src/python-from-rust/calling-existing-code.md:91
msgid "\"Yu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:92
msgid ""
"r#\"\n"
"assert repr(userdata) == \"User Yu(id: 34)\"\n"
"assert userdata.as_tuple() == userdata_as_tuple\n"
"    \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:100
msgid "You have a Python file or code snippet? Then use `PyModule::from_code`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:102
msgid ""
"[`PyModule::from_code`](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.from_code) can be used to generate a Python module which can "
"then be used just as if it was imported with `PyModule::import`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:106
msgid ""
"**Warning**: This will compile and execute code. **Never** pass untrusted "
"code to this function!"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:117
msgid ""
"r#\"\n"
"def relu(x):\n"
"    \"\"\"see https://en.wikipedia.org/wiki/"
"Rectifier_(neural_networks)\"\"\"\n"
"    return max(0.0, x)\n"
"\n"
"def leaky_relu(x, slope=0.01):\n"
"    return x if x >= 0 else x * slope\n"
"    \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:125
msgid "\"activators.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:126
msgid "\"activators\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:129
msgid "\"relu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:132
msgid "\"slope\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:134
msgid "\"leaky_relu\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:143
msgid "Want to embed Python in Rust with additional modules?"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:145
msgid ""
"Python maintains the `sys.modules` dict as a cache of all imported modules. "
"An import in Python will first attempt to lookup the module from this dict, "
"and if not present will use various strategies to attempt to locate and load "
"the module."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:150
msgid ""
"The [`append_to_inittab`](https://pyo3.rs/main/doc/pyo3/macro."
"append_to_inittab.html) macro can be used to add additional `#[pymodule]` "
"modules to an embedded Python interpreter. The macro **must** be invoked "
"_before_ initializing Python."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:154
msgid ""
"As an example, the below adds the module `foo` to the embedded interpreter:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:172
#: src/python-from-rust/calling-existing-code.md:204
msgid "\"import foo; foo.add_one(6)\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:176
msgid ""
"If `append_to_inittab` cannot be used due to constraints in the program, an "
"alternative is to create a module using [`PyModule::new`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PyModule.html#method.new) and insert it manually "
"into `sys.modules`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:192
msgid "// Create new module\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:193
#: src/python-from-rust/calling-existing-code.md:201
msgid "\"foo\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:196
msgid "// Import and get sys.modules\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:197
#: src/python-from-rust/calling-existing-code.md:308
msgid "\"sys\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:198
msgid "\"modules\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:200
msgid "// Insert foo into sys.modules\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:203
msgid "// Now we can import + run our python code\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:209
msgid "Include multiple Python files"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:211
msgid ""
"You can include a file at compile time by using [`std::include_str`](https://"
"doc.rust-lang.org/std/macro.include_str.html) macro."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:214
msgid ""
"Or you can load a file at runtime by using [`std::fs::read_to_string`]"
"(https://doc.rust-lang.org/std/fs/fn.read_to_string.html) function."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:217
msgid ""
"Many Python files can be included and loaded as modules. If one file depends "
"on another you must preserve correct order while declaring `PyModule`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:220
msgid "Example directory structure:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:234
msgid "`python_app/app.py`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:244
msgid "`python_app/utils/foo.py`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:248
msgid "\"baz\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:251
#: src/python-from-rust/calling-existing-code.md:282
msgid "The example below shows:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:253
msgid ""
"how to include content of `app.py` and `utils/foo.py` into your rust binary"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:254
#: src/python-from-rust/calling-existing-code.md:286
msgid ""
"how to call function `run()` (declared in `app.py`) that needs function "
"imported from `utils/foo.py`"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:257
#: src/python-from-rust/calling-existing-code.md:293
msgid "`src/main.rs`:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:265
#: src/python-from-rust/calling-existing-code.md:268
msgid "\"CARGO_MANIFEST_DIR\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:266
msgid "\"/python_app/utils/foo.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:268
msgid "\"/python_app/app.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:270
msgid "\"foo.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:270
msgid "\"utils.foo\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:271
#: src/python-from-rust/calling-existing-code.md:305
#: src/python-from-rust/calling-existing-code.md:312
msgid "\"app.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:272
#: src/python-from-rust/calling-existing-code.md:313
msgid "\"run\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:277
#: src/python-from-rust/calling-existing-code.md:318
msgid "\"py: {}\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:284
msgid ""
"how to load content of `app.py` at runtime so that it sees its dependencies "
"automatically"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:289
msgid ""
"It is recommended to use absolute paths because then your binary can be run "
"from anywhere as long as your `app.py` is in the expected directory (in this "
"example that directory is `/usr/share/python_app`)."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:304
msgid "\"/usr/share/python_app\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:309
msgid "\"path\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:323
msgid "Need to use a context manager from Rust?"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:325
msgid "Use context managers by directly invoking `__enter__` and `__exit__`."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:335
msgid ""
"r#\"\n"
"class House(object):\n"
"    def __init__(self, address):\n"
"        self.address = address\n"
"    def __enter__(self):\n"
"        print(f\"Welcome to {self.address}!\")\n"
"    def __exit__(self, type, value, traceback):\n"
"        if type:\n"
"            print(f\"Sorry you had {type} trouble at {self.address}\")\n"
"        else:\n"
"            print(f\"Thank you for visiting {self.address}, come again soon!"
"\")\n"
"\n"
"        \"#"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:348
msgid "\"house.py\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:349
msgid "\"house\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:353
msgid "\"House\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:354
msgid "\"123 Main Street\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:356
msgid "\"__enter__\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:358
msgid "\"undefined_variable + 1\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:360
msgid ""
"// If the eval threw an exception we'll pass it through to the context "
"manager.\n"
"        // Otherwise, __exit__  is called with empty arguments (Python "
"\"None\").\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:366
#: src/python-from-rust/calling-existing-code.md:372
msgid "\"__exit__\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:386
msgid "Handling system signals/interrupts (Ctrl-C)"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:388
msgid ""
"The best way to handle system signals when running Rust code is to "
"periodically call `Python::check_signals` to handle any signals captured by "
"Python's signal handler. See also [the FAQ entry](../faq.md#ctrl-c-doesnt-do-"
"anything-while-my-rust-code-is-executing)."
msgstr ""

#: src/python-from-rust/calling-existing-code.md:390
msgid ""
"Alternatively, set Python's `signal` module to take the default action for a "
"signal:"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:397
#: src/python-from-rust/calling-existing-code.md:400
msgid "\"signal\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:398
msgid "// Set SIGINT to have the default action\n"
msgstr ""

#: src/python-from-rust/calling-existing-code.md:401
msgid "\"SIGINT\""
msgstr ""

#: src/python-from-rust/calling-existing-code.md:401
msgid "\"SIG_DFL\""
msgstr ""

#: src/exception.md:1
msgid "Python exceptions"
msgstr ""

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"Use the [`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"create_exception.html) macro:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr ""

#: src/exception.md:28 src/exception.md:162
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:32
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:34
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:40
msgid ""
"When using PyO3 to create an extension module, you can add the new exception "
"to the module like this, so that it is importable from Python:"
msgstr ""

#: src/exception.md:55
msgid "// ... other elements added to module ...\n"
msgstr ""

#: src/exception.md:59
msgid "Raising an exception"
msgstr ""

#: src/exception.md:61
msgid ""
"As described in the [function error handling](./function/error-handling.md) "
"chapter, to raise an exception from a `#[pyfunction]` or `#[pymethods]`, "
"return an `Err(PyErr)`. PyO3 will automatically raise this exception for you "
"when returning the result to Python."
msgstr ""

#: src/exception.md:63
msgid ""
"You can also manually write and fetch errors in the Python interpreter's "
"global state:"
msgstr ""

#: src/exception.md:70
msgid "\"Error\""
msgstr ""

#: src/exception.md:76
msgid "Checking exception types"
msgstr ""

#: src/exception.md:78
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type. In PyO3 every object has "
"the [`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/types/trait."
"PyAnyMethods.html#tymethod.is_instance) and [`PyAny::is_instance_of`]"
"(https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods.html#tymethod."
"is_instance_of) methods which do the same thing."
msgstr ""

#: src/exception.md:96
msgid "To check the type of an exception, you can similarly do:"
msgstr ""

#: src/exception.md:107
msgid "Using exceptions defined in Python code"
msgstr ""

#: src/exception.md:109
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The [`import_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"import_exception.html) macro allows importing a specific exception class and "
"defines a Rust type for that exception."
msgstr ""

#: src/exception.md:122
msgid "\"tell\""
msgstr ""

#: src/exception.md:123
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:129
msgid ""
"[`pyo3::exceptions`](https://pyo3.rs/main/doc/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""

#: src/exception.md:132
msgid "Creating more complex exceptions"
msgstr ""

#: src/exception.md:134
msgid ""
"If you need to create an exception with more complex behavior, you can also "
"manually create a subclass of `PyException`:"
msgstr ""

#: src/exception.md:138
msgid "\"abi3\""
msgstr ""

#: src/exception.md:166
msgid ""
"\"assert str(CustomError) == \\\"<class 'builtins.CustomError'>\\\", "
"repr(CustomError)\""
msgstr ""

#: src/exception.md:168
msgid ""
"\"assert CustomError('https://example.com', 'something went bad').args == "
"('https://example.com', 'something went bad')\""
msgstr ""

#: src/exception.md:169
msgid ""
"\"assert CustomError('https://example.com', 'something went bad').url == "
"'https://example.com'\""
msgstr ""

#: src/exception.md:177
msgid ""
"Note that this is not possible when the `abi3` feature is enabled, as that "
"prevents subclassing `PyException`."
msgstr ""

#: src/types.md:1
msgid "Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"PyO3 offers two main sets of types to interact with Python objects. This "
"section of the guide expands into detail about these types and how to choose "
"which to use."
msgstr ""

#: src/types.md:5
msgid ""
"The first set of types are the [smart pointers](https://doc.rust-lang.org/"
"book/ch15-00-smart-pointers.html) which all Python objects are wrapped in. "
"These are `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`. The [first "
"section below](#pyo3s-smart-pointers) expands on each of these in detail and "
"why there are three of them."
msgstr ""

#: src/types.md:7
msgid ""
"The second set of types are types which fill in the generic parameter `T` of "
"the smart pointers. The most common is `PyAny`, which represents any Python "
"object (similar to Python's `typing.Any`). There are also concrete types for "
"many Python built-in types, such as `PyList`, `PyDict`, and `PyTuple`. User "
"defined `#[pyclass]` types also fit this category. The [second section below]"
"(#concrete-python-types) expands on how to use these types."
msgstr ""

#: src/types.md:9
msgid "PyO3's smart pointers"
msgstr ""

#: src/types.md:11
msgid ""
"PyO3's API offers three generic smart pointers: `Py<T>`, `Bound<'py, T>` and "
"`Borrowed<'a, 'py, T>`. For each of these the type parameter `T` will be "
"filled by a [concrete Python type](#concrete-python-types). For example, a "
"Python list object can be represented by `Py<PyList>`, `Bound<'py, PyList>`, "
"and `Borrowed<'a, 'py, PyList>`."
msgstr ""

#: src/types.md:13
msgid ""
"These smart pointers behave differently due to their lifetime parameters. "
"`Py<T>` has no lifetime parameters, `Bound<'py, T>` has [the `'py` lifetime]"
"(./python-from-rust.md#the-py-lifetime) as a parameter, and `Borrowed<'a, "
"'py, T>` has the `'py` lifetime plus an additional lifetime `'a` to denote "
"the lifetime it is borrowing data for. (You can read more about these "
"lifetimes in the subsections below)."
msgstr ""

#: src/types.md:15
msgid ""
"Python objects are reference counted, like [`std::sync::Arc`](https://doc."
"rust-lang.org/stable/std/sync/struct.Arc.html). A major reason for these "
"smart pointers is to bring Python's reference counting to a Rust API."
msgstr ""

#: src/types.md:17
msgid ""
"The recommendation of when to use each of these smart pointers is as follows:"
msgstr ""

#: src/types.md:19
msgid ""
"Use `Bound<'py, T>` for as much as possible, as it offers the most efficient "
"and complete API."
msgstr ""

#: src/types.md:20
msgid ""
"Use `Py<T>` mostly just for storage inside Rust `struct`s which do not want "
"to or can't add a lifetime parameter for `Bound<'py, T>`."
msgstr ""

#: src/types.md:21
msgid ""
"`Borrowed<'a, 'py, T>` is almost never used. It is occasionally present at "
"the boundary between Rust and the Python interpreter, for example when "
"borrowing data from Python tuples (which is safe because they are immutable)."
msgstr ""

#: src/types.md:23
msgid ""
"The sections below also explain these smart pointers in a little more detail."
msgstr ""

#: src/types.md:25
msgid "`Py<T>`"
msgstr ""

#: src/types.md:27
msgid ""
"[`Py<T>`](https://pyo3.rs/main/doc/pyo3/struct.Py.html) is the foundational "
"smart pointer in PyO3's API. The type parameter `T` denotes the type of the "
"Python object. Very frequently this is `PyAny`, meaning any Python object."
msgstr ""

#: src/types.md:29
msgid ""
"Because `Py<T>` is not bound to [the `'py` lifetime](./python-from-rust."
"md#the-py-lifetime), it is the type to use when storing a Python object "
"inside a Rust `struct` or `enum` which do not want to have a lifetime "
"parameter. In particular, [`#[pyclass]`](class.md) types are not permitted "
"to have a lifetime, so `Py<T>` is the correct type to store Python objects "
"inside them."
msgstr ""

#: src/types.md:31
msgid "The lack of binding to the `'py` lifetime also carries drawbacks:"
msgstr ""

#: src/types.md:33
msgid ""
"Almost all methods on `Py<T>` require a `Python<'py>` token as the first "
"argument"
msgstr ""

#: src/types.md:34
msgid ""
"Other functionality, such as [`Drop`](https://doc.rust-lang.org/std/ops/"
"trait.Drop.html), needs to check at runtime for attachment to the Python "
"interpreter, at a small performance cost"
msgstr ""

#: src/types.md:36
msgid ""
"Because of the drawbacks `Bound<'py, T>` is preferred for many of PyO3's "
"APIs. In particular, `Bound<'py, T>` is better for function arguments."
msgstr ""

#: src/types.md:38
msgid ""
"To convert a `Py<T>` into a `Bound<'py, T>`, the `Py::bind` and `Py::"
"into_bound` methods are available. `Bound<'py, T>` can be converted back "
"into `Py<T>` using [`Bound::unbind`](https://pyo3.rs/main/doc/pyo3/struct."
"Bound.html#method.unbind)."
msgstr ""

#: src/types.md:40
msgid "`Bound<'py, T>`"
msgstr ""

#: src/types.md:42
msgid ""
"[`Bound<'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html) is the "
"counterpart to `Py<T>` which is also bound to the `'py` lifetime. It can be "
"thought of as equivalent to the Rust tuple `(Python<'py>, Py<T>)`."
msgstr ""

#: src/types.md:44
msgid ""
"By having the binding to the `'py` lifetime, `Bound<'py, T>` can offer the "
"complete PyO3 API at maximum efficiency. This means that `Bound<'py, T>` "
"should usually be used whenever carrying this lifetime is acceptable, and "
"`Py<T>` otherwise."
msgstr ""

#: src/types.md:46
msgid ""
"`Bound<'py, T>` engages in Python reference counting. This means that "
"`Bound<'py, T>` owns a Python object. Rust code which just wants to borrow a "
"Python object should use a shared reference `&Bound<'py, T>`. Just like "
"`std::sync::Arc`, using `.clone()` and `drop()` will cheaply increment and "
"decrement the reference count of the object (just in this case, the "
"reference counting is implemented by the Python interpreter itself)."
msgstr ""

#: src/types.md:48
msgid ""
"To give an example of how `Bound<'py, T>` is PyO3's primary API type, "
"consider the following Python code:"
msgstr ""

#: src/types.md:52
msgid "# create a Python list\n"
msgstr ""

#: src/types.md:53
msgid "# append the integer 1 to it\n"
msgstr ""

#: src/types.md:54
msgid "# create a second reference to the list\n"
msgstr ""

#: src/types.md:55
msgid "# delete the original reference\n"
msgstr ""

#: src/types.md:58
msgid ""
"Using PyO3's API, and in particular `Bound<'py, PyList>`, this code "
"translates into the following Rust code:"
msgstr ""

#: src/types.md:67
msgid "// y is a new reference to the same list\n"
msgstr ""

#: src/types.md:68
msgid "// release the original reference x\n"
msgstr ""

#: src/types.md:74
msgid "Or, without the type annotations:"
msgstr ""

#: src/types.md:90
msgid "Function argument lifetimes"
msgstr ""

#: src/types.md:92
msgid ""
"Because the `'py` lifetime often appears in many function arguments as part "
"of the `Bound<'py, T>` smart pointer, the Rust compiler will often require "
"annotations of input and output lifetimes. This occurs when the function "
"output has at least one lifetime, and there is more than one lifetime "
"present on the inputs."
msgstr ""

#: src/types.md:94
msgid ""
"To demonstrate, consider this function which takes accepts Python objects "
"and applies the [Python `+` operation](https://pyo3.rs/main/doc/pyo3/types/"
"trait.PyAnyMethods.html#tymethod.add) to them:"
msgstr ""

#: src/types.md:103
msgid ""
"Because the Python `+` operation might raise an exception, this function "
"returns `PyResult<Bound<'_, PyAny>>`. It doesn't need ownership of the "
"inputs, so it takes `&Bound<'_, PyAny>` shared references. To demonstrate "
"the point, all lifetimes have used the wildcard `'_` to allow the Rust "
"compiler to attempt to infer them. Because there are four input lifetimes "
"(two lifetimes of the shared references, and two `'py` lifetimes unnamed "
"inside the `Bound<'_, PyAny>` pointers), the compiler cannot reason about "
"which must be connected to the output."
msgstr ""

#: src/types.md:105
msgid ""
"The correct way to solve this is to add the `'py` lifetime as a parameter "
"for the function, and name all the `'py` lifetimes inside the `Bound<'py, "
"PyAny>` smart pointers. For the shared references, it's also fine to reduce "
"`&'_` to just `&`. The working end result is below:"
msgstr ""

#: src/types.md:116 src/types.md:130
msgid "\"s\""
msgstr ""

#: src/types.md:117 src/types.md:131
msgid "\"ss\""
msgstr ""

#: src/types.md:121
msgid ""
"If naming the `'py` lifetime adds unwanted complexity to the function "
"signature, it is also acceptable to return `Py<PyAny>`, which has no "
"lifetime. The cost is instead paid by a slight increase in implementation "
"complexity, as seen by the introduction of a call to [`Bound::unbind`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Bound.html#method.unbind):"
msgstr ""

#: src/types.md:135
msgid "`Borrowed<'a, 'py, T>`"
msgstr ""

#: src/types.md:137
msgid ""
"[`Borrowed<'a, 'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Borrowed.html) "
"is an advanced type used just occasionally at the edge of interaction with "
"the Python interpreter. It can be thought of as analogous to the shared "
"reference `&'a Bound<'py, T>`. The difference is that `Borrowed<'a, 'py, T>` "
"is just a smart pointer rather than a reference-to-a-smart-pointer, which is "
"a helpful reduction in indirection in specific interactions with the Python "
"interpreter."
msgstr ""

#: src/types.md:139
msgid ""
"`Borrowed<'a, 'py, T>` dereferences to `Bound<'py, T>`, so all methods on "
"`Bound<'py, T>` are available on `Borrowed<'a, 'py, T>`."
msgstr ""

#: src/types.md:141
msgid ""
"An example where `Borrowed<'a, 'py, T>` is used is in [`PyTupleMethods::"
"get_borrowed_item`](https://pyo3.rs/main/doc/pyo3/types/trait.PyTupleMethods."
"html#tymethod.get_item):"
msgstr ""

#: src/types.md:147
msgid "// Create a new tuple with the elements (0, 1, 2)\n"
msgstr ""

#: src/types.md:152
msgid ""
"// `PyAnyMethods::extract` is available on `Borrowed`\n"
"    // via the dereference to `Bound`\n"
msgstr ""

#: src/types.md:162
msgid "Casting between smart pointer types"
msgstr ""

#: src/types.md:164
msgid ""
"To convert between `Py<T>` and `Bound<'py, T>` use the `bind()` / "
"`into_bound()` methods. Use the `as_unbound()` / `unbind()` methods to go "
"back from `Bound<'py, T>` to `Py<T>`."
msgstr ""

#: src/types.md:175
msgid ""
"To convert between `Bound<'py, T>` and `Borrowed<'a, 'py, T>` use the "
"`as_borrowed()` method. `Borrowed<'a, 'py, T>` has a deref coercion to "
"`Bound<'py, T>`. Use the `to_owned()` method to increment the Python "
"reference count and to create a new `Bound<'py, T>` from the `Borrowed<'a, "
"'py, T>`."
msgstr ""

#: src/types.md:180
msgid "// deref coercion\n"
msgstr ""

#: src/types.md:183
msgid "// create a new Bound by increase the Python reference count\n"
msgstr ""

#: src/types.md:188
msgid ""
"To convert between `Py<T>` and `Borrowed<'a, 'py, T>` use the "
"`bind_borrowed()` method. Use either `as_unbound()` or `.to_owned()."
"unbind()` to go back to `Py<T>` from `Borrowed<'a, 'py, T>`, via `Bound<'py, "
"T>`."
msgstr ""

#: src/types.md:193
msgid "// via deref coercion to Bound and then using Bound::as_unbound\n"
msgstr ""

#: src/types.md:196
msgid ""
"// via a new Bound by increasing the Python reference count, and unbind it\n"
msgstr ""

#: src/types.md:201
msgid "Concrete Python types"
msgstr ""

#: src/types.md:203
msgid ""
"In all of `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`, the type "
"parameter `T` denotes the type of the Python object referred to by the smart "
"pointer."
msgstr ""

#: src/types.md:205
msgid "This parameter `T` can be filled by:"
msgstr ""

#: src/types.md:207
msgid ""
"[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html), which "
"represents any Python object,"
msgstr ""

#: src/types.md:208
msgid "Native Python types such as `PyList`, `PyTuple`, and `PyDict`, and"
msgstr ""

#: src/types.md:209
msgid "[`#[pyclass]`](class.md) types defined from Rust"
msgstr ""

#: src/types.md:211
msgid ""
"The following subsections covers some further detail about how to work with "
"these types:"
msgstr ""

#: src/types.md:213
msgid "the APIs that are available for these concrete types,"
msgstr ""

#: src/types.md:214
msgid "how to cast `Bound<'py, T>` to a specific concrete type, and"
msgstr ""

#: src/types.md:215
msgid "how to get Rust data out of a `Bound<'py, T>`."
msgstr ""

#: src/types.md:217
msgid "Using APIs for concrete Python types"
msgstr ""

#: src/types.md:219
msgid ""
"Each concrete Python type such as `PyAny`, `PyTuple` and `PyDict` exposes "
"its API on the corresponding bound smart pointer `Bound<'py, PyAny>`, "
"`Bound<'py, PyTuple>` and `Bound<'py, PyDict>`."
msgstr ""

#: src/types.md:221
msgid ""
"Each type's API is exposed as a trait: [`PyAnyMethods`](https://pyo3.rs/main/"
"doc/pyo3/types/trait.PyAnyMethods.html), [`PyTupleMethods`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyTupleMethods.html), [`PyDictMethods`](https://"
"pyo3.rs/main/doc/pyo3/types/trait.PyDictMethods.html), and so on for all "
"concrete types. Using traits rather than associated methods on the `Bound` "
"smart pointer is done for a couple of reasons:"
msgstr ""

#: src/types.md:223
msgid ""
"Clarity of documentation: each trait gets its own documentation page in the "
"PyO3 API docs. If all methods were on the `Bound` smart pointer directly, "
"the vast majority of PyO3's API would be on a single, extremely long, "
"documentation page."
msgstr ""

#: src/types.md:224
msgid ""
"Consistency: downstream code implementing Rust APIs for existing Python "
"types can also follow this pattern of using a trait. Downstream code would "
"not be allowed to add new associated methods directly on the `Bound` type."
msgstr ""

#: src/types.md:225
msgid ""
"Future design: it is hoped that a future Rust with [arbitrary self types]"
"(https://github.com/rust-lang/rust/issues/44874) will remove the need for "
"these traits in favour of placing the methods directly on `PyAny`, "
"`PyTuple`, `PyDict`, and so on."
msgstr ""

#: src/types.md:227
msgid ""
"These traits are all included in the `pyo3::prelude` module, so with the "
"glob import `use pyo3::prelude::*` the full PyO3 API is made available to "
"downstream code."
msgstr ""

#: src/types.md:229
msgid ""
"The following function accesses the first item in the input Python list, "
"using the `.get_item()` method from the `PyListMethods` trait:"
msgstr ""

#: src/types.md:239 src/types.md:240
msgid "\"hello world\""
msgstr ""

#: src/types.md:244
msgid "Casting between Python object types"
msgstr ""

#: src/types.md:246
msgid ""
"To cast `Bound<'py, T>` smart pointers to some other type, use the [`."
"cast()`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html#method.cast) family "
"of functions. This converts `&Bound<'py, T>` to a different `&Bound<'py, "
"U>`, without transferring ownership. There is also [`.cast_into()`](https://"
"pyo3.rs/main/doc/pyo3/struct.Bound.html#method.cast_into) to convert "
"`Bound<'py, T>` to `Bound<'py, U>` with transfer of ownership. These methods "
"are available for all types `T` which implement the [`PyTypeCheck`](https://"
"pyo3.rs/main/doc/pyo3/type_object/trait.PyTypeCheck.html) trait."
msgstr ""

#: src/types.md:248
msgid ""
"Casting to `Bound<'py, PyAny>` can be done with `.as_any()` or `.into_any()`."
msgstr ""

#: src/types.md:250
msgid ""
"For example, the following snippet shows how to cast `Bound<'py, PyAny>` to "
"`Bound<'py, PyTuple>`:"
msgstr ""

#: src/types.md:255 src/types.md:277 src/types.md:300
msgid ""
"// create a new Python `tuple`, and use `.into_any()` to erase the type\n"
msgstr ""

#: src/types.md:258
msgid "// use `.cast()` to cast to `PyTuple` without transferring ownership\n"
msgstr ""

#: src/types.md:261
msgid "// use `.cast_into()` to cast to `PyTuple` with transfer of ownership\n"
msgstr ""

#: src/types.md:269
msgid ""
"Custom [`#[pyclass]`](class.md) types implement [`PyTypeCheck`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeCheck.html), so `.cast()` also "
"works for these types. The snippet below is the same as the snippet above "
"casting instead to a custom type `MyClass`:"
msgstr ""

#: src/types.md:280
msgid "// use `.cast()` to cast to `MyClass` without transferring ownership\n"
msgstr ""

#: src/types.md:283
msgid "// use `.cast_into()` to cast to `MyClass` with transfer of ownership\n"
msgstr ""

#: src/types.md:291
msgid "Extracting Rust data from Python objects"
msgstr ""

#: src/types.md:293
msgid ""
"To extract Rust data from Python objects, use [`.extract()`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyAnyMethods.html#tymethod.extract) instead of `."
"cast()`. This method is available for all types which implement the "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) trait."
msgstr ""

#: src/types.md:295
msgid ""
"For example, the following snippet extracts a Rust tuple of integers from a "
"Python tuple:"
msgstr ""

#: src/types.md:303
msgid "// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple\n"
msgstr ""

#: src/types.md:312
msgid ""
"To avoid copying data, [`#[pyclass]`](class.md) types can directly reference "
"Rust data stored within the Python objects without needing to `.extract()`. "
"See the [corresponding documentation in the class section of the guide](./"
"class.md#bound-and-interior-mutability) for more detail."
msgstr ""

#: src/changelog.md:1
msgid "Changelog"
msgstr ""

#: src/changelog.md:3
msgid ""
"All notable changes to this project will be documented in this file. For "
"help with updating to new PyO3 versions, please see the [migration guide]"
"(https://pyo3.rs/latest/migration.html)."
msgstr ""

#: src/changelog.md:6
msgid ""
"The format is based on [Keep a Changelog](https://keepachangelog.com/"
"en/1.0.0/) and this project adheres to [Semantic Versioning](https://semver."
"org/spec/v2.0.0.html)."
msgstr ""

#: src/changelog.md:9
msgid ""
"To see unreleased changes, please see the [CHANGELOG on the main branch "
"guide](https://pyo3.rs/main/changelog.html)."
msgstr ""

#: src/changelog.md:13
msgid "\\[0.27.2\\] - 2025-11-30"
msgstr ""

#: src/changelog.md:15 src/changelog.md:65 src/changelog.md:138
#: src/changelog.md:191 src/changelog.md:229 src/changelog.md:311
#: src/changelog.md:354 src/changelog.md:441 src/changelog.md:513
#: src/changelog.md:538 src/changelog.md:567 src/changelog.md:625
#: src/changelog.md:657 src/changelog.md:677 src/changelog.md:722
#: src/changelog.md:825 src/changelog.md:879 src/changelog.md:938
#: src/changelog.md:993 src/changelog.md:1016 src/changelog.md:1053
#: src/changelog.md:1153 src/changelog.md:1217 src/changelog.md:1232
#: src/changelog.md:1249 src/changelog.md:1278 src/changelog.md:1342
#: src/changelog.md:1416 src/changelog.md:1454 src/changelog.md:1496
#: src/changelog.md:1524 src/changelog.md:1578 src/changelog.md:1659
#: src/changelog.md:1731 src/changelog.md:1812 src/changelog.md:1867
#: src/changelog.md:1882 src/changelog.md:1931 src/changelog.md:1992
#: src/changelog.md:2086 src/changelog.md:2112 src/changelog.md:2155
#: src/changelog.md:2218 src/changelog.md:2250 src/changelog.md:2264
#: src/changelog.md:2276 src/changelog.md:2293 src/changelog.md:2343
#: src/changelog.md:2357 src/changelog.md:2379
msgid "Changed"
msgstr ""

#: src/changelog.md:17
msgid ""
"Disable subclassing `PyDict` on GraalPy (unsupported for now, may crash at "
"runtime). [\\#5653](https://github.com/PyO3/pyo3/pull/5653)"
msgstr ""

#: src/changelog.md:19 src/changelog.md:26 src/changelog.md:94
#: src/changelog.md:167 src/changelog.md:196 src/changelog.md:254
#: src/changelog.md:263 src/changelog.md:279 src/changelog.md:330
#: src/changelog.md:342 src/changelog.md:359 src/changelog.md:381
#: src/changelog.md:393 src/changelog.md:488 src/changelog.md:502
#: src/changelog.md:517 src/changelog.md:548 src/changelog.md:572
#: src/changelog.md:584 src/changelog.md:644 src/changelog.md:661
#: src/changelog.md:682 src/changelog.md:749 src/changelog.md:767
#: src/changelog.md:778 src/changelog.md:795 src/changelog.md:851
#: src/changelog.md:886 src/changelog.md:915 src/changelog.md:954
#: src/changelog.md:972 src/changelog.md:1000 src/changelog.md:1021
#: src/changelog.md:1075 src/changelog.md:1098 src/changelog.md:1114
#: src/changelog.md:1122 src/changelog.md:1187 src/changelog.md:1236
#: src/changelog.md:1255 src/changelog.md:1285 src/changelog.md:1305
#: src/changelog.md:1387 src/changelog.md:1420 src/changelog.md:1472
#: src/changelog.md:1490 src/changelog.md:1506 src/changelog.md:1529
#: src/changelog.md:1545 src/changelog.md:1625 src/changelog.md:1664
#: src/changelog.md:1698 src/changelog.md:1752 src/changelog.md:1764
#: src/changelog.md:1770 src/changelog.md:1781 src/changelog.md:1789
#: src/changelog.md:1847 src/changelog.md:1904 src/changelog.md:1913
#: src/changelog.md:1948 src/changelog.md:1965 src/changelog.md:1971
#: src/changelog.md:2013 src/changelog.md:2043 src/changelog.md:2054
#: src/changelog.md:2070 src/changelog.md:2098 src/changelog.md:2118
#: src/changelog.md:2185 src/changelog.md:2193 src/changelog.md:2199
#: src/changelog.md:2240 src/changelog.md:2254 src/changelog.md:2282
#: src/changelog.md:2305 src/changelog.md:2311 src/changelog.md:2321
#: src/changelog.md:2336 src/changelog.md:2347 src/changelog.md:2363
msgid "Fixed"
msgstr ""

#: src/changelog.md:21
msgid ""
"Fix crash when compiling on Rust 1.92+ with both debug assertions and "
"optimizations enabled. [\\#5638](https://github.com/PyO3/pyo3/pull/5638)"
msgstr ""

#: src/changelog.md:22
msgid ""
"Fix FFI definition of `PyDictObject` on PyPy. [\\#5653](https://github.com/"
"PyO3/pyo3/pull/5653)"
msgstr ""

#: src/changelog.md:24
msgid ""
"[0.27.1](https://github.com/pyo3/pyo3/compare/v0.27.0...v0.27.1) - 2025-10-21"
msgstr ""

#: src/changelog.md:28
msgid ""
"Fix `clippy:declare_interior_mutable_const` warning from `#[pyfunction]`. "
"[\\#5538](https://github.com/PyO3/pyo3/pull/5538)"
msgstr ""

#: src/changelog.md:29
msgid ""
"Expose `pyo3::types::PySendResult` in public API. [\\#5539](https://github."
"com/PyO3/pyo3/pull/5539)"
msgstr ""

#: src/changelog.md:31
msgid ""
"[0.27.0](https://github.com/pyo3/pyo3/compare/v0.26.0...v0.27.0) - 2025-10-19"
msgstr ""

#: src/changelog.md:33 src/changelog.md:106 src/changelog.md:181
#: src/changelog.md:204 src/changelog.md:289 src/changelog.md:338
#: src/changelog.md:377 src/changelog.md:405 src/changelog.md:563
#: src/changelog.md:594 src/changelog.md:762 src/changelog.md:774
#: src/changelog.md:803 src/changelog.md:899 src/changelog.md:924
#: src/changelog.md:982 src/changelog.md:1032 src/changelog.md:1090
#: src/changelog.md:1106 src/changelog.md:1130 src/changelog.md:1263
#: src/changelog.md:1294 src/changelog.md:1301 src/changelog.md:1312
#: src/changelog.md:1405 src/changelog.md:1430 src/changelog.md:1551
#: src/changelog.md:1647 src/changelog.md:1708
msgid "Packaging"
msgstr ""

#: src/changelog.md:35
msgid ""
"Extend range of supported versions of `hashbrown` optional dependency to "
"include version 0.16. [\\#5428](https://github.com/PyO3/pyo3/pull/5428)"
msgstr ""

#: src/changelog.md:36
msgid ""
"Bump optional `num-bigint` dependency minimum version to 0.4.4. [\\#5471]"
"(https://github.com/PyO3/pyo3/pull/5471)"
msgstr ""

#: src/changelog.md:37
msgid ""
"Test against Python 3.14 final release. [\\#5499](https://github.com/PyO3/"
"pyo3/pull/5499)"
msgstr ""

#: src/changelog.md:38
msgid ""
"Drop support for PyPy 3.9 and 3.10. [\\#5516](https://github.com/PyO3/pyo3/"
"pull/5516)"
msgstr ""

#: src/changelog.md:39
msgid ""
"Provide a better error message when building an outdated PyO3 for a too-new "
"Python version. [\\#5519](https://github.com/PyO3/pyo3/pull/5519)"
msgstr ""

#: src/changelog.md:41 src/changelog.md:115 src/changelog.md:186
#: src/changelog.md:213 src/changelog.md:271 src/changelog.md:297
#: src/changelog.md:349 src/changelog.md:389 src/changelog.md:416
#: src/changelog.md:509 src/changelog.md:529 src/changelog.md:579
#: src/changelog.md:602 src/changelog.md:671 src/changelog.md:693
#: src/changelog.md:785 src/changelog.md:813 src/changelog.md:869
#: src/changelog.md:905 src/changelog.md:928 src/changelog.md:966
#: src/changelog.md:986 src/changelog.md:1010 src/changelog.md:1038
#: src/changelog.md:1094 src/changelog.md:1110 src/changelog.md:1134
#: src/changelog.md:1227 src/changelog.md:1243 src/changelog.md:1267
#: src/changelog.md:1323 src/changelog.md:1411 src/changelog.md:1438
#: src/changelog.md:1485 src/changelog.md:1502 src/changelog.md:1518
#: src/changelog.md:1541 src/changelog.md:1558 src/changelog.md:1651
#: src/changelog.md:1676 src/changelog.md:1716 src/changelog.md:1776
#: src/changelog.md:1796 src/changelog.md:1863 src/changelog.md:1873
#: src/changelog.md:1919 src/changelog.md:1961 src/changelog.md:1978
#: src/changelog.md:2026 src/changelog.md:2033 src/changelog.md:2050
#: src/changelog.md:2066 src/changelog.md:2078 src/changelog.md:2104
#: src/changelog.md:2147 src/changelog.md:2209 src/changelog.md:2288
#: src/changelog.md:2317 src/changelog.md:2330 src/changelog.md:2369
#: src/changelog.md:2386
msgid "Added"
msgstr ""

#: src/changelog.md:43
msgid ""
"Add `FromPyObjectOwned` as convenient trait bound for `FromPyObject` when "
"the data is not borrowed from Python. [\\#4390](https://github.com/PyO3/pyo3/"
"pull/4390)"
msgstr ""

#: src/changelog.md:44
msgid ""
"Add `Borrowed::extract`, same as `PyAnyMethods::extract`, but does not "
"restrict the lifetime by deref. [\\#4390](https://github.com/PyO3/pyo3/"
"pull/4390)"
msgstr ""

#: src/changelog.md:45
msgid ""
"`experimental-inspect`: basic support for `#[derive(IntoPyObject)]` (no "
"struct fields support yet). [\\#5365](https://github.com/PyO3/pyo3/pull/5365)"
msgstr ""

#: src/changelog.md:46
msgid ""
"`experimental-inspect`: support `#[pyo3(get, set)]` and `#[pyclass(get_all, "
"set_all)]`. [\\#5370](https://github.com/PyO3/pyo3/pull/5370)"
msgstr ""

#: src/changelog.md:47
msgid ""
"Add `PyTypeCheck::classinfo_object` that returns an object that can be used "
"as parameter in `isinstance` or `issubclass`. [\\#5387](https://github.com/"
"PyO3/pyo3/pull/5387)"
msgstr ""

#: src/changelog.md:48
msgid ""
"Implement `PyTypeInfo` on `datetime.*` types even when the limited API is "
"enabled. [\\#5388](https://github.com/PyO3/pyo3/pull/5388)"
msgstr ""

#: src/changelog.md:49
msgid ""
"Implement `PyTypeInfo` on `PyIterator`, `PyMapping` and `PySequence`. "
"[\\#5402](https://github.com/PyO3/pyo3/pull/5402)"
msgstr ""

#: src/changelog.md:50
msgid ""
"Implement `PyTypeInfo` on `PyCode` when using the stable ABI. [\\#5403]"
"(https://github.com/PyO3/pyo3/pull/5403)"
msgstr ""

#: src/changelog.md:51
msgid ""
"Implement `PyTypeInfo` on `PyWeakrefReference` when using the stable ABI. "
"[\\#5404](https://github.com/PyO3/pyo3/pull/5404)"
msgstr ""

#: src/changelog.md:52
msgid ""
"Add `pyo3::sync::RwLockExt` trait, analogous to `pyo3::sync::MutexExt` for "
"readwrite locks. [\\#5435](https://github.com/PyO3/pyo3/pull/5435)"
msgstr ""

#: src/changelog.md:53
msgid ""
"Add `PyString::from_bytes`. [\\#5437](https://github.com/PyO3/pyo3/pull/5437)"
msgstr ""

#: src/changelog.md:54
msgid ""
"Implement `AsRef<[u8]>` for `PyBytes`. [\\#5445](https://github.com/PyO3/"
"pyo3/pull/5445)"
msgstr ""

#: src/changelog.md:55
msgid ""
"Add `CastError` and `CastIntoError`. [\\#5468](https://github.com/PyO3/pyo3/"
"pull/5468)"
msgstr ""

#: src/changelog.md:56
msgid ""
"Add `PyCapsuleMethods::pointer_checked` and `PyCapsuleMethods::"
"is_valid_checked`. [\\#5474](https://github.com/PyO3/pyo3/pull/5474)"
msgstr ""

#: src/changelog.md:57
msgid ""
"Add `Borrowed::cast`, `Borrowed::cast_exact` and `Borrowed::cast_unchecked`. "
"[\\#5475](https://github.com/PyO3/pyo3/pull/5475)"
msgstr ""

#: src/changelog.md:58
msgid ""
"Add conversions for `jiff::civil::ISOWeekDate`. [\\#5478](https://github.com/"
"PyO3/pyo3/pull/5478)"
msgstr ""

#: src/changelog.md:59
msgid ""
"Add conversions for `&Cstr`, `Cstring` and `Cow<Cstr>`. [\\#5482](https://"
"github.com/PyO3/pyo3/pull/5482)"
msgstr ""

#: src/changelog.md:60
msgid ""
"add `#[pyclass(skip_from_py_object)]` option, to opt-out of the "
"`FromPyObject: PyClass + Clone` blanket impl. [\\#5488](https://github.com/"
"PyO3/pyo3/pull/5488)"
msgstr ""

#: src/changelog.md:61
msgid ""
"Add `PyErr::add_note`. [\\#5489](https://github.com/PyO3/pyo3/pull/5489)"
msgstr ""

#: src/changelog.md:62
msgid ""
"Add `FromPyObject` impl for `Cow<Path>` & `Cow<OsStr>`. [\\#5497](https://"
"github.com/PyO3/pyo3/pull/5497)"
msgstr ""

#: src/changelog.md:63
msgid ""
"Add `#[pyclass(from_py_object)]` pyclass option, to opt-in to the extraction "
"of pyclasses by value (requires `Clone`). [\\#5506](https://github.com/PyO3/"
"pyo3/pull/5506)"
msgstr ""

#: src/changelog.md:67
msgid ""
"Rework `FromPyObject` trait for flexibility and performance: [\\#4390]"
"(https://github.com/PyO3/pyo3/pull/4390)"
msgstr ""

#: src/changelog.md:68
msgid ""
"Add a second lifetime to `FromPyObject`, to allow borrowing data from Python "
"objects (e.g. `&str` from Python `str`)."
msgstr ""

#: src/changelog.md:69
msgid ""
"Replace `extract_bound` with `extract`, which takes `Borrowed<'a, 'py, "
"PyAny>`."
msgstr ""

#: src/changelog.md:70
msgid ""
"Optimize `FromPyObject` implementations for `Vec<u8>` and `[u8; N]` from "
"`bytes` and `bytearray`. [\\#5244](https://github.com/PyO3/pyo3/pull/5244)"
msgstr ""

#: src/changelog.md:71
msgid ""
"Deprecate `#[pyfn]` attribute. [\\#5384](https://github.com/PyO3/pyo3/"
"pull/5384)"
msgstr ""

#: src/changelog.md:72
msgid ""
"Fetch type name dynamically on cast errors instead of using `PyTypeCheck::"
"NAME`. [\\#5387](https://github.com/PyO3/pyo3/pull/5387)"
msgstr ""

#: src/changelog.md:73
msgid ""
"Deprecate `PyTypeCheck::NAME` in favour of `PyTypeCheck::classinfo_object` "
"which provides the type information at runtime. [\\#5387](https://github.com/"
"PyO3/pyo3/pull/5387)"
msgstr ""

#: src/changelog.md:74
msgid ""
"`PyClassGuard(Mut)` and `PyRef(Mut)` extraction now returns an opaque Rust "
"error [\\#5413](https://github.com/PyO3/pyo3/pull/5413)"
msgstr ""

#: src/changelog.md:75
msgid ""
"Fetch type name dynamically when exporting types implementing `PyTypeInfo` "
"with `#[pymodule_use]`. [\\#5414](https://github.com/PyO3/pyo3/pull/5414)"
msgstr ""

#: src/changelog.md:76
msgid ""
"Improve `Debug` representation of `PyBuffer<T>`. [\\#5442](https://github."
"com/PyO3/pyo3/pull/5442)"
msgstr ""

#: src/changelog.md:77
msgid ""
"`experimental-inspect`: change the way introspection data is emitted in the "
"binaries to avoid a pointer indirection and simplify parsing. [\\#5450]"
"(https://github.com/PyO3/pyo3/pull/5450)"
msgstr ""

#: src/changelog.md:78
msgid ""
"Optimize `Py<T>::drop` for the case when attached to the Python interpreter. "
"[\\#5454](https://github.com/PyO3/pyo3/pull/5454)"
msgstr ""

#: src/changelog.md:79
msgid ""
"Replace `DowncastError` and `DowncastIntoError` with `CastError` and "
"`CastIntoError`. [\\#5468](https://github.com/PyO3/pyo3/pull/5468)"
msgstr ""

#: src/changelog.md:80
msgid ""
"Enable fast-path for 128-bit integer conversions on `GraalPy`. [\\#5471]"
"(https://github.com/PyO3/pyo3/pull/5471)"
msgstr ""

#: src/changelog.md:81
msgid ""
"Deprecate `PyAnyMethods::downcast` functions in favour of `Bound::cast` "
"functions. [\\#5472](https://github.com/PyO3/pyo3/pull/5472)"
msgstr ""

#: src/changelog.md:82
msgid ""
"Make `PyTypeCheck` an `unsafe trait`. [\\#5473](https://github.com/PyO3/pyo3/"
"pull/5473)"
msgstr ""

#: src/changelog.md:83
msgid ""
"Deprecate unchecked `PyCapsuleMethods`: `pointer()`, `reference()`, and "
"`is_valid()`. [\\#5474](https://github.com/PyO3/pyo3/pull/5474)"
msgstr ""

#: src/changelog.md:84
msgid ""
"Reduce lifetime of return value in `PyCapsuleMethods::reference`. [\\#5474]"
"(https://github.com/PyO3/pyo3/pull/5474)"
msgstr ""

#: src/changelog.md:85
msgid ""
"`PyCapsuleMethods::name` now returns `CapsuleName` wrapper instead of "
"`&CStr`. [\\#5474](https://github.com/PyO3/pyo3/pull/5474)"
msgstr ""

#: src/changelog.md:86
msgid ""
"Deprecate `import_exception_bound` in favour of `import_exception`. [\\#5480]"
"(https://github.com/PyO3/pyo3/pull/5480)"
msgstr ""

#: src/changelog.md:87
msgid ""
"`PyList::get_item_unchecked`, `PyTuple::get_item_unchecked`, and `PyTuple::"
"get_borrowed_item_unchecked` no longer check for null values at the provided "
"index. [\\#5494](https://github.com/PyO3/pyo3/pull/5494)"
msgstr ""

#: src/changelog.md:88
msgid ""
"Allow converting naive datetime into chrono `DateTime<Local>`. [\\#5507]"
"(https://github.com/PyO3/pyo3/pull/5507)"
msgstr ""

#: src/changelog.md:90 src/changelog.md:161 src/changelog.md:243
#: src/changelog.md:324 src/changelog.md:477 src/changelog.md:544
#: src/changelog.md:745 src/changelog.md:846 src/changelog.md:950
#: src/changelog.md:1070 src/changelog.md:1182 src/changelog.md:1381
#: src/changelog.md:1607 src/changelog.md:1692 src/changelog.md:1747
#: src/changelog.md:1837 src/changelog.md:1900 src/changelog.md:1940
#: src/changelog.md:2003 src/changelog.md:2039 src/changelog.md:2093
#: src/changelog.md:2178 src/changelog.md:2232 src/changelog.md:2258
#: src/changelog.md:2270 src/changelog.md:2351
msgid "Removed"
msgstr ""

#: src/changelog.md:92
msgid ""
"Removed `FromPyObjectBound` trait. [\\#4390](https://github.com/PyO3/pyo3/"
"pull/4390)"
msgstr ""

#: src/changelog.md:96
msgid ""
"Fix compilation failure on `wasm32-wasip2`. [\\#5368](https://github.com/"
"PyO3/pyo3/pull/5368)"
msgstr ""

#: src/changelog.md:97
msgid ""
"Fix `OsStr` conversion for non-utf8 strings on Windows. [\\#5444](https://"
"github.com/PyO3/pyo3/pull/5444)"
msgstr ""

#: src/changelog.md:98
msgid ""
"Fix issue with `cargo vendor` caused by gitignored build artifact "
"`emscripten/pybuilddir.txt`. [\\#5456](https://github.com/PyO3/pyo3/"
"pull/5456)"
msgstr ""

#: src/changelog.md:99
msgid ""
"Stop leaking `PyMethodDef` instances inside `#[pyfunction]` macro generated "
"code. [\\#5459](https://github.com/PyO3/pyo3/pull/5459)"
msgstr ""

#: src/changelog.md:100
msgid ""
"Don't export definition of FFI struct `PyObjectObFlagsAndRefcnt` on 32-bit "
"Python 3.14 (doesn't exist). [\\#5499](https://github.com/PyO3/pyo3/"
"pull/5499)"
msgstr ""

#: src/changelog.md:101
msgid ""
"Fix failure to build for `abi3` interpreters on Windows using maturin's "
"built-in sysconfig in combination with the `generate-import-lib` feature. "
"[\\#5503](https://github.com/PyO3/pyo3/pull/5503)"
msgstr ""

#: src/changelog.md:102
msgid ""
"Fix FFI definitions `PyModule_ExecDef` and `PyModule_FromDefAndSpec2` on "
"PyPy. [\\#5529](https://github.com/PyO3/pyo3/pull/5529)"
msgstr ""

#: src/changelog.md:104
msgid ""
"[0.26.0](https://github.com/pyo3/pyo3/compare/v0.25.1...v0.26.0) - 2025-08-29"
msgstr ""

#: src/changelog.md:108
msgid ""
"Bump hashbrown dependency to 0.15. [\\#5152](https://github.com/PyO3/pyo3/"
"pull/5152)"
msgstr ""

#: src/changelog.md:109
msgid "Update MSRV to 1.74. [\\#5171](https://github.com/PyO3/pyo3/pull/5171)"
msgstr ""

#: src/changelog.md:110
msgid ""
"Set the same maximum supported version for alternative interpreters as for "
"CPython. [\\#5192](https://github.com/PyO3/pyo3/pull/5192)"
msgstr ""

#: src/changelog.md:111
msgid ""
"Add optional `bytes` dependency to add conversions for `bytes::Bytes`. "
"[\\#5252](https://github.com/PyO3/pyo3/pull/5252)"
msgstr ""

#: src/changelog.md:112
msgid ""
"Publish new crate `pyo3-introspection` to pair with the `experimental-"
"inspect` feature. [\\#5300](https://github.com/PyO3/pyo3/pull/5300)"
msgstr ""

#: src/changelog.md:113
msgid ""
"The `PYO3_BUILD_EXTENSION_MODULE` now causes the same effect as the "
"`extension-module` feature. Eventually we expect maturin and setuptools-rust "
"to set this environment variable automatically. Users with their own build "
"systems will need to do the same. [\\#5343](https://github.com/PyO3/pyo3/"
"pull/5343)"
msgstr ""

#: src/changelog.md:117
msgid ""
"Add `#[pyo3(warn(message = \"...\", category = ...))]` attribute for "
"automatic warnings generation for `#[pyfunction]` and `#[pymethods]`. "
"[\\#4364](https://github.com/PyO3/pyo3/pull/4364)"
msgstr ""

#: src/changelog.md:118
msgid ""
"Add `PyMutex`, available on Python 3.13 and newer. [\\#4523](https://github."
"com/PyO3/pyo3/pull/4523)"
msgstr ""

#: src/changelog.md:119
msgid ""
"Add FFI definition `PyMutex_IsLocked`, available on Python 3.14 and newer. "
"[\\#4523](https://github.com/PyO3/pyo3/pull/4523)"
msgstr ""

#: src/changelog.md:120
msgid ""
"Add `PyString::from_encoded_object`. [\\#5017](https://github.com/PyO3/pyo3/"
"pull/5017)"
msgstr ""

#: src/changelog.md:121
msgid ""
"`experimental-inspect`: add basic input type annotations. [\\#5089](https://"
"github.com/PyO3/pyo3/pull/5089)"
msgstr ""

#: src/changelog.md:122
msgid ""
"Add FFI function definitions for `PyFrameObject` from CPython 3.13. [\\#5154]"
"(https://github.com/PyO3/pyo3/pull/5154)"
msgstr ""

#: src/changelog.md:123
msgid ""
"`experimental-inspect`: tag modules created using `#[pymodule]` or "
"`#[pymodule_init]` functions as incomplete. [\\#5207](https://github.com/"
"PyO3/pyo3/pull/5207)"
msgstr ""

#: src/changelog.md:124
msgid ""
"`experimental-inspect`: add basic return type support. [\\#5208](https://"
"github.com/PyO3/pyo3/pull/5208)"
msgstr ""

#: src/changelog.md:125
msgid ""
"Add `PyCode::compile` and `PyCodeMethods::run` to create and execute code "
"objects. [\\#5217](https://github.com/PyO3/pyo3/pull/5217)"
msgstr ""

#: src/changelog.md:126
msgid ""
"Add `PyOnceLock` type for thread-safe single-initialization. [\\#5223]"
"(https://github.com/PyO3/pyo3/pull/5223)"
msgstr ""

#: src/changelog.md:127
msgid ""
"Add `PyClassGuard(Mut)` pyclass holders. In the future they will replace "
"`PyRef(Mut)`. [\\#5233](https://github.com/PyO3/pyo3/pull/5233)"
msgstr ""

#: src/changelog.md:128
msgid ""
"`experimental-inspect`: allow annotations in `#[pyo3(signature)]` signature "
"attribute. [\\#5241](https://github.com/PyO3/pyo3/pull/5241)"
msgstr ""

#: src/changelog.md:129
msgid ""
"Implement `MutexExt` for parking_lot's/lock_api `ReentrantMutex`. [\\#5258]"
"(https://github.com/PyO3/pyo3/pull/5258)"
msgstr ""

#: src/changelog.md:130
msgid ""
"`experimental-inspect`: support class associated constants. [\\#5272]"
"(https://github.com/PyO3/pyo3/pull/5272)"
msgstr ""

#: src/changelog.md:131
msgid ""
"Add `Bound::cast` family of functions superseding the `PyAnyMethods::"
"downcast` family. [\\#5289](https://github.com/PyO3/pyo3/pull/5289)"
msgstr ""

#: src/changelog.md:132
msgid ""
"Add FFI definitions `Py_Version` and `Py_IsFinalizing`. [\\#5317](https://"
"github.com/PyO3/pyo3/pull/5317)"
msgstr ""

#: src/changelog.md:133
msgid ""
"`experimental-inspect`: add output type annotation for `#[pyclass]`. "
"[\\#5320](https://github.com/PyO3/pyo3/pull/5320)"
msgstr ""

#: src/changelog.md:134
msgid ""
"`experimental-inspect`: support `#[pyclass(eq, eq_int, ord, hash, str)]`. "
"[\\#5338](https://github.com/PyO3/pyo3/pull/5338)"
msgstr ""

#: src/changelog.md:135
msgid ""
"`experimental-inspect`: add basic support for `#[derive(FromPyObject)]` (no "
"struct fields support yet). [\\#5339](https://github.com/PyO3/pyo3/pull/5339)"
msgstr ""

#: src/changelog.md:136
msgid ""
"Add `Python::try_attach`. [\\#5342](https://github.com/PyO3/pyo3/pull/5342)"
msgstr ""

#: src/changelog.md:140
msgid ""
"Use `Py_TPFLAGS_DISALLOW_INSTANTIATION` instead of a `__new__` which always "
"fails for a `#[pyclass]` without a `#[new]` on Python 3.10 and up. [\\#4568]"
"(https://github.com/PyO3/pyo3/pull/4568)"
msgstr ""

#: src/changelog.md:141
msgid ""
"`PyModule::from_code` now defaults `file_name` to `<string>` if empty. "
"[\\#4777](https://github.com/PyO3/pyo3/pull/4777)"
msgstr ""

#: src/changelog.md:142
msgid ""
"Deprecate `PyString::from_object` in favour of `PyString::"
"from_encoded_object`. [\\#5017](https://github.com/PyO3/pyo3/pull/5017)"
msgstr ""

#: src/changelog.md:143
msgid ""
"When building with `abi3` for a Python version newer than pyo3 supports, "
"automatically fall back to an abi3 build for the latest supported version. "
"[\\#5144](https://github.com/PyO3/pyo3/pull/5144)"
msgstr ""

#: src/changelog.md:144
msgid ""
"Change `is_instance_of` trait bound from `PyTypeInfo` to `PyTypeCheck`. "
"[\\#5146](https://github.com/PyO3/pyo3/pull/5146)"
msgstr ""

#: src/changelog.md:145
msgid ""
"Many PyO3 proc macros now report multiple errors instead of only the first "
"one. [\\#5159](https://github.com/PyO3/pyo3/pull/5159)"
msgstr ""

#: src/changelog.md:146
msgid ""
"Change `MutexExt` return type to be an associated type. [\\#5201](https://"
"github.com/PyO3/pyo3/pull/5201)"
msgstr ""

#: src/changelog.md:147
msgid ""
"Use `PyCallArgs` for `Py::call` and friends so they're equivalent to their "
"`Bound` counterpart. [\\#5206](https://github.com/PyO3/pyo3/pull/5206)"
msgstr ""

#: src/changelog.md:148
msgid ""
"Rename `Python::with_gil` to `Python::attach`. [\\#5209](https://github.com/"
"PyO3/pyo3/pull/5209)"
msgstr ""

#: src/changelog.md:149
msgid ""
"Rename `Python::allow_threads` to `Python::detach` [\\#5221](https://github."
"com/PyO3/pyo3/pull/5221)"
msgstr ""

#: src/changelog.md:150
msgid ""
"Deprecate `GILOnceCell` type in favour of `PyOnceLock`. [\\#5223](https://"
"github.com/PyO3/pyo3/pull/5223)"
msgstr ""

#: src/changelog.md:151
msgid ""
"Rename `pyo3::prepare_freethreaded_python` to `Python::initialize`. [\\#5247]"
"(https://github.com/PyO3/pyo3/pull/5247)"
msgstr ""

#: src/changelog.md:152
msgid ""
"Convert `PyMemoryError` into/from `io::ErrorKind::OutOfMemory`. [\\#5256]"
"(https://github.com/PyO3/pyo3/pull/5256)"
msgstr ""

#: src/changelog.md:153
msgid ""
"Deprecate `GILProtected`. [\\#5285](https://github.com/PyO3/pyo3/pull/5285)"
msgstr ""

#: src/changelog.md:154
msgid ""
"Move `#[pyclass]` docstring formatting from import time to compile time. "
"[\\#5286](https://github.com/PyO3/pyo3/pull/5286)"
msgstr ""

#: src/changelog.md:155
msgid ""
"`Python::attach` will now panic if the Python interpreter is in the process "
"of shutting down. [\\#5317](https://github.com/PyO3/pyo3/pull/5317)"
msgstr ""

#: src/changelog.md:156
msgid ""
"Add fast-path to `PyTypeInfo::type_object` for `#[pyclass]` types. [\\#5324]"
"(https://github.com/PyO3/pyo3/pull/5324)"
msgstr ""

#: src/changelog.md:157
msgid ""
"Deprecate `PyObject` type alias for `Py<PyAny>`. [\\#5325](https://github."
"com/PyO3/pyo3/pull/5325)"
msgstr ""

#: src/changelog.md:158
msgid ""
"Rename `Python::with_gil_unchecked` to `Python::attach_unchecked`. [\\#5340]"
"(https://github.com/PyO3/pyo3/pull/5340)"
msgstr ""

#: src/changelog.md:159
msgid ""
"Rename `Python::assume_gil_acquired` to `Python::assume_attached`. [\\#5354]"
"(https://github.com/PyO3/pyo3/pull/5354)"
msgstr ""

#: src/changelog.md:163
msgid ""
"Remove FFI definition of internals of `PyFrameObject`. [\\#5154](https://"
"github.com/PyO3/pyo3/pull/5154)"
msgstr ""

#: src/changelog.md:164
msgid ""
"Remove `Eq` and `PartialEq` implementations on `PyGetSetDef` FFI definition. "
"[\\#5196](https://github.com/PyO3/pyo3/pull/5196)"
msgstr ""

#: src/changelog.md:165
msgid ""
"Remove private FFI definitions `_Py_IsCoreInitialized` and "
"`_Py_InitializeMain`. [\\#5317](https://github.com/PyO3/pyo3/pull/5317)"
msgstr ""

#: src/changelog.md:169
msgid ""
"Use critical section in `PyByteArray::to_vec` on freethreaded build to "
"replicate GIL-enabled \"soundness\". [\\#4742](https://github.com/PyO3/pyo3/"
"pull/4742)"
msgstr ""

#: src/changelog.md:170
msgid ""
"Fix precision loss when converting `bigdecimal` into Python. [\\#5198]"
"(https://github.com/PyO3/pyo3/pull/5198)"
msgstr ""

#: src/changelog.md:171
msgid ""
"Don't treat win7 target as a cross-compilation. [\\#5210](https://github.com/"
"PyO3/pyo3/pull/5210)"
msgstr ""

#: src/changelog.md:172
msgid ""
"WASM targets no longer require exception handling support for Python \\< "
"3.14. [\\#5239](https://github.com/PyO3/pyo3/pull/5239)"
msgstr ""

#: src/changelog.md:173
msgid ""
"Fix segfault when dropping `PyBuffer<T>` after the Python interpreter has "
"been finalized. [\\#5242](https://github.com/PyO3/pyo3/pull/5242)"
msgstr ""

#: src/changelog.md:174
msgid ""
"`experimental-inspect`: better automated imports generation. [\\#5251]"
"(https://github.com/PyO3/pyo3/pull/5251)"
msgstr ""

#: src/changelog.md:175
msgid ""
"`experimental-inspect`: fix introspection of `__richcmp__`, `__concat__`, "
"`__repeat__`, `__inplace_concat__` and `__inplace_repeat__`. [\\#5273]"
"(https://github.com/PyO3/pyo3/pull/5273)"
msgstr ""

#: src/changelog.md:176
msgid ""
"fixed a leaked borrow, when converting a mutable sub class into a frozen "
"base class using `PyRef::into_super` [\\#5281](https://github.com/PyO3/pyo3/"
"pull/5281)"
msgstr ""

#: src/changelog.md:177
msgid ""
"Fix FFI definition `Py_Exit` (never returns, was `()` return value, now `!"
"`). [\\#5317](https://github.com/PyO3/pyo3/pull/5317)"
msgstr ""

#: src/changelog.md:178
msgid ""
"`experimental-inspect`: fix handling of module members gated behind "
"`#[cfg(...)]` attributes. [\\#5318](https://github.com/PyO3/pyo3/pull/5318)"
msgstr ""

#: src/changelog.md:180
msgid ""
"[0.25.1](https://github.com/pyo3/pyo3/compare/v0.25.0...v0.25.1) - 2025-06-12"
msgstr ""

#: src/changelog.md:183
msgid ""
"Add support for Windows on ARM64. [\\#5145](https://github.com/PyO3/pyo3/"
"pull/5145)"
msgstr ""

#: src/changelog.md:184
msgid ""
"Add `chrono-local` feature for optional conversions for chrono's `Local` "
"timezone & `DateTime<Local>` instances. [\\#5174](https://github.com/PyO3/"
"pyo3/pull/5174)"
msgstr ""

#: src/changelog.md:188
msgid ""
"Add FFI definition `PyBytes_AS_STRING`. [\\#5121](https://github.com/PyO3/"
"pyo3/pull/5121)"
msgstr ""

#: src/changelog.md:189
msgid ""
"Add support for module associated consts introspection. [\\#5150](https://"
"github.com/PyO3/pyo3/pull/5150)"
msgstr ""

#: src/changelog.md:193
msgid ""
"Enable \"vectorcall\" FFI definitions on GraalPy. [\\#5121](https://github."
"com/PyO3/pyo3/pull/5121)"
msgstr ""

#: src/changelog.md:194
msgid ""
"Use `Py_Is` function on GraalPy [\\#5121](https://github.com/PyO3/pyo3/"
"pull/5121)"
msgstr ""

#: src/changelog.md:198
msgid ""
"Report a better compile error for `async` declarations when not using "
"`experimental-async` feature. [\\#5156](https://github.com/PyO3/pyo3/"
"pull/5156)"
msgstr ""

#: src/changelog.md:199
msgid ""
"Fix implementation of `FromPyObject` for `uuid::Uuid` on big-endian "
"architectures. [\\#5161](https://github.com/PyO3/pyo3/pull/5161)"
msgstr ""

#: src/changelog.md:200
msgid ""
"Fix segmentation faults on 32-bit x86 with Python 3.14. [\\#5180](https://"
"github.com/PyO3/pyo3/pull/5180)"
msgstr ""

#: src/changelog.md:202
msgid ""
"[0.25.0](https://github.com/pyo3/pyo3/compare/v0.24.2...v0.25.0) - 2025-05-14"
msgstr ""

#: src/changelog.md:206
msgid ""
"Support Python 3.14.0b1. [\\#4811](https://github.com/PyO3/pyo3/pull/4811)"
msgstr ""

#: src/changelog.md:207
msgid ""
"Bump supported GraalPy version to 24.2. [\\#5116](https://github.com/PyO3/"
"pyo3/pull/5116)"
msgstr ""

#: src/changelog.md:208
msgid ""
"Add optional `bigdecimal` dependency to add conversions for `bigdecimal::"
"BigDecimal`. [\\#5011](https://github.com/PyO3/pyo3/pull/5011)"
msgstr ""

#: src/changelog.md:209
msgid ""
"Add optional `time` dependency to add conversions for `time` types. [\\#5057]"
"(https://github.com/PyO3/pyo3/pull/5057)"
msgstr ""

#: src/changelog.md:210
msgid ""
"Remove `cfg-if` dependency. [\\#5110](https://github.com/PyO3/pyo3/pull/5110)"
msgstr ""

#: src/changelog.md:211
msgid ""
"Add optional `ordered_float` dependency to add conversions for "
"`ordered_float::NotNan` and `ordered_float::OrderedFloat`. [\\#5114](https://"
"github.com/PyO3/pyo3/pull/5114)"
msgstr ""

#: src/changelog.md:215
msgid ""
"Add initial type stub generation to the `experimental-inspect` feature. "
"[\\#3977](https://github.com/PyO3/pyo3/pull/3977)"
msgstr ""

#: src/changelog.md:216
msgid ""
"Add `#[pyclass(generic)]` option to support runtime generic typing. [\\#4926]"
"(https://github.com/PyO3/pyo3/pull/4926)"
msgstr ""

#: src/changelog.md:217
msgid ""
"Implement `OnceExt` & `MutexExt` for `parking_lot` & `lock_api`. Use the new "
"extension traits by enabling the `arc_lock`, `lock_api`, or `parking_lot` "
"cargo features. [\\#5044](https://github.com/PyO3/pyo3/pull/5044)"
msgstr ""

#: src/changelog.md:218
msgid ""
"Implement `From`/`Into` for `Borrowed<T>` -> `Py<T>`. [\\#5054](https://"
"github.com/PyO3/pyo3/pull/5054)"
msgstr ""

#: src/changelog.md:219
msgid ""
"Add `PyTzInfo` constructors. [\\#5055](https://github.com/PyO3/pyo3/"
"pull/5055)"
msgstr ""

#: src/changelog.md:220
msgid ""
"Add FFI definition `PY_INVALID_STACK_EFFECT`. [\\#5064](https://github.com/"
"PyO3/pyo3/pull/5064)"
msgstr ""

#: src/changelog.md:221
msgid ""
"Implement `AsRef<Py<PyAny>>` for `Py<T>`, `Bound<T>` and `Borrowed<T>`. "
"[\\#5071](https://github.com/PyO3/pyo3/pull/5071)"
msgstr ""

#: src/changelog.md:222
msgid ""
"Add FFI definition `PyModule_Add` and `compat::PyModule_Add`. [\\#5085]"
"(https://github.com/PyO3/pyo3/pull/5085)"
msgstr ""

#: src/changelog.md:223
msgid ""
"Add FFI definitions `Py_HashBuffer`, `Py_HashPointer`, and "
"`PyObject_GenericHash`. [\\#5086](https://github.com/PyO3/pyo3/pull/5086)"
msgstr ""

#: src/changelog.md:224
msgid ""
"Support `#[pymodule_export]` on `const` items in declarative modules. "
"[\\#5096](https://github.com/PyO3/pyo3/pull/5096)"
msgstr ""

#: src/changelog.md:225
msgid ""
"Add `#[pyclass(immutable_type)]` option (on Python 3.14+ with `abi3`, or "
"3.10+ otherwise) for immutable type objects. [\\#5101](https://github.com/"
"PyO3/pyo3/pull/5101)"
msgstr ""

#: src/changelog.md:226
msgid ""
"Support `#[pyo3(rename_all)]` support on `#[derive(IntoPyObject)]`. [\\#5112]"
"(https://github.com/PyO3/pyo3/pull/5112)"
msgstr ""

#: src/changelog.md:227
msgid ""
"Add `PyRange` wrapper. [\\#5117](https://github.com/PyO3/pyo3/pull/5117)"
msgstr ""

#: src/changelog.md:231
msgid ""
"Enable use of `datetime` types with `abi3` feature enabled. [\\#4970]"
"(https://github.com/PyO3/pyo3/pull/4970)"
msgstr ""

#: src/changelog.md:232
msgid ""
"Deprecate `timezone_utc` in favor of `PyTzInfo::utc`. [\\#5055](https://"
"github.com/PyO3/pyo3/pull/5055)"
msgstr ""

#: src/changelog.md:233
msgid ""
"Reduce visibility of some CPython implementation details: [\\#5064](https://"
"github.com/PyO3/pyo3/pull/5064)"
msgstr ""

#: src/changelog.md:234
msgid ""
"The FFI definition `PyCodeObject` is now an opaque struct on all Python "
"versions."
msgstr ""

#: src/changelog.md:235
msgid ""
"The FFI definition `PyFutureFeatures` is now only defined up until Python "
"3.10 (it was present in CPython headers but unused in 3.11 and 3.12)."
msgstr ""

#: src/changelog.md:236
msgid ""
"Change `PyAnyMethods::is` to take `other: &Bound<T>`. [\\#5071](https://"
"github.com/PyO3/pyo3/pull/5071)"
msgstr ""

#: src/changelog.md:237
msgid ""
"Change `Py::is` to take `other: &Py<T>`. [\\#5071](https://github.com/PyO3/"
"pyo3/pull/5071)"
msgstr ""

#: src/changelog.md:238
msgid ""
"Change `PyVisit::call` to take `T: Into<Option<&Py<T>>>`. [\\#5071](https://"
"github.com/PyO3/pyo3/pull/5071)"
msgstr ""

#: src/changelog.md:239
msgid ""
"Expose `PyDateTime_DATE_GET_TZINFO` and `PyDateTime_TIME_GET_TZINFO` on PyPy "
"3.10 and later. [\\#5079](https://github.com/PyO3/pyo3/pull/5079)"
msgstr ""

#: src/changelog.md:240
msgid ""
"Add `#[track_caller]` to `with_gil` and `with_gil_unchecked`. [\\#5109]"
"(https://github.com/PyO3/pyo3/pull/5109)"
msgstr ""

#: src/changelog.md:241
msgid ""
"Use `std::thread::park()` instead of `libc::pause()` or `sleep(9999999)`. "
"[\\#5115](https://github.com/PyO3/pyo3/pull/5115)"
msgstr ""

#: src/changelog.md:245
msgid ""
"Remove all functionality deprecated in PyO3 0.23. [\\#4982](https://github."
"com/PyO3/pyo3/pull/4982)"
msgstr ""

#: src/changelog.md:246
msgid ""
"Remove deprecated `IntoPy` and `ToPyObject` traits. [\\#5010](https://github."
"com/PyO3/pyo3/pull/5010)"
msgstr ""

#: src/changelog.md:247
msgid ""
"Remove private types from `pyo3-ffi` (i.e. starting with `_Py`) which are "
"not referenced by public APIs: `_PyLocalMonitors`, `_Py_GlobalMonitors`, "
"`_PyCoCached`, `_PyCoLineInstrumentationData`, `_PyCoMonitoringData`, "
"`_PyCompilerSrcLocation`, `_PyErr_StackItem`. [\\#5064](https://github.com/"
"PyO3/pyo3/pull/5064)"
msgstr ""

#: src/changelog.md:248
msgid ""
"Remove FFI definition `PyCode_GetNumFree` (PyO3 cannot support it due to "
"knowledge of the code object). [\\#5064](https://github.com/PyO3/pyo3/"
"pull/5064)"
msgstr ""

#: src/changelog.md:249
msgid ""
"Remove `AsPyPointer` trait. [\\#5071](https://github.com/PyO3/pyo3/pull/5071)"
msgstr ""

#: src/changelog.md:250
msgid ""
"Remove support for the deprecated string form of `from_py_with`. [\\#5097]"
"(https://github.com/PyO3/pyo3/pull/5097)"
msgstr ""

#: src/changelog.md:251
msgid ""
"Remove FFI definitions of private static variables: `_PyMethodWrapper_Type`, "
"`_PyCoroWrapper_Type`, `_PyImport_FrozenBootstrap`, "
"`_PyImport_FrozenStdlib`, `_PyImport_FrozenTest`, `_PyManagedBuffer_Type`, "
"`_PySet_Dummy`, `_PyWeakref_ProxyType`, and `_PyWeakref_CallableProxyType`. "
"[\\#5105](https://github.com/PyO3/pyo3/pull/5105)"
msgstr ""

#: src/changelog.md:252
msgid ""
"Remove FFI definitions `PyASCIIObjectState`, `PyUnicode_IS_ASCII`, "
"`PyUnicode_IS_COMPACT`, and `PyUnicode_IS_COMPACT_ASCII` on Python 3.14 and "
"newer. [\\#5133](https://github.com/PyO3/pyo3/pull/5133)"
msgstr ""

#: src/changelog.md:256
msgid ""
"Correctly pick up the shared state for conda-based Python installation when "
"reading information from sysconfigdata. [\\#5037](https://github.com/PyO3/"
"pyo3/pull/5037)"
msgstr ""

#: src/changelog.md:257
msgid ""
"Fix compile failure with `#[derive(IntoPyObject, FromPyObject)]` when using "
"`#[pyo3()]` options recognised by only one of the two derives. [\\#5070]"
"(https://github.com/PyO3/pyo3/pull/5070)"
msgstr ""

#: src/changelog.md:258
msgid ""
"Fix various compile errors from missing FFI definitions using certain "
"feature combinations on PyPy and GraalPy. [\\#5091](https://github.com/PyO3/"
"pyo3/pull/5091)"
msgstr ""

#: src/changelog.md:259
msgid ""
"Fallback on `backports.zoneinfo` for python \\<3.9 when converting timezones "
"into python. [\\#5120](https://github.com/PyO3/pyo3/pull/5120)"
msgstr ""

#: src/changelog.md:261
msgid ""
"[0.24.2](https://github.com/pyo3/pyo3/compare/v0.24.1...v0.24.2) - 2025-04-21"
msgstr ""

#: src/changelog.md:265
msgid ""
"Fix `unused_imports` lint of `#[pyfunction]` and `#[pymethods]` expanded in "
"`macro_rules` context. [\\#5030](https://github.com/PyO3/pyo3/pull/5030)"
msgstr ""

#: src/changelog.md:266
msgid ""
"Fix size of `PyCodeObject::_co_instrumentation_version` ffi struct member on "
"Python 3.13 for systems where `uintptr_t` is not 64 bits. [\\#5048](https://"
"github.com/PyO3/pyo3/pull/5048)"
msgstr ""

#: src/changelog.md:267
msgid ""
"Fix struct-type complex enum variant fields incorrectly exposing raw "
"identifiers as `r#ident` in Python bindings. [\\#5050](https://github.com/"
"PyO3/pyo3/pull/5050)"
msgstr ""

#: src/changelog.md:269
msgid ""
"[0.24.1](https://github.com/pyo3/pyo3/compare/v0.24.0...v0.24.1) - 2025-03-31"
msgstr ""

#: src/changelog.md:273
msgid ""
"Add `abi3-py313` feature. [\\#4969](https://github.com/PyO3/pyo3/pull/4969)"
msgstr ""

#: src/changelog.md:274
msgid ""
"Add `PyAnyMethods::getattr_opt`. [\\#4978](https://github.com/PyO3/pyo3/"
"pull/4978)"
msgstr ""

#: src/changelog.md:275
msgid ""
"Add `PyInt::new` constructor for all supported number types (i32, u32, i64, "
"u64, isize, usize). [\\#4984](https://github.com/PyO3/pyo3/pull/4984)"
msgstr ""

#: src/changelog.md:276
msgid ""
"Add `pyo3::sync::with_critical_section2`. [\\#4992](https://github.com/PyO3/"
"pyo3/pull/4992)"
msgstr ""

#: src/changelog.md:277
msgid ""
"Implement `PyCallArgs` for `Borrowed<'_, 'py, PyTuple>`, `&Bound<'py, "
"PyTuple>`, and `&Py<PyTuple>`. [\\#5013](https://github.com/PyO3/pyo3/"
"pull/5013)"
msgstr ""

#: src/changelog.md:281
msgid ""
"Fix `is_type_of` for native types not using same specialized check as "
"`is_type_of_bound`. [\\#4981](https://github.com/PyO3/pyo3/pull/4981)"
msgstr ""

#: src/changelog.md:282
msgid ""
"Fix `Probe` class naming issue with `#[pymethods]`. [\\#4988](https://github."
"com/PyO3/pyo3/pull/4988)"
msgstr ""

#: src/changelog.md:283
msgid ""
"Fix compile failure with required `#[pyfunction]` arguments taking "
"`Option<&str>` and `Option<&T>` (for `#[pyclass]` types). [\\#5002](https://"
"github.com/PyO3/pyo3/pull/5002)"
msgstr ""

#: src/changelog.md:284
msgid ""
"Fix `PyString::from_object` causing of bounds reads with `encoding` and "
"`errors` parameters which are not nul-terminated. [\\#5008](https://github."
"com/PyO3/pyo3/pull/5008)"
msgstr ""

#: src/changelog.md:285
msgid ""
"Fix compile error when additional options follow after `crate` for "
"`#[pyfunction]`. [\\#5015](https://github.com/PyO3/pyo3/pull/5015)"
msgstr ""

#: src/changelog.md:287
msgid ""
"[0.24.0](https://github.com/pyo3/pyo3/compare/v0.23.5...v0.24.0) - 2025-03-09"
msgstr ""

#: src/changelog.md:291
msgid ""
"Add supported CPython/PyPy versions to cargo package metadata. [\\#4756]"
"(https://github.com/PyO3/pyo3/pull/4756)"
msgstr ""

#: src/changelog.md:292
msgid ""
"Bump `target-lexicon` dependency to 0.13. [\\#4822](https://github.com/PyO3/"
"pyo3/pull/4822)"
msgstr ""

#: src/changelog.md:293
msgid ""
"Add optional `jiff` dependency to add conversions for `jiff` datetime types. "
"[\\#4823](https://github.com/PyO3/pyo3/pull/4823)"
msgstr ""

#: src/changelog.md:294
msgid ""
"Add optional `uuid` dependency to add conversions for `uuid::Uuid`. [\\#4864]"
"(https://github.com/PyO3/pyo3/pull/4864)"
msgstr ""

#: src/changelog.md:295
msgid ""
"Bump minimum supported `inventory` version to 0.3.5. [\\#4954](https://"
"github.com/PyO3/pyo3/pull/4954)"
msgstr ""

#: src/changelog.md:299
msgid ""
"Add `PyIterator::send` method to allow sending values into a python "
"generator. [\\#4746](https://github.com/PyO3/pyo3/pull/4746)"
msgstr ""

#: src/changelog.md:300
msgid ""
"Add `PyCallArgs` trait for passing arguments into the Python calling "
"protocol. This enabled using a faster calling convention for certain types, "
"improving performance. [\\#4768](https://github.com/PyO3/pyo3/pull/4768)"
msgstr ""

#: src/changelog.md:301
msgid ""
"Add `#[pyo3(default = ...']` option for `#[derive(FromPyObject)]` to set a "
"default value for extracted fields of named structs. [\\#4829](https://"
"github.com/PyO3/pyo3/pull/4829)"
msgstr ""

#: src/changelog.md:302
msgid ""
"Add `#[pyo3(into_py_with = ...)]` option for `#[derive(IntoPyObject, "
"IntoPyObjectRef)]`. [\\#4850](https://github.com/PyO3/pyo3/pull/4850)"
msgstr ""

#: src/changelog.md:303
msgid ""
"Add FFI definitions `PyThreadState_GetFrame` and `PyFrame_GetBack`. [\\#4866]"
"(https://github.com/PyO3/pyo3/pull/4866)"
msgstr ""

#: src/changelog.md:304
msgid ""
"Optimize `last` for `BoundListIterator`, `BoundTupleIterator` and "
"`BorrowedTupleIterator`. [\\#4878](https://github.com/PyO3/pyo3/pull/4878)"
msgstr ""

#: src/changelog.md:305
msgid ""
"Optimize `Iterator::count()` for `PyDict`, `PyList`, `PyTuple` & `PySet`. "
"[\\#4878](https://github.com/PyO3/pyo3/pull/4878)"
msgstr ""

#: src/changelog.md:306
msgid ""
"Optimize `nth`, `nth_back`, `advance_by` and `advance_back_by` for "
"`BoundTupleIterator` [\\#4897](https://github.com/PyO3/pyo3/pull/4897)"
msgstr ""

#: src/changelog.md:307
msgid ""
"Add support for `types.GenericAlias` as `pyo3::types::PyGenericAlias`. "
"[\\#4917](https://github.com/PyO3/pyo3/pull/4917)"
msgstr ""

#: src/changelog.md:308
msgid ""
"Add `MutextExt` trait to help avoid deadlocks with the GIL while locking a "
"`std::sync::Mutex`. [\\#4934](https://github.com/PyO3/pyo3/pull/4934)"
msgstr ""

#: src/changelog.md:309
msgid ""
"Add `#[pyo3(rename_all = \"...\")]` option for `#[derive(FromPyObject)]`. "
"[\\#4941](https://github.com/PyO3/pyo3/pull/4941)"
msgstr ""

#: src/changelog.md:313
msgid ""
"Optimize `nth`, `nth_back`, `advance_by` and `advance_back_by` for "
"`BoundListIterator`. [\\#4810](https://github.com/PyO3/pyo3/pull/4810)"
msgstr ""

#: src/changelog.md:314
msgid ""
"Use `DerefToPyAny` in blanket implementations of `From<Py<T>>` and "
"`From<Bound<'py, T>>` for `PyObject`. [\\#4593](https://github.com/PyO3/pyo3/"
"pull/4593)"
msgstr ""

#: src/changelog.md:315
msgid ""
"Map `io::ErrorKind::IsADirectory`/`NotADirectory` to the corresponding "
"Python exception on Rust 1.83+. [\\#4747](https://github.com/PyO3/pyo3/"
"pull/4747)"
msgstr ""

#: src/changelog.md:316
msgid ""
"`PyAnyMethods::call` and friends now require `PyCallArgs` for their "
"positional arguments. [\\#4768](https://github.com/PyO3/pyo3/pull/4768)"
msgstr ""

#: src/changelog.md:317
msgid ""
"Expose FFI definitions for `PyObject_Vectorcall(Method)` on the stable abi "
"on 3.12+. [\\#4853](https://github.com/PyO3/pyo3/pull/4853)"
msgstr ""

#: src/changelog.md:318
msgid ""
"`#[pyo3(from_py_with = ...)]` now take a path rather than a string literal "
"[\\#4860](https://github.com/PyO3/pyo3/pull/4860)"
msgstr ""

#: src/changelog.md:319
msgid ""
"Format Python traceback in impl Debug for PyErr. [\\#4900](https://github."
"com/PyO3/pyo3/pull/4900)"
msgstr ""

#: src/changelog.md:320
msgid ""
"Convert `PathBuf` & `Path` into Python `pathlib.Path` instead of `PyString`. "
"[\\#4925](https://github.com/PyO3/pyo3/pull/4925)"
msgstr ""

#: src/changelog.md:321
msgid ""
"Relax parsing of exotic Python versions. [\\#4949](https://github.com/PyO3/"
"pyo3/pull/4949)"
msgstr ""

#: src/changelog.md:322
msgid ""
"PyO3 threads now hang instead of `pthread_exit` trying to acquire the GIL "
"when the interpreter is shutting down. This mimics the [Python 3.14](https://"
"github.com/python/cpython/issues/87135) behavior and avoids undefined "
"behavior and crashes. [\\#4874](https://github.com/PyO3/pyo3/pull/4874)"
msgstr ""

#: src/changelog.md:326
msgid ""
"Remove implementations of `Deref` for `PyAny` and other \"native\" types. "
"[\\#4593](https://github.com/PyO3/pyo3/pull/4593)"
msgstr ""

#: src/changelog.md:327
msgid ""
"Remove implicit default of trailing optional arguments (see #2935) [\\#4729]"
"(https://github.com/PyO3/pyo3/pull/4729)"
msgstr ""

#: src/changelog.md:328
msgid ""
"Remove the deprecated implicit eq fallback for simple enums. [\\#4730]"
"(https://github.com/PyO3/pyo3/pull/4730)"
msgstr ""

#: src/changelog.md:332
msgid ""
"Correct FFI definition of `PyIter_Send` to return a `PySendResult`. [\\#4746]"
"(https://github.com/PyO3/pyo3/pull/4746)"
msgstr ""

#: src/changelog.md:333
msgid ""
"Fix a thread safety issue in the runtime borrow checker used by mutable "
"pyclass instances on the free-threaded build. [\\#4948](https://github.com/"
"PyO3/pyo3/pull/4948)"
msgstr ""

#: src/changelog.md:336
msgid ""
"[0.23.5](https://github.com/pyo3/pyo3/compare/v0.23.4...v0.23.5) - 2025-02-22"
msgstr ""

#: src/changelog.md:340
msgid ""
"Add support for PyPy3.11 [\\#4760](https://github.com/PyO3/pyo3/pull/4760)"
msgstr ""

#: src/changelog.md:344
msgid ""
"Fix thread-unsafe implementation of freelist pyclasses on the free-threaded "
"build. [\\#4902](https://github.com/PyO3/pyo3/pull/4902)"
msgstr ""

#: src/changelog.md:345
msgid ""
"Re-enable a workaround for situations where CPython incorrectly does not add "
"`__builtins__` to `__globals__` in code executed by `Python::py_run` (was "
"removed in PyO3 0.23.0). [\\#4921](https://github.com/PyO3/pyo3/pull/4921)"
msgstr ""

#: src/changelog.md:347
msgid ""
"[0.23.4](https://github.com/pyo3/pyo3/compare/v0.23.3...v0.23.4) - 2025-01-10"
msgstr ""

#: src/changelog.md:351
msgid ""
"Add `PyList::locked_for_each`, which uses a critical section to lock the "
"list on the free-threaded build. [\\#4789](https://github.com/PyO3/pyo3/"
"pull/4789)"
msgstr ""

#: src/changelog.md:352
msgid ""
"Add `pyo3_build_config::add_python_framework_link_args` build script API to "
"set rpath when using macOS system Python. [\\#4833](https://github.com/PyO3/"
"pyo3/pull/4833)"
msgstr ""

#: src/changelog.md:356
msgid ""
"Use `datetime.fold` to distinguish ambiguous datetimes when converting to "
"and from `chrono::DateTime<Tz>` (rather than erroring). [\\#4791](https://"
"github.com/PyO3/pyo3/pull/4791)"
msgstr ""

#: src/changelog.md:357
msgid ""
"Optimize PyList iteration on the free-threaded build. [\\#4789](https://"
"github.com/PyO3/pyo3/pull/4789)"
msgstr ""

#: src/changelog.md:361
msgid ""
"Fix unnecessary internal `py.allow_threads` GIL-switch when attempting to "
"access contents of a `PyErr` which originated from Python (could lead to "
"unintended deadlocks). [\\#4766](https://github.com/PyO3/pyo3/pull/4766)"
msgstr ""

#: src/changelog.md:362
msgid ""
"Fix thread-unsafe access of dict internals in `BoundDictIterator` on the "
"free-threaded build. [\\#4788](https://github.com/PyO3/pyo3/pull/4788)"
msgstr ""

#: src/changelog.md:363
msgid ""
"Fix unnecessary critical sections in `BoundDictIterator` on the free-"
"threaded build. [\\#4788](https://github.com/PyO3/pyo3/pull/4788)"
msgstr ""

#: src/changelog.md:364
msgid ""
"Fix time-of-check to time-of-use issues with list iteration on the free-"
"threaded build. [\\#4789](https://github.com/PyO3/pyo3/pull/4789)"
msgstr ""

#: src/changelog.md:365
msgid ""
"Fix `chrono::DateTime<Tz>` to-Python conversion when `Tz` is `chrono_tz::"
"Tz`. [\\#4790](https://github.com/PyO3/pyo3/pull/4790)"
msgstr ""

#: src/changelog.md:366
msgid ""
"Fix `#[pyclass]` not being able to be named `Probe`. [\\#4794](https://"
"github.com/PyO3/pyo3/pull/4794)"
msgstr ""

#: src/changelog.md:367
msgid ""
"Fix not treating cross-compilation from x64 to aarch64 on Windows as a cross-"
"compile. [\\#4800](https://github.com/PyO3/pyo3/pull/4800)"
msgstr ""

#: src/changelog.md:368
msgid ""
"Fix missing struct fields on GraalPy when subclassing builtin classes. "
"[\\#4802](https://github.com/PyO3/pyo3/pull/4802)"
msgstr ""

#: src/changelog.md:369
msgid ""
"Fix generating import lib for PyPy when `abi3` feature is enabled. [\\#4806]"
"(https://github.com/PyO3/pyo3/pull/4806)"
msgstr ""

#: src/changelog.md:370
msgid ""
"Fix generating import lib for python3.13t when `abi3` feature is enabled. "
"[\\#4808](https://github.com/PyO3/pyo3/pull/4808)"
msgstr ""

#: src/changelog.md:371
msgid ""
"Fix compile failure for raw identifiers like `r#box` in "
"`derive(FromPyObject)`. [\\#4814](https://github.com/PyO3/pyo3/pull/4814)"
msgstr ""

#: src/changelog.md:372
msgid ""
"Fix compile failure for `#[pyclass]` enum variants with more than 12 fields. "
"[\\#4832](https://github.com/PyO3/pyo3/pull/4832)"
msgstr ""

#: src/changelog.md:375
msgid ""
"[0.23.3](https://github.com/pyo3/pyo3/compare/v0.23.2...v0.23.3) - 2024-12-03"
msgstr ""

#: src/changelog.md:379
msgid ""
"Bump optional `python3-dll-a` dependency to 0.2.11. [\\#4749](https://github."
"com/PyO3/pyo3/pull/4749)"
msgstr ""

#: src/changelog.md:383
msgid ""
"Fix unresolved symbol link failures on Windows when compiling for Python "
"3.13t with `abi3` features enabled. [\\#4733](https://github.com/PyO3/pyo3/"
"pull/4733)"
msgstr ""

#: src/changelog.md:384
msgid ""
"Fix unresolved symbol link failures on Windows when compiling for Python "
"3.13t using the `generate-import-lib` feature. [\\#4749](https://github.com/"
"PyO3/pyo3/pull/4749)"
msgstr ""

#: src/changelog.md:385
msgid ""
"Fix compile-time regression in PyO3 0.23.0 where changing `PYO3_CONFIG_FILE` "
"would not reconfigure PyO3 for the new interpreter. [\\#4758](https://github."
"com/PyO3/pyo3/pull/4758)"
msgstr ""

#: src/changelog.md:387
msgid ""
"[0.23.2](https://github.com/pyo3/pyo3/compare/v0.23.1...v0.23.2) - 2024-11-25"
msgstr ""

#: src/changelog.md:391
msgid ""
"Add `IntoPyObjectExt` trait. [\\#4708](https://github.com/PyO3/pyo3/"
"pull/4708)"
msgstr ""

#: src/changelog.md:395
msgid ""
"Fix compile failures when building for free-threaded Python when the `abi3` "
"or `abi3-pyxx` features are enabled. [\\#4719](https://github.com/PyO3/pyo3/"
"pull/4719)"
msgstr ""

#: src/changelog.md:396
msgid ""
"Fix `ambiguous_associated_items` lint error in `#[pyclass]` and "
"`#[derive(IntoPyObject)]` macros. [\\#4725](https://github.com/PyO3/pyo3/"
"pull/4725)"
msgstr ""

#: src/changelog.md:399
msgid ""
"[0.23.1](https://github.com/pyo3/pyo3/compare/v0.23.0...v0.23.1) - 2024-11-16"
msgstr ""

#: src/changelog.md:401
msgid "Re-release of 0.23.0 with fixes to docs.rs build."
msgstr ""

#: src/changelog.md:403
msgid ""
"[0.23.0](https://github.com/pyo3/pyo3/compare/v0.22.5...v0.23.0) - 2024-11-15"
msgstr ""

#: src/changelog.md:407
msgid ""
"Drop support for PyPy 3.7 and 3.8. [\\#4582](https://github.com/PyO3/pyo3/"
"pull/4582)"
msgstr ""

#: src/changelog.md:408
msgid ""
"Extend range of supported versions of `hashbrown` optional dependency to "
"include version 0.15. [\\#4604](https://github.com/PyO3/pyo3/pull/4604)"
msgstr ""

#: src/changelog.md:409
msgid ""
"Bump minimum version of `eyre` optional dependency to 0.6.8. [\\#4617]"
"(https://github.com/PyO3/pyo3/pull/4617)"
msgstr ""

#: src/changelog.md:410
msgid ""
"Bump minimum version of `hashbrown` optional dependency to 0.14.5. [\\#4617]"
"(https://github.com/PyO3/pyo3/pull/4617)"
msgstr ""

#: src/changelog.md:411
msgid ""
"Bump minimum version of `indexmap` optional dependency to 2.5.0. [\\#4617]"
"(https://github.com/PyO3/pyo3/pull/4617)"
msgstr ""

#: src/changelog.md:412
msgid ""
"Bump minimum version of `num-complex` optional dependency to 0.4.6. [\\#4617]"
"(https://github.com/PyO3/pyo3/pull/4617)"
msgstr ""

#: src/changelog.md:413
msgid ""
"Bump minimum version of `chrono-tz` optional dependency to 0.10. [\\#4617]"
"(https://github.com/PyO3/pyo3/pull/4617)"
msgstr ""

#: src/changelog.md:414
msgid ""
"Support free-threaded Python 3.13t. [\\#4588](https://github.com/PyO3/pyo3/"
"pull/4588)"
msgstr ""

#: src/changelog.md:418
msgid ""
"Add `IntoPyObject` (fallible) conversion trait to convert from Rust to "
"Python values. [\\#4060](https://github.com/PyO3/pyo3/pull/4060)"
msgstr ""

#: src/changelog.md:419
msgid ""
"Add `#[pyclass(str=\"<format string>\")]` option to generate `__str__` based "
"on a `Display` implementation or format string. [\\#4233](https://github.com/"
"PyO3/pyo3/pull/4233)"
msgstr ""

#: src/changelog.md:420
msgid ""
"Implement `PartialEq` for `Bound<'py, PyInt>` with `u8`, `u16`, `u32`, "
"`u64`, `u128`, `usize`, `i8`, `i16`, `i32`, `i64`, `i128` and `isize`. "
"[\\#4317](https://github.com/PyO3/pyo3/pull/4317)"
msgstr ""

#: src/changelog.md:421
msgid ""
"Implement `PartialEq<f64>` and `PartialEq<f32>` for `Bound<'py, PyFloat>`. "
"[\\#4348](https://github.com/PyO3/pyo3/pull/4348)"
msgstr ""

#: src/changelog.md:422
msgid ""
"Add `as_super` and `into_super` methods for `Bound<T: PyClass>`. [\\#4351]"
"(https://github.com/PyO3/pyo3/pull/4351)"
msgstr ""

#: src/changelog.md:423
msgid ""
"Add FFI definitions `PyCFunctionFast` and `PyCFunctionFastWithKeywords` "
"[\\#4415](https://github.com/PyO3/pyo3/pull/4415)"
msgstr ""

#: src/changelog.md:424
msgid ""
"Add FFI definitions for `PyMutex` on Python 3.13 and newer. [\\#4421]"
"(https://github.com/PyO3/pyo3/pull/4421)"
msgstr ""

#: src/changelog.md:425
msgid ""
"Add `PyDict::locked_for_each` to iterate efficiently on freethreaded Python. "
"[\\#4439](https://github.com/PyO3/pyo3/pull/4439)"
msgstr ""

#: src/changelog.md:426
msgid ""
"Add FFI definitions `PyObject_GetOptionalAttr`, "
"`PyObject_GetOptionalAttrString`, `PyObject_HasAttrWithError`, "
"`PyObject_HasAttrStringWithError`, `Py_CONSTANT_*` constants, "
"`Py_GetConstant`, `Py_GetConstantBorrowed`, and `PyType_GetModuleByDef` on "
"Python 3.13 and newer. [\\#4447](https://github.com/PyO3/pyo3/pull/4447)"
msgstr ""

#: src/changelog.md:427
msgid ""
"Add FFI definitions for the Python critical section API available on Python "
"3.13 and newer. [\\#4477](https://github.com/PyO3/pyo3/pull/4477)"
msgstr ""

#: src/changelog.md:428
msgid ""
"Add derive macro for `IntoPyObject`. [\\#4495](https://github.com/PyO3/pyo3/"
"pull/4495)"
msgstr ""

#: src/changelog.md:429
msgid ""
"Add `Borrowed::as_ptr`. [\\#4520](https://github.com/PyO3/pyo3/pull/4520)"
msgstr ""

#: src/changelog.md:430
msgid ""
"Add FFI definition for `PyImport_AddModuleRef`. [\\#4529](https://github.com/"
"PyO3/pyo3/pull/4529)"
msgstr ""

#: src/changelog.md:431
msgid ""
"Add `PyAnyMethods::try_iter`. [\\#4553](https://github.com/PyO3/pyo3/"
"pull/4553)"
msgstr ""

#: src/changelog.md:432
msgid ""
"Add `pyo3::sync::with_critical_section`, a wrapper around the Python "
"Critical Section API added in Python 3.13. [\\#4587](https://github.com/PyO3/"
"pyo3/pull/4587)"
msgstr ""

#: src/changelog.md:433
msgid ""
"Add `#[pymodule(gil_used = false)]` option to declare that a module supports "
"the free-threaded build. [\\#4588](https://github.com/PyO3/pyo3/pull/4588)"
msgstr ""

#: src/changelog.md:434
msgid ""
"Add `PyModule::gil_used` method to declare that a module supports the free-"
"threaded build. [\\#4588](https://github.com/PyO3/pyo3/pull/4588)"
msgstr ""

#: src/changelog.md:435
msgid ""
"Add FFI definition `PyDateTime_CAPSULE_NAME`. [\\#4634](https://github.com/"
"PyO3/pyo3/pull/4634)"
msgstr ""

#: src/changelog.md:436
msgid ""
"Add `PyMappingProxy` type to represent the `mappingproxy` Python class. "
"[\\#4644](https://github.com/PyO3/pyo3/pull/4644)"
msgstr ""

#: src/changelog.md:437
msgid ""
"Add FFI definitions `PyList_Extend` and `PyList_Clear`. [\\#4667](https://"
"github.com/PyO3/pyo3/pull/4667)"
msgstr ""

#: src/changelog.md:438
msgid ""
"Add derive macro for `IntoPyObjectRef`. [\\#4674](https://github.com/PyO3/"
"pyo3/pull/4674)"
msgstr ""

#: src/changelog.md:439
msgid ""
"Add `pyo3::sync::OnceExt` and `pyo3::sync::OnceLockExt` traits. [\\#4676]"
"(https://github.com/PyO3/pyo3/pull/4676)"
msgstr ""

#: src/changelog.md:443
msgid ""
"Prefer `IntoPyObject` over `IntoPy<Py<PyAny>>>` for `#[pyfunction]` and "
"`#[pymethods]` return types. [\\#4060](https://github.com/PyO3/pyo3/"
"pull/4060)"
msgstr ""

#: src/changelog.md:444
msgid ""
"Report multiple errors from `#[pyclass]` and `#[pyo3(..)]` attributes. "
"[\\#4243](https://github.com/PyO3/pyo3/pull/4243)"
msgstr ""

#: src/changelog.md:445
msgid ""
"Nested declarative `#[pymodule]` are automatically treated as submodules (no "
"`PyInit_` entrypoint is created). [\\#4308](https://github.com/PyO3/pyo3/"
"pull/4308)"
msgstr ""

#: src/changelog.md:446
msgid ""
"Deprecate `PyAnyMethods::is_ellipsis` (`Py::is_ellipsis` was deprecated in "
"PyO3 0.20). [\\#4322](https://github.com/PyO3/pyo3/pull/4322)"
msgstr ""

#: src/changelog.md:447
msgid ""
"Deprecate `PyLong` in favor of `PyInt`. [\\#4347](https://github.com/PyO3/"
"pyo3/pull/4347)"
msgstr ""

#: src/changelog.md:448
msgid ""
"Rename `IntoPyDict::into_py_dict_bound` to `IntoPyDict::into_py_dict`. "
"[\\#4388](https://github.com/PyO3/pyo3/pull/4388)"
msgstr ""

#: src/changelog.md:449
msgid ""
"`PyModule::from_code` now expects `&CStr` as arguments instead of `&str`. "
"[\\#4404](https://github.com/PyO3/pyo3/pull/4404)"
msgstr ""

#: src/changelog.md:450
msgid ""
"Use \"fastcall\" Python calling convention for `#[pyfunction]`s when "
"compiling on abi3 for Python 3.10 and up. [\\#4415](https://github.com/PyO3/"
"pyo3/pull/4415)"
msgstr ""

#: src/changelog.md:451
msgid ""
"Remove `Copy` and `Clone` from `PyObject` struct FFI definition. [\\#4434]"
"(https://github.com/PyO3/pyo3/pull/4434)"
msgstr ""

#: src/changelog.md:452
msgid ""
"`Python::eval` and `Python::run` now take a `&CStr` instead of `&str`. "
"[\\#4435](https://github.com/PyO3/pyo3/pull/4435)"
msgstr ""

#: src/changelog.md:453
msgid ""
"Deprecate `IPowModulo`, `PyClassAttributeDef`, `PyGetterDef`, `PyMethodDef`, "
"`PyMethodDefType`, and `PySetterDef` from PyO3's public API. [\\#4441]"
"(https://github.com/PyO3/pyo3/pull/4441)"
msgstr ""

#: src/changelog.md:454
msgid ""
"`IntoPyObject` impls for `Vec<u8>`, `&[u8]`, `[u8; N]`, `Cow<[u8]>` and "
"`SmallVec<[u8; N]>` now convert into Python `bytes` rather than a `list` of "
"integers. [\\#4442](https://github.com/PyO3/pyo3/pull/4442)"
msgstr ""

#: src/changelog.md:455
msgid ""
"Emit a compile-time error when attempting to subclass a class that doesn't "
"allow subclassing. [\\#4453](https://github.com/PyO3/pyo3/pull/4453)"
msgstr ""

#: src/changelog.md:456
msgid ""
"`IntoPyDict::into_py_dict` is now fallible due to `IntoPyObject` migration. "
"[\\#4493](https://github.com/PyO3/pyo3/pull/4493)"
msgstr ""

#: src/changelog.md:457
msgid ""
"The `abi3` feature will now override config files provided via "
"`PYO3_BUILD_CONFIG`. [\\#4497](https://github.com/PyO3/pyo3/pull/4497)"
msgstr ""

#: src/changelog.md:458
msgid ""
"Disable the `GILProtected` struct on free-threaded Python. [\\#4504](https://"
"github.com/PyO3/pyo3/pull/4504)"
msgstr ""

#: src/changelog.md:459
msgid ""
"Updated FFI definitions for functions and struct fields that have been "
"deprecated or removed from CPython. [\\#4534](https://github.com/PyO3/pyo3/"
"pull/4534)"
msgstr ""

#: src/changelog.md:460
msgid ""
"Disable `PyListMethods::get_item_unchecked` on free-threaded Python. "
"[\\#4539](https://github.com/PyO3/pyo3/pull/4539)"
msgstr ""

#: src/changelog.md:461
msgid ""
"Add `GILOnceCell::import`. [\\#4542](https://github.com/PyO3/pyo3/pull/4542)"
msgstr ""

#: src/changelog.md:462
msgid ""
"Deprecate `PyAnyMethods::iter` in favour of `PyAnyMethods::try_iter`. "
"[\\#4553](https://github.com/PyO3/pyo3/pull/4553)"
msgstr ""

#: src/changelog.md:463
msgid ""
"The `#[pyclass]` macro now requires a types to be `Sync`. (Except for "
"`#[pyclass(unsendable)]` types). [\\#4566](https://github.com/PyO3/pyo3/"
"pull/4566)"
msgstr ""

#: src/changelog.md:464
msgid ""
"`PyList::new` and `PyTuple::new` are now fallible due to `IntoPyObject` "
"migration. [\\#4580](https://github.com/PyO3/pyo3/pull/4580)"
msgstr ""

#: src/changelog.md:465
msgid ""
"`PyErr::matches` is now fallible due to `IntoPyObject` migration. [\\#4595]"
"(https://github.com/PyO3/pyo3/pull/4595)"
msgstr ""

#: src/changelog.md:466
msgid ""
"Deprecate `ToPyObject` in favour of `IntoPyObject` [\\#4595](https://github."
"com/PyO3/pyo3/pull/4595)"
msgstr ""

#: src/changelog.md:467
msgid ""
"Deprecate `PyWeakrefMethods::get_option`. [\\#4597](https://github.com/PyO3/"
"pyo3/pull/4597)"
msgstr ""

#: src/changelog.md:468
msgid ""
"Seal `PyWeakrefMethods` trait. [\\#4598](https://github.com/PyO3/pyo3/"
"pull/4598)"
msgstr ""

#: src/changelog.md:469
msgid ""
"Remove `PyNativeTypeInitializer` and `PyObjectInit` from the PyO3 public "
"API. [\\#4611](https://github.com/PyO3/pyo3/pull/4611)"
msgstr ""

#: src/changelog.md:470
msgid ""
"Deprecate `IntoPy` in favor of `IntoPyObject` [\\#4618](https://github.com/"
"PyO3/pyo3/pull/4618)"
msgstr ""

#: src/changelog.md:471
msgid ""
"Eagerly normalize exceptions in `PyErr::take()` and `PyErr::fetch()` on "
"Python 3.11 and older. [\\#4655](https://github.com/PyO3/pyo3/pull/4655)"
msgstr ""

#: src/changelog.md:472
msgid ""
"Move `IntoPy::type_output` to `IntoPyObject::type_output`. [\\#4657](https://"
"github.com/PyO3/pyo3/pull/4657)"
msgstr ""

#: src/changelog.md:473
msgid ""
"Change return type of `PyMapping::keys`, `PyMapping::values` and `PyMapping::"
"items` to `Bound<'py, PyList>` instead of `Bound<'py, PySequence>`. [\\#4661]"
"(https://github.com/PyO3/pyo3/pull/4661)"
msgstr ""

#: src/changelog.md:474
msgid ""
"Complex enums now allow field types that either implement `IntoPyObject` by "
"reference or by value together with `Clone`. This makes `Py<T>` available as "
"field type. [\\#4694](https://github.com/PyO3/pyo3/pull/4694)"
msgstr ""

#: src/changelog.md:479
msgid ""
"Remove all functionality deprecated in PyO3 0.20. [\\#4322](https://github."
"com/PyO3/pyo3/pull/4322)"
msgstr ""

#: src/changelog.md:480
msgid ""
"Remove all functionality deprecated in PyO3 0.21. [\\#4323](https://github."
"com/PyO3/pyo3/pull/4323)"
msgstr ""

#: src/changelog.md:481
msgid ""
"Deprecate `PyUnicode` in favour of `PyString`. [\\#4370](https://github.com/"
"PyO3/pyo3/pull/4370)"
msgstr ""

#: src/changelog.md:482
msgid ""
"Remove deprecated `gil-refs` feature. [\\#4378](https://github.com/PyO3/pyo3/"
"pull/4378)"
msgstr ""

#: src/changelog.md:483
msgid ""
"Remove private FFI definitions `_Py_IMMORTAL_REFCNT`, `_Py_IsImmortal`, "
"`_Py_TPFLAGS_STATIC_BUILTIN`, `_Py_Dealloc`, `_Py_IncRef`, `_Py_DecRef`. "
"[\\#4447](https://github.com/PyO3/pyo3/pull/4447)"
msgstr ""

#: src/changelog.md:484
msgid ""
"Remove private FFI definitions `_Py_c_sum`, `_Py_c_diff`, `_Py_c_neg`, "
"`_Py_c_prod`, `_Py_c_quot`, `_Py_c_pow`, `_Py_c_abs`. [\\#4521](https://"
"github.com/PyO3/pyo3/pull/4521)"
msgstr ""

#: src/changelog.md:485
msgid ""
"Remove `_borrowed` methods of `PyWeakRef` and `PyWeakRefProxy`. [\\#4528]"
"(https://github.com/PyO3/pyo3/pull/4528)"
msgstr ""

#: src/changelog.md:486
msgid ""
"Removed private FFI definition `_PyErr_ChainExceptions`. [\\#4534](https://"
"github.com/PyO3/pyo3/pull/4534)"
msgstr ""

#: src/changelog.md:490
msgid ""
"Fix invalid library search path `lib_dir` when cross-compiling. [\\#4389]"
"(https://github.com/PyO3/pyo3/pull/4389)"
msgstr ""

#: src/changelog.md:491
msgid ""
"Fix FFI definition `Py_Is` for PyPy on 3.10 to call the function defined by "
"PyPy. [\\#4447](https://github.com/PyO3/pyo3/pull/4447)"
msgstr ""

#: src/changelog.md:492
msgid ""
"Fix compile failure when using `#[cfg]` attributes for simple enum variants. "
"[\\#4509](https://github.com/PyO3/pyo3/pull/4509)"
msgstr ""

#: src/changelog.md:493
msgid ""
"Fix compiler warning for `non_snake_case` method names inside `#[pymethods]` "
"generated code. [\\#4567](https://github.com/PyO3/pyo3/pull/4567)"
msgstr ""

#: src/changelog.md:494
msgid ""
"Fix compile error with `#[derive(FromPyObject)]` generic struct with trait "
"bounds. [\\#4645](https://github.com/PyO3/pyo3/pull/4645)"
msgstr ""

#: src/changelog.md:495
msgid ""
"Fix compile error for `#[classmethod]` and `#[staticmethod]` on magic "
"methods. [\\#4654](https://github.com/PyO3/pyo3/pull/4654)"
msgstr ""

#: src/changelog.md:496
msgid ""
"Fix compile warning for `unsafe_op_in_unsafe_fn` in generated macro code. "
"[\\#4674](https://github.com/PyO3/pyo3/pull/4674)"
msgstr ""

#: src/changelog.md:497
msgid ""
"Fix incorrect deprecation warning for `#[pyclass] enum`s with custom "
"`__eq__` implementation. [\\#4692](https://github.com/PyO3/pyo3/pull/4692)"
msgstr ""

#: src/changelog.md:498
msgid ""
"Fix `non_upper_case_globals` lint firing for generated `__match_args__` on "
"complex enums. [\\#4705](https://github.com/PyO3/pyo3/pull/4705)"
msgstr ""

#: src/changelog.md:500
msgid ""
"[0.22.5](https://github.com/pyo3/pyo3/compare/v0.22.4...v0.22.5) - 2024-10-15"
msgstr ""

#: src/changelog.md:504
msgid ""
"Fix regression in 0.22.4 of naming collision in `__clear__` slot and `clear` "
"method generated code. [\\#4619](https://github.com/PyO3/pyo3/pull/4619)"
msgstr ""

#: src/changelog.md:507
msgid ""
"[0.22.4](https://github.com/pyo3/pyo3/compare/v0.22.3...v0.22.4) - 2024-10-12"
msgstr ""

#: src/changelog.md:511
msgid ""
"Add FFI definition `PyWeakref_GetRef` and `compat::PyWeakref_GetRef`. "
"[\\#4528](https://github.com/PyO3/pyo3/pull/4528)"
msgstr ""

#: src/changelog.md:515
msgid ""
"Deprecate `_borrowed` methods on `PyWeakRef` and `PyWeakrefProxy` (just use "
"the owning forms). [\\#4590](https://github.com/PyO3/pyo3/pull/4590)"
msgstr ""

#: src/changelog.md:519
msgid ""
"Revert removal of private FFI function `_PyLong_NumBits` on Python 3.13 and "
"later. [\\#4450](https://github.com/PyO3/pyo3/pull/4450)"
msgstr ""

#: src/changelog.md:520
msgid ""
"Fix `__traverse__` functions for base classes not being called by subclasses "
"created with `#[pyclass(extends = ...)]`. [\\#4563](https://github.com/PyO3/"
"pyo3/pull/4563)"
msgstr ""

#: src/changelog.md:521
msgid ""
"Fix regression in 0.22.3 failing compiles under `#![forbid(unsafe_code)]`. "
"[\\#4574](https://github.com/PyO3/pyo3/pull/4574)"
msgstr ""

#: src/changelog.md:522
msgid ""
"Fix `create_exception` macro triggering lint and compile errors due to "
"interaction with `gil-refs` feature. [\\#4589](https://github.com/PyO3/pyo3/"
"pull/4589)"
msgstr ""

#: src/changelog.md:523
msgid ""
"Workaround possible use-after-free in `_borrowed` methods on `PyWeakRef` and "
"`PyWeakrefProxy` by leaking their contents. [\\#4590](https://github.com/"
"PyO3/pyo3/pull/4590)"
msgstr ""

#: src/changelog.md:524
msgid ""
"Fix crash calling `PyType_GetSlot` on static types before Python 3.10. "
"[\\#4599](https://github.com/PyO3/pyo3/pull/4599)"
msgstr ""

#: src/changelog.md:527
msgid ""
"[0.22.3](https://github.com/pyo3/pyo3/compare/v0.22.2...v0.22.3) - 2024-09-15"
msgstr ""

#: src/changelog.md:531
msgid ""
"Add `pyo3::ffi::compat` namespace with compatibility shims for C API "
"functions added in recent versions of Python."
msgstr ""

#: src/changelog.md:532
msgid ""
"Add FFI definition `PyDict_GetItemRef` on Python 3.13 and newer, and "
"`compat::PyDict_GetItemRef` for all versions. [\\#4355](https://github.com/"
"PyO3/pyo3/pull/4355)"
msgstr ""

#: src/changelog.md:533
msgid ""
"Add FFI definition `PyList_GetItemRef` on Python 3.13 and newer, and "
"`pyo3_ffi::compat::PyList_GetItemRef` for all versions. [\\#4410](https://"
"github.com/PyO3/pyo3/pull/4410)"
msgstr ""

#: src/changelog.md:534
msgid ""
"Add FFI definitions `compat::Py_NewRef` and `compat::Py_XNewRef`. [\\#4445]"
"(https://github.com/PyO3/pyo3/pull/4445)"
msgstr ""

#: src/changelog.md:535
msgid ""
"Add FFI definitions `compat::PyObject_CallNoArgs` and `compat::"
"PyObject_CallMethodNoArgs`. [\\#4461](https://github.com/PyO3/pyo3/pull/4461)"
msgstr ""

#: src/changelog.md:536
msgid ""
"Add `GilOnceCell<Py<T>>::clone_ref`. [\\#4511](https://github.com/PyO3/pyo3/"
"pull/4511)"
msgstr ""

#: src/changelog.md:540
msgid ""
"Improve error messages for `#[pyfunction]` defined inside `#[pymethods]`. "
"[\\#4349](https://github.com/PyO3/pyo3/pull/4349)"
msgstr ""

#: src/changelog.md:541
msgid ""
"Improve performance of calls to Python by using the vectorcall calling "
"convention where possible. [\\#4456](https://github.com/PyO3/pyo3/pull/4456)"
msgstr ""

#: src/changelog.md:542
msgid ""
"Mention the type name in the exception message when trying to instantiate a "
"class with no constructor defined. [\\#4481](https://github.com/PyO3/pyo3/"
"pull/4481)"
msgstr ""

#: src/changelog.md:546
msgid ""
"Remove private FFI definition `_Py_PackageContext`. [\\#4420](https://github."
"com/PyO3/pyo3/pull/4420)"
msgstr ""

#: src/changelog.md:550 src/changelog.md:574
msgid ""
"Fix compile failure in declarative `#[pymodule]` under presence of `#!"
"[no_implicit_prelude]`. [\\#4328](https://github.com/PyO3/pyo3/pull/4328)"
msgstr ""

#: src/changelog.md:551
msgid ""
"Fix use of borrowed reference in `PyDict::get_item` (unsafe in free-threaded "
"Python). [\\#4355](https://github.com/PyO3/pyo3/pull/4355)"
msgstr ""

#: src/changelog.md:552
msgid ""
"Fix `#[pyclass(eq)]` macro hygiene issues for structs and enums. [\\#4359]"
"(https://github.com/PyO3/pyo3/pull/4359)"
msgstr ""

#: src/changelog.md:553
msgid ""
"Fix hygiene/span issues of `#[pyfunction]` and `#[pymethods]` generated code "
"which affected expansion in `macro_rules` context. [\\#4382](https://github."
"com/PyO3/pyo3/pull/4382)"
msgstr ""

#: src/changelog.md:554
msgid ""
"Fix `unsafe_code` lint error in `#[pyclass]` generated code. [\\#4396]"
"(https://github.com/PyO3/pyo3/pull/4396)"
msgstr ""

#: src/changelog.md:555
msgid ""
"Fix async functions returning a tuple only returning the first element to "
"Python. [\\#4407](https://github.com/PyO3/pyo3/pull/4407)"
msgstr ""

#: src/changelog.md:556
msgid ""
"Fix use of borrowed reference in `PyList::get_item` (unsafe in free-threaded "
"Python). [\\#4410](https://github.com/PyO3/pyo3/pull/4410)"
msgstr ""

#: src/changelog.md:557
msgid ""
"Correct FFI definition `PyArg_ParseTupleAndKeywords` to take `*const *const "
"c_char` instead of `*mut *mut c_char` on Python 3.13 and up. [\\#4420]"
"(https://github.com/PyO3/pyo3/pull/4420)"
msgstr ""

#: src/changelog.md:558
msgid ""
"Fix a soundness bug with `PyClassInitializer`: panic if adding subclass to "
"existing instance via `PyClassInitializer::from(Py<BaseClass>)."
"add_subclass(SubClass)`. [\\#4454](https://github.com/PyO3/pyo3/pull/4454)"
msgstr ""

#: src/changelog.md:559
msgid ""
"Fix illegal reference counting op inside implementation of `__traverse__` "
"handlers. [\\#4479](https://github.com/PyO3/pyo3/pull/4479)"
msgstr ""

#: src/changelog.md:561
msgid ""
"[0.22.2](https://github.com/pyo3/pyo3/compare/v0.22.1...v0.22.2) - 2024-07-17"
msgstr ""

#: src/changelog.md:565
msgid ""
"Require opt-in to freethreaded Python using the "
"`UNSAFE_PYO3_BUILD_FREE_THREADED=1` environment variable (it is not yet "
"supported by PyO3). [\\#4327](https://github.com/PyO3/pyo3/pull/4327)"
msgstr ""

#: src/changelog.md:569
msgid ""
"Use FFI function calls for reference counting on all abi3 versions. [\\#4324]"
"(https://github.com/PyO3/pyo3/pull/4324)"
msgstr ""

#: src/changelog.md:570
msgid ""
"`#[pymodule(...)]` now directly accepts all relevant `#[pyo3(...)]` options. "
"[\\#4330](https://github.com/PyO3/pyo3/pull/4330)"
msgstr ""

#: src/changelog.md:575
msgid ""
"Fix compile failure due to c-string literals on Rust \\< 1.79. [\\#4353]"
"(https://github.com/PyO3/pyo3/pull/4353)"
msgstr ""

#: src/changelog.md:577
msgid ""
"[0.22.1](https://github.com/pyo3/pyo3/compare/v0.22.0...v0.22.1) - 2024-07-06"
msgstr ""

#: src/changelog.md:581
msgid ""
"Add `#[pyo3(submodule)]` option for declarative `#[pymodule]`s. [\\#4301]"
"(https://github.com/PyO3/pyo3/pull/4301)"
msgstr ""

#: src/changelog.md:582
msgid ""
"Implement `PartialEq<bool>` for `Bound<'py, PyBool>`. [\\#4305](https://"
"github.com/PyO3/pyo3/pull/4305)"
msgstr ""

#: src/changelog.md:586
msgid ""
"Return `NotImplemented` instead of raising `TypeError` from generated "
"equality method when comparing different types. [\\#4287](https://github.com/"
"PyO3/pyo3/pull/4287)"
msgstr ""

#: src/changelog.md:587
msgid ""
"Handle full-path `#[pyo3::prelude::pymodule]` and similar for `#[pyclass]` "
"and `#[pyfunction]` in declarative modules. [\\#4288](https://github.com/"
"PyO3/pyo3/pull/4288)"
msgstr ""

#: src/changelog.md:588
msgid ""
"Fix 128-bit int regression on big-endian platforms with Python \\<3.13. "
"[\\#4291](https://github.com/PyO3/pyo3/pull/4291)"
msgstr ""

#: src/changelog.md:589
msgid ""
"Stop generating code that will never be covered with declarative modules. "
"[\\#4297](https://github.com/PyO3/pyo3/pull/4297)"
msgstr ""

#: src/changelog.md:590
msgid ""
"Fix invalid deprecation warning for trailing optional on `#[setter]` "
"function. [\\#4304](https://github.com/PyO3/pyo3/pull/4304)"
msgstr ""

#: src/changelog.md:592
msgid ""
"[0.22.0](https://github.com/pyo3/pyo3/compare/v0.21.2...v0.22.0) - 2024-06-24"
msgstr ""

#: src/changelog.md:596
msgid ""
"Update `heck` dependency to 0.5. [\\#3966](https://github.com/PyO3/pyo3/"
"pull/3966)"
msgstr ""

#: src/changelog.md:597
msgid ""
"Extend range of supported versions of `chrono-tz` optional dependency to "
"include version 0.10. [\\#4061](https://github.com/PyO3/pyo3/pull/4061)"
msgstr ""

#: src/changelog.md:598
msgid "Update MSRV to 1.63. [\\#4129](https://github.com/PyO3/pyo3/pull/4129)"
msgstr ""

#: src/changelog.md:599
msgid ""
"Add optional `num-rational` feature to add conversions with Python's "
"`fractions.Fraction`. [\\#4148](https://github.com/PyO3/pyo3/pull/4148)"
msgstr ""

#: src/changelog.md:600
msgid "Support Python 3.13. [\\#4184](https://github.com/PyO3/pyo3/pull/4184)"
msgstr ""

#: src/changelog.md:604
msgid ""
"Add `PyWeakref`, `PyWeakrefReference` and `PyWeakrefProxy`. [\\#3835]"
"(https://github.com/PyO3/pyo3/pull/3835)"
msgstr ""

#: src/changelog.md:605
msgid ""
"Support `#[pyclass]` on enums that have tuple variants. [\\#4072](https://"
"github.com/PyO3/pyo3/pull/4072)"
msgstr ""

#: src/changelog.md:606
msgid ""
"Add support for scientific notation in `Decimal` conversion. [\\#4079]"
"(https://github.com/PyO3/pyo3/pull/4079)"
msgstr ""

#: src/changelog.md:607
msgid ""
"Add `pyo3_disable_reference_pool` conditional compilation flag to avoid the "
"overhead of the global reference pool at the cost of known limitations as "
"explained in the performance section of the guide. [\\#4095](https://github."
"com/PyO3/pyo3/pull/4095)"
msgstr ""

#: src/changelog.md:608
msgid ""
"Add `#[pyo3(constructor = (...))]` to customize the generated constructors "
"for complex enum variants. [\\#4158](https://github.com/PyO3/pyo3/pull/4158)"
msgstr ""

#: src/changelog.md:609
msgid ""
"Add `PyType::module`, which always matches Python `__module__`. [\\#4196]"
"(https://github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:610
msgid ""
"Add `PyType::fully_qualified_name` which matches the \"fully qualified "
"name\" defined in [PEP 737](https://peps.python.org/pep-0737). [\\#4196]"
"(https://github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:611
msgid ""
"Add `PyTypeMethods::mro` and `PyTypeMethods::bases`. [\\#4197](https://"
"github.com/PyO3/pyo3/pull/4197)"
msgstr ""

#: src/changelog.md:612
msgid ""
"Add `#[pyclass(ord)]` to implement ordering based on `PartialOrd`. [\\#4202]"
"(https://github.com/PyO3/pyo3/pull/4202)"
msgstr ""

#: src/changelog.md:613
msgid ""
"Implement `ToPyObject` and `IntoPy<PyObject>` for `PyBackedStr` and "
"`PyBackedBytes`. [\\#4205](https://github.com/PyO3/pyo3/pull/4205)"
msgstr ""

#: src/changelog.md:614
msgid ""
"Add `#[pyclass(hash)]` option to implement `__hash__` in terms of the `Hash` "
"implementation [\\#4206](https://github.com/PyO3/pyo3/pull/4206)"
msgstr ""

#: src/changelog.md:615
msgid ""
"Add `#[pyclass(eq)]` option to generate `__eq__` based on `PartialEq`, and "
"`#[pyclass(eq_int)]` for simple enums to implement equality based on their "
"discriminants. [\\#4210](https://github.com/PyO3/pyo3/pull/4210)"
msgstr ""

#: src/changelog.md:616
msgid ""
"Implement `From<Bound<'py, T>>` for `PyClassInitializer<T>`. [\\#4214]"
"(https://github.com/PyO3/pyo3/pull/4214)"
msgstr ""

#: src/changelog.md:617
msgid ""
"Add `as_super` methods to `PyRef` and `PyRefMut` for accessing the base "
"class by reference. [\\#4219](https://github.com/PyO3/pyo3/pull/4219)"
msgstr ""

#: src/changelog.md:618
msgid ""
"Implement `PartialEq<str>` for `Bound<'py, PyString>`. [\\#4245](https://"
"github.com/PyO3/pyo3/pull/4245)"
msgstr ""

#: src/changelog.md:619
msgid ""
"Implement `PyModuleMethods::filename` on PyPy. [\\#4249](https://github.com/"
"PyO3/pyo3/pull/4249)"
msgstr ""

#: src/changelog.md:620
msgid ""
"Implement `PartialEq<[u8]>` for `Bound<'py, PyBytes>`. [\\#4250](https://"
"github.com/PyO3/pyo3/pull/4250)"
msgstr ""

#: src/changelog.md:621
msgid ""
"Add `pyo3_ffi::c_str` macro to create `&'static CStr` on Rust versions which "
"don't have 1.77's `c\"\"` literals. [\\#4255](https://github.com/PyO3/pyo3/"
"pull/4255)"
msgstr ""

#: src/changelog.md:622
msgid ""
"Support `bool` conversion with `numpy` 2.0's `numpy.bool` type [\\#4258]"
"(https://github.com/PyO3/pyo3/pull/4258)"
msgstr ""

#: src/changelog.md:623
msgid ""
"Add `PyAnyMethods::{bitnot, matmul, floor_div, rem, divmod}`. [\\#4264]"
"(https://github.com/PyO3/pyo3/pull/4264)"
msgstr ""

#: src/changelog.md:627
msgid ""
"Change the type of `PySliceIndices::slicelength` and the `length` parameter "
"of `PySlice::indices()`. [\\#3761](https://github.com/PyO3/pyo3/pull/3761)"
msgstr ""

#: src/changelog.md:628
msgid ""
"Deprecate implicit default for trailing optional arguments [\\#4078](https://"
"github.com/PyO3/pyo3/pull/4078)"
msgstr ""

#: src/changelog.md:629
msgid ""
"`Clone`ing pointers into the Python heap has been moved behind the `py-"
"clone` feature, as it must panic without the GIL being held as a soundness "
"fix. [\\#4095](https://github.com/PyO3/pyo3/pull/4095)"
msgstr ""

#: src/changelog.md:630
msgid ""
"Add `#[track_caller]` to all `Py<T>`, `Bound<'py, T>` and `Borrowed<'a, 'py, "
"T>` methods which can panic. [\\#4098](https://github.com/PyO3/pyo3/"
"pull/4098)"
msgstr ""

#: src/changelog.md:631
msgid ""
"Change `PyAnyMethods::dir` to be fallible and return `PyResult<Bound<'py, "
"PyList>>` (and similar for `PyAny::dir`). [\\#4100](https://github.com/PyO3/"
"pyo3/pull/4100)"
msgstr ""

#: src/changelog.md:632
msgid ""
"The global reference pool (to track pending reference count decrements) is "
"now initialized lazily to avoid the overhead of taking a mutex upon function "
"entry when the functionality is not actually used. [\\#4178](https://github."
"com/PyO3/pyo3/pull/4178)"
msgstr ""

#: src/changelog.md:633
msgid ""
"Emit error messages when using `weakref` or `dict` when compiling for `abi3` "
"for Python older than 3.9. [\\#4194](https://github.com/PyO3/pyo3/pull/4194)"
msgstr ""

#: src/changelog.md:634
msgid ""
"Change `PyType::name` to always match Python `__name__`. [\\#4196](https://"
"github.com/PyO3/pyo3/pull/4196)"
msgstr ""

#: src/changelog.md:635
msgid ""
"Remove CPython internal ffi call for complex number including: add, sub, "
"mul, div, neg, abs, pow. Added PyAnyMethods::{abs, pos, neg} [\\#4201]"
"(https://github.com/PyO3/pyo3/pull/4201)"
msgstr ""

#: src/changelog.md:636
msgid ""
"Deprecate implicit integer comparison for simple enums in favor of "
"`#[pyclass(eq_int)]`. [\\#4210](https://github.com/PyO3/pyo3/pull/4210)"
msgstr ""

#: src/changelog.md:637
msgid ""
"Set the `module=` attribute of declarative modules' child `#[pymodule]`s and "
"`#[pyclass]`es. [\\#4213](https://github.com/PyO3/pyo3/pull/4213)"
msgstr ""

#: src/changelog.md:638
msgid ""
"Set the `module` option for complex enum variants from the value set on the "
"complex enum `module`. [\\#4228](https://github.com/PyO3/pyo3/pull/4228)"
msgstr ""

#: src/changelog.md:639
msgid ""
"Respect the Python \"limited API\" when building for the `abi3` feature on "
"PyPy or GraalPy. [\\#4237](https://github.com/PyO3/pyo3/pull/4237)"
msgstr ""

#: src/changelog.md:640
msgid ""
"Optimize code generated by `#[pyo3(get)]` on `#[pyclass]` fields. [\\#4254]"
"(https://github.com/PyO3/pyo3/pull/4254)"
msgstr ""

#: src/changelog.md:641
msgid ""
"`PyCFunction::new`, `PyCFunction::new_with_keywords` and `PyCFunction::"
"new_closure` now take `&'static CStr` name and doc arguments (previously was "
"`&'static str`). [\\#4255](https://github.com/PyO3/pyo3/pull/4255)"
msgstr ""

#: src/changelog.md:642
msgid ""
"The `experimental-declarative-modules` feature is now stabilized and "
"available by default. [\\#4257](https://github.com/PyO3/pyo3/pull/4257)"
msgstr ""

#: src/changelog.md:646
msgid ""
"Fix panic when `PYO3_CROSS_LIB_DIR` is set to a missing path. [\\#4043]"
"(https://github.com/PyO3/pyo3/pull/4043)"
msgstr ""

#: src/changelog.md:647
msgid ""
"Fix a compile error when exporting an exception created with "
"`create_exception!` living in a different Rust module using the `declarative-"
"module` feature. [\\#4086](https://github.com/PyO3/pyo3/pull/4086)"
msgstr ""

#: src/changelog.md:648
msgid ""
"Fix FFI definitions of `PY_VECTORCALL_ARGUMENTS_OFFSET` and "
"`PyVectorcall_NARGS` to fix a false-positive assertion. [\\#4104](https://"
"github.com/PyO3/pyo3/pull/4104)"
msgstr ""

#: src/changelog.md:649
msgid ""
"Disable `PyUnicode_DATA` on PyPy: not exposed by PyPy. [\\#4116](https://"
"github.com/PyO3/pyo3/pull/4116)"
msgstr ""

#: src/changelog.md:650
msgid ""
"Correctly handle `#[pyo3(from_py_with = ...)]` attribute on dunder "
"(`__magic__`) method arguments instead of silently ignoring it. [\\#4117]"
"(https://github.com/PyO3/pyo3/pull/4117)"
msgstr ""

#: src/changelog.md:651
msgid ""
"Fix a compile error when declaring a standalone function or class method "
"with a Python name that is a Rust keyword. [\\#4226](https://github.com/PyO3/"
"pyo3/pull/4226)"
msgstr ""

#: src/changelog.md:652
msgid ""
"Fix declarative modules discarding doc comments on the `mod` node. [\\#4236]"
"(https://github.com/PyO3/pyo3/pull/4236)"
msgstr ""

#: src/changelog.md:653
msgid ""
"Fix `__dict__` attribute missing for `#[pyclass(dict)]` instances when "
"building for `abi3` on Python 3.9. [\\#4251](https://github.com/PyO3/pyo3/"
"pull/4251)"
msgstr ""

#: src/changelog.md:655
msgid ""
"[0.21.2](https://github.com/pyo3/pyo3/compare/v0.21.1...v0.21.2) - 2024-04-16"
msgstr ""

#: src/changelog.md:659
msgid ""
"Deprecate the `PySet::empty()` gil-ref constructor. [\\#4082](https://github."
"com/PyO3/pyo3/pull/4082)"
msgstr ""

#: src/changelog.md:663
msgid ""
"Fix compile error for `async fn` in `#[pymethods]` with a `&self` receiver "
"and more than one additional argument. [\\#4035](https://github.com/PyO3/"
"pyo3/pull/4035)"
msgstr ""

#: src/changelog.md:664
msgid ""
"Improve error message for wrong receiver type in `__traverse__`. [\\#4045]"
"(https://github.com/PyO3/pyo3/pull/4045)"
msgstr ""

#: src/changelog.md:665
msgid ""
"Fix compile error when exporting a `#[pyclass]` living in a different Rust "
"module using the `experimental-declarative-modules` feature. [\\#4054]"
"(https://github.com/PyO3/pyo3/pull/4054)"
msgstr ""

#: src/changelog.md:666
msgid ""
"Fix `missing_docs` lint triggering on documented `#[pymodule]` functions. "
"[\\#4067](https://github.com/PyO3/pyo3/pull/4067)"
msgstr ""

#: src/changelog.md:667
msgid ""
"Fix undefined symbol errors for extension modules on AIX (by linking "
"`libpython`). [\\#4073](https://github.com/PyO3/pyo3/pull/4073)"
msgstr ""

#: src/changelog.md:669
msgid ""
"[0.21.1](https://github.com/pyo3/pyo3/compare/v0.21.0...v0.21.1) - 2024-04-01"
msgstr ""

#: src/changelog.md:673
msgid ""
"Implement `Send` and `Sync` for `PyBackedStr` and `PyBackedBytes`. [\\#4007]"
"(https://github.com/PyO3/pyo3/pull/4007)"
msgstr ""

#: src/changelog.md:674
msgid ""
"Implement `Clone`, `Debug`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and "
"`Hash` implementation for `PyBackedBytes` and `PyBackedStr`, and `Display` "
"for `PyBackedStr`. [\\#4020](https://github.com/PyO3/pyo3/pull/4020)"
msgstr ""

#: src/changelog.md:675
msgid ""
"Add `import_exception_bound!` macro to import exception types without "
"generating GIL Ref functionality for them. [\\#4027](https://github.com/PyO3/"
"pyo3/pull/4027)"
msgstr ""

#: src/changelog.md:679
msgid ""
"Emit deprecation warning for uses of GIL Refs as `#[setter]` function "
"arguments. [\\#3998](https://github.com/PyO3/pyo3/pull/3998)"
msgstr ""

#: src/changelog.md:680
msgid ""
"Add `#[inline]` hints on many `Bound` and `Borrowed` methods. [\\#4024]"
"(https://github.com/PyO3/pyo3/pull/4024)"
msgstr ""

#: src/changelog.md:684
msgid ""
"Handle `#[pyo3(from_py_with = \"\")]` in `#[setter]` methods [\\#3995]"
"(https://github.com/PyO3/pyo3/pull/3995)"
msgstr ""

#: src/changelog.md:685
msgid ""
"Allow extraction of `&Bound` in `#[setter]` methods. [\\#3998](https://"
"github.com/PyO3/pyo3/pull/3998)"
msgstr ""

#: src/changelog.md:686
msgid ""
"Fix some uncovered code blocks emitted by `#[pymodule]`, `#[pyfunction]` and "
"`#[pyclass]` macros. [\\#4009](https://github.com/PyO3/pyo3/pull/4009)"
msgstr ""

#: src/changelog.md:687
msgid ""
"Fix typo in the panic message when a class referenced in `pyo3::"
"import_exception!` does not exist. [\\#4012](https://github.com/PyO3/pyo3/"
"pull/4012)"
msgstr ""

#: src/changelog.md:688
msgid ""
"Fix compile error when using an async `#[pymethod]` with a receiver and "
"additional arguments. [\\#4015](https://github.com/PyO3/pyo3/pull/4015)"
msgstr ""

#: src/changelog.md:691
msgid ""
"[0.21.0](https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0) - 2024-03-25"
msgstr ""

#: src/changelog.md:695
msgid ""
"Add support for GraalPy (24.0 and up). [\\#3247](https://github.com/PyO3/"
"pyo3/pull/3247)"
msgstr ""

#: src/changelog.md:696
msgid ""
"Add `PyMemoryView` type. [\\#3514](https://github.com/PyO3/pyo3/pull/3514)"
msgstr ""

#: src/changelog.md:697
msgid ""
"Allow `async fn` in for `#[pyfunction]` and `#[pymethods]`, with the "
"`experimental-async` feature. [\\#3540](https://github.com/PyO3/pyo3/"
"pull/3540) [\\#3588](https://github.com/PyO3/pyo3/pull/3588) [\\#3599]"
"(https://github.com/PyO3/pyo3/pull/3599) [\\#3931](https://github.com/PyO3/"
"pyo3/pull/3931)"
msgstr ""

#: src/changelog.md:698
msgid ""
"Implement `PyTypeInfo` for `PyEllipsis`, `PyNone` and `PyNotImplemented`. "
"[\\#3577](https://github.com/PyO3/pyo3/pull/3577)"
msgstr ""

#: src/changelog.md:699
msgid ""
"Support `#[pyclass]` on enums that have non-unit variants. [\\#3582](https://"
"github.com/PyO3/pyo3/pull/3582)"
msgstr ""

#: src/changelog.md:700
msgid ""
"Support `chrono` feature with `abi3` feature. [\\#3664](https://github.com/"
"PyO3/pyo3/pull/3664)"
msgstr ""

#: src/changelog.md:701
msgid ""
"`FromPyObject`, `IntoPy<PyObject>` and `ToPyObject` are implemented on `std::"
"duration::Duration` [\\#3670](https://github.com/PyO3/pyo3/pull/3670)"
msgstr ""

#: src/changelog.md:702
msgid ""
"Add `PyString::to_cow`. Add `Py<PyString>::to_str`, `Py<PyString>::to_cow`, "
"and `Py<PyString>::to_string_lossy`, as ways to access Python string data "
"safely beyond the GIL lifetime. [\\#3677](https://github.com/PyO3/pyo3/"
"pull/3677)"
msgstr ""

#: src/changelog.md:703
msgid ""
"Add `Bound<T>` and `Borrowed<T>` smart pointers as a new API for accessing "
"Python objects. [\\#3686](https://github.com/PyO3/pyo3/pull/3686)"
msgstr ""

#: src/changelog.md:704
msgid ""
"Add `PyNativeType::as_borrowed` to convert \"GIL refs\" to the new `Bound` "
"smart pointer. [\\#3692](https://github.com/PyO3/pyo3/pull/3692)"
msgstr ""

#: src/changelog.md:705
msgid ""
"Add `FromPyObject::extract_bound` method, to migrate `FromPyObject` "
"implementations to the Bound API. [\\#3706](https://github.com/PyO3/pyo3/"
"pull/3706)"
msgstr ""

#: src/changelog.md:706
msgid ""
"Add `gil-refs` feature to allow continued use of the deprecated GIL Refs "
"APIs. [\\#3707](https://github.com/PyO3/pyo3/pull/3707)"
msgstr ""

#: src/changelog.md:707
msgid ""
"Add methods to `PyAnyMethods` for binary operators (`add`, `sub`, etc.) "
"[\\#3712](https://github.com/PyO3/pyo3/pull/3712)"
msgstr ""

#: src/changelog.md:708
msgid ""
"Add `chrono-tz` feature allowing conversion between `chrono_tz::Tz` and "
"`zoneinfo.ZoneInfo` [\\#3730](https://github.com/PyO3/pyo3/pull/3730)"
msgstr ""

#: src/changelog.md:709
msgid ""
"Add FFI definition `PyType_GetModuleByDef`. [\\#3734](https://github.com/"
"PyO3/pyo3/pull/3734)"
msgstr ""

#: src/changelog.md:710
msgid ""
"Conversion between `std::time::SystemTime` and `datetime.datetime` [\\#3736]"
"(https://github.com/PyO3/pyo3/pull/3736)"
msgstr ""

#: src/changelog.md:711
msgid ""
"Add `Py::as_any` and `Py::into_any`. [\\#3785](https://github.com/PyO3/pyo3/"
"pull/3785)"
msgstr ""

#: src/changelog.md:712
msgid ""
"Add `PyStringMethods::encode_utf8`. [\\#3801](https://github.com/PyO3/pyo3/"
"pull/3801)"
msgstr ""

#: src/changelog.md:713
msgid ""
"Add `PyBackedStr` and `PyBackedBytes`, as alternatives to `&str` and "
"`&bytes` where a Python object owns the data. [\\#3802](https://github.com/"
"PyO3/pyo3/pull/3802) [\\#3991](https://github.com/PyO3/pyo3/pull/3991)"
msgstr ""

#: src/changelog.md:714
msgid ""
"Allow `#[pymodule]` macro on Rust `mod` blocks, with the `experimental-"
"declarative-modules` feature. [\\#3815](https://github.com/PyO3/pyo3/"
"pull/3815)"
msgstr ""

#: src/changelog.md:715
msgid ""
"Implement `ExactSizeIterator` for `set` and `frozenset` iterators on `abi3` "
"feature. [\\#3849](https://github.com/PyO3/pyo3/pull/3849)"
msgstr ""

#: src/changelog.md:716
msgid ""
"Add `Py::drop_ref` to explicitly drop a \\`Py\\`` and immediately decrease "
"the Python reference count if the GIL is already held. [\\#3871](https://"
"github.com/PyO3/pyo3/pull/3871)"
msgstr ""

#: src/changelog.md:717
msgid ""
"Allow `#[pymodule]` macro on single argument functions that take `&Bound<'_, "
"PyModule>`. [\\#3905](https://github.com/PyO3/pyo3/pull/3905)"
msgstr ""

#: src/changelog.md:718
msgid ""
"Implement `FromPyObject` for `Cow<str>`. [\\#3928](https://github.com/PyO3/"
"pyo3/pull/3928)"
msgstr ""

#: src/changelog.md:719
msgid ""
"Implement `Default` for `GILOnceCell`. [\\#3971](https://github.com/PyO3/"
"pyo3/pull/3971)"
msgstr ""

#: src/changelog.md:720
msgid ""
"Add `PyDictMethods::into_mapping`, `PyListMethods::into_sequence` and "
"`PyTupleMethods::into_sequence`. [\\#3982](https://github.com/PyO3/pyo3/"
"pull/3982)"
msgstr ""

#: src/changelog.md:724
msgid ""
"`PyDict::from_sequence` now takes a single argument of type `&PyAny` "
"(previously took two arguments `Python` and `PyObject`). [\\#3532](https://"
"github.com/PyO3/pyo3/pull/3532)"
msgstr ""

#: src/changelog.md:725
msgid ""
"Deprecate `Py::is_ellipsis` and `PyAny::is_ellipsis` in favour of `any.is(py."
"Ellipsis())`. [\\#3577](https://github.com/PyO3/pyo3/pull/3577)"
msgstr ""

#: src/changelog.md:726
msgid ""
"Split some `PyTypeInfo` functionality into new traits `HasPyGilRef` and "
"`PyTypeCheck`. [\\#3600](https://github.com/PyO3/pyo3/pull/3600)"
msgstr ""

#: src/changelog.md:727
msgid ""
"Deprecate `PyTryFrom` and `PyTryInto` traits in favor of `any.downcast()` "
"via the `PyTypeCheck` and `PyTypeInfo` traits. [\\#3601](https://github.com/"
"PyO3/pyo3/pull/3601)"
msgstr ""

#: src/changelog.md:728
msgid ""
"Allow async methods to accept `&self`/`&mut self` [\\#3609](https://github."
"com/PyO3/pyo3/pull/3609)"
msgstr ""

#: src/changelog.md:729
msgid ""
"`FromPyObject` for set types now also accept `frozenset` objects as input. "
"[\\#3632](https://github.com/PyO3/pyo3/pull/3632)"
msgstr ""

#: src/changelog.md:730
msgid ""
"`FromPyObject` for `bool` now also accepts NumPy's `bool_` as input. "
"[\\#3638](https://github.com/PyO3/pyo3/pull/3638)"
msgstr ""

#: src/changelog.md:731
msgid ""
"Add `AsRefSource` associated type to `PyNativeType`. [\\#3653](https://"
"github.com/PyO3/pyo3/pull/3653)"
msgstr ""

#: src/changelog.md:732
msgid ""
"Rename `.is_true` to `.is_truthy` on `PyAny` and `Py<PyAny>` to clarify that "
"the test is not based on identity with or equality to the True singleton. "
"[\\#3657](https://github.com/PyO3/pyo3/pull/3657)"
msgstr ""

#: src/changelog.md:733
msgid ""
"`PyType::name` is now `PyType::qualname` whereas `PyType::name` efficiently "
"accesses the full name which includes the module name. [\\#3660](https://"
"github.com/PyO3/pyo3/pull/3660)"
msgstr ""

#: src/changelog.md:734
msgid ""
"The `Iter(A)NextOutput` types are now deprecated and `__(a)next__` can "
"directly return anything which can be converted into Python objects, i.e. "
"awaitables do not need to be wrapped into `IterANextOutput` or `Option` any "
"more. `Option` can still be used as well and returning `None` will trigger "
"the fast path for `__next__`, stopping iteration without having to raise a "
"`StopIteration` exception. [\\#3661](https://github.com/PyO3/pyo3/pull/3661)"
msgstr ""

#: src/changelog.md:735
msgid ""
"Implement `FromPyObject` on `chrono::DateTime<Tz>` for all `Tz`, not just "
"`FixedOffset` and `Utc`. [\\#3663](https://github.com/PyO3/pyo3/pull/3663)"
msgstr ""

#: src/changelog.md:736
msgid ""
"Add lifetime parameter to `PyTzInfoAccess` trait. For the deprecated gil-ref "
"API, the trait is now implemented for `&'py PyTime` and `&'py PyDateTime` "
"instead of `PyTime` and `PyDate`. [\\#3679](https://github.com/PyO3/pyo3/"
"pull/3679)"
msgstr ""

#: src/changelog.md:737
msgid ""
"Calls to `__traverse__` become no-ops for unsendable pyclasses if on the "
"wrong thread, thereby avoiding hard aborts at the cost of potential leakage. "
"[\\#3689](https://github.com/PyO3/pyo3/pull/3689)"
msgstr ""

#: src/changelog.md:738
msgid ""
"Include `PyNativeType` in `pyo3::prelude`. [\\#3692](https://github.com/PyO3/"
"pyo3/pull/3692)"
msgstr ""

#: src/changelog.md:739
msgid ""
"Improve performance of `extract::<i64>` (and other integer types) by "
"avoiding call to `__index__()` converting the value to an integer for 3.10+. "
"Gives performance improvement of around 30% for successful extraction. "
"[\\#3742](https://github.com/PyO3/pyo3/pull/3742)"
msgstr ""

#: src/changelog.md:740
msgid ""
"Relax bound of `FromPyObject` for `Py<T>` to just `T: PyTypeCheck`. [\\#3776]"
"(https://github.com/PyO3/pyo3/pull/3776)"
msgstr ""

#: src/changelog.md:741
msgid ""
"`PySet` and `PyFrozenSet` iterators now always iterate the equivalent of "
"`iter(set)`. (A \"fast path\" with no noticeable performance benefit was "
"removed.) [\\#3849](https://github.com/PyO3/pyo3/pull/3849)"
msgstr ""

#: src/changelog.md:742
msgid ""
"Move implementations of `FromPyObject` for `&str`, `Cow<str>`, `&[u8]` and "
"`Cow<[u8]>` onto a temporary trait `FromPyObjectBound` when `gil-refs` "
"feature is deactivated. [\\#3928](https://github.com/PyO3/pyo3/pull/3928)"
msgstr ""

#: src/changelog.md:743
msgid ""
"Deprecate `GILPool`, `Python::with_pool`, and `Python::new_pool`. [\\#3947]"
"(https://github.com/PyO3/pyo3/pull/3947)"
msgstr ""

#: src/changelog.md:747
msgid ""
"Remove all functionality deprecated in PyO3 0.19. [\\#3603](https://github."
"com/PyO3/pyo3/pull/3603)"
msgstr ""

#: src/changelog.md:751
msgid ""
"Match PyPy 7.3.14 in removing PyPy-only symbol `Py_MAX_NDIMS` in favour of "
"`PyBUF_MAX_NDIM`. [\\#3757](https://github.com/PyO3/pyo3/pull/3757)"
msgstr ""

#: src/changelog.md:752
msgid ""
"Fix segmentation fault using `datetime` types when an invalid `datetime` "
"module is on sys.path. [\\#3818](https://github.com/PyO3/pyo3/pull/3818)"
msgstr ""

#: src/changelog.md:753
msgid ""
"Fix `non_local_definitions` lint warning triggered by many PyO3 macros. "
"[\\#3901](https://github.com/PyO3/pyo3/pull/3901)"
msgstr ""

#: src/changelog.md:754
msgid ""
"Disable `PyCode` and `PyCode_Type` on PyPy: `PyCode_Type` is not exposed by "
"PyPy. [\\#3934](https://github.com/PyO3/pyo3/pull/3934)"
msgstr ""

#: src/changelog.md:756
msgid ""
"[0.21.0-beta.0](https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0-"
"beta.0) - 2024-03-10"
msgstr ""

#: src/changelog.md:758
msgid ""
"Prerelease of PyO3 0.21. See [the GitHub diff](https://github.com/pyo3/pyo3/"
"compare/v0.21.0-beta.0...v0.21.0) for what changed between 0.21.0-beta.0 and "
"the final release."
msgstr ""

#: src/changelog.md:760
msgid ""
"[0.20.3](https://github.com/pyo3/pyo3/compare/v0.20.2...v0.20.3) - 2024-02-23"
msgstr ""

#: src/changelog.md:764
msgid ""
"Add `portable-atomic` dependency. [\\#3619](https://github.com/PyO3/pyo3/"
"pull/3619)"
msgstr ""

#: src/changelog.md:765
msgid ""
"Check maximum version of Python at build time and for versions not yet "
"supported require opt-in to the `abi3` stable ABI by the environment "
"variable `PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1`. [\\#3821](https://github."
"com/PyO3/pyo3/pull/3821)"
msgstr ""

#: src/changelog.md:769
msgid ""
"Use `portable-atomic` to support platforms without 64-bit atomics. [\\#3619]"
"(https://github.com/PyO3/pyo3/pull/3619)"
msgstr ""

#: src/changelog.md:770
msgid ""
"Fix compilation failure with `either` feature enabled without `experimental-"
"inspect` enabled. [\\#3834](https://github.com/PyO3/pyo3/pull/3834)"
msgstr ""

#: src/changelog.md:772
msgid ""
"[0.20.2](https://github.com/pyo3/pyo3/compare/v0.20.1...v0.20.2) - 2024-01-04"
msgstr ""

#: src/changelog.md:776
msgid ""
"Pin `pyo3` and `pyo3-ffi` dependencies on `pyo3-build-config` to require the "
"same patch version, i.e. `pyo3` 0.20.2 requires _exactly_ `pyo3-build-"
"config` 0.20.2. [\\#3721](https://github.com/PyO3/pyo3/pull/3721)"
msgstr ""

#: src/changelog.md:780
msgid ""
"Fix compile failure when building `pyo3` 0.20.0 with latest `pyo3-build-"
"config` 0.20.X. [\\#3724](https://github.com/PyO3/pyo3/pull/3724)"
msgstr ""

#: src/changelog.md:781
msgid "Fix docs.rs build. [\\#3722](https://github.com/PyO3/pyo3/pull/3722)"
msgstr ""

#: src/changelog.md:783
msgid ""
"[0.20.1](https://github.com/pyo3/pyo3/compare/v0.20.0...v0.20.1) - 2023-12-30"
msgstr ""

#: src/changelog.md:787
msgid ""
"Add optional `either` feature to add conversions for `either::Either<L, R>` "
"sum type. [\\#3456](https://github.com/PyO3/pyo3/pull/3456)"
msgstr ""

#: src/changelog.md:788
msgid ""
"Add optional `smallvec` feature to add conversions for `smallvec::SmallVec`. "
"[\\#3507](https://github.com/PyO3/pyo3/pull/3507)"
msgstr ""

#: src/changelog.md:789
msgid ""
"Add `take` and `into_inner` methods to `GILOnceCell` [\\#3556](https://"
"github.com/PyO3/pyo3/pull/3556)"
msgstr ""

#: src/changelog.md:790
msgid ""
"`#[classmethod]` methods can now also receive `Py<PyType>` as their first "
"argument. [\\#3587](https://github.com/PyO3/pyo3/pull/3587)"
msgstr ""

#: src/changelog.md:791
msgid ""
"`#[pyfunction(pass_module)]` can now also receive `Py<PyModule>` as their "
"first argument. [\\#3587](https://github.com/PyO3/pyo3/pull/3587)"
msgstr ""

#: src/changelog.md:792
msgid ""
"Add `traverse` method to `GILProtected`. [\\#3616](https://github.com/PyO3/"
"pyo3/pull/3616)"
msgstr ""

#: src/changelog.md:793
msgid ""
"Added `abi3-py312` feature [\\#3687](https://github.com/PyO3/pyo3/pull/3687)"
msgstr ""

#: src/changelog.md:797
msgid ""
"Fix minimum version specification for optional `chrono` dependency. [\\#3512]"
"(https://github.com/PyO3/pyo3/pull/3512)"
msgstr ""

#: src/changelog.md:798
msgid ""
"Silenced new `clippy::unnecessary_fallible_conversions` warning when using a "
"`Py<Self>` `self` receiver. [\\#3564](https://github.com/PyO3/pyo3/pull/3564)"
msgstr ""

#: src/changelog.md:801
msgid ""
"[0.20.0](https://github.com/pyo3/pyo3/compare/v0.19.2...v0.20.0) - 2023-10-11"
msgstr ""

#: src/changelog.md:805
msgid ""
"Dual-license PyO3 under either the Apache 2.0 OR the MIT license. This makes "
"the project GPLv2 compatible. [\\#3108](https://github.com/PyO3/pyo3/"
"pull/3108)"
msgstr ""

#: src/changelog.md:806
msgid ""
"Update MSRV to Rust 1.56. [\\#3208](https://github.com/PyO3/pyo3/pull/3208)"
msgstr ""

#: src/changelog.md:807
msgid ""
"Bump `indoc` dependency to 2.0 and `unindent` dependency to 0.2. [\\#3237]"
"(https://github.com/PyO3/pyo3/pull/3237)"
msgstr ""

#: src/changelog.md:808
msgid ""
"Bump `syn` dependency to 2.0. [\\#3239](https://github.com/PyO3/pyo3/"
"pull/3239)"
msgstr ""

#: src/changelog.md:809
msgid ""
"Drop support for debug builds of Python 3.7. [\\#3387](https://github.com/"
"PyO3/pyo3/pull/3387)"
msgstr ""

#: src/changelog.md:810
msgid ""
"Bump `chrono` optional dependency to require 0.4.25 or newer. [\\#3427]"
"(https://github.com/PyO3/pyo3/pull/3427)"
msgstr ""

#: src/changelog.md:811
msgid "Support Python 3.12. [\\#3488](https://github.com/PyO3/pyo3/pull/3488)"
msgstr ""

#: src/changelog.md:815
msgid ""
"Support `__lt__`, `__le__`, `__eq__`, `__ne__`, `__gt__` and `__ge__` in "
"`#[pymethods]`. [\\#3203](https://github.com/PyO3/pyo3/pull/3203)"
msgstr ""

#: src/changelog.md:816
msgid ""
"Add FFI definition `Py_GETENV`. [\\#3336](https://github.com/PyO3/pyo3/"
"pull/3336)"
msgstr ""

#: src/changelog.md:817
msgid ""
"Add `as_ptr` and `into_ptr` inherent methods for `Py`, `PyAny`, `PyRef`, and "
"`PyRefMut`. [\\#3359](https://github.com/PyO3/pyo3/pull/3359)"
msgstr ""

#: src/changelog.md:818
msgid ""
"Implement `DoubleEndedIterator` for `PyTupleIterator` and `PyListIterator`. "
"[\\#3366](https://github.com/PyO3/pyo3/pull/3366)"
msgstr ""

#: src/changelog.md:819
msgid ""
"Add `#[pyclass(rename_all = \"...\")]` option: this allows renaming all "
"getters and setters of a struct, or all variants of an enum. Available "
"renaming rules are: `\"camelCase\"`, `\"kebab-case\"`, `\"lowercase\"`, "
"`\"PascalCase\"`, `\"SCREAMING-KEBAB-CASE\"`, `\"SCREAMING_SNAKE_CASE\"`, "
"`\"snake_case\"`, `\"UPPERCASE\"`. [\\#3384](https://github.com/PyO3/pyo3/"
"pull/3384)"
msgstr ""

#: src/changelog.md:820
msgid ""
"Add FFI definitions `PyObject_GC_IsTracked` and `PyObject_GC_IsFinalized` on "
"Python 3.9 and up (PyPy 3.10 and up). [\\#3403](https://github.com/PyO3/pyo3/"
"pull/3403)"
msgstr ""

#: src/changelog.md:821
msgid ""
"Add types for `None`, `Ellipsis`, and `NotImplemented`. [\\#3408](https://"
"github.com/PyO3/pyo3/pull/3408)"
msgstr ""

#: src/changelog.md:822
msgid ""
"Add FFI definitions for the `Py_mod_multiple_interpreters` constant and its "
"possible values. [\\#3494](https://github.com/PyO3/pyo3/pull/3494)"
msgstr ""

#: src/changelog.md:823
msgid ""
"Add FFI definitions for `PyInterpreterConfig` struct, its constants and "
"`Py_NewInterpreterFromConfig`. [\\#3502](https://github.com/PyO3/pyo3/"
"pull/3502)"
msgstr ""

#: src/changelog.md:827
msgid ""
"Change `PySet::discard` to return `PyResult<bool>` (previously returned "
"nothing). [\\#3281](https://github.com/PyO3/pyo3/pull/3281)"
msgstr ""

#: src/changelog.md:828
msgid ""
"Optimize implementation of `IntoPy` for Rust tuples to Python tuples. "
"[\\#3321](https://github.com/PyO3/pyo3/pull/3321)"
msgstr ""

#: src/changelog.md:829
msgid ""
"Change `PyDict::get_item` to no longer suppress arbitrary exceptions (the "
"return type is now `PyResult<Option<&PyAny>>` instead of `Option<&PyAny>`), "
"and deprecate `PyDict::get_item_with_error`. [\\#3330](https://github.com/"
"PyO3/pyo3/pull/3330)"
msgstr ""

#: src/changelog.md:830
msgid ""
"Deprecate FFI definitions which are deprecated in Python 3.12. [\\#3336]"
"(https://github.com/PyO3/pyo3/pull/3336)"
msgstr ""

#: src/changelog.md:831
msgid ""
"`AsPyPointer` is now an `unsafe trait`. [\\#3358](https://github.com/PyO3/"
"pyo3/pull/3358)"
msgstr ""

#: src/changelog.md:832
msgid ""
"Accept all `os.PathLike` values in implementation of `FromPyObject` for "
"`PathBuf`. [\\#3374](https://github.com/PyO3/pyo3/pull/3374)"
msgstr ""

#: src/changelog.md:833
msgid ""
"Add `__builtins__` to globals in `py.run()` and `py.eval()` if they're "
"missing. [\\#3378](https://github.com/PyO3/pyo3/pull/3378)"
msgstr ""

#: src/changelog.md:834
msgid ""
"Optimize implementation of `FromPyObject` for `BigInt` and `BigUint`. "
"[\\#3379](https://github.com/PyO3/pyo3/pull/3379)"
msgstr ""

#: src/changelog.md:835
msgid ""
"`PyIterator::from_object` and `PyByteArray::from` now take a single argument "
"of type `&PyAny` (previously took two arguments `Python` and `AsPyPointer`). "
"[\\#3389](https://github.com/PyO3/pyo3/pull/3389)"
msgstr ""

#: src/changelog.md:836
msgid ""
"Replace `AsPyPointer` with `AsRef<PyAny>` as a bound in the blanket "
"implementation of `From<&T> for PyObject`. [\\#3391](https://github.com/PyO3/"
"pyo3/pull/3391)"
msgstr ""

#: src/changelog.md:837
msgid ""
"Replace blanket `impl IntoPy<PyObject> for &T where T: AsPyPointer` with "
"implementations of `impl IntoPy<PyObject>` for `&PyAny`, `&T where T: "
"AsRef<PyAny>`, and `&Py<T>`. [\\#3393](https://github.com/PyO3/pyo3/"
"pull/3393)"
msgstr ""

#: src/changelog.md:838
msgid ""
"Preserve `std::io::Error` kind in implementation of `From<std::io::"
"IntoInnerError>` for `PyErr` [\\#3396](https://github.com/PyO3/pyo3/"
"pull/3396)"
msgstr ""

#: src/changelog.md:839
msgid ""
"Try to select a relevant `ErrorKind` in implementation of `From<PyErr>` for "
"`OSError` subclass. [\\#3397](https://github.com/PyO3/pyo3/pull/3397)"
msgstr ""

#: src/changelog.md:840
msgid ""
"Retrieve the original `PyErr` in implementation of `From<std::io::Error>` "
"for `PyErr` if the `std::io::Error` has been built using a Python exception "
"(previously would create a new exception wrapping the `std::io::Error`). "
"[\\#3402](https://github.com/PyO3/pyo3/pull/3402)"
msgstr ""

#: src/changelog.md:841
msgid ""
"`#[pymodule]` will now return the same module object on repeated import by "
"the same Python interpreter, on Python 3.9 and up. [\\#3446](https://github."
"com/PyO3/pyo3/pull/3446)"
msgstr ""

#: src/changelog.md:842
msgid ""
"Truncate leap-seconds and warn when converting `chrono` types to Python "
"`datetime` types (`datetime` cannot represent leap-seconds). [\\#3458]"
"(https://github.com/PyO3/pyo3/pull/3458)"
msgstr ""

#: src/changelog.md:843
msgid ""
"`Err` returned from `#[pyfunction]` will now have a non-None `__context__` "
"if called from inside a `catch` block. [\\#3455](https://github.com/PyO3/"
"pyo3/pull/3455)"
msgstr ""

#: src/changelog.md:844
msgid ""
"Deprecate undocumented `#[__new__]` form of `#[new]` attribute. [\\#3505]"
"(https://github.com/PyO3/pyo3/pull/3505)"
msgstr ""

#: src/changelog.md:848
msgid ""
"Remove all functionality deprecated in PyO3 0.18, including `#[args]` "
"attribute for `#[pymethods]`. [\\#3232](https://github.com/PyO3/pyo3/"
"pull/3232)"
msgstr ""

#: src/changelog.md:849
msgid ""
"Remove `IntoPyPointer` trait in favour of `into_ptr` inherent methods. "
"[\\#3385](https://github.com/PyO3/pyo3/pull/3385)"
msgstr ""

#: src/changelog.md:853
msgid ""
"Handle exceptions properly in `PySet::discard`. [\\#3281](https://github.com/"
"PyO3/pyo3/pull/3281)"
msgstr ""

#: src/changelog.md:854
msgid ""
"The `PyTupleIterator` type returned by `PyTuple::iter` is now public and "
"hence can be named by downstream crates. [\\#3366](https://github.com/PyO3/"
"pyo3/pull/3366)"
msgstr ""

#: src/changelog.md:855
msgid ""
"Linking of `PyOS_FSPath` on PyPy. [\\#3374](https://github.com/PyO3/pyo3/"
"pull/3374)"
msgstr ""

#: src/changelog.md:856
msgid ""
"Fix memory leak in `PyTypeBuilder::build`. [\\#3401](https://github.com/PyO3/"
"pyo3/pull/3401)"
msgstr ""

#: src/changelog.md:857
msgid ""
"Disable removed FFI definitions `_Py_GetAllocatedBlocks`, "
"`_PyObject_GC_Malloc`, and `_PyObject_GC_Calloc` on Python 3.11 and up. "
"[\\#3403](https://github.com/PyO3/pyo3/pull/3403)"
msgstr ""

#: src/changelog.md:858
msgid ""
"Fix `ResourceWarning` and crashes related to GC when running with debug "
"builds of CPython. [\\#3404](https://github.com/PyO3/pyo3/pull/3404)"
msgstr ""

#: src/changelog.md:859
msgid ""
"Some-wrapping of `Option<T>` default arguments will no longer re-wrap "
"`Some(T)` or expressions evaluating to `None`. [\\#3461](https://github.com/"
"PyO3/pyo3/pull/3461)"
msgstr ""

#: src/changelog.md:860
msgid ""
"Fix `IterNextOutput::Return` not returning a value on PyPy. [\\#3471]"
"(https://github.com/PyO3/pyo3/pull/3471)"
msgstr ""

#: src/changelog.md:861
msgid ""
"Emit compile errors instead of ignoring macro invocations inside "
"`#[pymethods]` blocks. [\\#3491](https://github.com/PyO3/pyo3/pull/3491)"
msgstr ""

#: src/changelog.md:862
msgid ""
"Emit error on invalid arguments to `#[new]`, `#[classmethod]`, "
"`#[staticmethod]`, and `#[classattr]`. [\\#3484](https://github.com/PyO3/"
"pyo3/pull/3484)"
msgstr ""

#: src/changelog.md:863
msgid ""
"Disable `PyMarshal_WriteObjectToString` from "
"`PyMarshal_ReadObjectFromString` with the `abi3` feature. [\\#3490](https://"
"github.com/PyO3/pyo3/pull/3490)"
msgstr ""

#: src/changelog.md:864
msgid ""
"Fix FFI definitions for `_PyFrameEvalFunction` on Python 3.11 and up (it now "
"receives a `_PyInterpreterFrame` opaque struct). [\\#3500](https://github."
"com/PyO3/pyo3/pull/3500)"
msgstr ""

#: src/changelog.md:867
msgid ""
"[0.19.2](https://github.com/pyo3/pyo3/compare/v0.19.1...v0.19.2) - 2023-08-01"
msgstr ""

#: src/changelog.md:871
msgid ""
"Add FFI definitions `PyState_AddModule`, `PyState_RemoveModule` and "
"`PyState_FindModule` for PyPy 3.9 and up. [\\#3295](https://github.com/PyO3/"
"pyo3/pull/3295)"
msgstr ""

#: src/changelog.md:872
msgid ""
"Add FFI definitions `_PyObject_CallFunction_SizeT` and "
"`_PyObject_CallMethod_SizeT`. [\\#3297](https://github.com/PyO3/pyo3/"
"pull/3297)"
msgstr ""

#: src/changelog.md:873
msgid ""
"Add a \"performance\" section to the guide collecting performance-related "
"tricks and problems. [\\#3304](https://github.com/PyO3/pyo3/pull/3304)"
msgstr ""

#: src/changelog.md:874
msgid ""
"Add `PyErr::Display` for all Python versions, and FFI symbol "
"`PyErr_DisplayException` for Python 3.12. [\\#3334](https://github.com/PyO3/"
"pyo3/pull/3334)"
msgstr ""

#: src/changelog.md:875
msgid ""
"Add FFI definition `PyType_GetDict()` for Python 3.12. [\\#3339](https://"
"github.com/PyO3/pyo3/pull/3339)"
msgstr ""

#: src/changelog.md:876
msgid ""
"Add `PyAny::downcast_exact`. [\\#3346](https://github.com/PyO3/pyo3/"
"pull/3346)"
msgstr ""

#: src/changelog.md:877
msgid ""
"Add `PySlice::full()` to construct a full slice (`::`). [\\#3353](https://"
"github.com/PyO3/pyo3/pull/3353)"
msgstr ""

#: src/changelog.md:881
msgid ""
"Update `PyErr` for 3.12 betas to avoid deprecated ffi methods. [\\#3306]"
"(https://github.com/PyO3/pyo3/pull/3306)"
msgstr ""

#: src/changelog.md:882
msgid ""
"Update FFI definitions of `object.h` for Python 3.12.0b4. [\\#3335](https://"
"github.com/PyO3/pyo3/pull/3335)"
msgstr ""

#: src/changelog.md:883
msgid ""
"Update `pyo3::ffi` struct definitions to be compatible with 3.12.0b4. "
"[\\#3342](https://github.com/PyO3/pyo3/pull/3342)"
msgstr ""

#: src/changelog.md:884
msgid ""
"Optimize conversion of `float` to `f64` (and `PyFloat::value`) on non-abi3 "
"builds. [\\#3345](https://github.com/PyO3/pyo3/pull/3345)"
msgstr ""

#: src/changelog.md:888
msgid ""
"Fix timezone conversion bug for FixedOffset datetimes that were being "
"incorrectly converted to and from UTC. [\\#3269](https://github.com/PyO3/"
"pyo3/pull/3269)"
msgstr ""

#: src/changelog.md:889
msgid ""
"Fix `SystemError` raised in `PyUnicodeDecodeError_Create` on PyPy 3.10. "
"[\\#3297](https://github.com/PyO3/pyo3/pull/3297)"
msgstr ""

#: src/changelog.md:890
msgid ""
"Correct FFI definition `Py_EnterRecursiveCall` to return `c_int` (was "
"incorrectly returning `()`). [\\#3300](https://github.com/PyO3/pyo3/"
"pull/3300)"
msgstr ""

#: src/changelog.md:891
msgid ""
"Fix case where `PyErr::matches` and `PyErr::is_instance` returned results "
"inconsistent with `PyErr::get_type`. [\\#3313](https://github.com/PyO3/pyo3/"
"pull/3313)"
msgstr ""

#: src/changelog.md:892
msgid ""
"Fix loss of panic message in `PanicException` when unwinding after the "
"exception was \"normalized\". [\\#3326](https://github.com/PyO3/pyo3/"
"pull/3326)"
msgstr ""

#: src/changelog.md:893
msgid ""
"Fix `PyErr::from_value` and `PyErr::into_value` losing traceback on "
"conversion. [\\#3328](https://github.com/PyO3/pyo3/pull/3328)"
msgstr ""

#: src/changelog.md:894
msgid ""
"Fix reference counting of immortal objects on Python 3.12.0b4. [\\#3335]"
"(https://github.com/PyO3/pyo3/pull/3335)"
msgstr ""

#: src/changelog.md:897
msgid ""
"[0.19.1](https://github.com/pyo3/pyo3/compare/v0.19.0...v0.19.1) - 2023-07-03"
msgstr ""

#: src/changelog.md:901
msgid ""
"Extend range of supported versions of `hashbrown` optional dependency to "
"include version 0.14 [\\#3258](https://github.com/PyO3/pyo3/pull/3258)"
msgstr ""

#: src/changelog.md:902
msgid ""
"Extend range of supported versions of `indexmap` optional dependency to "
"include version 2. [\\#3277](https://github.com/PyO3/pyo3/pull/3277)"
msgstr ""

#: src/changelog.md:903
msgid "Support PyPy 3.10. [\\#3289](https://github.com/PyO3/pyo3/pull/3289)"
msgstr ""

#: src/changelog.md:907
msgid ""
"Add `pyo3::types::PyFrozenSetBuilder` to allow building a `PyFrozenSet` item "
"by item. [\\#3156](https://github.com/PyO3/pyo3/pull/3156)"
msgstr ""

#: src/changelog.md:908
msgid ""
"Add support for converting to and from Python's `ipaddress.IPv4Address`/"
"`ipaddress.IPv6Address` and `std::net::IpAddr`. [\\#3197](https://github.com/"
"PyO3/pyo3/pull/3197)"
msgstr ""

#: src/changelog.md:909
msgid ""
"Add support for `num-bigint` feature in combination with `abi3`. [\\#3198]"
"(https://github.com/PyO3/pyo3/pull/3198)"
msgstr ""

#: src/changelog.md:910
msgid ""
"Add `PyErr_GetRaisedException()`, `PyErr_SetRaisedException()` to FFI "
"definitions for Python 3.12 and later. [\\#3248](https://github.com/PyO3/"
"pyo3/pull/3248)"
msgstr ""

#: src/changelog.md:911
msgid ""
"Add `Python::with_pool` which is a safer but more limited alternative to "
"`Python::new_pool`. [\\#3263](https://github.com/PyO3/pyo3/pull/3263)"
msgstr ""

#: src/changelog.md:912
msgid ""
"Add `PyDict::get_item_with_error` on PyPy. [\\#3270](https://github.com/PyO3/"
"pyo3/pull/3270)"
msgstr ""

#: src/changelog.md:913
msgid ""
"Allow `#[new]` methods may to return `Py<Self>` in order to return existing "
"instances. [\\#3287](https://github.com/PyO3/pyo3/pull/3287)"
msgstr ""

#: src/changelog.md:917
msgid ""
"Fix conversion of classes implementing `__complex__` to `Complex` when using "
"`abi3` or PyPy. [\\#3185](https://github.com/PyO3/pyo3/pull/3185)"
msgstr ""

#: src/changelog.md:918
msgid ""
"Stop suppressing unrelated exceptions in `PyAny::hasattr`. [\\#3271](https://"
"github.com/PyO3/pyo3/pull/3271)"
msgstr ""

#: src/changelog.md:919
msgid ""
"Fix memory leak when creating `PySet` or `PyFrozenSet` or returning types "
"converted into these internally, e.g. `HashSet` or `BTreeSet`. [\\#3286]"
"(https://github.com/PyO3/pyo3/pull/3286)"
msgstr ""

#: src/changelog.md:922
msgid ""
"[0.19.0](https://github.com/pyo3/pyo3/compare/v0.18.3...v0.19.0) - 2023-05-31"
msgstr ""

#: src/changelog.md:926
msgid ""
"Correct dependency on syn to version 1.0.85 instead of the incorrect version "
"1.0.56. [\\#3152](https://github.com/PyO3/pyo3/pull/3152)"
msgstr ""

#: src/changelog.md:930
msgid ""
"Accept `text_signature` option (and automatically generate signature) for "
"`#[new]` in `#[pymethods]`. [\\#2980](https://github.com/PyO3/pyo3/pull/2980)"
msgstr ""

#: src/changelog.md:931
msgid ""
"Add support for converting to and from Python's `decimal.Decimal` and "
"`rust_decimal::Decimal`. [\\#3016](https://github.com/PyO3/pyo3/pull/3016)"
msgstr ""

#: src/changelog.md:932
msgid ""
"Add `#[pyo3(from_item_all)]` when deriving `FromPyObject` to specify "
"`get_item` as getter for all fields. [\\#3120](https://github.com/PyO3/pyo3/"
"pull/3120)"
msgstr ""

#: src/changelog.md:933
msgid ""
"Add `pyo3::exceptions::PyBaseExceptionGroup` for Python 3.11, and "
"corresponding FFI definition `PyExc_BaseExceptionGroup`. [\\#3141](https://"
"github.com/PyO3/pyo3/pull/3141)"
msgstr ""

#: src/changelog.md:934
msgid ""
"Accept `#[new]` with `#[classmethod]` to create a constructor which receives "
"a (subtype's) class/`PyType` as its first argument. [\\#3157](https://github."
"com/PyO3/pyo3/pull/3157)"
msgstr ""

#: src/changelog.md:935
msgid ""
"Add `PyClass::get` and `Py::get` for GIL-independent access to classes with "
"`#[pyclass(frozen)]`. [\\#3158](https://github.com/PyO3/pyo3/pull/3158)"
msgstr ""

#: src/changelog.md:936
msgid ""
"Add `PyAny::is_exact_instance` and `PyAny::is_exact_instance_of`. [\\#3161]"
"(https://github.com/PyO3/pyo3/pull/3161)"
msgstr ""

#: src/changelog.md:940
msgid ""
"`PyAny::is_instance_of::<T>(obj)` is now equivalent to `T::is_type_of(obj)`, "
"and now returns `bool` instead of `PyResult<bool>`. [\\#2881](https://github."
"com/PyO3/pyo3/pull/2881)"
msgstr ""

#: src/changelog.md:941
msgid ""
"Deprecate `text_signature` option on `#[pyclass]` structs. [\\#2980](https://"
"github.com/PyO3/pyo3/pull/2980)"
msgstr ""

#: src/changelog.md:942
msgid ""
"No longer wrap `anyhow::Error`/`eyre::Report` containing a basic `PyErr` "
"without a chain in a `PyRuntimeError`. [\\#3004](https://github.com/PyO3/"
"pyo3/pull/3004)"
msgstr ""

#: src/changelog.md:943
msgid ""
"Change `#[getter]` and `#[setter]` to use a common call \"trampoline\" to "
"slightly reduce generated code size and compile times. [\\#3029](https://"
"github.com/PyO3/pyo3/pull/3029)"
msgstr ""

#: src/changelog.md:944
msgid ""
"Improve default values for str, numbers and bool in automatically-generated "
"`text_signature`. [\\#3050](https://github.com/PyO3/pyo3/pull/3050)"
msgstr ""

#: src/changelog.md:945
msgid ""
"Improve default value for `None` in automatically-generated "
"`text_signature`. [\\#3066](https://github.com/PyO3/pyo3/pull/3066)"
msgstr ""

#: src/changelog.md:946
msgid ""
"Rename `PySequence::list` and `PySequence::tuple` to `PySequence::to_list` "
"and `PySequence::to_tuple`. (The old names continue to exist as deprecated "
"forms.) [\\#3111](https://github.com/PyO3/pyo3/pull/3111)"
msgstr ""

#: src/changelog.md:947
msgid ""
"Extend the lifetime of the GIL token returned by `PyRef::py` and `PyRefMut::"
"py` to match the underlying borrow. [\\#3131](https://github.com/PyO3/pyo3/"
"pull/3131)"
msgstr ""

#: src/changelog.md:948
msgid ""
"Safe access to the GIL, for example via `Python::with_gil`, is now locked "
"inside of implementations of the `__traverse__` slot. [\\#3168](https://"
"github.com/PyO3/pyo3/pull/3168)"
msgstr ""

#: src/changelog.md:952
msgid ""
"Remove all functionality deprecated in PyO3 0.17, most prominently `Python::"
"acquire_gil` is replaced by `Python::with_gil`. [\\#2981](https://github.com/"
"PyO3/pyo3/pull/2981)"
msgstr ""

#: src/changelog.md:956
msgid ""
"Correct FFI definitions `PyGetSetDef`, `PyMemberDef`, "
"`PyStructSequence_Field` and `PyStructSequence_Desc` to have `*const c_char` "
"members for `name` and `doc` (not `*mut c_char`). [\\#3036](https://github."
"com/PyO3/pyo3/pull/3036)"
msgstr ""

#: src/changelog.md:957
msgid ""
"Fix panic on `fmt::Display`, instead return `\"<unprintable object>\"` "
"string and report error via `sys.unraisablehook()` [\\#3062](https://github."
"com/PyO3/pyo3/pull/3062)"
msgstr ""

#: src/changelog.md:958
msgid ""
"Fix a compile error of \"temporary value dropped while borrowed\" when "
"`#[pyfunction]`s take references into `#[pyclass]`es [\\#3142](https://"
"github.com/PyO3/pyo3/pull/3142)"
msgstr ""

#: src/changelog.md:959
msgid ""
"Fix crashes caused by PyO3 applying deferred reference count updates when "
"entering a `__traverse__` implementation. [\\#3168](https://github.com/PyO3/"
"pyo3/pull/3168)"
msgstr ""

#: src/changelog.md:960
msgid ""
"Forbid running the `Drop` implementations of unsendable classes on other "
"threads. [\\#3176](https://github.com/PyO3/pyo3/pull/3176)"
msgstr ""

#: src/changelog.md:961
msgid ""
"Fix a compile error when `#[pymethods]` items come from somewhere else (for "
"example, as a macro argument) and a custom receiver like `Py<Self>` is used. "
"[\\#3178](https://github.com/PyO3/pyo3/pull/3178)"
msgstr ""

#: src/changelog.md:964
msgid ""
"[0.18.3](https://github.com/pyo3/pyo3/compare/v0.18.2...v0.18.3) - 2023-04-13"
msgstr ""

#: src/changelog.md:968
msgid ""
"Add `GILProtected<T>` to mediate concurrent access to a value using Python's "
"global interpreter lock (GIL). [\\#2975](https://github.com/PyO3/pyo3/"
"pull/2975)"
msgstr ""

#: src/changelog.md:969
msgid ""
"Support `PyASCIIObject` / `PyUnicode` and associated methods on big-endian "
"architectures. [\\#3015](https://github.com/PyO3/pyo3/pull/3015)"
msgstr ""

#: src/changelog.md:970
msgid ""
"Add FFI definition `_PyDict_Contains_KnownHash()` for CPython 3.10 and up. "
"[\\#3088](https://github.com/PyO3/pyo3/pull/3088)"
msgstr ""

#: src/changelog.md:974
msgid ""
"Fix compile error for `#[pymethods]` and `#[pyfunction]` called \"output\". "
"[\\#3022](https://github.com/PyO3/pyo3/pull/3022)"
msgstr ""

#: src/changelog.md:975
msgid ""
"Fix compile error in generated code for magic methods implemented as a "
"`#[staticmethod]`. [\\#3055](https://github.com/PyO3/pyo3/pull/3055)"
msgstr ""

#: src/changelog.md:976
msgid ""
"Fix `is_instance` for `PyDateTime` (would incorrectly check for a `PyDate`). "
"[\\#3071](https://github.com/PyO3/pyo3/pull/3071)"
msgstr ""

#: src/changelog.md:977
msgid ""
"Fix upstream deprecation of `PyUnicode_InternImmortal` since Python 3.10. "
"[\\#3071](https://github.com/PyO3/pyo3/pull/3087)"
msgstr ""

#: src/changelog.md:980
msgid ""
"[0.18.2](https://github.com/pyo3/pyo3/compare/v0.18.1...v0.18.2) - 2023-03-24"
msgstr ""

#: src/changelog.md:984
msgid ""
"Disable default features of `chrono` to avoid depending on `time` v0.1.x. "
"[\\#2939](https://github.com/PyO3/pyo3/pull/2939)"
msgstr ""

#: src/changelog.md:988
msgid ""
"Implement `IntoPy<PyObject>`, `ToPyObject` and `FromPyObject` for "
"`Cow<[u8]>` to efficiently handle both `bytes` and `bytearray` objects. "
"[\\#2899](https://github.com/PyO3/pyo3/pull/2899)"
msgstr ""

#: src/changelog.md:989
msgid ""
"Implement `IntoPy<PyObject>`, `ToPyObject` and `FromPyObject` for `Cell<T>`. "
"[\\#3014](https://github.com/PyO3/pyo3/pull/3014)"
msgstr ""

#: src/changelog.md:990
msgid ""
"Add `PyList::to_tuple()`, as a convenient and efficient conversion from "
"lists to tuples. [\\#3042](https://github.com/PyO3/pyo3/pull/3042)"
msgstr ""

#: src/changelog.md:991
msgid ""
"Add `PyTuple::to_list()`, as a convenient and efficient conversion from "
"tuples to lists. [\\#3044](https://github.com/PyO3/pyo3/pull/3044)"
msgstr ""

#: src/changelog.md:995
msgid ""
"Optimize `PySequence` conversion for `list` and `tuple` inputs. [\\#2944]"
"(https://github.com/PyO3/pyo3/pull/2944)"
msgstr ""

#: src/changelog.md:996
msgid ""
"Improve exception raised when creating `#[pyclass]` type object fails during "
"module import. [\\#2947](https://github.com/PyO3/pyo3/pull/2947)"
msgstr ""

#: src/changelog.md:997
msgid ""
"Optimize `PyMapping` conversion for `dict` inputs. [\\#2954](https://github."
"com/PyO3/pyo3/pull/2954)"
msgstr ""

#: src/changelog.md:998
msgid ""
"Allow `create_exception!` to take a `dotted.module` to place the exception "
"in a submodule. [\\#2979](https://github.com/PyO3/pyo3/pull/2979)"
msgstr ""

#: src/changelog.md:1002
msgid ""
"Fix a reference counting race condition affecting `PyObject`s cloned in "
"`allow_threads` blocks. [\\#2952](https://github.com/PyO3/pyo3/pull/2952)"
msgstr ""

#: src/changelog.md:1003
msgid ""
"Fix `clippy::redundant_closure` lint on default arguments in "
"`#[pyo3(signature = (...))]` annotations. [\\#2990](https://github.com/PyO3/"
"pyo3/pull/2990)"
msgstr ""

#: src/changelog.md:1004
msgid ""
"Fix `non_snake_case` lint on generated code in `#[pyfunction]` macro. "
"[\\#2993](https://github.com/PyO3/pyo3/pull/2993)"
msgstr ""

#: src/changelog.md:1005
msgid ""
"Fix some FFI definitions for the upcoming PyPy 3.10 release. [\\#3031]"
"(https://github.com/PyO3/pyo3/pull/3031)"
msgstr ""

#: src/changelog.md:1008
msgid ""
"[0.18.1](https://github.com/pyo3/pyo3/compare/v0.18.0...v0.18.1) - 2023-02-07"
msgstr ""

#: src/changelog.md:1012
msgid ""
"Add `PyErr::write_unraisable()`. [\\#2889](https://github.com/PyO3/pyo3/"
"pull/2889)"
msgstr ""

#: src/changelog.md:1013
msgid ""
"Add `Python::Ellipsis()` and `PyAny::is_ellipsis()` methods. [\\#2911]"
"(https://github.com/PyO3/pyo3/pull/2911)"
msgstr ""

#: src/changelog.md:1014
msgid ""
"Add `PyDict::update()` and `PyDict::update_if_missing()` methods. [\\#2912]"
"(https://github.com/PyO3/pyo3/pull/2912)"
msgstr ""

#: src/changelog.md:1018
msgid ""
"FFI definition `PyIter_Check` on CPython 3.7 is now implemented as "
"`hasattr(type(obj), \"__next__\")`, which works correctly on all platforms "
"and adds support for `abi3`. [\\#2914](https://github.com/PyO3/pyo3/"
"pull/2914)"
msgstr ""

#: src/changelog.md:1019
msgid ""
"Warn about unknown config keys in `PYO3_CONFIG_FILE` instead of denying. "
"[\\#2926](https://github.com/PyO3/pyo3/pull/2926)"
msgstr ""

#: src/changelog.md:1023
msgid ""
"Send errors returned by `__releasebuffer__` to `sys.unraisablehook` rather "
"than causing `SystemError`. [\\#2886](https://github.com/PyO3/pyo3/pull/2886)"
msgstr ""

#: src/changelog.md:1024
msgid ""
"Fix downcast to `PyIterator` succeeding for Python classes which did not "
"implement `__next__`. [\\#2914](https://github.com/PyO3/pyo3/pull/2914)"
msgstr ""

#: src/changelog.md:1025
msgid ""
"Fix segfault in `__traverse__` when visiting `None` fields of `Option<T: "
"AsPyPointer>`. [\\#2921](https://github.com/PyO3/pyo3/pull/2921)"
msgstr ""

#: src/changelog.md:1026
msgid ""
"Fix `#[pymethods(crate = \"...\")]` option being ignored. [\\#2923](https://"
"github.com/PyO3/pyo3/pull/2923)"
msgstr ""

#: src/changelog.md:1027
msgid ""
"Link against `pythonXY_d.dll` for debug Python builds on Windows. [\\#2937]"
"(https://github.com/PyO3/pyo3/pull/2937)"
msgstr ""

#: src/changelog.md:1030
msgid ""
"[0.18.0](https://github.com/pyo3/pyo3/compare/v0.17.3...v0.18.0) - 2023-01-17"
msgstr ""

#: src/changelog.md:1034
msgid ""
"Relax `indexmap` optional depecency to allow `>= 1.6, < 2`. [\\#2849]"
"(https://github.com/PyO3/pyo3/pull/2849)"
msgstr ""

#: src/changelog.md:1035
msgid ""
"Relax `hashbrown` optional dependency to allow `>= 0.9, < 0.14`. [\\#2875]"
"(https://github.com/PyO3/pyo3/pull/2875)"
msgstr ""

#: src/changelog.md:1036
msgid ""
"Update `memoffset` dependency to 0.8. [\\#2875](https://github.com/PyO3/pyo3/"
"pull/2875)"
msgstr ""

#: src/changelog.md:1040
msgid ""
"Add `GILOnceCell::get_or_try_init` for fallible `GILOnceCell` "
"initialization. [\\#2398](https://github.com/PyO3/pyo3/pull/2398)"
msgstr ""

#: src/changelog.md:1041
msgid ""
"Add experimental feature `experimental-inspect` with `type_input()` and "
"`type_output()` helpers to get the Python type of any Python-compatible "
"object. [\\#2490](https://github.com/PyO3/pyo3/pull/2490) [\\#2882](https://"
"github.com/PyO3/pyo3/pull/2882)"
msgstr ""

#: src/changelog.md:1042
msgid ""
"The `#[pyclass]` macro can now take `get_all` and `set_all` to create "
"getters and setters for every field. [\\#2692](https://github.com/PyO3/pyo3/"
"pull/2692)"
msgstr ""

#: src/changelog.md:1043
msgid ""
"Add `#[pyo3(signature = (...))]` option for `#[pyfunction]` and "
"`#[pymethods]`. [\\#2702](https://github.com/PyO3/pyo3/pull/2702)"
msgstr ""

#: src/changelog.md:1044
msgid ""
"`pyo3-build-config`: rebuild when `PYO3_ENVIRONMENT_SIGNATURE` environment "
"variable value changes. [\\#2727](https://github.com/PyO3/pyo3/pull/2727)"
msgstr ""

#: src/changelog.md:1045
msgid ""
"Add conversions between non-zero int types in `std::num` and Python `int`. "
"[\\#2730](https://github.com/PyO3/pyo3/pull/2730)"
msgstr ""

#: src/changelog.md:1046
msgid ""
"Add `Py::downcast()` as a companion to `PyAny::downcast()`, as well as "
"`downcast_unchecked()` for both types. [\\#2734](https://github.com/PyO3/"
"pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:1047
msgid ""
"Add types for all built-in `Warning` classes as well as `PyErr::"
"warn_explicit`. [\\#2742](https://github.com/PyO3/pyo3/pull/2742)"
msgstr ""

#: src/changelog.md:1048
msgid ""
"Add `abi3-py311` feature. [\\#2776](https://github.com/PyO3/pyo3/pull/2776)"
msgstr ""

#: src/changelog.md:1049
msgid ""
"Add FFI definition `_PyErr_ChainExceptions()` for CPython. [\\#2788](https://"
"github.com/PyO3/pyo3/pull/2788)"
msgstr ""

#: src/changelog.md:1050
msgid ""
"Add FFI definitions `PyVectorcall_NARGS` and "
"`PY_VECTORCALL_ARGUMENTS_OFFSET` for PyPy 3.8 and up. [\\#2811](https://"
"github.com/PyO3/pyo3/pull/2811)"
msgstr ""

#: src/changelog.md:1051
msgid ""
"Add `PyList::get_item_unchecked` for PyPy. [\\#2827](https://github.com/PyO3/"
"pyo3/pull/2827)"
msgstr ""

#: src/changelog.md:1055
msgid ""
"PyO3's macros now emit a much nicer error message if function return values "
"don't implement the required trait(s). [\\#2664](https://github.com/PyO3/"
"pyo3/pull/2664)"
msgstr ""

#: src/changelog.md:1056
msgid ""
"Use a TypeError, rather than a ValueError, when refusing to treat a str as a "
"Vec. [\\#2685](https://github.com/PyO3/pyo3/pull/2685)"
msgstr ""

#: src/changelog.md:1057
msgid ""
"Change `PyCFunction::new_closure` to take `name` and `doc` arguments. "
"[\\#2686](https://github.com/PyO3/pyo3/pull/2686)"
msgstr ""

#: src/changelog.md:1058
msgid ""
"`PyType::is_subclass`, `PyErr::is_instance` and `PyAny::is_instance` now "
"take `&PyAny` instead of `&PyType` arguments, so that they work with objects "
"that pretend to be types using `__subclasscheck__` and `__instancecheck__`. "
"[\\#2695](https://github.com/PyO3/pyo3/pull/2695)"
msgstr ""

#: src/changelog.md:1059
msgid ""
"Deprecate `#[args]` attribute and passing \"args\" specification directly to "
"`#[pyfunction]` in favor of the new `#[pyo3(signature = (...))]` option. "
"[\\#2702](https://github.com/PyO3/pyo3/pull/2702)"
msgstr ""

#: src/changelog.md:1060
msgid ""
"Deprecate required arguments after `Option<T>` arguments to `#[pyfunction]` "
"and `#[pymethods]` without also using `#[pyo3(signature)]` to specify "
"whether the arguments should be required or have defaults. [\\#2703](https://"
"github.com/PyO3/pyo3/pull/2703)"
msgstr ""

#: src/changelog.md:1061
msgid ""
"Change `#[pyfunction]` and `#[pymethods]` to use a common call "
"\"trampoline\" to slightly reduce generated code size and compile times. "
"[\\#2705](https://github.com/PyO3/pyo3/pull/2705)"
msgstr ""

#: src/changelog.md:1062
msgid ""
"`PyAny::cast_as()` and `Py::cast_as()` are now deprecated in favor of "
"`PyAny::downcast()` and the new `Py::downcast()`. [\\#2734](https://github."
"com/PyO3/pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:1063
msgid ""
"Relax lifetime bounds on `PyAny::downcast()`. [\\#2734](https://github.com/"
"PyO3/pyo3/pull/2734)"
msgstr ""

#: src/changelog.md:1064
msgid ""
"Automatically generate `__text_signature__` for all Python functions created "
"using `#[pyfunction]` and `#[pymethods]`. [\\#2784](https://github.com/PyO3/"
"pyo3/pull/2784)"
msgstr ""

#: src/changelog.md:1065
msgid ""
"Accept any iterator in `PySet::new` and `PyFrozenSet::new`. [\\#2795]"
"(https://github.com/PyO3/pyo3/pull/2795)"
msgstr ""

#: src/changelog.md:1066
msgid ""
"Mixing `#[cfg(...)]` and `#[pyo3(...)]` attributes on `#[pyclass]` struct "
"fields will now work. [\\#2796](https://github.com/PyO3/pyo3/pull/2796)"
msgstr ""

#: src/changelog.md:1067
msgid ""
"Re-enable `PyFunction` on when building for abi3 or PyPy. [\\#2838](https://"
"github.com/PyO3/pyo3/pull/2838)"
msgstr ""

#: src/changelog.md:1068
msgid ""
"Improve `derive(FromPyObject)` to use `intern!` when applicable for "
"`#[pyo3(item)]`. [\\#2879](https://github.com/PyO3/pyo3/pull/2879)"
msgstr ""

#: src/changelog.md:1072
msgid ""
"Remove the deprecated `pyproto` feature, `#[pyproto]` macro, and all "
"accompanying APIs. [\\#2587](https://github.com/PyO3/pyo3/pull/2587)"
msgstr ""

#: src/changelog.md:1073
msgid ""
"Remove all functionality deprecated in PyO3 0.16. [\\#2843](https://github."
"com/PyO3/pyo3/pull/2843)"
msgstr ""

#: src/changelog.md:1077
msgid ""
"Disable `PyModule::filename` on PyPy. [\\#2715](https://github.com/PyO3/pyo3/"
"pull/2715)"
msgstr ""

#: src/changelog.md:1078
msgid ""
"`PyCodeObject` is now once again defined with fields on Python 3.7. [\\#2726]"
"(https://github.com/PyO3/pyo3/pull/2726)"
msgstr ""

#: src/changelog.md:1079
msgid ""
"Raise a `TypeError` if `#[new]` pymethods with no arguments receive "
"arguments when called from Python. [\\#2749](https://github.com/PyO3/pyo3/"
"pull/2749)"
msgstr ""

#: src/changelog.md:1080
msgid ""
"Use the `NOARGS` argument calling convention for methods that have a single "
"`py: Python` argument (as a performance optimization). [\\#2760](https://"
"github.com/PyO3/pyo3/pull/2760)"
msgstr ""

#: src/changelog.md:1081
msgid ""
"Fix truncation of `isize` values to `c_long` in `PySlice::new`. [\\#2769]"
"(https://github.com/PyO3/pyo3/pull/2769)"
msgstr ""

#: src/changelog.md:1082
msgid ""
"Fix soundness issue with FFI definition `PyUnicodeDecodeError_Create` on "
"PyPy leading to indeterminate behavior (typically a `TypeError`). [\\#2772]"
"(https://github.com/PyO3/pyo3/pull/2772)"
msgstr ""

#: src/changelog.md:1083
msgid ""
"Allow functions taking `**kwargs` to accept keyword arguments which share a "
"name with a positional-only argument (as permitted by PEP 570). [\\#2800]"
"(https://github.com/PyO3/pyo3/pull/2800)"
msgstr ""

#: src/changelog.md:1084
msgid ""
"Fix unresolved symbol for `PyObject_Vectorcall` on PyPy 3.9 and up. [\\#2811]"
"(https://github.com/PyO3/pyo3/pull/2811)"
msgstr ""

#: src/changelog.md:1085
msgid ""
"Fix memory leak in `PyCFunction::new_closure`. [\\#2842](https://github.com/"
"PyO3/pyo3/pull/2842)"
msgstr ""

#: src/changelog.md:1088
msgid ""
"[0.17.3](https://github.com/pyo3/pyo3/compare/v0.17.2...v0.17.3) - 2022-11-01"
msgstr ""

#: src/changelog.md:1092
msgid ""
"Support Python 3.11. (Previous versions of PyO3 0.17 have been tested "
"against Python 3.11 release candidates and are expected to be compatible, "
"this is the first version tested against Python 3.11.0.) [\\#2708](https://"
"github.com/PyO3/pyo3/pull/2708)"
msgstr ""

#: src/changelog.md:1096
msgid ""
"Implemented `ExactSizeIterator` for `PyListIterator`, `PyDictIterator`, "
"`PySetIterator` and `PyFrozenSetIterator`. [\\#2676](https://github.com/PyO3/"
"pyo3/pull/2676)"
msgstr ""

#: src/changelog.md:1100
msgid ""
"Fix regression of `impl FromPyObject for [T; N]` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since version 0.17.0. This "
"the same fix that was applied `impl FromPyObject for Vec<T>` in version "
"0.17.1 extended to fixed-size arrays. [\\#2675](https://github.com/PyO3/pyo3/"
"pull/2675)"
msgstr ""

#: src/changelog.md:1101
msgid ""
"Fix UB in `FunctionDescription::extract_arguments_fastcall` due to creating "
"slices from a null pointer. [\\#2687](https://github.com/PyO3/pyo3/pull/2687)"
msgstr ""

#: src/changelog.md:1104
msgid ""
"[0.17.2](https://github.com/pyo3/pyo3/compare/v0.17.1...v0.17.2) - 2022-10-04"
msgstr ""

#: src/changelog.md:1108
msgid ""
"Added optional `chrono` feature to convert `chrono` types into types in the "
"`datetime` module. [\\#2612](https://github.com/PyO3/pyo3/pull/2612)"
msgstr ""

#: src/changelog.md:1112
msgid ""
"Add support for `num-bigint` feature on `PyPy`. [\\#2626](https://github.com/"
"PyO3/pyo3/pull/2626)"
msgstr ""

#: src/changelog.md:1116
msgid ""
"Correctly implement `__richcmp__` for enums, fixing `__ne__` returning "
"always returning `True`. [\\#2622](https://github.com/PyO3/pyo3/pull/2622)"
msgstr ""

#: src/changelog.md:1117
msgid ""
"Fix compile error since 0.17.0 with `Option<&SomePyClass>` argument with a "
"default. [\\#2630](https://github.com/PyO3/pyo3/pull/2630)"
msgstr ""

#: src/changelog.md:1118
msgid ""
"Fix regression of `impl FromPyObject for Vec<T>` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since 0.17.0. [\\#2631]"
"(https://github.com/PyO3/pyo3/pull/2631)"
msgstr ""

#: src/changelog.md:1120
msgid ""
"[0.17.1](https://github.com/pyo3/pyo3/compare/v0.17.0...v0.17.1) - 2022-08-28"
msgstr ""

#: src/changelog.md:1124
msgid ""
"Fix visibility of `PyDictItems`, `PyDictKeys`, and `PyDictValues` types "
"added in PyO3 0.17.0."
msgstr ""

#: src/changelog.md:1125
msgid ""
"Fix compile failure when using `#[pyo3(from_py_with = \"...\")]` attribute "
"on an argument of type `Option<T>`. [\\#2592](https://github.com/PyO3/pyo3/"
"pull/2592)"
msgstr ""

#: src/changelog.md:1126
msgid ""
"Fix clippy `redundant-closure` lint on `**kwargs` arguments for "
"`#[pyfunction]` and `#[pymethods]`. [\\#2595](https://github.com/PyO3/pyo3/"
"pull/2595)"
msgstr ""

#: src/changelog.md:1128
msgid ""
"[0.17.0](https://github.com/pyo3/pyo3/compare/v0.16.6...v0.17.0) - 2022-08-23"
msgstr ""

#: src/changelog.md:1132
msgid ""
"Update inventory dependency to `0.3` (the `multiple-pymethods` feature now "
"requires Rust 1.62 for correctness). [\\#2492](https://github.com/PyO3/pyo3/"
"pull/2492)"
msgstr ""

#: src/changelog.md:1136
msgid "Add `timezone_utc`. [\\#1588](https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:1137
msgid ""
"Implement `ToPyObject` for `[T; N]`. [\\#2313](https://github.com/PyO3/pyo3/"
"pull/2313)"
msgstr ""

#: src/changelog.md:1138
msgid ""
"Add `PyDictKeys`, `PyDictValues` and `PyDictItems` Rust types. [\\#2358]"
"(https://github.com/PyO3/pyo3/pull/2358)"
msgstr ""

#: src/changelog.md:1139
msgid ""
"Add `append_to_inittab`. [\\#2377](https://github.com/PyO3/pyo3/pull/2377)"
msgstr ""

#: src/changelog.md:1140
msgid ""
"Add FFI definition `PyFrame_GetCode`. [\\#2406](https://github.com/PyO3/pyo3/"
"pull/2406)"
msgstr ""

#: src/changelog.md:1141
msgid ""
"Add `PyCode` and `PyFrame` high level objects. [\\#2408](https://github.com/"
"PyO3/pyo3/pull/2408)"
msgstr ""

#: src/changelog.md:1142
msgid ""
"Add FFI definitions `Py_fstring_input`, `sendfunc`, and `_PyErr_StackItem`. "
"[\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:1143
msgid ""
"Add `PyDateTime::new_with_fold`, `PyTime::new_with_fold`, `PyTime::"
"get_fold`, and `PyDateTime::get_fold` for PyPy. [\\#2428](https://github.com/"
"PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:1144
msgid ""
"Add `#[pyclass(frozen)]`. [\\#2448](https://github.com/PyO3/pyo3/pull/2448)"
msgstr ""

#: src/changelog.md:1145
msgid ""
"Accept `#[pyo3(name)]` on enum variants. [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:1146
msgid ""
"Add `CompareOp::matches` to implement `__richcmp__` as the result of a Rust "
"`std::cmp::Ordering` comparison. [\\#2460](https://github.com/PyO3/pyo3/"
"pull/2460)"
msgstr ""

#: src/changelog.md:1147
msgid "Add `PySuper` type. [\\#2486](https://github.com/PyO3/pyo3/pull/2486)"
msgstr ""

#: src/changelog.md:1148
msgid ""
"Support PyPy on Windows with the `generate-import-lib` feature. [\\#2506]"
"(https://github.com/PyO3/pyo3/pull/2506)"
msgstr ""

#: src/changelog.md:1149
msgid ""
"Add FFI definitions `Py_EnterRecursiveCall` and `Py_LeaveRecursiveCall`. "
"[\\#2511](https://github.com/PyO3/pyo3/pull/2511)"
msgstr ""

#: src/changelog.md:1150
msgid ""
"Add `PyDict::get_item_with_error`. [\\#2536](https://github.com/PyO3/pyo3/"
"pull/2536)"
msgstr ""

#: src/changelog.md:1151
msgid ""
"Add `#[pyclass(sequence)]` option. [\\#2567](https://github.com/PyO3/pyo3/"
"pull/2567)"
msgstr ""

#: src/changelog.md:1155
msgid ""
"Change datetime constructors taking a `tzinfo` to take `Option<&PyTzInfo>` "
"instead of `Option<&PyObject>`: `PyDateTime::new`, `PyDateTime::"
"new_with_fold`, `PyTime::new`, and `PyTime::new_with_fold`. [\\#1588]"
"(https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:1156
msgid ""
"Move `PyTypeObject::type_object` method to the `PyTypeInfo` trait, and "
"deprecate the `PyTypeObject` trait. [\\#2287](https://github.com/PyO3/pyo3/"
"pull/2287)"
msgstr ""

#: src/changelog.md:1157
msgid ""
"Methods of `Py` and `PyAny` now accept `impl IntoPy<Py<PyString>>` rather "
"than just `&str` to allow use of the `intern!` macro. [\\#2312](https://"
"github.com/PyO3/pyo3/pull/2312)"
msgstr ""

#: src/changelog.md:1158
msgid ""
"Change the deprecated `pyproto` feature to be opt-in instead of opt-out. "
"[\\#2322](https://github.com/PyO3/pyo3/pull/2322)"
msgstr ""

#: src/changelog.md:1159
msgid ""
"Emit better error messages when `#[pyfunction]` return types do not "
"implement `IntoPy`. [\\#2326](https://github.com/PyO3/pyo3/pull/2326)"
msgstr ""

#: src/changelog.md:1160
msgid ""
"Require `T: IntoPy` for `impl<T, const N: usize> IntoPy<PyObject> for [T; "
"N]` instead of `T: ToPyObject`. [\\#2326](https://github.com/PyO3/pyo3/"
"pull/2326)"
msgstr ""

#: src/changelog.md:1161
msgid ""
"Deprecate the `ToBorrowedObject` trait. [\\#2333](https://github.com/PyO3/"
"pyo3/pull/2333)"
msgstr ""

#: src/changelog.md:1162 src/changelog.md:1163
msgid ""
"Iterators over `PySet` and `PyDict` will now panic if the underlying "
"collection is mutated during the iteration. [\\#2380](https://github.com/"
"PyO3/pyo3/pull/2380)"
msgstr ""

#: src/changelog.md:1164
msgid ""
"Allow `#[classattr]` methods to be fallible. [\\#2385](https://github.com/"
"PyO3/pyo3/pull/2385)"
msgstr ""

#: src/changelog.md:1165
msgid ""
"Prevent multiple `#[pymethods]` with the same name for a single "
"`#[pyclass]`. [\\#2399](https://github.com/PyO3/pyo3/pull/2399)"
msgstr ""

#: src/changelog.md:1166
msgid ""
"Fixup `lib_name` when using `PYO3_CONFIG_FILE`. [\\#2404](https://github.com/"
"PyO3/pyo3/pull/2404)"
msgstr ""

#: src/changelog.md:1167
msgid ""
"Add a message to the `ValueError` raised by the `#[derive(FromPyObject)]` "
"implementation for a tuple struct. [\\#2414](https://github.com/PyO3/pyo3/"
"pull/2414)"
msgstr ""

#: src/changelog.md:1168
msgid ""
"Allow `#[classattr]` methods to take `Python` argument. [\\#2456](https://"
"github.com/PyO3/pyo3/pull/2456)"
msgstr ""

#: src/changelog.md:1169
msgid ""
"Rework `PyCapsule` type to resolve soundness issues: [\\#2485](https://"
"github.com/PyO3/pyo3/pull/2485)"
msgstr ""

#: src/changelog.md:1170
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take `name: "
"Option<CString>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:1171
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` must now be `Send`."
msgstr ""

#: src/changelog.md:1172
msgid ""
"`PyCapsule::get_context` deprecated in favor of `PyCapsule::context` which "
"doesn't take a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:1173
msgid "`PyCapsule::set_context` no longer takes a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:1174
msgid ""
"`PyCapsule::name` now returns `PyResult<Option<&CStr>>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:1175
msgid ""
"`FromPyObject::extract` for `Vec<T>` no longer accepts Python `str` inputs. "
"[\\#2500](https://github.com/PyO3/pyo3/pull/2500)"
msgstr ""

#: src/changelog.md:1176
msgid ""
"Ensure each `#[pymodule]` is only initialized once. [\\#2523](https://github."
"com/PyO3/pyo3/pull/2523)"
msgstr ""

#: src/changelog.md:1177
msgid ""
"`pyo3_build_config::add_extension_module_link_args` now also emits linker "
"arguments for `wasm32-unknown-emscripten`. [\\#2538](https://github.com/PyO3/"
"pyo3/pull/2538)"
msgstr ""

#: src/changelog.md:1178
msgid ""
"Type checks for `PySequence` and `PyMapping` now require inputs to inherit "
"from (or register with) `collections.abc.Sequence` and `collections.abc."
"Mapping` respectively. [\\#2477](https://github.com/PyO3/pyo3/pull/2477)"
msgstr ""

#: src/changelog.md:1179
msgid ""
"Disable `PyFunction` on when building for abi3 or PyPy. [\\#2542](https://"
"github.com/PyO3/pyo3/pull/2542)"
msgstr ""

#: src/changelog.md:1180
msgid ""
"Deprecate `Python::acquire_gil`. [\\#2549](https://github.com/PyO3/pyo3/"
"pull/2549)"
msgstr ""

#: src/changelog.md:1184
msgid ""
"Remove all functionality deprecated in PyO3 0.15. [\\#2283](https://github."
"com/PyO3/pyo3/pull/2283)"
msgstr ""

#: src/changelog.md:1185
msgid ""
"Make the `Dict`, `WeakRef` and `BaseNativeType` members of the `PyClass` "
"private implementation details. [\\#2572](https://github.com/PyO3/pyo3/"
"pull/2572)"
msgstr ""

#: src/changelog.md:1189
msgid ""
"Enable incorrectly disabled FFI definition `PyThreadState_DeleteCurrent`. "
"[\\#2357](https://github.com/PyO3/pyo3/pull/2357)"
msgstr ""

#: src/changelog.md:1190
msgid ""
"Fix `wrap_pymodule` interactions with name resolution rules: it no longer "
"\"sees through\" glob imports of `use submodule::*` when `submodule::"
"submodule` is a `#[pymodule]`. [\\#2363](https://github.com/PyO3/pyo3/"
"pull/2363)"
msgstr ""

#: src/changelog.md:1191
msgid ""
"Correct FFI definition `PyEval_EvalCodeEx` to take `*const *mut PyObject` "
"array arguments instead of `*mut *mut PyObject`. [\\#2368](https://github."
"com/PyO3/pyo3/pull/2368)"
msgstr ""

#: src/changelog.md:1192
msgid ""
"Fix \"raw-ident\" structs (e.g. `#[pyclass] struct r#RawName`) incorrectly "
"having `r#` at the start of the class name created in Python. [\\#2395]"
"(https://github.com/PyO3/pyo3/pull/2395)"
msgstr ""

#: src/changelog.md:1193
msgid ""
"Correct FFI definition `Py_tracefunc` to be `unsafe extern \"C\" fn` (was "
"previously safe). [\\#2407](https://github.com/PyO3/pyo3/pull/2407)"
msgstr ""

#: src/changelog.md:1194
msgid ""
"Fix compile failure with `#[pyo3(from_py_with = \"...\")]` annotations on a "
"field in a `#[derive(FromPyObject)]` struct. [\\#2414](https://github.com/"
"PyO3/pyo3/pull/2414)"
msgstr ""

#: src/changelog.md:1195
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"lacking leading underscores in their names. [\\#2421](https://github.com/"
"PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:1196
msgid ""
"Remove FFI definition `PyArena` on Python 3.10 and up. [\\#2421](https://"
"github.com/PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:1197
msgid ""
"Fix FFI definition `PyCompilerFlags` missing member `cf_feature_version` on "
"Python 3.8 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:1198
msgid ""
"Fix FFI definition `PyAsyncMethods` missing member `am_send` on Python 3.10 "
"and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:1199
msgid ""
"Fix FFI definition `PyGenObject` having multiple incorrect members on "
"various Python versions. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:1200
msgid ""
"Fix FFI definition `PySyntaxErrorObject` missing members `end_lineno` and "
"`end_offset` on Python 3.10 and up. [\\#2423](https://github.com/PyO3/pyo3/"
"pull/2423)"
msgstr ""

#: src/changelog.md:1201
msgid ""
"Fix FFI definition `PyHeapTypeObject` missing member `ht_module` on Python "
"3.9 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:1202
msgid ""
"Fix FFI definition `PyFrameObject` having multiple incorrect members on "
"various Python versions. [\\#2424](https://github.com/PyO3/pyo3/pull/2424) "
"[\\#2434](https://github.com/PyO3/pyo3/pull/2434)"
msgstr ""

#: src/changelog.md:1203
msgid ""
"Fix FFI definition `PyTypeObject` missing deprecated field `tp_print` on "
"Python 3.8. [\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:1204
msgid ""
"Fix FFI definitions `PyDateTime_CAPI`. `PyDateTime_Date`, `PyASCIIObject`, "
"`PyBaseExceptionObject`, `PyListObject`, and `PyTypeObject` on PyPy. "
"[\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:1205
msgid ""
"Fix FFI definition `_inittab` field `initfunc` typo'd as `initfun`. [\\#2431]"
"(https://github.com/PyO3/pyo3/pull/2431)"
msgstr ""

#: src/changelog.md:1206
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"incorrectly having `fold` member. [\\#2432](https://github.com/PyO3/pyo3/"
"pull/2432)"
msgstr ""

#: src/changelog.md:1207
msgid ""
"Fix FFI definitions `PyTypeObject`. `PyHeapTypeObject`, and "
"`PyCFunctionObject` having incorrect members on PyPy 3.9. [\\#2433](https://"
"github.com/PyO3/pyo3/pull/2433)"
msgstr ""

#: src/changelog.md:1208
msgid ""
"Fix FFI definition `PyGetSetDef` to have `*const c_char` for `doc` member "
"(not `*mut c_char`). [\\#2439](https://github.com/PyO3/pyo3/pull/2439)"
msgstr ""

#: src/changelog.md:1209
msgid ""
"Fix `#[pyo3(from_py_with = \"...\")]` being ignored for 1-element tuple "
"structs and transparent structs. [\\#2440](https://github.com/PyO3/pyo3/"
"pull/2440)"
msgstr ""

#: src/changelog.md:1210
msgid ""
"Use `memoffset` to avoid UB when computing `PyCell` layout. [\\#2450]"
"(https://github.com/PyO3/pyo3/pull/2450)"
msgstr ""

#: src/changelog.md:1211
msgid ""
"Fix incorrect enum names being returned by the generated `repr` for enums "
"renamed by `#[pyclass(name = \"...\")]` [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:1212
msgid ""
"Fix `PyObject_CallNoArgs` incorrectly being available when building for abi3 "
"on Python 3.9. [\\#2476](https://github.com/PyO3/pyo3/pull/2476)"
msgstr ""

#: src/changelog.md:1213
msgid ""
"Fix several clippy warnings generated by `#[pyfunction]` arguments. [\\#2503]"
"(https://github.com/PyO3/pyo3/pull/2503)"
msgstr ""

#: src/changelog.md:1215
msgid ""
"[0.16.6](https://github.com/pyo3/pyo3/compare/v0.16.5...v0.16.6) - 2022-08-23"
msgstr ""

#: src/changelog.md:1219
msgid ""
"Fix soundness issues with `PyCapsule` type with select workarounds. Users "
"are encourage to upgrade to PyO3 0.17 at their earliest convenience which "
"contains API breakages which fix the issues in a long-term fashion. [\\#2522]"
"(https://github.com/PyO3/pyo3/pull/2522)"
msgstr ""

#: src/changelog.md:1220
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take ownership of "
"a copy of the `name` to resolve a possible use-after-free."
msgstr ""

#: src/changelog.md:1221
msgid ""
"`PyCapsule::name` now returns an empty `CStr` instead of dereferencing a "
"null pointer if the capsule has no name."
msgstr ""

#: src/changelog.md:1222
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` will never be called "
"if the capsule is deleted from a thread other than the one which the capsule "
"was created in (a warning will be emitted)."
msgstr ""

#: src/changelog.md:1223
msgid ""
"Panics during drop of panic payload caught by PyO3 will now abort. [\\#2544]"
"(https://github.com/PyO3/pyo3/pull/2544)"
msgstr ""

#: src/changelog.md:1225
msgid ""
"[0.16.5](https://github.com/pyo3/pyo3/compare/v0.16.4...v0.16.5) - 2022-05-15"
msgstr ""

#: src/changelog.md:1229
msgid ""
"Add an experimental `generate-import-lib` feature to support auto-generating "
"non-abi3 python import libraries for Windows targets. [\\#2364](https://"
"github.com/PyO3/pyo3/pull/2364)"
msgstr ""

#: src/changelog.md:1230
msgid ""
"Add FFI definition `Py_ExitStatusException`. [\\#2374](https://github.com/"
"PyO3/pyo3/pull/2374)"
msgstr ""

#: src/changelog.md:1234
msgid ""
"Deprecate experimental `generate-abi3-import-lib` feature in favor of the "
"new `generate-import-lib` feature. [\\#2364](https://github.com/PyO3/pyo3/"
"pull/2364)"
msgstr ""

#: src/changelog.md:1238
msgid ""
"Added missing `warn_default_encoding` field to `PyConfig` on 3.10+. The "
"previously missing field could result in incorrect behavior or crashes. "
"[\\#2370](https://github.com/PyO3/pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:1239
msgid ""
"Fixed order of `pathconfig_warnings` and `program_name` fields of `PyConfig` "
"on 3.10+. Previously, the order of the fields was swapped and this could "
"lead to incorrect behavior or crashes. [\\#2370](https://github.com/PyO3/"
"pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:1241
msgid ""
"[0.16.4](https://github.com/pyo3/pyo3/compare/v0.16.3...v0.16.4) - 2022-04-14"
msgstr ""

#: src/changelog.md:1245
msgid ""
"Add `PyTzInfoAccess` trait for safe access to time zone information. "
"[\\#2263](https://github.com/PyO3/pyo3/pull/2263)"
msgstr ""

#: src/changelog.md:1246
msgid ""
"Add an experimental `generate-abi3-import-lib` feature to auto-generate "
"`python3.dll` import libraries for Windows. [\\#2282](https://github.com/"
"PyO3/pyo3/pull/2282)"
msgstr ""

#: src/changelog.md:1247
msgid ""
"Add FFI definitions for `PyDateTime_BaseTime` and `PyDateTime_BaseDateTime`. "
"[\\#2294](https://github.com/PyO3/pyo3/pull/2294)"
msgstr ""

#: src/changelog.md:1251
msgid ""
"Improved performance of failing calls to `FromPyObject::extract` which is "
"common when functions accept multiple distinct types. [\\#2279](https://"
"github.com/PyO3/pyo3/pull/2279)"
msgstr ""

#: src/changelog.md:1252
msgid ""
"Default to \"m\" ABI tag when choosing `libpython` link name for CPython 3.7 "
"on Unix. [\\#2288](https://github.com/PyO3/pyo3/pull/2288)"
msgstr ""

#: src/changelog.md:1253
msgid ""
"Allow to compile \"abi3\" extensions without a working build host Python "
"interpreter. [\\#2293](https://github.com/PyO3/pyo3/pull/2293)"
msgstr ""

#: src/changelog.md:1257
msgid ""
"Crates depending on PyO3 can collect code coverage via LLVM instrumentation "
"using stable Rust. [\\#2286](https://github.com/PyO3/pyo3/pull/2286)"
msgstr ""

#: src/changelog.md:1258
msgid ""
"Fix segfault when calling FFI methods `PyDateTime_DATE_GET_TZINFO` or "
"`PyDateTime_TIME_GET_TZINFO` on `datetime` or `time` without a tzinfo. "
"[\\#2289](https://github.com/PyO3/pyo3/pull/2289)"
msgstr ""

#: src/changelog.md:1259
msgid ""
"Fix directory names starting with the letter `n` breaking serialization of "
"the interpreter configuration on Windows since PyO3 0.16.3. [\\#2299]"
"(https://github.com/PyO3/pyo3/pull/2299)"
msgstr ""

#: src/changelog.md:1261
msgid ""
"[0.16.3](https://github.com/pyo3/pyo3/compare/v0.16.2...v0.16.3) - 2022-04-05"
msgstr ""

#: src/changelog.md:1265
msgid ""
"Extend `parking_lot` dependency supported versions to include 0.12. [\\#2239]"
"(https://github.com/PyO3/pyo3/pull/2239)"
msgstr ""

#: src/changelog.md:1269
msgid ""
"Add methods to `pyo3_build_config::InterpreterConfig` to run Python scripts "
"using the configured executable. [\\#2092](https://github.com/PyO3/pyo3/"
"pull/2092)"
msgstr ""

#: src/changelog.md:1270
msgid ""
"Add `as_bytes` method to `Py<PyBytes>`. [\\#2235](https://github.com/PyO3/"
"pyo3/pull/2235)"
msgstr ""

#: src/changelog.md:1271
msgid ""
"Add FFI definitions for `PyType_FromModuleAndSpec`, `PyType_GetModule`, "
"`PyType_GetModuleState` and `PyModule_AddType`. [\\#2250](https://github.com/"
"PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:1272
msgid ""
"Add `pyo3_build_config::cross_compiling_from_to` as a helper to detect when "
"PyO3 is cross-compiling. [\\#2253](https://github.com/PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:1273
msgid ""
"Add `#[pyclass(mapping)]` option to leave sequence slots empty in container "
"implementations. [\\#2265](https://github.com/PyO3/pyo3/pull/2265)"
msgstr ""

#: src/changelog.md:1274
msgid ""
"Add `PyString::intern` to enable usage of the Python's built-in string "
"interning. [\\#2268](https://github.com/PyO3/pyo3/pull/2268)"
msgstr ""

#: src/changelog.md:1275
msgid ""
"Add `intern!` macro which can be used to amortize the cost of creating "
"Python strings by storing them inside a `GILOnceCell`. [\\#2269](https://"
"github.com/PyO3/pyo3/pull/2269)"
msgstr ""

#: src/changelog.md:1276
msgid ""
"Add `PYO3_CROSS_PYTHON_IMPLEMENTATION` environment variable for selecting "
"the default cross Python implementation. [\\#2272](https://github.com/PyO3/"
"pyo3/pull/2272)"
msgstr ""

#: src/changelog.md:1280
msgid ""
"Allow `#[pyo3(crate = \"...\", text_signature = \"...\")]` options to be "
"used directly in `#[pyclass(crate = \"...\", text_signature = \"...\")]`. "
"[\\#2234](https://github.com/PyO3/pyo3/pull/2234)"
msgstr ""

#: src/changelog.md:1281
msgid ""
"Make `PYO3_CROSS_LIB_DIR` environment variable optional when cross "
"compiling. [\\#2241](https://github.com/PyO3/pyo3/pull/2241)"
msgstr ""

#: src/changelog.md:1282
msgid ""
"Mark `METH_FASTCALL` calling convention as limited API on Python 3.10. "
"[\\#2250](https://github.com/PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:1283
msgid ""
"Deprecate `pyo3_build_config::cross_compiling` in favor of "
"`pyo3_build_config::cross_compiling_from_to`. [\\#2253](https://github.com/"
"PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:1287
msgid ""
"Fix `abi3-py310` feature: use Python 3.10 ABI when available instead of "
"silently falling back to the 3.9 ABI. [\\#2242](https://github.com/PyO3/pyo3/"
"pull/2242)"
msgstr ""

#: src/changelog.md:1288
msgid ""
"Use shared linking mode when cross compiling against a [Framework bundle]"
"(https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/"
"BPFrameworks/Concepts/FrameworkAnatomy.html) for macOS. [\\#2233](https://"
"github.com/PyO3/pyo3/pull/2233)"
msgstr ""

#: src/changelog.md:1289
msgid ""
"Fix panic during compilation when `PYO3_CROSS_LIB_DIR` is set for some host/"
"target combinations. [\\#2232](https://github.com/PyO3/pyo3/pull/2232)"
msgstr ""

#: src/changelog.md:1290
msgid ""
"Correct dependency version for `syn` to require minimal patch version "
"1.0.56. [\\#2240](https://github.com/PyO3/pyo3/pull/2240)"
msgstr ""

#: src/changelog.md:1292
msgid ""
"[0.16.2](https://github.com/pyo3/pyo3/compare/v0.16.1...v0.16.2) - 2022-03-15"
msgstr ""

#: src/changelog.md:1296
msgid ""
"Warn when modules are imported on PyPy 3.7 versions older than PyPy 7.3.8, "
"as they are known to have binary compatibility issues. [\\#2217](https://"
"github.com/PyO3/pyo3/pull/2217)"
msgstr ""

#: src/changelog.md:1297
msgid ""
"Ensure build script of `pyo3-ffi` runs before that of `pyo3` to fix cross "
"compilation. [\\#2224](https://github.com/PyO3/pyo3/pull/2224)"
msgstr ""

#: src/changelog.md:1299
msgid ""
"[0.16.1](https://github.com/pyo3/pyo3/compare/v0.16.0...v0.16.1) - 2022-03-05"
msgstr ""

#: src/changelog.md:1303
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.12. "
"[\\#2197](https://github.com/PyO3/pyo3/pull/2197)"
msgstr ""

#: src/changelog.md:1307
msgid ""
"Fix incorrect platform detection for Windows in `pyo3-build-config`. "
"[\\#2198](https://github.com/PyO3/pyo3/pull/2198)"
msgstr ""

#: src/changelog.md:1308
msgid ""
"Fix regression from 0.16 preventing cross compiling to aarch64 macOS. "
"[\\#2201](https://github.com/PyO3/pyo3/pull/2201)"
msgstr ""

#: src/changelog.md:1310
msgid ""
"[0.16.0](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.16.0) - 2022-02-27"
msgstr ""

#: src/changelog.md:1314
msgid ""
"Update MSRV to Rust 1.48. [\\#2004](https://github.com/PyO3/pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:1315
msgid ""
"Update `indoc` optional dependency to 1.0. [\\#2004](https://github.com/PyO3/"
"pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:1316
msgid ""
"Drop support for Python 3.6, remove `abi3-py36` feature. [\\#2006](https://"
"github.com/PyO3/pyo3/pull/2006)"
msgstr ""

#: src/changelog.md:1317
msgid ""
"`pyo3-build-config` no longer enables the `resolve-config` feature by "
"default. [\\#2008](https://github.com/PyO3/pyo3/pull/2008)"
msgstr ""

#: src/changelog.md:1318
msgid ""
"Update `inventory` optional dependency to 0.2. [\\#2019](https://github.com/"
"PyO3/pyo3/pull/2019)"
msgstr ""

#: src/changelog.md:1319
msgid ""
"Drop `paste` dependency. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:1320
msgid ""
"The bindings found in `pyo3::ffi` are now a re-export of a separate `pyo3-"
"ffi` crate. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:1321
msgid "Support PyPy 3.9. [\\#2143](https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:1325
msgid ""
"Add `PyCapsule` type exposing the [Capsule API](https://docs.python.org/3/c-"
"api/capsule.html#capsules). [\\#1980](https://github.com/PyO3/pyo3/pull/1980)"
msgstr ""

#: src/changelog.md:1326
msgid ""
"Add `pyo3_build_config::Sysconfigdata` and supporting APIs. [\\#1996]"
"(https://github.com/PyO3/pyo3/pull/1996)"
msgstr ""

#: src/changelog.md:1327
msgid ""
"Add `Py::setattr` method. [\\#2009](https://github.com/PyO3/pyo3/pull/2009)"
msgstr ""

#: src/changelog.md:1328
msgid ""
"Add `#[pyo3(crate = \"some::path\")]` option to all attribute macros (except "
"the deprecated `#[pyproto]`). [\\#2022](https://github.com/PyO3/pyo3/"
"pull/2022)"
msgstr ""

#: src/changelog.md:1329
msgid ""
"Enable `create_exception!` macro to take an optional docstring. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:1330
msgid ""
"Enable `#[pyclass]` for fieldless (aka C-like) enums. [\\#2034](https://"
"github.com/PyO3/pyo3/pull/2034)"
msgstr ""

#: src/changelog.md:1331
msgid ""
"Add buffer magic methods `__getbuffer__` and `__releasebuffer__` to "
"`#[pymethods]`. [\\#2067](https://github.com/PyO3/pyo3/pull/2067)"
msgstr ""

#: src/changelog.md:1332
msgid ""
"Add support for paths in `wrap_pyfunction` and `wrap_pymodule`. [\\#2081]"
"(https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:1333
msgid ""
"Enable `wrap_pyfunction!` to wrap a `#[pyfunction]` implemented in a "
"different Rust module or crate. [\\#2091](https://github.com/PyO3/pyo3/"
"pull/2091)"
msgstr ""

#: src/changelog.md:1334
msgid ""
"Add `PyAny::contains` method (`in` operator for `PyAny`). [\\#2115](https://"
"github.com/PyO3/pyo3/pull/2115)"
msgstr ""

#: src/changelog.md:1335
msgid ""
"Add `PyMapping::contains` method (`in` operator for `PyMapping`). [\\#2133]"
"(https://github.com/PyO3/pyo3/pull/2133)"
msgstr ""

#: src/changelog.md:1336
msgid ""
"Add garbage collection magic magic methods `__traverse__` and `__clear__` to "
"`#[pymethods]`. [\\#2159](https://github.com/PyO3/pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:1337
msgid ""
"Add support for `from_py_with` on struct tuples and enums to override the "
"default from-Python conversion. [\\#2181](https://github.com/PyO3/pyo3/"
"pull/2181)"
msgstr ""

#: src/changelog.md:1338
msgid ""
"Add `eq`, `ne`, `lt`, `le`, `gt`, `ge` methods to `PyAny` that wrap "
"`rich_compare`. [\\#2175](https://github.com/PyO3/pyo3/pull/2175)"
msgstr ""

#: src/changelog.md:1339
msgid ""
"Add `Py::is` and `PyAny::is` methods to check for object identity. [\\#2183]"
"(https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:1340
msgid ""
"Add support for the `__getattribute__` magic method. [\\#2187](https://"
"github.com/PyO3/pyo3/pull/2187)"
msgstr ""

#: src/changelog.md:1344
msgid ""
"`PyType::is_subclass`, `PyErr::is_instance` and `PyAny::is_instance` now "
"operate run-time type object instead of a type known at compile-time. The "
"old behavior is still available as `PyType::is_subclass_of`, `PyErr::"
"is_instance_of` and `PyAny::is_instance_of`.  [\\#1985](https://github.com/"
"PyO3/pyo3/pull/1985)"
msgstr ""

#: src/changelog.md:1345
msgid ""
"Rename some methods on `PyErr` (the old names are just marked deprecated for "
"now): [\\#2026](https://github.com/PyO3/pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:1346
msgid "`pytype` -> `get_type`"
msgstr ""

#: src/changelog.md:1347
msgid "`pvalue` -> `value` (and deprecate equivalent `instance`)"
msgstr ""

#: src/changelog.md:1348
msgid "`ptraceback` -> `traceback`"
msgstr ""

#: src/changelog.md:1349
msgid "`from_instance` -> `from_value`"
msgstr ""

#: src/changelog.md:1350
msgid "`into_instance` -> `into_value`"
msgstr ""

#: src/changelog.md:1351
msgid ""
"`PyErr::new_type` now takes an optional docstring and now returns "
"`PyResult<Py<PyType>>` rather than a `ffi::PyTypeObject` pointer. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:1352
msgid ""
"Deprecate `PyType::is_instance`; it is inconsistent with other `is_instance` "
"methods in PyO3. Instead of `typ.is_instance(obj)`, use `obj."
"is_instance(typ)`. [\\#2031](https://github.com/PyO3/pyo3/pull/2031)"
msgstr ""

#: src/changelog.md:1353
msgid ""
"`__getitem__`, `__setitem__` and `__delitem__` in `#[pymethods]` now "
"implement both a Python mapping and sequence by default. [\\#2065](https://"
"github.com/PyO3/pyo3/pull/2065)"
msgstr ""

#: src/changelog.md:1354
msgid ""
"Improve performance and error messages for `#[derive(FromPyObject)]` for "
"enums. [\\#2068](https://github.com/PyO3/pyo3/pull/2068)"
msgstr ""

#: src/changelog.md:1355
msgid "Reduce generated LLVM code size (to improve compile times) for:"
msgstr ""

#: src/changelog.md:1356
msgid ""
"internal `handle_panic` helper [\\#2074](https://github.com/PyO3/pyo3/"
"pull/2074) [\\#2158](https://github.com/PyO3/pyo3/pull/2158)"
msgstr ""

#: src/changelog.md:1357
msgid ""
"`#[pyfunction]` and `#[pymethods]` argument extraction [\\#2075](https://"
"github.com/PyO3/pyo3/pull/2075) [\\#2085](https://github.com/PyO3/pyo3/"
"pull/2085)"
msgstr ""

#: src/changelog.md:1358
msgid ""
"`#[pyclass]` type object creation [\\#2076](https://github.com/PyO3/pyo3/"
"pull/2076) [\\#2081](https://github.com/PyO3/pyo3/pull/2081) [\\#2157]"
"(https://github.com/PyO3/pyo3/pull/2157)"
msgstr ""

#: src/changelog.md:1359
msgid ""
"Respect Rust privacy rules for items wrapped with `wrap_pyfunction` and "
"`wrap_pymodule`. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:1360
msgid ""
"Add modulo argument to `__ipow__` magic method. [\\#2083](https://github.com/"
"PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:1361
msgid ""
"Fix FFI definition for `_PyCFunctionFast`. [\\#2126](https://github.com/PyO3/"
"pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:1362
msgid ""
"`PyDateTimeAPI` and `PyDateTime_TimeZone_UTC` are now unsafe functions "
"instead of statics. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:1363
msgid ""
"`PyDateTimeAPI` does not implicitly call `PyDateTime_IMPORT` anymore to "
"reflect the original Python API more closely. Before the first call to "
"`PyDateTime_IMPORT` a null pointer is returned. Therefore before calling any "
"of the following FFI functions `PyDateTime_IMPORT` must be called to avoid "
"undefined behavior: [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:1364
msgid "`PyDateTime_TimeZone_UTC`"
msgstr ""

#: src/changelog.md:1365
msgid "`PyDate_Check`"
msgstr ""

#: src/changelog.md:1366
msgid "`PyDate_CheckExact`"
msgstr ""

#: src/changelog.md:1367
msgid "`PyDateTime_Check`"
msgstr ""

#: src/changelog.md:1368
msgid "`PyDateTime_CheckExact`"
msgstr ""

#: src/changelog.md:1369
msgid "`PyTime_Check`"
msgstr ""

#: src/changelog.md:1370
msgid "`PyTime_CheckExact`"
msgstr ""

#: src/changelog.md:1371
msgid "`PyDelta_Check`"
msgstr ""

#: src/changelog.md:1372
msgid "`PyDelta_CheckExact`"
msgstr ""

#: src/changelog.md:1373
msgid "`PyTZInfo_Check`"
msgstr ""

#: src/changelog.md:1374
msgid "`PyTZInfo_CheckExact`"
msgstr ""

#: src/changelog.md:1375
msgid "`PyDateTime_FromTimestamp`"
msgstr ""

#: src/changelog.md:1376
msgid "`PyDate_FromTimestamp`"
msgstr ""

#: src/changelog.md:1377
msgid ""
"Deprecate the `gc` option for `pyclass` (e.g. `#[pyclass(gc)]`). Just "
"implement a `__traverse__` `#[pymethod]`. [\\#2159](https://github.com/PyO3/"
"pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:1378
msgid ""
"The `ml_meth` field of `PyMethodDef` is now represented by the "
"`PyMethodDefPointer` union. [2166](https://github.com/PyO3/pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:1379
msgid ""
"Deprecate the `#[pyproto]` traits. [\\#2173](https://github.com/PyO3/pyo3/"
"pull/2173)"
msgstr ""

#: src/changelog.md:1383
msgid ""
"Remove all functionality deprecated in PyO3 0.14. [\\#2007](https://github."
"com/PyO3/pyo3/pull/2007)"
msgstr ""

#: src/changelog.md:1384
msgid ""
"Remove `Default` impl for `PyMethodDef`. [\\#2166](https://github.com/PyO3/"
"pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:1385
msgid ""
"Remove `PartialEq` impl for `Py` and `PyAny` (use the new `is` instead). "
"[\\#2183](https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:1389
msgid ""
"Fix undefined symbol for `PyObject_HasAttr` on PyPy. [\\#2025](https://"
"github.com/PyO3/pyo3/pull/2025)"
msgstr ""

#: src/changelog.md:1390
msgid ""
"Fix memory leak in `PyErr::into_value`. [\\#2026](https://github.com/PyO3/"
"pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:1391
msgid ""
"Fix clippy warning `needless-option-as-deref` in code generated by "
"`#[pyfunction]` and `#[pymethods]`. [\\#2040](https://github.com/PyO3/pyo3/"
"pull/2040)"
msgstr ""

#: src/changelog.md:1392
msgid ""
"Fix undefined behavior in `PySlice::indices`. [\\#2061](https://github.com/"
"PyO3/pyo3/pull/2061)"
msgstr ""

#: src/changelog.md:1393
msgid ""
"Fix the `wrap_pymodule!` macro using the wrong name for a `#[pymodule]` with "
"a `#[pyo3(name = \"..\")]` attribute. [\\#2081](https://github.com/PyO3/pyo3/"
"pull/2081)"
msgstr ""

#: src/changelog.md:1394
msgid ""
"Fix magic methods in `#[pymethods]` accepting implementations with the wrong "
"number of arguments. [\\#2083](https://github.com/PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:1395
msgid ""
"Fix panic in `#[pyfunction]` generated code when a required argument "
"following an `Option` was not provided.  [\\#2093](https://github.com/PyO3/"
"pyo3/pull/2093)"
msgstr ""

#: src/changelog.md:1396
msgid ""
"Fixed undefined behavior caused by incorrect `ExactSizeIterator` "
"implementations. [\\#2124](https://github.com/PyO3/pyo3/pull/2124)"
msgstr ""

#: src/changelog.md:1397
msgid ""
"Fix missing FFI definition `PyCMethod_New` on Python 3.9 and up. [\\#2143]"
"(https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:1398
msgid ""
"Add missing FFI definitions `_PyLong_NumBits` and `_PyLong_AsByteArray` on "
"PyPy. [\\#2146](https://github.com/PyO3/pyo3/pull/2146)"
msgstr ""

#: src/changelog.md:1399
msgid ""
"Fix memory leak in implementation of `AsPyPointer` for `Option<T>`. [\\#2160]"
"(https://github.com/PyO3/pyo3/pull/2160)"
msgstr ""

#: src/changelog.md:1400
msgid ""
"Fix FFI definition of `_PyLong_NumBits` to return `size_t` instead of "
"`c_int`. [\\#2161](https://github.com/PyO3/pyo3/pull/2161)"
msgstr ""

#: src/changelog.md:1401
msgid ""
"Fix `TypeError` thrown when argument parsing failed missing the originating "
"causes. [2177](https://github.com/PyO3/pyo3/pull/2178)"
msgstr ""

#: src/changelog.md:1403
msgid ""
"[0.15.2](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2) - 2022-04-14"
msgstr ""

#: src/changelog.md:1407
msgid ""
"Backport of PyPy 3.9 support from PyO3 0.16. [\\#2262](https://github.com/"
"PyO3/pyo3/pull/2262)"
msgstr ""

#: src/changelog.md:1409
msgid ""
"[0.15.1](https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1) - 2021-11-19"
msgstr ""

#: src/changelog.md:1413
msgid ""
"Add implementations for `Py::as_ref` and `Py::into_ref` for "
"`Py<PySequence>`, `Py<PyIterator>` and `Py<PyMapping>`. [\\#1682](https://"
"github.com/PyO3/pyo3/pull/1682)"
msgstr ""

#: src/changelog.md:1414
msgid ""
"Add `PyTraceback` type to represent and format Python tracebacks. [\\#1977]"
"(https://github.com/PyO3/pyo3/pull/1977)"
msgstr ""

#: src/changelog.md:1418
msgid ""
"`#[classattr]` constants with a known magic method name (which is lowercase) "
"no longer trigger lint warnings expecting constants to be uppercase. "
"[\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:1422
msgid ""
"Fix creating `#[classattr]` by functions with the name of a known magic "
"method. [\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:1423
msgid ""
"Fix use of `catch_unwind` in `allow_threads` which can cause fatal crashes. "
"[\\#1989](https://github.com/PyO3/pyo3/pull/1989)"
msgstr ""

#: src/changelog.md:1424
msgid ""
"Fix build failure on PyPy when abi3 features are activated. [\\#1991]"
"(https://github.com/PyO3/pyo3/pull/1991)"
msgstr ""

#: src/changelog.md:1425
msgid ""
"Fix mingw platform detection. [\\#1993](https://github.com/PyO3/pyo3/"
"pull/1993)"
msgstr ""

#: src/changelog.md:1426
msgid ""
"Fix panic in `__get__` implementation when accessing descriptor on type "
"object. [\\#1997](https://github.com/PyO3/pyo3/pull/1997)"
msgstr ""

#: src/changelog.md:1428
msgid ""
"[0.15.0](https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0) - 2021-11-03"
msgstr ""

#: src/changelog.md:1432
msgid ""
"`pyo3`'s `Cargo.toml` now advertises `links = \"python\"` to inform Cargo "
"that it links against _libpython_. [\\#1819](https://github.com/PyO3/pyo3/"
"pull/1819)"
msgstr ""

#: src/changelog.md:1433
msgid ""
"Added optional `anyhow` feature to convert `anyhow::Error` into `PyErr`. "
"[\\#1822](https://github.com/PyO3/pyo3/pull/1822)"
msgstr ""

#: src/changelog.md:1434
msgid "Support Python 3.10. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:1435
msgid ""
"Added optional `eyre` feature to convert `eyre::Report` into `PyErr`. "
"[\\#1893](https://github.com/PyO3/pyo3/pull/1893)"
msgstr ""

#: src/changelog.md:1436
msgid "Support PyPy 3.8. [\\#1948](https://github.com/PyO3/pyo3/pull/1948)"
msgstr ""

#: src/changelog.md:1440
msgid ""
"Add `PyList::get_item_unchecked` and `PyTuple::get_item_unchecked` to get "
"items without bounds checks. [\\#1733](https://github.com/PyO3/pyo3/"
"pull/1733)"
msgstr ""

#: src/changelog.md:1441
msgid ""
"Support `#[doc = include_str!(...)]` attributes on Rust 1.54 and up. "
"[\\#1746](https://github.com/PyO3/pyo3/issues/1746)"
msgstr ""

#: src/changelog.md:1442
msgid ""
"Add `PyAny::py` as a convenience for `PyNativeType::py`. [\\#1751](https://"
"github.com/PyO3/pyo3/pull/1751)"
msgstr ""

#: src/changelog.md:1443
msgid ""
"Add implementation of `std::ops::Index<usize>` for `PyList`, `PyTuple` and "
"`PySequence`. [\\#1825](https://github.com/PyO3/pyo3/pull/1825)"
msgstr ""

#: src/changelog.md:1444
msgid ""
"Add range indexing implementations of `std::ops::Index` for `PyList`, "
"`PyTuple` and `PySequence`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:1445
msgid ""
"Add `PyMapping` type to represent the Python mapping protocol. [\\#1844]"
"(https://github.com/PyO3/pyo3/pull/1844)"
msgstr ""

#: src/changelog.md:1446
msgid ""
"Add commonly-used sequence methods to `PyList` and `PyTuple`. [\\#1849]"
"(https://github.com/PyO3/pyo3/pull/1849)"
msgstr ""

#: src/changelog.md:1447
msgid ""
"Add `as_sequence` methods to `PyList` and `PyTuple`. [\\#1860](https://"
"github.com/PyO3/pyo3/pull/1860)"
msgstr ""

#: src/changelog.md:1448
msgid ""
"Add support for magic methods in `#[pymethods]`, intended as a replacement "
"for `#[pyproto]`. [\\#1864](https://github.com/PyO3/pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:1449
msgid ""
"Add `abi3-py310` feature. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:1450
msgid ""
"Add `PyCFunction::new_closure` to create a Python function from a Rust "
"closure. [\\#1901](https://github.com/PyO3/pyo3/pull/1901)"
msgstr ""

#: src/changelog.md:1451
msgid ""
"Add support for positional-only arguments in `#[pyfunction]`. [\\#1925]"
"(https://github.com/PyO3/pyo3/pull/1925)"
msgstr ""

#: src/changelog.md:1452
msgid ""
"Add `PyErr::take` to attempt to fetch a Python exception if present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:1456
msgid ""
"`PyList`, `PyTuple` and `PySequence`'s APIs now accepts only `usize` indices "
"instead of `isize`. [\\#1733](https://github.com/PyO3/pyo3/pull/1733), "
"[\\#1802](https://github.com/PyO3/pyo3/pull/1802), [\\#1803](https://github."
"com/PyO3/pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:1459
msgid ""
"`PyList::get_item` and `PyTuple::get_item` now return `PyResult<&PyAny>` "
"instead of panicking. [\\#1733](https://github.com/PyO3/pyo3/pull/1733)"
msgstr ""

#: src/changelog.md:1460
msgid ""
"`PySequence::in_place_repeat` and `PySequence::in_place_concat` now return "
"`PyResult<&PySequence>` instead of `PyResult<()>`, which is needed in case "
"of immutable sequences such as tuples. [\\#1803](https://github.com/PyO3/"
"pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:1461
msgid ""
"`PySequence::get_slice` now returns `PyResult<&PySequence>` instead of "
"`PyResult<&PyAny>`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:1462
msgid ""
"Deprecate `PyTuple::split_from`. [\\#1804](https://github.com/PyO3/pyo3/"
"pull/1804)"
msgstr ""

#: src/changelog.md:1463
msgid ""
"Deprecate `PyTuple::slice`, new method `PyTuple::get_slice` added with "
"`usize` indices. [\\#1828](https://github.com/PyO3/pyo3/pull/1828)"
msgstr ""

#: src/changelog.md:1464
msgid ""
"Deprecate FFI definitions `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags` "
"when building for Python 3.9. [\\#1830](https://github.com/PyO3/pyo3/"
"pull/1830)"
msgstr ""

#: src/changelog.md:1465
msgid ""
"Mark FFI definitions removed in Python 3.10 `PyParser_ASTFromString`, "
"`PyParser_ASTFromStringObject`, `PyParser_ASTFromFile`, "
"`PyParser_ASTFromFileObject`, `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags`, "
"`PyParser_SimpleParseString`, `PyParser_SimpleParseFile`, "
"`Py_SymtableString`, and `Py_SymtableStringObject`. [\\#1830](https://github."
"com/PyO3/pyo3/pull/1830)"
msgstr ""

#: src/changelog.md:1466
msgid ""
"`#[pymethods]` now handles magic methods similarly to `#[pyproto]`. In the "
"future, `#[pyproto]` may be deprecated. [\\#1864](https://github.com/PyO3/"
"pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:1467
msgid ""
"Deprecate FFI definitions `PySys_AddWarnOption`, "
"`PySys_AddWarnOptionUnicode` and `PySys_HasWarnOptions`. [\\#1887](https://"
"github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:1468
msgid ""
"Deprecate `#[call]` attribute in favor of using `fn __call__`. [\\#1929]"
"(https://github.com/PyO3/pyo3/pull/1929)"
msgstr ""

#: src/changelog.md:1469 src/changelog.md:1481
msgid ""
"Fix missing FFI definition `_PyImport_FindExtensionObject` on Python 3.10. "
"[\\#1942](https://github.com/PyO3/pyo3/pull/1942)"
msgstr ""

#: src/changelog.md:1470
msgid ""
"Change `PyErr::fetch` to panic in debug mode if no exception is present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:1474
msgid ""
"Fix building with a conda environment on Windows. [\\#1873](https://github."
"com/PyO3/pyo3/pull/1873)"
msgstr ""

#: src/changelog.md:1475
msgid ""
"Fix panic on Python 3.6 when calling `Python::with_gil` with Python "
"initialized but threading not initialized. [\\#1874](https://github.com/PyO3/"
"pyo3/pull/1874)"
msgstr ""

#: src/changelog.md:1476
msgid ""
"Fix incorrect linking to version-specific DLL instead of `python3.dll` when "
"cross-compiling to Windows with `abi3`. [\\#1880](https://github.com/PyO3/"
"pyo3/pull/1880)"
msgstr ""

#: src/changelog.md:1477
msgid ""
"Fix FFI definition for `PyTuple_ClearFreeList` incorrectly being present for "
"Python 3.9 and up. [\\#1887](https://github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:1478
msgid ""
"Fix panic in generated `#[derive(FromPyObject)]` for enums. [\\#1888]"
"(https://github.com/PyO3/pyo3/pull/1888)"
msgstr ""

#: src/changelog.md:1479
msgid ""
"Fix cross-compiling to Python 3.7 builds with the \"m\" abi flag. [\\#1908]"
"(https://github.com/PyO3/pyo3/pull/1908)"
msgstr ""

#: src/changelog.md:1480
msgid ""
"Fix `__mod__` magic method fallback to `__rmod__`. [\\#1934](https://github."
"com/PyO3/pyo3/pull/1934)."
msgstr ""

#: src/changelog.md:1483
msgid ""
"[0.14.5](https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5) - 2021-09-05"
msgstr ""

#: src/changelog.md:1487
msgid ""
"Make `pyo3_build_config::InterpreterConfig` and subfields public. [\\#1848]"
"(https://github.com/PyO3/pyo3/pull/1848)"
msgstr ""

#: src/changelog.md:1488
msgid ""
"Add `resolve-config` feature to the `pyo3-build-config` to control whether "
"its build script does anything. [\\#1856](https://github.com/PyO3/pyo3/"
"pull/1856)"
msgstr ""

#: src/changelog.md:1492
msgid ""
"Fix 0.14.4 compile regression on `s390x-unknown-linux-gnu` target. [\\#1850]"
"(https://github.com/PyO3/pyo3/pull/1850)"
msgstr ""

#: src/changelog.md:1494
msgid ""
"[0.14.4](https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4) - 2021-08-29"
msgstr ""

#: src/changelog.md:1498
msgid ""
"Mark `PyString::data` as `unsafe` and disable it and some supporting "
"PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. "
"[\\#1834](https://github.com/PyO3/pyo3/pull/1834)"
msgstr ""

#: src/changelog.md:1500
msgid ""
"[0.14.3](https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3) - 2021-08-22"
msgstr ""

#: src/changelog.md:1504
msgid ""
"Add `PyString::data` to access the raw bytes stored in a Python string. "
"[\\#1794](https://github.com/PyO3/pyo3/pull/1794)"
msgstr ""

#: src/changelog.md:1508
msgid ""
"Raise `AttributeError` to avoid panic when calling `del` on a `#[setter]` "
"defined class property. [\\#1779](https://github.com/PyO3/pyo3/pull/1779)"
msgstr ""

#: src/changelog.md:1509
msgid ""
"Restrict FFI definitions `PyGILState_Check` and `Py_tracefunc` to the "
"unlimited API. [\\#1787](https://github.com/PyO3/pyo3/pull/1787)"
msgstr ""

#: src/changelog.md:1510
msgid ""
"Add missing `_type` field to `PyStatus` struct definition. [\\#1791](https://"
"github.com/PyO3/pyo3/pull/1791)"
msgstr ""

#: src/changelog.md:1511
msgid ""
"Reduce lower bound `num-complex` optional dependency to support interop with "
"`rust-numpy` and `ndarray` when building with the MSRV of 1.41 [\\#1799]"
"(https://github.com/PyO3/pyo3/pull/1799)"
msgstr ""

#: src/changelog.md:1512
msgid ""
"Fix memory leak in `Python::run_code`. [\\#1806](https://github.com/PyO3/"
"pyo3/pull/1806)"
msgstr ""

#: src/changelog.md:1513
msgid ""
"Fix memory leak in `PyModule::from_code`. [\\#1810](https://github.com/PyO3/"
"pyo3/pull/1810)"
msgstr ""

#: src/changelog.md:1514
msgid ""
"Remove use of `pyo3::` in `pyo3::types::datetime` which broke builds using `-"
"Z avoid-dev-deps` [\\#1811](https://github.com/PyO3/pyo3/pull/1811)"
msgstr ""

#: src/changelog.md:1516
msgid ""
"[0.14.2](https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2) - 2021-08-09"
msgstr ""

#: src/changelog.md:1520
msgid ""
"Add `indexmap` feature to add `ToPyObject`, `IntoPy` and `FromPyObject` "
"implementations for `indexmap::IndexMap`. [\\#1728](https://github.com/PyO3/"
"pyo3/pull/1728)"
msgstr ""

#: src/changelog.md:1521
msgid ""
"Add `pyo3_build_config::add_extension_module_link_args` to use in build "
"scripts to set linker arguments (for macOS). [\\#1755](https://github.com/"
"PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:1522
msgid ""
"Add `Python::with_gil_unchecked` unsafe variation of `Python::with_gil` to "
"allow obtaining a `Python` in scenarios where `Python::with_gil` would fail. "
"[\\#1769](https://github.com/PyO3/pyo3/pull/1769)"
msgstr ""

#: src/changelog.md:1526
msgid ""
"`PyErr::new` no longer acquires the Python GIL internally. [\\#1724](https://"
"github.com/PyO3/pyo3/pull/1724)"
msgstr ""

#: src/changelog.md:1527
msgid ""
"Reverted PyO3 0.14.0's use of `cargo:rustc-cdylib-link-arg` in its build "
"script, as Cargo unintentionally allowed crates to pass linker args to "
"downstream crates in this way. Projects supporting macOS may need to restore "
"`.cargo/config.toml` files. [\\#1755](https://github.com/PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:1531
msgid ""
"Fix regression in 0.14.0 rejecting usage of `#[doc(hidden)]` on structs and "
"functions annotated with PyO3 macros. [\\#1722](https://github.com/PyO3/pyo3/"
"pull/1722)"
msgstr ""

#: src/changelog.md:1532
msgid ""
"Fix regression in 0.14.0 leading to incorrect code coverage being computed "
"for `#[pyfunction]`s. [\\#1726](https://github.com/PyO3/pyo3/pull/1726)"
msgstr ""

#: src/changelog.md:1533
msgid ""
"Fix incorrect FFI definition of `Py_Buffer` on PyPy. [\\#1737](https://"
"github.com/PyO3/pyo3/pull/1737)"
msgstr ""

#: src/changelog.md:1534
msgid ""
"Fix incorrect calculation of `dictoffset` on 32-bit Windows. [\\#1475]"
"(https://github.com/PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:1535
msgid ""
"Fix regression in 0.13.2 leading to linking to incorrect Python library on "
"Windows \"gnu\" targets. [\\#1759](https://github.com/PyO3/pyo3/pull/1759)"
msgstr ""

#: src/changelog.md:1536
msgid ""
"Fix compiler warning: deny trailing semicolons in expression macro. [\\#1762]"
"(https://github.com/PyO3/pyo3/pull/1762)"
msgstr ""

#: src/changelog.md:1537
msgid ""
"Fix incorrect FFI definition of `Py_DecodeLocale`. The 2nd argument is now "
"`*mut Py_ssize_t` instead of `Py_ssize_t`. [\\#1766](https://github.com/PyO3/"
"pyo3/pull/1766)"
msgstr ""

#: src/changelog.md:1539
msgid ""
"[0.14.1](https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1) - 2021-07-04"
msgstr ""

#: src/changelog.md:1543
msgid ""
"Implement `IntoPy<PyObject>` for `&PathBuf` and `&OsString`. [\\#1712]"
"(https://github.com/PyO3/pyo3/pull/1712)"
msgstr ""

#: src/changelog.md:1547
msgid ""
"Fix crashes on PyPy due to incorrect definitions of `PyList_SET_ITEM`. "
"[\\#1713](https://github.com/PyO3/pyo3/pull/1713)"
msgstr ""

#: src/changelog.md:1549
msgid ""
"[0.14.0](https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0) - 2021-07-03"
msgstr ""

#: src/changelog.md:1553
msgid ""
"Update `num-bigint` optional dependency to 0.4. [\\#1481](https://github.com/"
"PyO3/pyo3/pull/1481)"
msgstr ""

#: src/changelog.md:1554
msgid ""
"Update `num-complex` optional dependency to 0.4. [\\#1482](https://github."
"com/PyO3/pyo3/pull/1482)"
msgstr ""

#: src/changelog.md:1555
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.11. "
"[\\#1496](https://github.com/PyO3/pyo3/pull/1496)"
msgstr ""

#: src/changelog.md:1556
msgid "Support PyPy 3.7. [\\#1538](https://github.com/PyO3/pyo3/pull/1538)"
msgstr ""

#: src/changelog.md:1560
msgid ""
"Extend conversions for `[T; N]` to all `N` using const generics (on Rust "
"1.51 and up). [\\#1128](https://github.com/PyO3/pyo3/pull/1128)"
msgstr ""

#: src/changelog.md:1561
msgid ""
"Add conversions between `OsStr`/ `OsString` and Python strings. [\\#1379]"
"(https://github.com/PyO3/pyo3/pull/1379)"
msgstr ""

#: src/changelog.md:1562
msgid ""
"Add conversions between `Path`/ `PathBuf` and Python strings (and `pathlib."
"Path` objects). [\\#1379](https://github.com/PyO3/pyo3/pull/1379) [\\#1654]"
"(https://github.com/PyO3/pyo3/pull/1654)"
msgstr ""

#: src/changelog.md:1563
msgid ""
"Add a new set of `#[pyo3(...)]` attributes to control various PyO3 macro "
"functionality:"
msgstr ""

#: src/changelog.md:1564
msgid ""
"`#[pyo3(from_py_with = \"...\")]` function arguments and struct fields to "
"override the default from-Python conversion. [\\#1411](https://github.com/"
"PyO3/pyo3/pull/1411)"
msgstr ""

#: src/changelog.md:1565
msgid ""
"`#[pyo3(name = \"...\")]` for setting Python names. [\\#1567](https://github."
"com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:1566
msgid ""
"`#[pyo3(text_signature = \"...\")]` for setting text signature. [\\#1658]"
"(https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:1567
msgid ""
"Add FFI definition `PyCFunction_CheckExact` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1568
msgid ""
"Add FFI definition `Py_IS_TYPE`. [\\#1429](https://github.com/PyO3/pyo3/"
"pull/1429)"
msgstr ""

#: src/changelog.md:1569
msgid ""
"Add FFI definition `_Py_InitializeMain`. [\\#1473](https://github.com/PyO3/"
"pyo3/pull/1473)"
msgstr ""

#: src/changelog.md:1570
msgid ""
"Add FFI definitions from `cpython/import.h`.[\\#1475](https://github.com/"
"PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:1571
msgid ""
"Add tuple and unit struct support for `#[pyclass]` macro. [\\#1504](https://"
"github.com/PyO3/pyo3/pull/1504)"
msgstr ""

#: src/changelog.md:1572
msgid ""
"Add FFI definition `PyDateTime_TimeZone_UTC`. [\\#1572](https://github.com/"
"PyO3/pyo3/pull/1572)"
msgstr ""

#: src/changelog.md:1573
msgid ""
"Add support for `#[pyclass(extends=Exception)]`. [\\#1591](https://github."
"com/PyO3/pyo3/pull/1591)"
msgstr ""

#: src/changelog.md:1574
msgid ""
"Add `PyErr::cause` and `PyErr::set_cause`. [\\#1679](https://github.com/PyO3/"
"pyo3/pull/1679)"
msgstr ""

#: src/changelog.md:1575
msgid ""
"Add FFI definitions from `cpython/pystate.h`. [\\#1687](https://github.com/"
"PyO3/pyo3/pull/1687/)"
msgstr ""

#: src/changelog.md:1576
msgid ""
"Add `wrap_pyfunction!` macro to `pyo3::prelude`. [\\#1695](https://github."
"com/PyO3/pyo3/pull/1695)"
msgstr ""

#: src/changelog.md:1580
msgid ""
"Allow only one `#[pymethods]` block per `#[pyclass]` by default, to remove "
"the dependency on `inventory`. Add a `multiple-pymethods` feature to opt-in "
"the original behavior and dependency on `inventory`. [\\#1457](https://"
"github.com/PyO3/pyo3/pull/1457)"
msgstr ""

#: src/changelog.md:1581
msgid ""
"Change `PyTimeAccess::get_fold` to return a `bool` instead of a `u8`. "
"[\\#1397](https://github.com/PyO3/pyo3/pull/1397)"
msgstr ""

#: src/changelog.md:1582
msgid ""
"Deprecate FFI definition `PyCFunction_Call` for Python 3.9 and up. [\\#1425]"
"(https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1583
msgid ""
"Deprecate FFI definition `PyModule_GetFilename`. [\\#1425](https://github."
"com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1584
msgid ""
"The `auto-initialize` feature is no longer enabled by default. [\\#1443]"
"(https://github.com/PyO3/pyo3/pull/1443)"
msgstr ""

#: src/changelog.md:1585
msgid ""
"Change `PyCFunction::new` and `PyCFunction::new_with_keywords` to take "
"`&'static str` arguments rather than implicitly copying (and leaking) them. "
"[\\#1450](https://github.com/PyO3/pyo3/pull/1450)"
msgstr ""

#: src/changelog.md:1586
msgid ""
"Deprecate `PyModule::call`, `PyModule::call0`, `PyModule::call1` and "
"`PyModule::get`. [\\#1492](https://github.com/PyO3/pyo3/pull/1492)"
msgstr ""

#: src/changelog.md:1587
msgid ""
"Add length information to `PyBufferError`s raised from `PyBuffer::"
"copy_to_slice` and `PyBuffer::copy_from_slice`. [\\#1534](https://github.com/"
"PyO3/pyo3/pull/1534)"
msgstr ""

#: src/changelog.md:1588
msgid ""
"Automatically set `-undefined` and `dynamic_lookup` linker arguments on "
"macOS with the `extension-module` feature. [\\#1539](https://github.com/PyO3/"
"pyo3/pull/1539)"
msgstr ""

#: src/changelog.md:1589
msgid ""
"Deprecate `#[pyproto]` methods which are easier to implement as "
"`#[pymethods]`: [\\#1560](https://github.com/PyO3/pyo3/pull/1560)"
msgstr ""

#: src/changelog.md:1590
msgid "`PyBasicProtocol::__bytes__` and `PyBasicProtocol::__format__`"
msgstr ""

#: src/changelog.md:1591
msgid "`PyContextProtocol::__enter__` and `PyContextProtocol::__exit__`"
msgstr ""

#: src/changelog.md:1592
msgid "`PyDescrProtocol::__delete__` and `PyDescrProtocol::__set_name__`"
msgstr ""

#: src/changelog.md:1593
msgid "`PyMappingProtocol::__reversed__`"
msgstr ""

#: src/changelog.md:1594
msgid "`PyNumberProtocol::__complex__` and `PyNumberProtocol::__round__`"
msgstr ""

#: src/changelog.md:1595
msgid "`PyAsyncProtocol::__aenter__` and `PyAsyncProtocol::__aexit__`"
msgstr ""

#: src/changelog.md:1596
msgid ""
"Deprecate several attributes in favor of the new `#[pyo3(...)]` options:"
msgstr ""

#: src/changelog.md:1597
msgid ""
"`#[name = \"...\"]`, replaced by `#[pyo3(name = \"...\")]` [\\#1567](https://"
"github.com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:1598
msgid ""
"`#[pyfn(m, \"name\")]`, replaced by `#[pyfn(m)] #[pyo3(name = \"...\")]`. "
"[\\#1610](https://github.com/PyO3/pyo3/pull/1610)"
msgstr ""

#: src/changelog.md:1599
msgid ""
"`#[pymodule(name)]`, replaced by `#[pymodule] #[pyo3(name = \"...\")]` "
"[\\#1650](https://github.com/PyO3/pyo3/pull/1650)"
msgstr ""

#: src/changelog.md:1600
msgid ""
"`#[text_signature = \"...\"]`, replaced by `#[pyo3(text_signature = \"..."
"\")]`. [\\#1658](https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:1601
msgid ""
"Reduce LLVM line counts to improve compilation times. [\\#1604](https://"
"github.com/PyO3/pyo3/pull/1604)"
msgstr ""

#: src/changelog.md:1602
msgid ""
"No longer call `PyEval_InitThreads` in `#[pymodule]` init code. [\\#1630]"
"(https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:1603
msgid ""
"Use `METH_FASTCALL` argument passing convention, when possible, to improve "
"`#[pyfunction]` and method performance. [\\#1619](https://github.com/PyO3/"
"pyo3/pull/1619), [\\#1660](https://github.com/PyO3/pyo3/pull/1660)"
msgstr ""

#: src/changelog.md:1605
msgid ""
"Filter sysconfigdata candidates by architecture when cross-compiling. "
"[\\#1626](https://github.com/PyO3/pyo3/pull/1626)"
msgstr ""

#: src/changelog.md:1609
msgid ""
"Remove deprecated exception names `BaseException` etc. [\\#1426](https://"
"github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1610
msgid ""
"Remove deprecated methods `Python::is_instance`, `Python::is_subclass`, "
"`Python::release`, `Python::xdecref`, and `Py::from_owned_ptr_or_panic`. "
"[\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1611
msgid "Remove many FFI definitions which never existed in the Python C-API:"
msgstr ""

#: src/changelog.md:1612
msgid ""
"(previously deprecated) `PyGetSetDef_INIT`, `PyGetSetDef_DICT`, "
"`PyCoro_Check`, `PyCoroWrapper_Check`, and `PyAsyncGen_Check` [\\#1426]"
"(https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1613
msgid "`PyMethodDef_INIT` [\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:1614
msgid "`PyTypeObject_INIT` [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:1615
msgid ""
"`PyObject_Check`, `PySuper_Check`, and `FreeFunc` [\\#1438](https://github."
"com/PyO3/pyo3/pull/1438)"
msgstr ""

#: src/changelog.md:1616
msgid "`PyModuleDef_INIT` [\\#1630](https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:1617
msgid "Remove pyclass implementation details from `PyTypeInfo`:"
msgstr ""

#: src/changelog.md:1618
msgid ""
"`Type`, `DESCRIPTION`, and `FLAGS` [\\#1456](https://github.com/PyO3/pyo3/"
"pull/1456)"
msgstr ""

#: src/changelog.md:1619
msgid ""
"`BaseType`, `BaseLayout`, `Layout`, `Initializer` [\\#1596](https://github."
"com/PyO3/pyo3/pull/1596)"
msgstr ""

#: src/changelog.md:1620
msgid ""
"Remove `PYO3_CROSS_INCLUDE_DIR` environment variable and the associated C "
"header parsing functionality. [\\#1521](https://github.com/PyO3/pyo3/"
"pull/1521)"
msgstr ""

#: src/changelog.md:1621
msgid ""
"Remove `raw_pycfunction!` macro. [\\#1619](https://github.com/PyO3/pyo3/"
"pull/1619)"
msgstr ""

#: src/changelog.md:1622
msgid ""
"Remove `PyClassAlloc` trait. [\\#1657](https://github.com/PyO3/pyo3/"
"pull/1657)"
msgstr ""

#: src/changelog.md:1623
msgid ""
"Remove `PyList::get_parked_item`. [\\#1664](https://github.com/PyO3/pyo3/"
"pull/1664)"
msgstr ""

#: src/changelog.md:1627
msgid ""
"Remove FFI definition `PyCFunction_ClearFreeList` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:1628
msgid ""
"`PYO3_CROSS_LIB_DIR` environment variable no long required when compiling "
"for x86-64 Python from macOS arm64 and reverse. [\\#1428](https://github.com/"
"PyO3/pyo3/pull/1428)"
msgstr ""

#: src/changelog.md:1629
msgid ""
"Fix FFI definition `_PyEval_RequestCodeExtraIndex`, which took an argument "
"of the wrong type. [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:1630
msgid ""
"Fix FFI definition `PyIndex_Check` missing with the `abi3` feature. [\\#1436]"
"(https://github.com/PyO3/pyo3/pull/1436)"
msgstr ""

#: src/changelog.md:1631
msgid ""
"Fix incorrect `TypeError` raised when keyword-only argument passed along "
"with a positional argument in `*args`. [\\#1440](https://github.com/PyO3/"
"pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:1632
msgid ""
"Fix inability to use a named lifetime for `&PyTuple` of `*args` in "
"`#[pyfunction]`. [\\#1440](https://github.com/PyO3/pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:1633
msgid ""
"Fix use of Python argument for `#[pymethods]` inside macro expansions. "
"[\\#1505](https://github.com/PyO3/pyo3/pull/1505)"
msgstr ""

#: src/changelog.md:1634
msgid ""
"No longer include `__doc__` in `__all__` generated for `#[pymodule]`. "
"[\\#1509](https://github.com/PyO3/pyo3/pull/1509)"
msgstr ""

#: src/changelog.md:1635
msgid ""
"Always use cross-compiling configuration if any of the `PYO3_CROSS` family "
"of environment variables are set. [\\#1514](https://github.com/PyO3/pyo3/"
"pull/1514)"
msgstr ""

#: src/changelog.md:1636
msgid ""
"Support `EnvironmentError`, `IOError`, and `WindowsError` on PyPy. [\\#1533]"
"(https://github.com/PyO3/pyo3/pull/1533)"
msgstr ""

#: src/changelog.md:1637
msgid ""
"Fix unnecessary rebuilds when cycling between `cargo check` and `cargo "
"clippy` in a Python virtualenv. [\\#1557](https://github.com/PyO3/pyo3/"
"pull/1557)"
msgstr ""

#: src/changelog.md:1638
msgid ""
"Fix segfault when dereferencing `ffi::PyDateTimeAPI` without the GIL. "
"[\\#1563](https://github.com/PyO3/pyo3/pull/1563)"
msgstr ""

#: src/changelog.md:1639
msgid ""
"Fix memory leak in `FromPyObject` implementations for `u128` and `i128`. "
"[\\#1638](https://github.com/PyO3/pyo3/pull/1638)"
msgstr ""

#: src/changelog.md:1640
msgid ""
"Fix `#[pyclass(extends=PyDict)]` leaking the dict contents on drop. [\\#1657]"
"(https://github.com/PyO3/pyo3/pull/1657)"
msgstr ""

#: src/changelog.md:1641
msgid ""
"Fix segfault when calling `PyList::get_item` with negative indices. [\\#1668]"
"(https://github.com/PyO3/pyo3/pull/1668)"
msgstr ""

#: src/changelog.md:1642
msgid ""
"Fix FFI definitions of `PyEval_SetProfile`/`PyEval_SetTrace` to take "
"`Option<Py_tracefunc>` parameters. [\\#1692](https://github.com/PyO3/pyo3/"
"pull/1692)"
msgstr ""

#: src/changelog.md:1643
msgid ""
"Fix `ToPyObject` impl for `HashSet` to accept non-default hashers. [\\#1702]"
"(https://github.com/PyO3/pyo3/pull/1702)"
msgstr ""

#: src/changelog.md:1645
msgid ""
"[0.13.2](https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2) - 2021-02-12"
msgstr ""

#: src/changelog.md:1649
msgid ""
"Lower minimum supported Rust version to 1.41. [\\#1421](https://github.com/"
"PyO3/pyo3/pull/1421)"
msgstr ""

#: src/changelog.md:1653
msgid ""
"Add unsafe API `with_embedded_python_interpreter` to initialize a Python "
"interpreter, execute a closure, and finalize the interpreter. [\\#1355]"
"(https://github.com/PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:1654
msgid ""
"Add `serde` feature which provides implementations of `Serialize` and "
"`Deserialize` for `Py<T>`. [\\#1366](https://github.com/PyO3/pyo3/pull/1366)"
msgstr ""

#: src/changelog.md:1655
msgid ""
"Add FFI definition `_PyCFunctionFastWithKeywords` on Python 3.7 and up. "
"[\\#1384](https://github.com/PyO3/pyo3/pull/1384)"
msgstr ""

#: src/changelog.md:1656
msgid ""
"Add `PyDateTime::new_with_fold` method. [\\#1398](https://github.com/PyO3/"
"pyo3/pull/1398)"
msgstr ""

#: src/changelog.md:1657
msgid ""
"Add `size_hint` impls for `{PyDict,PyList,PySet,PyTuple}Iterator`s. [\\#1699]"
"(https://github.com/PyO3/pyo3/pull/1699)"
msgstr ""

#: src/changelog.md:1661
msgid ""
"`prepare_freethreaded_python` will no longer register an `atexit` handler to "
"call `Py_Finalize`. This resolves a number of issues with incompatible C "
"extensions causing crashes at finalization. [\\#1355](https://github.com/"
"PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:1662
msgid ""
"Mark `PyLayout::py_init`, `PyClassDict::clear_dict`, and `opt_to_pyobj` "
"safe, as they do not perform any unsafe operations. [\\#1404](https://github."
"com/PyO3/pyo3/pull/1404)"
msgstr ""

#: src/changelog.md:1666
msgid ""
"Fix support for using `r#raw_idents` as argument names in pyfunctions. "
"[\\#1383](https://github.com/PyO3/pyo3/pull/1383)"
msgstr ""

#: src/changelog.md:1667
msgid ""
"Fix typo in FFI definition for `PyFunction_GetCode` (was incorrectly "
"`PyFunction_Code`). [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1668
msgid ""
"Fix FFI definitions `PyMarshal_WriteObjectToString` and "
"`PyMarshal_ReadObjectFromString` as available in limited API. [\\#1387]"
"(https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1669
msgid ""
"Fix FFI definitions `PyListObject` and those from `funcobject.h` as "
"requiring non-limited API. [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:1670
msgid ""
"Fix unqualified `Result` usage in `pyobject_native_type_base`. [\\#1402]"
"(https://github.com/PyO3/pyo3/pull/1402)"
msgstr ""

#: src/changelog.md:1671
msgid ""
"Fix build on systems where the default Python encoding is not UTF-8. "
"[\\#1405](https://github.com/PyO3/pyo3/pull/1405)"
msgstr ""

#: src/changelog.md:1672
msgid ""
"Fix build on mingw / MSYS2. [\\#1423](https://github.com/PyO3/pyo3/pull/1423)"
msgstr ""

#: src/changelog.md:1674
msgid ""
"[0.13.1](https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1) - 2021-01-10"
msgstr ""

#: src/changelog.md:1678
msgid ""
"Add support for `#[pyclass(dict)]` and `#[pyclass(weakref)]` with the `abi3` "
"feature on Python 3.9 and up. [\\#1342](https://github.com/PyO3/pyo3/"
"pull/1342)"
msgstr ""

#: src/changelog.md:1679
msgid ""
"Add FFI definitions `PyOS_BeforeFork`, `PyOS_AfterFork_Parent`, "
"`PyOS_AfterFork_Child` for Python 3.7 and up. [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1680
msgid ""
"Add an `auto-initialize` feature to control whether PyO3 should "
"automatically initialize an embedded Python interpreter. For compatibility "
"this feature is enabled by default in PyO3 0.13.1, but is planned to become "
"opt-in from PyO3 0.14.0. [\\#1347](https://github.com/PyO3/pyo3/pull/1347)"
msgstr ""

#: src/changelog.md:1681
msgid ""
"Add support for cross-compiling to Windows without needing "
"`PYO3_CROSS_INCLUDE_DIR`. [\\#1350](https://github.com/PyO3/pyo3/pull/1350)"
msgstr ""

#: src/changelog.md:1683 src/changelog.md:1743
msgid "Deprecated"
msgstr ""

#: src/changelog.md:1685
msgid ""
"Deprecate FFI definitions `PyEval_CallObjectWithKeywords`, "
"`PyEval_CallObject`, `PyEval_CallFunction`, `PyEval_CallMethod` when "
"building for Python 3.9. [\\#1338](https://github.com/PyO3/pyo3/pull/1338)"
msgstr ""

#: src/changelog.md:1686
msgid ""
"Deprecate FFI definitions `PyGetSetDef_DICT` and `PyGetSetDef_INIT` which "
"have never been in the Python API. [\\#1341](https://github.com/PyO3/pyo3/"
"pull/1341)"
msgstr ""

#: src/changelog.md:1687
msgid ""
"Deprecate FFI definitions `PyGen_NeedsFinalizing`, `PyImport_Cleanup` "
"(removed in 3.9), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github."
"com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1688
msgid ""
"Deprecate FFI definition `PyOS_AfterFork` for Python 3.7 and up. [\\#1348]"
"(https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1689
msgid ""
"Deprecate FFI definitions `PyCoro_Check`, `PyAsyncGen_Check`, and "
"`PyCoroWrapper_Check`, which have never been in the Python API (for the "
"first two, it is possible to use `PyCoro_CheckExact` and "
"`PyAsyncGen_CheckExact` instead; these are the actual functions provided by "
"the Python API). [\\#1348](https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1690
msgid ""
"Deprecate FFI definitions for `PyUnicode_FromUnicode`, `PyUnicode_AsUnicode` "
"and `PyUnicode_AsUnicodeAndSize`, which will be removed from 3.12 and up due "
"to [PEP 623](https://www.python.org/dev/peps/pep-0623/). [\\#1370](https://"
"github.com/PyO3/pyo3/pull/1370)"
msgstr ""

#: src/changelog.md:1694
msgid ""
"Remove FFI definition `PyFrame_ClearFreeList` when building for Python 3.9. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:1695
msgid ""
"Remove FFI definition `_PyDict_Contains` when building for Python 3.10. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:1696
msgid ""
"Remove FFI definitions `PyGen_NeedsFinalizing` and `PyImport_Cleanup` (for "
"3.9 and up), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:1700
msgid ""
"Stop including `Py_TRACE_REFS` config setting automatically if `Py_DEBUG` is "
"set on Python 3.8 and up. [\\#1334](https://github.com/PyO3/pyo3/pull/1334)"
msgstr ""

#: src/changelog.md:1701
msgid ""
"Remove `#[deny(warnings)]` attribute (and instead refuse warnings only in "
"CI). [\\#1340](https://github.com/PyO3/pyo3/pull/1340)"
msgstr ""

#: src/changelog.md:1702
msgid ""
"Fix deprecation warning for missing `__module__` with `#[pyclass]`. [\\#1343]"
"(https://github.com/PyO3/pyo3/pull/1343)"
msgstr ""

#: src/changelog.md:1703
msgid ""
"Correct return type of `PyFrozenSet::empty` to `&PyFrozenSet` (was "
"incorrectly `&PySet`). [\\#1351](https://github.com/PyO3/pyo3/pull/1351)"
msgstr ""

#: src/changelog.md:1704
msgid ""
"Fix missing `Py_INCREF` on heap type objects on Python versions before 3.8. "
"[\\#1365](https://github.com/PyO3/pyo3/pull/1365)"
msgstr ""

#: src/changelog.md:1706
msgid ""
"[0.13.0](https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0) - 2020-12-22"
msgstr ""

#: src/changelog.md:1710
msgid ""
"Drop support for Python 3.5 (as it is now end-of-life). [\\#1250](https://"
"github.com/PyO3/pyo3/pull/1250)"
msgstr ""

#: src/changelog.md:1711
msgid ""
"Bump minimum supported Rust version to 1.45. [\\#1272](https://github.com/"
"PyO3/pyo3/pull/1272)"
msgstr ""

#: src/changelog.md:1712
msgid ""
"Bump indoc dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:1713
msgid ""
"Bump paste dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:1714
msgid ""
"Rename internal crates `pyo3cls` and `pyo3-derive-backend` to `pyo3-macros` "
"and `pyo3-macros-backend` respectively. [\\#1317](https://github.com/PyO3/"
"pyo3/pull/1317)"
msgstr ""

#: src/changelog.md:1718
msgid ""
"Add support for building for CPython limited API. Opting-in to the limited "
"API enables a single extension wheel built with PyO3 to be installable on "
"multiple Python versions. This required a few minor changes to runtime "
"behavior of of PyO3 `#[pyclass]` types. See the migration guide for full "
"details. [\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1719
msgid ""
"Add feature flags `abi3-py36`, `abi3-py37`, `abi3-py38` etc. to set the "
"minimum Python version when using the limited API. [\\#1263](https://github."
"com/PyO3/pyo3/pull/1263)"
msgstr ""

#: src/changelog.md:1720
msgid ""
"Add argument names to `TypeError` messages generated by pymethod wrappers. "
"[\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:1721
msgid ""
"Add FFI definitions for PEP 587 \"Python Initialization Configuration\". "
"[\\#1247](https://github.com/PyO3/pyo3/pull/1247)"
msgstr ""

#: src/changelog.md:1722
msgid ""
"Add FFI definitions for `PyEval_SetProfile` and `PyEval_SetTrace`. [\\#1255]"
"(https://github.com/PyO3/pyo3/pull/1255)"
msgstr ""

#: src/changelog.md:1723
msgid ""
"Add FFI definitions for context.h functions (`PyContext_New`, etc). [\\#1259]"
"(https://github.com/PyO3/pyo3/pull/1259)"
msgstr ""

#: src/changelog.md:1724
msgid ""
"Add `PyAny::is_instance` method. [\\#1276](https://github.com/PyO3/pyo3/"
"pull/1276)"
msgstr ""

#: src/changelog.md:1725
msgid ""
"Add support for conversion between `char` and `PyString`. [\\#1282](https://"
"github.com/PyO3/pyo3/pull/1282)"
msgstr ""

#: src/changelog.md:1726
msgid ""
"Add FFI definitions for `PyBuffer_SizeFromFormat`, `PyObject_LengthHint`, "
"`PyObject_CallNoArgs`, `PyObject_CallOneArg`, `PyObject_CallMethodNoArgs`, "
"`PyObject_CallMethodOneArg`, `PyObject_VectorcallDict`, and "
"`PyObject_VectorcallMethod`. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1287)"
msgstr ""

#: src/changelog.md:1727
msgid ""
"Add conversions between `u128`/`i128` and `PyLong` for PyPy. [\\#1310]"
"(https://github.com/PyO3/pyo3/pull/1310)"
msgstr ""

#: src/changelog.md:1728
msgid ""
"Add `Python::version` and `Python::version_info` to get the running "
"interpreter version. [\\#1322](https://github.com/PyO3/pyo3/pull/1322)"
msgstr ""

#: src/changelog.md:1729
msgid ""
"Add conversions for tuples of length 10, 11, and 12. [\\#1454](https://"
"github.com/PyO3/pyo3/pull/1454)"
msgstr ""

#: src/changelog.md:1733
msgid ""
"Change return type of `PyType::name` from `Cow<str>` to `PyResult<&str>`. "
"[\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1734
msgid ""
"`#[pyclass(subclass)]` is now required for subclassing from Rust (was "
"previously just required for subclassing from Python). [\\#1152](https://"
"github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:1735
msgid ""
"Change `PyIterator` to be consistent with other native types: it is now used "
"as `&PyIterator` instead of `PyIterator<'a>`. [\\#1176](https://github.com/"
"PyO3/pyo3/pull/1176)"
msgstr ""

#: src/changelog.md:1736
msgid ""
"Change formatting of `PyDowncastError` messages to be closer to Python's "
"builtin error messages. [\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:1737
msgid ""
"Change `Debug` and `Display` impls for `PyException` to be consistent with "
"`PyAny`. [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:1738
msgid ""
"Change `Debug` impl of `PyErr` to output more helpful information (acquiring "
"the GIL if necessary). [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:1739
msgid ""
"Rename `PyTypeInfo::is_instance` and `PyTypeInfo::is_exact_instance` to "
"`PyTypeInfo::is_type_of` and `PyTypeInfo::is_exact_type_of`. [\\#1278]"
"(https://github.com/PyO3/pyo3/pull/1278)"
msgstr ""

#: src/changelog.md:1740
msgid ""
"Optimize `PyAny::call0`, `Py::call0` and `PyAny::call_method0` and `Py::"
"call_method0` on Python 3.9 and up. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1285)"
msgstr ""

#: src/changelog.md:1741
msgid ""
"Require double-quotes for pyclass name argument e.g `#[pyclass(name = "
"\"MyClass\")]`. [\\#1303](https://github.com/PyO3/pyo3/pull/1303)"
msgstr ""

#: src/changelog.md:1745
msgid ""
"Deprecate `Python::is_instance`, `Python::is_subclass`, `Python::release`, "
"and `Python::xdecref`. [\\#1292](https://github.com/PyO3/pyo3/pull/1292)"
msgstr ""

#: src/changelog.md:1749
msgid ""
"Remove deprecated ffi definitions `PyUnicode_AsUnicodeCopy`, "
"`PyUnicode_GetMax`, `_Py_CheckRecursionLimit`, `PyObject_AsCharBuffer`, "
"`PyObject_AsReadBuffer`, `PyObject_CheckReadBuffer` and "
"`PyObject_AsWriteBuffer`, which will be removed in Python 3.10. [\\#1217]"
"(https://github.com/PyO3/pyo3/pull/1217)"
msgstr ""

#: src/changelog.md:1750
msgid ""
"Remove unused `python3` feature. [\\#1235](https://github.com/PyO3/pyo3/"
"pull/1235)"
msgstr ""

#: src/changelog.md:1754
msgid ""
"Fix missing field in `PyCodeObject` struct (`co_posonlyargcount`) - caused "
"invalid access to other fields in Python >3.7. [\\#1260](https://github.com/"
"PyO3/pyo3/pull/1260)"
msgstr ""

#: src/changelog.md:1755
msgid ""
"Fix building for `x86_64-unknown-linux-musl` target from `x86_64-unknown-"
"linux-gnu` host. [\\#1267](https://github.com/PyO3/pyo3/pull/1267)"
msgstr ""

#: src/changelog.md:1756
msgid ""
"Fix `#[text_signature]` interacting badly with rust `r#raw_identifiers`. "
"[\\#1286](https://github.com/PyO3/pyo3/pull/1286)"
msgstr ""

#: src/changelog.md:1757
msgid ""
"Fix FFI definitions for `PyObject_Vectorcall` and `PyVectorcall_Call`. "
"[\\#1287](https://github.com/PyO3/pyo3/pull/1285)"
msgstr ""

#: src/changelog.md:1758
msgid ""
"Fix building with Anaconda python inside a virtualenv. [\\#1290](https://"
"github.com/PyO3/pyo3/pull/1290)"
msgstr ""

#: src/changelog.md:1759
msgid ""
"Fix definition of opaque FFI types. [\\#1312](https://github.com/PyO3/pyo3/"
"pull/1312)"
msgstr ""

#: src/changelog.md:1760
msgid ""
"Fix using custom error type in pyclass `#[new]` methods. [\\#1319](https://"
"github.com/PyO3/pyo3/pull/1319)"
msgstr ""

#: src/changelog.md:1762
msgid ""
"[0.12.4](https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4) - 2020-11-28"
msgstr ""

#: src/changelog.md:1766
msgid ""
"Fix reference count bug in implementation of `From<Py<T>>` for `PyObject`, a "
"regression introduced in PyO3 0.12. [\\#1297](https://github.com/PyO3/pyo3/"
"pull/1297)"
msgstr ""

#: src/changelog.md:1768
msgid ""
"[0.12.3](https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3) - 2020-10-12"
msgstr ""

#: src/changelog.md:1772
msgid ""
"Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal "
"update to paste 1.0 which was done in PyO3 0.12.2. [\\#1234](https://github."
"com/PyO3/pyo3/pull/1234)"
msgstr ""

#: src/changelog.md:1774
msgid ""
"[0.12.2](https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2) - 2020-10-12"
msgstr ""

#: src/changelog.md:1778
msgid ""
"Add support for keyword-only arguments without default values in "
"`#[pyfunction]`. [\\#1209](https://github.com/PyO3/pyo3/pull/1209)"
msgstr ""

#: src/changelog.md:1779
msgid ""
"Add `Python::check_signals` as a safe a wrapper for `PyErr_CheckSignals`. "
"[\\#1214](https://github.com/PyO3/pyo3/pull/1214)"
msgstr ""

#: src/changelog.md:1783
msgid ""
"Fix invalid document for protocol methods. [\\#1169](https://github.com/PyO3/"
"pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:1784
msgid ""
"Hide docs of PyO3 private implementation details in `pyo3::class::methods`. "
"[\\#1169](https://github.com/PyO3/pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:1785
msgid ""
"Fix unnecessary rebuild on PATH changes when the python interpreter is "
"provided by PYO3_PYTHON. [\\#1231](https://github.com/PyO3/pyo3/pull/1231)"
msgstr ""

#: src/changelog.md:1787
msgid ""
"[0.12.1](https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1) - 2020-09-16"
msgstr ""

#: src/changelog.md:1791
msgid ""
"Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust "
"toolchain. [\\#1179](https://github.com/PyO3/pyo3/pull/1179)"
msgstr ""

#: src/changelog.md:1792
msgid ""
"Fix building on platforms where `c_char` is `u8`. [\\#1182](https://github."
"com/PyO3/pyo3/pull/1182)"
msgstr ""

#: src/changelog.md:1794
msgid ""
"[0.12.0](https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0) - 2020-09-12"
msgstr ""

#: src/changelog.md:1798
msgid ""
"Add FFI definitions `Py_FinalizeEx`, `PyOS_getsig`, and `PyOS_setsig`. "
"[\\#1021](https://github.com/PyO3/pyo3/pull/1021)"
msgstr ""

#: src/changelog.md:1799
msgid ""
"Add `PyString::to_str` for accessing `PyString` as `&str`. [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:1800
msgid ""
"Add `Python::with_gil` for executing a closure with the Python GIL. [\\#1037]"
"(https://github.com/PyO3/pyo3/pull/1037)"
msgstr ""

#: src/changelog.md:1801
msgid ""
"Add type information to failures in `PyAny::downcast`. [\\#1050](https://"
"github.com/PyO3/pyo3/pull/1050)"
msgstr ""

#: src/changelog.md:1802
msgid ""
"Implement `Debug` for `PyIterator`. [\\#1051](https://github.com/PyO3/pyo3/"
"pull/1051)"
msgstr ""

#: src/changelog.md:1803
msgid ""
"Add `PyBytes::new_with` and `PyByteArray::new_with` for initialising `bytes` "
"and `bytearray` objects using a closure. [\\#1074](https://github.com/PyO3/"
"pyo3/pull/1074)"
msgstr ""

#: src/changelog.md:1804
msgid ""
"Add `#[derive(FromPyObject)]` macro for enums and structs. [\\#1065](https://"
"github.com/PyO3/pyo3/pull/1065)"
msgstr ""

#: src/changelog.md:1805
msgid ""
"Add `Py::as_ref` and `Py::into_ref` for converting `Py<T>` to `&T`. [\\#1098]"
"(https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:1806
msgid ""
"Add ability to return `Result` types other than `PyResult` from "
"`#[pyfunction]`, `#[pymethod]` and `#[pyproto]` functions. [\\#1106](https://"
"github.com/PyO3/pyo3/pull/1118)."
msgstr ""

#: src/changelog.md:1807
msgid ""
"Implement `ToPyObject`, `IntoPy`, and `FromPyObject` for [hashbrown](https://"
"crates.io/crates/hashbrown)'s `HashMap` and `HashSet` types (requires the "
"`hashbrown` feature). [\\#1114](https://github.com/PyO3/pyo3/pull/1114)"
msgstr ""

#: src/changelog.md:1808
msgid ""
"Add `#[pyfunction(pass_module)]` and `#[pyfn(pass_module)]` to pass the "
"module object as the first function argument. [\\#1143](https://github.com/"
"PyO3/pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:1809
msgid ""
"Add `PyModule::add_function` and `PyModule::add_submodule` as typed "
"alternatives to `PyModule::add_wrapped`. [\\#1143](https://github.com/PyO3/"
"pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:1810
msgid ""
"Add native `PyCFunction` and `PyFunction` types. [\\#1163](https://github."
"com/PyO3/pyo3/pull/1163)"
msgstr ""

#: src/changelog.md:1814
msgid ""
"Rework exception types: [\\#1024](https://github.com/PyO3/pyo3/pull/1024) "
"[\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1815
msgid ""
"Rename exception types from e.g. `RuntimeError` to `PyRuntimeError`. The old "
"names continue to exist but are deprecated."
msgstr ""

#: src/changelog.md:1816
msgid ""
"Exception objects are now accessible as `&T` or `Py<T>`, just like other "
"Python-native types."
msgstr ""

#: src/changelog.md:1817
msgid "Rename `PyException::py_err` to `PyException::new_err`."
msgstr ""

#: src/changelog.md:1818
msgid "Rename `PyUnicodeDecodeErr::new_err` to `PyUnicodeDecodeErr::new`."
msgstr ""

#: src/changelog.md:1819
msgid "Remove `PyStopIteration::stop_iteration`."
msgstr ""

#: src/changelog.md:1820
msgid ""
"Require `T: Send` for the return value `T` of `Python::allow_threads`. "
"[\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:1821
msgid ""
"Rename `PYTHON_SYS_EXECUTABLE` to `PYO3_PYTHON`. The old name will continue "
"to work (undocumented) but will be removed in a future release. [\\#1039]"
"(https://github.com/PyO3/pyo3/pull/1039)"
msgstr ""

#: src/changelog.md:1822
msgid ""
"Remove `unsafe` from signature of `PyType::as_type_ptr`. [\\#1047](https://"
"github.com/PyO3/pyo3/pull/1047)"
msgstr ""

#: src/changelog.md:1823
msgid ""
"Change return type of `PyIterator::from_object` to `PyResult<PyIterator>` "
"(was `Result<PyIterator, PyDowncastError>`). [\\#1051](https://github.com/"
"PyO3/pyo3/pull/1051)"
msgstr ""

#: src/changelog.md:1824
msgid ""
"`IntoPy` is no longer implied by `FromPy`. [\\#1063](https://github.com/PyO3/"
"pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1825
msgid ""
"Change `PyObject` to be a type alias for `Py<PyAny>`. [\\#1063](https://"
"github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1826
msgid ""
"Rework `PyErr` to be compatible with the `std::error::Error` trait: [\\#1067]"
"(https://github.com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/"
"pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1827
msgid ""
"Implement `Display`, `Error`, `Send` and `Sync` for `PyErr` and "
"`PyErrArguments`."
msgstr ""

#: src/changelog.md:1828
msgid "Add `PyErr::instance` for accessing `PyErr` as `&PyBaseException`."
msgstr ""

#: src/changelog.md:1829
msgid ""
"`PyErr`'s fields are now an implementation detail. The equivalent values can "
"be accessed with `PyErr::ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/changelog.md:1830
msgid ""
"Change receiver of `PyErr::print` and `PyErr::print_and_set_sys_last_vars` "
"to `&self` (was `self`)."
msgstr ""

#: src/changelog.md:1831
msgid ""
"Remove `PyErrValue`, `PyErr::from_value`, `PyErr::into_normalized`, and "
"`PyErr::normalize`."
msgstr ""

#: src/changelog.md:1832
msgid "Remove `PyException::into`."
msgstr ""

#: src/changelog.md:1833
msgid "Remove `Into<PyResult<T>>` for `PyErr` and `PyException`."
msgstr ""

#: src/changelog.md:1834
msgid ""
"Change methods generated by `#[pyproto]` to return `NotImplemented` if "
"Python should try a reversed operation. #[1072](https://github.com/PyO3/pyo3/"
"pull/1072)"
msgstr ""

#: src/changelog.md:1835
msgid ""
"Change argument to `PyModule::add` to `impl IntoPy<PyObject>` (was `impl "
"ToPyObject`). #[1124](https://github.com/PyO3/pyo3/pull/1124)"
msgstr ""

#: src/changelog.md:1839
msgid ""
"Remove many exception and `PyErr` APIs; see the \"changed\" section above. "
"[\\#1024](https://github.com/PyO3/pyo3/pull/1024) [\\#1067](https://github."
"com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:1840
msgid ""
"Remove `PyString::to_string` (use new `PyString::to_str`). [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:1841
msgid ""
"Remove `PyString::as_bytes`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:1842
msgid ""
"Remove `Python::register_any`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:1843
msgid ""
"Remove `GILGuard::acquire` from the public API. Use `Python::acquire_gil` or "
"`Python::with_gil`. [\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:1844
msgid ""
"Remove the `FromPy` trait. [\\#1063](https://github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:1845
msgid ""
"Remove the `AsPyRef` trait. [\\#1098](https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:1849
msgid ""
"Correct FFI definitions `Py_SetProgramName` and `Py_SetPythonHome` to take "
"`*const` arguments (was `*mut`). [\\#1021](https://github.com/PyO3/pyo3/"
"pull/1021)"
msgstr ""

#: src/changelog.md:1850
msgid ""
"Fix `FromPyObject` for `num_bigint::BigInt` for Python objects with an "
"`__index__` method. [\\#1027](https://github.com/PyO3/pyo3/pull/1027)"
msgstr ""

#: src/changelog.md:1851
msgid ""
"Correct FFI definition `_PyLong_AsByteArray` to take `*mut c_uchar` argument "
"(was `*const c_uchar`). [\\#1029](https://github.com/PyO3/pyo3/pull/1029)"
msgstr ""

#: src/changelog.md:1852
msgid ""
"Fix segfault with `#[pyclass(dict, unsendable)]`. [\\#1058](https://github."
"com/PyO3/pyo3/pull/1058) [\\#1059](https://github.com/PyO3/pyo3/pull/1059)"
msgstr ""

#: src/changelog.md:1853
msgid ""
"Fix using `&Self` as an argument type for functions in a `#[pymethods]` "
"block. [\\#1071](https://github.com/PyO3/pyo3/pull/1071)"
msgstr ""

#: src/changelog.md:1854
msgid ""
"Fix best-effort build against PyPy 3.6. [\\#1092](https://github.com/PyO3/"
"pyo3/pull/1092)"
msgstr ""

#: src/changelog.md:1855
msgid ""
"Fix many cases of lifetime elision in `#[pyproto]` implementations. [\\#1093]"
"(https://github.com/PyO3/pyo3/pull/1093)"
msgstr ""

#: src/changelog.md:1856
msgid ""
"Fix detection of Python build configuration when cross-compiling. [\\#1095]"
"(https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:1857
msgid ""
"Always link against libpython on android with the `extension-module` "
"feature. [\\#1095](https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:1858
msgid ""
"Fix the `+` operator not trying `__radd__` when both `__add__` and "
"`__radd__` are defined in `PyNumberProtocol` (and similar for all other "
"reversible operators). [\\#1107](https://github.com/PyO3/pyo3/pull/1107)"
msgstr ""

#: src/changelog.md:1859
msgid ""
"Fix building with Anaconda python. [\\#1175](https://github.com/PyO3/pyo3/"
"pull/1175)"
msgstr ""

#: src/changelog.md:1861
msgid ""
"[0.11.1](https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1) - 2020-06-30"
msgstr ""

#: src/changelog.md:1865
msgid ""
"`#[pyclass(unsendable)]`. [\\#1009](https://github.com/PyO3/pyo3/pull/1009)"
msgstr ""

#: src/changelog.md:1869
msgid ""
"Update `parking_lot` dependency to `0.11`. [\\#1010](https://github.com/PyO3/"
"pyo3/pull/1010)"
msgstr ""

#: src/changelog.md:1871
msgid ""
"[0.11.0](https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0) - 2020-06-28"
msgstr ""

#: src/changelog.md:1875
msgid ""
"Support stable versions of Rust (>=1.39). [\\#969](https://github.com/PyO3/"
"pyo3/pull/969)"
msgstr ""

#: src/changelog.md:1876
msgid ""
"Add FFI definition `PyObject_AsFileDescriptor`. [\\#938](https://github.com/"
"PyO3/pyo3/pull/938)"
msgstr ""

#: src/changelog.md:1877
msgid ""
"Add `PyByteArray::data`, `PyByteArray::as_bytes`, and `PyByteArray::"
"as_bytes_mut`. [\\#967](https://github.com/PyO3/pyo3/pull/967)"
msgstr ""

#: src/changelog.md:1878
msgid ""
"Add `GILOnceCell` to use in situations where `lazy_static` or `once_cell` "
"can deadlock. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:1879
msgid ""
"Add `Py::borrow`, `Py::borrow_mut`, `Py::try_borrow`, and `Py::"
"try_borrow_mut` for accessing `#[pyclass]` values. [\\#976](https://github."
"com/PyO3/pyo3/pull/976)"
msgstr ""

#: src/changelog.md:1880
msgid ""
"Add `IterNextOutput` and `IterANextOutput` for returning from `__next__` / "
"`__anext__`. [\\#997](https://github.com/PyO3/pyo3/pull/997)"
msgstr ""

#: src/changelog.md:1884
msgid ""
"Simplify internals of `#[pyo3(get)]` attribute. (Remove the hidden API "
"`GetPropertyValue`.) [\\#934](https://github.com/PyO3/pyo3/pull/934)"
msgstr ""

#: src/changelog.md:1885
msgid ""
"Call `Py_Finalize` at exit to flush buffers, etc. [\\#943](https://github."
"com/PyO3/pyo3/pull/943)"
msgstr ""

#: src/changelog.md:1886
msgid ""
"Add type parameter to PyBuffer. #[951](https://github.com/PyO3/pyo3/pull/951)"
msgstr ""

#: src/changelog.md:1887
msgid ""
"Require `Send` bound for `#[pyclass]`. [\\#966](https://github.com/PyO3/pyo3/"
"pull/966)"
msgstr ""

#: src/changelog.md:1888
msgid ""
"Add `Python` argument to most methods on `PyObject` and `Py<T>` to ensure "
"GIL safety. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:1889
msgid ""
"Change signature of `PyTypeObject::type_object` - now takes `Python` "
"argument and returns `&PyType`. [\\#970](https://github.com/PyO3/pyo3/"
"pull/970)"
msgstr ""

#: src/changelog.md:1890
msgid ""
"Change return type of `PyTuple::slice` and `PyTuple::split_from` from "
"`Py<PyTuple>` to `&PyTuple`. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:1891
msgid ""
"Change return type of `PyTuple::as_slice` to `&[&PyAny]`. [\\#971](https://"
"github.com/PyO3/pyo3/pull/971)"
msgstr ""

#: src/changelog.md:1892
msgid ""
"Rename `PyTypeInfo::type_object` to `type_object_raw`, and add `Python` "
"argument. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:1893
msgid ""
"Update `num-complex` optional dependency from `0.2` to `0.3`. [\\#977]"
"(https://github.com/PyO3/pyo3/pull/977)"
msgstr ""

#: src/changelog.md:1894
msgid ""
"Update `num-bigint` optional dependency from `0.2` to `0.3`. [\\#978]"
"(https://github.com/PyO3/pyo3/pull/978)"
msgstr ""

#: src/changelog.md:1895
msgid ""
"`#[pyproto]` is re-implemented without specialization. [\\#961](https://"
"github.com/PyO3/pyo3/pull/961)"
msgstr ""

#: src/changelog.md:1896
msgid ""
"`PyClassAlloc::alloc` is renamed to `PyClassAlloc::new`. [\\#990](https://"
"github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:1897
msgid ""
"`#[pyproto]` methods can now have return value `T` or `PyResult<T>` "
"(previously only `PyResult<T>` was supported). [\\#996](https://github.com/"
"PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:1898
msgid ""
"`#[pyproto]` methods can now skip annotating the return type if it is `()`. "
"[\\#998](https://github.com/PyO3/pyo3/pull/998)"
msgstr ""

#: src/changelog.md:1902
msgid ""
"Remove `ManagedPyRef` (unused, and needs specialization) [\\#930](https://"
"github.com/PyO3/pyo3/pull/930)"
msgstr ""

#: src/changelog.md:1906
msgid ""
"Fix passing explicit `None` to `Option<T>` argument `#[pyfunction]` with a "
"default value. [\\#936](https://github.com/PyO3/pyo3/pull/936)"
msgstr ""

#: src/changelog.md:1907
msgid ""
"Fix `PyClass.__new__`'s not respecting subclasses when inherited by a Python "
"class. [\\#990](https://github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:1908
msgid ""
"Fix returning `Option<T>` from `#[pyproto]` methods. [\\#996](https://github."
"com/PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:1909
msgid ""
"Fix accepting `PyRef<Self>` and `PyRefMut<Self>` to `#[getter]` and "
"`#[setter]` methods. [\\#999](https://github.com/PyO3/pyo3/pull/999)"
msgstr ""

#: src/changelog.md:1911
msgid ""
"[0.10.1](https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1) - 2020-05-14"
msgstr ""

#: src/changelog.md:1915
msgid ""
"Fix deadlock in `Python::acquire_gil` after dropping a `PyObject` or "
"`Py<T>`. [\\#924](https://github.com/PyO3/pyo3/pull/924)"
msgstr ""

#: src/changelog.md:1917
msgid ""
"[0.10.0](https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0) - 2020-05-13"
msgstr ""

#: src/changelog.md:1921
msgid ""
"Add FFI definition `_PyDict_NewPresized`. [\\#849](https://github.com/PyO3/"
"pyo3/pull/849)"
msgstr ""

#: src/changelog.md:1922
msgid ""
"Implement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`. [\\#864](https://"
"github.com/PyO3/pyo3/pull/864)"
msgstr ""

#: src/changelog.md:1923
msgid ""
"Add `PyAny::dir` method. [\\#886](https://github.com/PyO3/pyo3/pull/886)"
msgstr ""

#: src/changelog.md:1924
msgid ""
"Gate macros behind a `macros` feature (enabled by default). [\\#897](https://"
"github.com/PyO3/pyo3/pull/897)"
msgstr ""

#: src/changelog.md:1925
msgid ""
"Add ability to define class attributes using `#[classattr]` on functions in "
"`#[pymethods]`. [\\#905](https://github.com/PyO3/pyo3/pull/905)"
msgstr ""

#: src/changelog.md:1926
msgid ""
"Implement `Clone` for `PyObject` and `Py<T>`. [\\#908](https://github.com/"
"PyO3/pyo3/pull/908)"
msgstr ""

#: src/changelog.md:1927
msgid ""
"Implement `Deref<Target = PyAny>` for all builtin types. (`PyList`, "
"`PyTuple`, `PyDict` etc.) [\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1928
msgid ""
"Implement `Deref<Target = PyAny>` for `PyCell<T>`. [\\#911](https://github."
"com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1929
msgid ""
"Add `#[classattr]` support for associated constants in `#[pymethods]`. "
"[\\#914](https://github.com/PyO3/pyo3/pull/914)"
msgstr ""

#: src/changelog.md:1933
msgid ""
"Panics will now be raised as a Python `PanicException`. [\\#797](https://"
"github.com/PyO3/pyo3/pull/797)"
msgstr ""

#: src/changelog.md:1934
msgid ""
"Change `PyObject` and `Py<T>` reference counts to decrement immediately upon "
"drop when the GIL is held. [\\#851](https://github.com/PyO3/pyo3/pull/851)"
msgstr ""

#: src/changelog.md:1935
msgid ""
"Allow `PyIterProtocol` methods to use either `PyRef` or `PyRefMut` as the "
"receiver type. [\\#856](https://github.com/PyO3/pyo3/pull/856)"
msgstr ""

#: src/changelog.md:1936
msgid ""
"Change the implementation of `FromPyObject` for `Py<T>` to apply to a wider "
"range of `T`, including all `T: PyClass`. [\\#880](https://github.com/PyO3/"
"pyo3/pull/880)"
msgstr ""

#: src/changelog.md:1937
msgid ""
"Move all methods from the `ObjectProtocol` trait to the `PyAny` struct. "
"[\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1938
msgid ""
"Remove need for `#![feature(specialization)]` in crates depending on PyO3. "
"[\\#917](https://github.com/PyO3/pyo3/pull/917)"
msgstr ""

#: src/changelog.md:1942
msgid ""
"Remove `PyMethodsProtocol` trait. [\\#889](https://github.com/PyO3/pyo3/"
"pull/889)"
msgstr ""

#: src/changelog.md:1943
msgid ""
"Remove `num-traits` dependency. [\\#895](https://github.com/PyO3/pyo3/"
"pull/895)"
msgstr ""

#: src/changelog.md:1944
msgid ""
"Remove `ObjectProtocol` trait. [\\#911](https://github.com/PyO3/pyo3/"
"pull/911)"
msgstr ""

#: src/changelog.md:1945
msgid ""
"Remove `PyAny::None`. Users should use `Python::None` instead. [\\#911]"
"(https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:1946
msgid ""
"Remove all `*ProtocolImpl` traits. [\\#917](https://github.com/PyO3/pyo3/"
"pull/917)"
msgstr ""

#: src/changelog.md:1950
msgid ""
"Fix support for `__radd__` and other `__r*__` methods as implementations for "
"Python mathematical operators. [\\#839](https://github.com/PyO3/pyo3/"
"pull/839)"
msgstr ""

#: src/changelog.md:1951
msgid ""
"Fix panics during garbage collection when traversing objects that were "
"already mutably borrowed. [\\#855](https://github.com/PyO3/pyo3/pull/855)"
msgstr ""

#: src/changelog.md:1952
msgid ""
"Prevent `&'static` references to Python objects as arguments to "
"`#[pyfunction]` and `#[pymethods]`. [\\#869](https://github.com/PyO3/pyo3/"
"pull/869)"
msgstr ""

#: src/changelog.md:1953
msgid ""
"Fix lifetime safety bug with `AsPyRef::as_ref`. [\\#876](https://github.com/"
"PyO3/pyo3/pull/876)"
msgstr ""

#: src/changelog.md:1954
msgid ""
"Fix `#[pyo3(get)]` attribute on `Py<T>` fields. [\\#880](https://github.com/"
"PyO3/pyo3/pull/880)"
msgstr ""

#: src/changelog.md:1955
msgid ""
"Fix segmentation faults caused by functions such as `PyList::get_item` "
"returning borrowed objects when it was not safe to do so. [\\#890](https://"
"github.com/PyO3/pyo3/pull/890)"
msgstr ""

#: src/changelog.md:1956
msgid ""
"Fix segmentation faults caused by nested `Python::acquire_gil` calls "
"creating dangling references. [\\#893](https://github.com/PyO3/pyo3/pull/893)"
msgstr ""

#: src/changelog.md:1957
msgid ""
"Fix segmentatation faults when a panic occurs during a call to `Python::"
"allow_threads`. [\\#912](https://github.com/PyO3/pyo3/pull/912)"
msgstr ""

#: src/changelog.md:1959
msgid ""
"[0.9.2](https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2) - 2020-04-09"
msgstr ""

#: src/changelog.md:1963
msgid ""
"`FromPyObject` implementations for `HashSet` and `BTreeSet`. [\\#842]"
"(https://github.com/PyO3/pyo3/pull/842)"
msgstr ""

#: src/changelog.md:1967
msgid ""
"Correctly detect 32bit architecture. [\\#830](https://github.com/PyO3/pyo3/"
"pull/830)"
msgstr ""

#: src/changelog.md:1969
msgid ""
"[0.9.1](https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1) - 2020-03-23"
msgstr ""

#: src/changelog.md:1973
msgid ""
"Error messages for `#[pyclass]`. [\\#826](https://github.com/PyO3/pyo3/"
"pull/826)"
msgstr ""

#: src/changelog.md:1974
msgid ""
"`FromPyObject` implementation for `PySequence`. [\\#827](https://github.com/"
"PyO3/pyo3/pull/827)"
msgstr ""

#: src/changelog.md:1976
msgid ""
"[0.9.0](https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0) - 2020-03-19"
msgstr ""

#: src/changelog.md:1980
msgid ""
"`PyCell`, which has RefCell-like features. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1981
msgid ""
"`PyClass`, `PyLayout`, `PyClassInitializer`. [\\#683](https://github.com/"
"PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:1982
msgid ""
"Implemented `IntoIterator` for `PySet` and `PyFrozenSet`. [\\#716](https://"
"github.com/PyO3/pyo3/pull/716)"
msgstr ""

#: src/changelog.md:1983
msgid ""
"`FromPyObject` is now automatically implemented for `T: Clone` pyclasses. "
"[\\#730](https://github.com/PyO3/pyo3/pull/730)"
msgstr ""

#: src/changelog.md:1984
msgid ""
"`#[pyo3(get)]` and `#[pyo3(set)]` will now use the Rust doc-comment from the "
"field for the Python property. [\\#755](https://github.com/PyO3/pyo3/"
"pull/755)"
msgstr ""

#: src/changelog.md:1985
msgid ""
"`#[setter]` functions may now take an argument of `Pyo3::Python`. [\\#760]"
"(https://github.com/PyO3/pyo3/pull/760)"
msgstr ""

#: src/changelog.md:1986
msgid ""
"`PyTypeInfo::BaseLayout` and `PyClass::BaseNativeType`. [\\#770](https://"
"github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1987
msgid "`PyDowncastImpl`. [\\#770](https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:1988
msgid ""
"Implement `FromPyObject` and `IntoPy<PyObject>` traits for arrays (up to "
"32). [\\#778](https://github.com/PyO3/pyo3/pull/778)"
msgstr ""

#: src/changelog.md:1989
msgid ""
"`migration.md` and `types.md` in the guide. [\\#795](https://github.com/PyO3/"
"pyo3/pull/795), #[802](https://github.com/PyO3/pyo3/pull/802)"
msgstr ""

#: src/changelog.md:1990
msgid ""
"`ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}"
"`. #[820](https://github.com/PyO3/pyo3/pull/820)"
msgstr ""

#: src/changelog.md:1994
msgid ""
"`#[new]` does not take `PyRawObject` and can return `Self`. [\\#683](https://"
"github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:1995
msgid ""
"The blanket implementations for `FromPyObject` for `&T` and `&mut T` are no "
"longer specializable. Implement `PyTryFrom` for your type to control the "
"behavior of `FromPyObject::extract` for your types. [\\#713](https://github."
"com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:1996
msgid ""
"The implementation for `IntoPy<U> for T` where `U: FromPy<T>` is no longer "
"specializable. Control the behavior of this via the implementation of "
"`FromPy`. [\\#713](https://github.com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:1997
msgid ""
"Use `parking_lot::Mutex` instead of `spin::Mutex`. [\\#734](https://github."
"com/PyO3/pyo3/pull/734)"
msgstr ""

#: src/changelog.md:1998
msgid ""
"Bumped minimum Rust version to `1.42.0-nightly 2020-01-21`. [\\#761](https://"
"github.com/PyO3/pyo3/pull/761)"
msgstr ""

#: src/changelog.md:1999
msgid ""
"`PyRef` and `PyRefMut` are renewed for `PyCell`. [\\#770](https://github.com/"
"PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:2000
msgid ""
"Some new FFI functions for Python 3.8. [\\#784](https://github.com/PyO3/pyo3/"
"pull/784)"
msgstr ""

#: src/changelog.md:2001
msgid ""
"`PyAny` is now on the top level module and prelude. [\\#816](https://github."
"com/PyO3/pyo3/pull/816)"
msgstr ""

#: src/changelog.md:2005
msgid "`PyRawObject`. [\\#683](https://github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:2006
msgid "`PyNoArgsFunction`. [\\#741](https://github.com/PyO3/pyo3/pull/741)"
msgstr ""

#: src/changelog.md:2007
msgid ""
"`initialize_type`. To set the module name for a `#[pyclass]`, use the "
"`module` argument to the macro. #[751](https://github.com/PyO3/pyo3/pull/751)"
msgstr ""

#: src/changelog.md:2008
msgid ""
"`AsPyRef::as_mut/with/with_mut/into_py/into_mut_py`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:2009
msgid ""
"`PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked`. [\\#770]"
"(https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:2010
msgid ""
"`Python::mut_from_owned_ptr/mut_from_borrowed_ptr`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:2011
msgid ""
"`ObjectProtocol::get_base/get_mut_base`. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:2015
msgid ""
"Fixed unsoundness of subclassing. [\\#683](https://github.com/PyO3/pyo3/"
"pull/683)."
msgstr ""

#: src/changelog.md:2016
msgid ""
"Clear error indicator when the exception is handled on the Rust side. "
"[\\#719](https://github.com/PyO3/pyo3/pull/719)"
msgstr ""

#: src/changelog.md:2017
msgid ""
"Usage of raw identifiers with `#[pyo3(set)]`. [\\#745](https://github.com/"
"PyO3/pyo3/pull/745)"
msgstr ""

#: src/changelog.md:2018
msgid ""
"Usage of `PyObject` with `#[pyo3(get)]`. [\\#760](https://github.com/PyO3/"
"pyo3/pull/760)"
msgstr ""

#: src/changelog.md:2019
msgid ""
"`#[pymethods]` used in conjunction with `#[cfg]`. #[769](https://github.com/"
"PyO3/pyo3/pull/769)"
msgstr ""

#: src/changelog.md:2020
msgid ""
"`\"*\"` in a `#[pyfunction()]` argument list incorrectly accepting any "
"number of positional arguments (use `args = \"*\"` when this behavior is "
"desired). #[792](https://github.com/PyO3/pyo3/pull/792)"
msgstr ""

#: src/changelog.md:2021
msgid "`PyModule::dict`. #[809](https://github.com/PyO3/pyo3/pull/809)"
msgstr ""

#: src/changelog.md:2022
msgid ""
"Fix the case where `DESCRIPTION` is not null-terminated. #[822](https://"
"github.com/PyO3/pyo3/pull/822)"
msgstr ""

#: src/changelog.md:2024
msgid ""
"[0.8.5](https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5) - 2020-01-05"
msgstr ""

#: src/changelog.md:2028
msgid "Implemented `FromPyObject` for `HashMap` and `BTreeMap`"
msgstr ""

#: src/changelog.md:2029
msgid ""
"Support for `#[name = \"foo\"]` attribute for `#[pyfunction]` and in "
"`#[pymethods]`. [\\#692](https://github.com/PyO3/pyo3/pull/692)"
msgstr ""

#: src/changelog.md:2031
msgid ""
"[0.8.4](https://github.com/pyo3/pyo3/compare/v0.8.3...v0.8.4) - 2019-12-14"
msgstr ""

#: src/changelog.md:2035
msgid ""
"Support for `#[text_signature]` attribute. [\\#675](https://github.com/PyO3/"
"pyo3/pull/675)"
msgstr ""

#: src/changelog.md:2037
msgid ""
"[0.8.3](https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3) - 2019-11-23"
msgstr ""

#: src/changelog.md:2041
msgid "`#[init]` is removed. [\\#658](https://github.com/PyO3/pyo3/pull/658)"
msgstr ""

#: src/changelog.md:2045
msgid ""
"Now all `&Py~` types have `!Send` bound. [\\#655](https://github.com/PyO3/"
"pyo3/pull/655)"
msgstr ""

#: src/changelog.md:2046
msgid ""
"Fix a compile error raised by the stabilization of `!` type. [\\#672]"
"(https://github.com/PyO3/pyo3/issues/672)."
msgstr ""

#: src/changelog.md:2048
msgid ""
"[0.8.2](https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2) - 2019-10-27"
msgstr ""

#: src/changelog.md:2052
msgid ""
"FFI compatibility for PEP 590 Vectorcall. [\\#641](https://github.com/PyO3/"
"pyo3/pull/641)"
msgstr ""

#: src/changelog.md:2056
msgid ""
"Fix PySequenceProtocol::set_item. [\\#624](https://github.com/PyO3/pyo3/"
"pull/624)"
msgstr ""

#: src/changelog.md:2057
msgid ""
"Fix a corner case of BigInt::FromPyObject. [\\#630](https://github.com/PyO3/"
"pyo3/pull/630)"
msgstr ""

#: src/changelog.md:2058
msgid ""
"Fix index errors in parameter conversion. [\\#631](https://github.com/PyO3/"
"pyo3/pull/631)"
msgstr ""

#: src/changelog.md:2059
msgid ""
"Fix handling of invalid utf-8 sequences in `PyString::as_bytes`. [\\#639]"
"(https://github.com/PyO3/pyo3/pull/639) and `PyString::to_string_lossy` "
"[\\#642](https://github.com/PyO3/pyo3/pull/642)."
msgstr ""

#: src/changelog.md:2061
msgid ""
"Remove `__contains__` and `__iter__` from PyMappingProtocol. [\\#644]"
"(https://github.com/PyO3/pyo3/pull/644)"
msgstr ""

#: src/changelog.md:2062
msgid ""
"Fix proc-macro definition of PySetAttrProtocol. [\\#645](https://github.com/"
"PyO3/pyo3/pull/645)"
msgstr ""

#: src/changelog.md:2064
msgid ""
"[0.8.1](https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1) - 2019-10-08"
msgstr ""

#: src/changelog.md:2068
msgid ""
"Conversion between [num-bigint](https://github.com/rust-num/num-bigint) and "
"Python int. [\\#608](https://github.com/PyO3/pyo3/pull/608)"
msgstr ""

#: src/changelog.md:2072
msgid ""
"Make sure the right Python interpreter is used in OSX builds. [\\#604]"
"(https://github.com/PyO3/pyo3/pull/604)"
msgstr ""

#: src/changelog.md:2073
msgid ""
"Patch specialization being broken by Rust 1.40. [\\#614](https://github.com/"
"PyO3/pyo3/issues/614)"
msgstr ""

#: src/changelog.md:2074
msgid ""
"Fix a segfault around PyErr. [\\#597](https://github.com/PyO3/pyo3/pull/597)"
msgstr ""

#: src/changelog.md:2076
msgid ""
"[0.8.0](https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0) - 2019-09-16"
msgstr ""

#: src/changelog.md:2080
msgid ""
"`module` argument to `pyclass` macro. [\\#499](https://github.com/PyO3/pyo3/"
"pull/499)"
msgstr ""

#: src/changelog.md:2081
msgid "`py_run!` macro [\\#512](https://github.com/PyO3/pyo3/pull/512)"
msgstr ""

#: src/changelog.md:2082
msgid ""
"Use existing fields and methods before calling custom **getattr**. [\\#505]"
"(https://github.com/PyO3/pyo3/pull/505)"
msgstr ""

#: src/changelog.md:2083
msgid "`PyBytes` can now be indexed just like `Vec<u8>`"
msgstr ""

#: src/changelog.md:2084
msgid "Implement `IntoPy<PyObject>` for `PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:2088
msgid ""
"Implementing the Using the `gc` parameter for `pyclass` (e.g. "
"`#[pyclass(gc)]`) without implementing the `class::PyGCProtocol` trait is "
"now a compile-time error. Failing to implement this trait could lead to "
"segfaults. [\\#532](https://github.com/PyO3/pyo3/pull/532)"
msgstr ""

#: src/changelog.md:2089
msgid ""
"`PyByteArray::data` has been replaced with `PyDataArray::to_vec` because "
"returning a `&[u8]` is unsound. (See [this comment](https://github.com/PyO3/"
"pyo3/issues/373#issuecomment-512332696) for a great write-up for why that "
"was unsound)"
msgstr ""

#: src/changelog.md:2090
msgid "Replace `mashup` with `paste`."
msgstr ""

#: src/changelog.md:2091
msgid ""
"`GILPool` gained a `Python` marker to prevent it from being misused to "
"release Python objects without the GIL held."
msgstr ""

#: src/changelog.md:2095
msgid "`IntoPyObject` was replaced with `IntoPy<PyObject>`"
msgstr ""

#: src/changelog.md:2096
msgid ""
"`#[pyclass(subclass)]` is hidden a `unsound-subclass` feature because it's "
"causing segmentation faults."
msgstr ""

#: src/changelog.md:2100
msgid ""
"More readable error message for generics in pyclass [\\#503](https://github."
"com/PyO3/pyo3/pull/503)"
msgstr ""

#: src/changelog.md:2102
msgid ""
"[0.7.0](https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0) - 2019-05-26"
msgstr ""

#: src/changelog.md:2106
msgid ""
"PyPy support by omerbenamram in [\\#393](https://github.com/PyO3/pyo3/"
"pull/393)"
msgstr ""

#: src/changelog.md:2107
msgid "Have `PyModule` generate an index of its members (`__all__` list)."
msgstr ""

#: src/changelog.md:2108
msgid "Allow `slf: PyRef<T>` for pyclass(#419)"
msgstr ""

#: src/changelog.md:2109
msgid "Allow to use lifetime specifiers in `pymethods`"
msgstr ""

#: src/changelog.md:2110
msgid "Add `marshal` module. [\\#460](https://github.com/PyO3/pyo3/pull/460)"
msgstr ""

#: src/changelog.md:2114
msgid "`Python::run` returns `PyResult<()>` instead of `PyResult<&PyAny>`."
msgstr ""

#: src/changelog.md:2115
msgid ""
"Methods decorated with `#[getter]` and `#[setter]` can now omit wrapping the "
"result type in `PyResult` if they don't raise exceptions."
msgstr ""

#: src/changelog.md:2120
msgid ""
"`type_object::PyTypeObject` has been marked unsafe because breaking the "
"contract `type_object::PyTypeObject::init_type` can lead to UB."
msgstr ""

#: src/changelog.md:2121
msgid ""
"Fixed automatic derive of `PySequenceProtocol` implementation in [\\#423]"
"(https://github.com/PyO3/pyo3/pull/423)."
msgstr ""

#: src/changelog.md:2122
msgid "Capitalization & better wording to README.md."
msgstr ""

#: src/changelog.md:2123
msgid ""
"Docstrings of properties is now properly set using the doc of the "
"`#[getter]` method."
msgstr ""

#: src/changelog.md:2124
msgid ""
"Fixed issues with `pymethods` crashing on doc comments containing double "
"quotes."
msgstr ""

#: src/changelog.md:2125
msgid ""
"`PySet::new` and `PyFrozenSet::new` now return `PyResult<&Py[Frozen]Set>`; "
"exceptions are raised if the items are not hashable."
msgstr ""

#: src/changelog.md:2127
msgid "Fixed building using `venv` on Windows."
msgstr ""

#: src/changelog.md:2128
msgid "`PyTuple::new` now returns `&PyTuple` instead of `Py<PyTuple>`."
msgstr ""

#: src/changelog.md:2129
msgid ""
"Fixed several issues with argument parsing; notable, the `*args` and "
"`**kwargs` tuple/dict now doesn't contain arguments that are otherwise "
"assigned to parameters."
msgstr ""

#: src/changelog.md:2132
msgid ""
"[0.6.0](https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0) - 2019-03-28"
msgstr ""

#: src/changelog.md:2134
msgid "Regressions"
msgstr ""

#: src/changelog.md:2136
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For now you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/changelog.md:2138
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/changelog.md:2149
msgid ""
"Added a `wrap_pymodule!` macro similar to the existing `wrap_pyfunction!` "
"macro. Only available on python 3"
msgstr ""

#: src/changelog.md:2150
msgid ""
"Added support for cross compiling (e.g. to arm v7) by mtp401 in [\\#327]"
"(https://github.com/PyO3/pyo3/pull/327). See the \"Cross Compiling\" section "
"in the \"Building and Distribution\" chapter of the guide for more details."
msgstr ""

#: src/changelog.md:2151
msgid ""
"The `PyRef` and `PyRefMut` types, which allow to differentiate between an "
"instance of a rust struct on the rust heap and an instance that is embedded "
"inside a python object. By kngwyu in [\\#335](https://github.com/PyO3/pyo3/"
"pull/335)"
msgstr ""

#: src/changelog.md:2152
msgid ""
"Added `FromPy<T>` and `IntoPy<T>` which are equivalent to `From<T>` and "
"`Into<T>` except that they require a gil token."
msgstr ""

#: src/changelog.md:2153
msgid ""
"Added `ManagedPyRef`, which should eventually replace `ToBorrowedObject`."
msgstr ""

#: src/changelog.md:2157
msgid "Renamed `PyObjectRef` to `PyAny` in #388"
msgstr ""

#: src/changelog.md:2158
msgid ""
"Renamed `add_function` to `add_wrapped` as it now also supports modules."
msgstr ""

#: src/changelog.md:2159
msgid "Renamed `#[pymodinit]` to `#[pymodule]`"
msgstr ""

#: src/changelog.md:2160
msgid "`py.init(|| value)` becomes `Py::new(value)`"
msgstr ""

#: src/changelog.md:2161
msgid "`py.init_ref(|| value)` becomes `PyRef::new(value)`"
msgstr ""

#: src/changelog.md:2162
msgid "`py.init_mut(|| value)` becomes `PyRefMut::new(value)`."
msgstr ""

#: src/changelog.md:2163
msgid ""
"`PyRawObject::init` is now infallible, e.g. it returns `()` instead of "
"`PyResult<()>`."
msgstr ""

#: src/changelog.md:2164
msgid ""
"Renamed `py_exception!` to `create_exception!` and refactored the error "
"macros."
msgstr ""

#: src/changelog.md:2165
msgid "Renamed `wrap_function!` to `wrap_pyfunction!`"
msgstr ""

#: src/changelog.md:2166
msgid "Renamed `#[prop(get, set)]` to `#[pyo3(get, set)]`"
msgstr ""

#: src/changelog.md:2167
msgid "`#[pyfunction]` now supports the same arguments as `#[pyfn()]`"
msgstr ""

#: src/changelog.md:2168
msgid "Some macros now emit proper spanned errors instead of panics."
msgstr ""

#: src/changelog.md:2169
msgid "Migrated to the 2018 edition"
msgstr ""

#: src/changelog.md:2170
msgid "`crate::types::exceptions` moved to `crate::exceptions`"
msgstr ""

#: src/changelog.md:2171
msgid "Replace `IntoPyTuple` with `IntoPy<Py<PyTuple>>`."
msgstr ""

#: src/changelog.md:2172
msgid "`IntoPyPointer` and `ToPyPointer` moved into the crate root."
msgstr ""

#: src/changelog.md:2173
msgid "`class::CompareOp` moved into `class::basic::CompareOp`"
msgstr ""

#: src/changelog.md:2174
msgid ""
"PyTypeObject is now a direct subtrait PyTypeCreate, removing the old "
"cyclical implementation in [\\#350](https://github.com/PyO3/pyo3/pull/350)"
msgstr ""

#: src/changelog.md:2175
msgid ""
"Add `PyList::{sort, reverse}` by chr1sj0nes in [\\#357](https://github.com/"
"PyO3/pyo3/pull/357) and [\\#358](https://github.com/PyO3/pyo3/pull/358)"
msgstr ""

#: src/changelog.md:2176
msgid "Renamed the `typeob` module to `type_object`"
msgstr ""

#: src/changelog.md:2180
msgid ""
"`PyToken` was removed due to unsoundness (See [\\#94](https://github.com/"
"PyO3/pyo3/issues/94))."
msgstr ""

#: src/changelog.md:2181
msgid "Removed the unnecessary type parameter from `PyObjectAlloc`"
msgstr ""

#: src/changelog.md:2182
msgid "`NoArgs`. Just use an empty tuple"
msgstr ""

#: src/changelog.md:2183
msgid ""
"`PyObjectWithGIL`. `PyNativeType` is sufficient now that PyToken is removed."
msgstr ""

#: src/changelog.md:2187
msgid ""
"A soudness hole where every instances of a `#[pyclass]` struct was "
"considered to be part of a python object, even though you can create "
"instances that are not part of the python heap. This was fixed through "
"`PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:2188
msgid "Fix kwargs support in [\\#328](https://github.com/PyO3/pyo3/pull/328)."
msgstr ""

#: src/changelog.md:2189
msgid ""
"Add full support for `__dict__` in [\\#403](https://github.com/PyO3/pyo3/"
"pull/403)."
msgstr ""

#: src/changelog.md:2191
msgid ""
"[0.5.3](https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3) - 2019-01-04"
msgstr ""

#: src/changelog.md:2195
msgid ""
"Fix memory leak in ArrayList by kngwyu [\\#316](https://github.com/PyO3/pyo3/"
"pull/316)"
msgstr ""

#: src/changelog.md:2197
msgid ""
"[0.5.2](https://github.com/pyo3/pyo3/compare/v0.5.1...v0.5.2) - 2018-11-25"
msgstr ""

#: src/changelog.md:2201
msgid ""
"Fix undeterministic segfaults when creating many objects by kngwyu in "
"[\\#281](https://github.com/PyO3/pyo3/pull/281)"
msgstr ""

#: src/changelog.md:2203
msgid ""
"[0.5.1](https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.1) - 2018-11-24"
msgstr ""

#: src/changelog.md:2205
msgid "Yanked"
msgstr ""

#: src/changelog.md:2207
msgid ""
"[0.5.0](https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0) - 2018-11-11"
msgstr ""

#: src/changelog.md:2211
msgid "`#[pyclass]` objects can now be returned from rust functions"
msgstr ""

#: src/changelog.md:2212
msgid ""
"`PyComplex` by kngwyu in [\\#226](https://github.com/PyO3/pyo3/pull/226)"
msgstr ""

#: src/changelog.md:2213
msgid "`PyDict::from_sequence`, equivalent to `dict([(key, val), ...])`"
msgstr ""

#: src/changelog.md:2214
msgid ""
"Bindings for the `datetime` standard library types: `PyDate`, `PyTime`, "
"`PyDateTime`, `PyTzInfo`, `PyDelta` with associated `ffi` types, by pganssle "
"[\\#200](https://github.com/PyO3/pyo3/pull/200)."
msgstr ""

#: src/changelog.md:2215
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` now have an `as_bytes` method that "
"returns `&[u8]`."
msgstr ""

#: src/changelog.md:2216
msgid ""
"`PyObjectProtocol::get_type_ptr` by ijl in [\\#242](https://github.com/PyO3/"
"pyo3/pull/242)"
msgstr ""

#: src/changelog.md:2220
msgid ""
"Removes the types from the root module and the prelude. They now live in "
"`pyo3::types` instead."
msgstr ""

#: src/changelog.md:2221
msgid ""
"All exceptions are constructed with `py_err` instead of `new`, as they "
"return `PyErr` and not `Self`."
msgstr ""

#: src/changelog.md:2222
msgid "`as_mut` and friends take and `&mut self` instead of `&self`"
msgstr ""

#: src/changelog.md:2223
msgid ""
"`ObjectProtocol::call` now takes an `Option<&PyDict>` for the kwargs instead "
"of an `IntoPyDictPointer`."
msgstr ""

#: src/changelog.md:2224
msgid ""
"`IntoPyDictPointer` was replace by `IntoPyDict` which doesn't convert "
"`PyDict` itself anymore and returns a `PyDict` instead of `*mut PyObject`."
msgstr ""

#: src/changelog.md:2225
msgid "`PyTuple::new` now takes an `IntoIterator` instead of a slice"
msgstr ""

#: src/changelog.md:2226
msgid "Updated to syn 0.15"
msgstr ""

#: src/changelog.md:2227
msgid ""
"Split `PyTypeObject` into `PyTypeObject` without the create method and "
"`PyTypeCreate` with requires `PyObjectAlloc<Self> + PyTypeInfo + Sized`."
msgstr ""

#: src/changelog.md:2228
msgid ""
"Ran `cargo edition --fix` which prefixed path with `crate::` for rust 2018"
msgstr ""

#: src/changelog.md:2229
msgid ""
"Renamed `async` to `pyasync` as async will be a keyword in the 2018 edition."
msgstr ""

#: src/changelog.md:2230
msgid ""
"Starting to use `NonNull<*mut PyObject>` for Py and PyObject by ijl [\\#260]"
"(https://github.com/PyO3/pyo3/pull/260)"
msgstr ""

#: src/changelog.md:2234
msgid ""
"Removed most entries from the prelude. The new prelude is small and clear."
msgstr ""

#: src/changelog.md:2235
msgid "Slowly removing specialization uses"
msgstr ""

#: src/changelog.md:2236
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` no longer have a `data` method "
"(replaced by `as_bytes`) and `PyStringData` has been removed."
msgstr ""

#: src/changelog.md:2238
msgid "The pyobject_extract macro"
msgstr ""

#: src/changelog.md:2242
msgid ""
"Added an explanation that the GIL can temporarily be released even while "
"holding a GILGuard."
msgstr ""

#: src/changelog.md:2243
msgid "Lots of clippy errors"
msgstr ""

#: src/changelog.md:2244
msgid "Fix segfault on calling an unknown method on a PyObject"
msgstr ""

#: src/changelog.md:2245
msgid ""
"Work around a [bug](https://github.com/rust-lang/rust/issues/55380) in the "
"rust compiler by kngwyu [\\#252](https://github.com/PyO3/pyo3/pull/252)"
msgstr ""

#: src/changelog.md:2246
msgid ""
"Fixed a segfault with subclassing pyo3 create classes and using `__class__` "
"by kngwyu [\\#263](https://github.com/PyO3/pyo3/pull/263)"
msgstr ""

#: src/changelog.md:2248
msgid ""
"[0.4.1](https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1) - 2018-08-20"
msgstr ""

#: src/changelog.md:2252
msgid "PyTryFrom's error is always to `PyDowncastError`"
msgstr ""

#: src/changelog.md:2256
msgid "Fixed compilation on nightly since `use_extern_macros` was stabilized"
msgstr ""

#: src/changelog.md:2260
msgid "The pyobject_downcast macro"
msgstr ""

#: src/changelog.md:2262
msgid ""
"[0.4.0](https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0) - 2018-07-30"
msgstr ""

#: src/changelog.md:2266
msgid "Merged both examples into one"
msgstr ""

#: src/changelog.md:2267
msgid "Rustfmt all the things :heavy_check_mark:"
msgstr ""

#: src/changelog.md:2268
msgid "Switched to [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)"
msgstr ""

#: src/changelog.md:2272
msgid ""
"Conversions from tuples to PyDict due to [rust-lang/rust#52050](https://"
"github.com/rust-lang/rust/issues/52050)"
msgstr ""

#: src/changelog.md:2274
msgid ""
"[0.3.2](https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2) - 2018-07-22"
msgstr ""

#: src/changelog.md:2278
msgid "Replaced `concat_idents` with mashup"
msgstr ""

#: src/changelog.md:2280
msgid ""
"[0.3.1](https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1) - 2018-07-18"
msgstr ""

#: src/changelog.md:2284
msgid "Fixed scoping bug in pyobject_native_type that would break rust-numpy"
msgstr ""

#: src/changelog.md:2286
msgid ""
"[0.3.0](https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0) - 2018-07-18"
msgstr ""

#: src/changelog.md:2290
msgid ""
"A few internal macros became part of the public api ([\\#155](https://github."
"com/PyO3/pyo3/pull/155), [\\#186](https://github.com/PyO3/pyo3/pull/186))"
msgstr ""

#: src/changelog.md:2291
msgid ""
"Always clone in getters. This allows using the get-annotation on all Clone-"
"Types"
msgstr ""

#: src/changelog.md:2295
msgid "Upgraded to syn 0.14 which means much better error messages :tada:"
msgstr ""

#: src/changelog.md:2296
msgid ""
"128 bit integer support by [kngwyu](https://github.com/kngwyu) ([\\#137]"
"(https://github.com/PyO3/pyo3/pull/173))"
msgstr ""

#: src/changelog.md:2297
msgid ""
"`proc_macro` has been stabilized on nightly ([rust-lang/rust#52081](https://"
"github.com/rust-lang/rust/pull/52081)). This means that we can remove the "
"`proc_macro` feature, but now we need the `use_extern_macros` from the 2018 "
"edition instead."
msgstr ""

#: src/changelog.md:2298
msgid ""
"All proc macro are now prefixed with `py` and live in the prelude. This "
"means you can use `#[pyclass]`, `#[pymethods]`, `#[pyproto]`, "
"`#[pyfunction]` and `#[pymodinit]` directly, at least after a `use pyo3::"
"prelude::*`. They were also moved into a module called `proc_macro`. You "
"shouldn't use `#[pyo3::proc_macro::pyclass]` or other longer paths in "
"attributes because `proc_macro_path_invoc` isn't going to be stabilized soon."
msgstr ""

#: src/changelog.md:2299
msgid "Renamed the `base` option in the `pyclass` macro to `extends`."
msgstr ""

#: src/changelog.md:2300
msgid ""
"`#[pymodinit]` uses the function name as module name, unless the name is "
"overridden with `#[pymodinit(name)]`"
msgstr ""

#: src/changelog.md:2301
msgid "The guide is now properly versioned."
msgstr ""

#: src/changelog.md:2303
msgid ""
"[0.2.7](https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7) - 2018-05-18"
msgstr ""

#: src/changelog.md:2307
msgid "Fix nightly breakage with proc_macro_path"
msgstr ""

#: src/changelog.md:2309
msgid ""
"[0.2.6](https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6) - 2018-04-03"
msgstr ""

#: src/changelog.md:2313
msgid "Fix compatibility with TryFrom trait #137"
msgstr ""

#: src/changelog.md:2315
msgid ""
"[0.2.5](https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5) - 2018-02-21"
msgstr ""

#: src/changelog.md:2319
msgid "CPython 3.7 support"
msgstr ""

#: src/changelog.md:2323
msgid "Embedded CPython 3.7b1 crashes on initialization #110"
msgstr ""

#: src/changelog.md:2324
msgid "Generated extension functions are weakly typed #108"
msgstr ""

#: src/changelog.md:2325
msgid "call_method\\* crashes when the method does not exist #113"
msgstr ""

#: src/changelog.md:2326
msgid "Allow importing exceptions from nested modules #116"
msgstr ""

#: src/changelog.md:2328
msgid ""
"[0.2.4](https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4) - 2018-01-19"
msgstr ""

#: src/changelog.md:2332
msgid "Allow to get mutable ref from PyObject #106"
msgstr ""

#: src/changelog.md:2333
msgid "Drop `RefFromPyObject` trait"
msgstr ""

#: src/changelog.md:2334
msgid "Add Python::register_any method"
msgstr ""

#: src/changelog.md:2338
msgid "Fix impl `FromPyObject` for `Py<T>`"
msgstr ""

#: src/changelog.md:2339
msgid "Mark method that work with raw pointers as unsafe #95"
msgstr ""

#: src/changelog.md:2341
msgid ""
"[0.2.3](https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3) - 11-27-2017"
msgstr ""

#: src/changelog.md:2345
msgid "Rustup to 1.23.0-nightly 2017-11-07"
msgstr ""

#: src/changelog.md:2349
msgid "Proper `c_char` usage #93"
msgstr ""

#: src/changelog.md:2353
msgid "Remove use of now unneeded 'AsciiExt' trait"
msgstr ""

#: src/changelog.md:2355
msgid ""
"[0.2.2](https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2) - 09-26-2017"
msgstr ""

#: src/changelog.md:2359
msgid "Rustup to 1.22.0-nightly 2017-09-30"
msgstr ""

#: src/changelog.md:2361
msgid ""
"[0.2.1](https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1) - 09-26-2017"
msgstr ""

#: src/changelog.md:2365
msgid "Fix rustc const_fn nightly breakage"
msgstr ""

#: src/changelog.md:2367
msgid ""
"[0.2.0](https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0) - 08-12-2017"
msgstr ""

#: src/changelog.md:2371
msgid "Added inheritance support #15"
msgstr ""

#: src/changelog.md:2372
msgid "Added weakref support #56"
msgstr ""

#: src/changelog.md:2373
msgid "Added subclass support #64"
msgstr ""

#: src/changelog.md:2374
msgid "Added `self.__dict__` support #68"
msgstr ""

#: src/changelog.md:2375
msgid "Added `pyo3::prelude` module #70"
msgstr ""

#: src/changelog.md:2376
msgid "Better `Iterator` support for PyTuple, PyList, PyDict #75"
msgstr ""

#: src/changelog.md:2377
msgid "Introduce IntoPyDictPointer similar to IntoPyTuple #69"
msgstr ""

#: src/changelog.md:2381
msgid "Allow to add gc support without implementing PyGCProtocol #57"
msgstr ""

#: src/changelog.md:2382
msgid "Refactor `PyErr` implementation. Drop `py` parameter from constructor."
msgstr ""

#: src/changelog.md:2384
msgid "[0.1.0](https://github.com/PyO3/pyo3/tree/0.1.0) - 07-23-2017"
msgstr ""

#: src/changelog.md:2388
msgid "Initial release"
msgstr ""

#: src/contributing.md:1
msgid "Contributing"
msgstr ""

#: src/contributing.md:3
msgid ""
"Thank you for your interest in contributing to PyO3! All are welcome - "
"please consider reading our [Code of Conduct](https://github.com/PyO3/pyo3/"
"blob/main/Code-of-Conduct.md) to keep our community positive and inclusive."
msgstr ""

#: src/contributing.md:5
msgid ""
"If you are searching for ideas how to contribute, proceed to the [\"Getting "
"started contributing\"](#getting-started-contributing) section. If you have "
"found a specific issue to contribute to and need information about the "
"development process, you may find the section [\"Writing pull requests\"]"
"(#writing-pull-requests) helpful."
msgstr ""

#: src/contributing.md:7
msgid ""
"If you want to become familiar with the codebase, see [Architecture.md]"
"(https://github.com/PyO3/pyo3/blob/main/Architecture.md)."
msgstr ""

#: src/contributing.md:10
msgid "Getting started contributing"
msgstr ""

#: src/contributing.md:12
msgid ""
"Please join in with any part of PyO3 which interests you. We use GitHub "
"issues to record all bugs and ideas. Feel free to request an issue to be "
"assigned to you if you want to work on it."
msgstr ""

#: src/contributing.md:14
msgid ""
"You can browse the API of the non-public parts of PyO3 [here](https://pyo3."
"netlify.app/internal/doc/pyo3/index.html)."
msgstr ""

#: src/contributing.md:16
msgid ""
"The following sections also contain specific ideas on where to start "
"contributing to PyO3."
msgstr ""

#: src/contributing.md:18
msgid "Setting up a development environment"
msgstr ""

#: src/contributing.md:20
msgid ""
"To work and develop PyO3, you need Python & Rust installed on your system."
msgstr ""

#: src/contributing.md:22
msgid ""
"We encourage the use of [rustup](https://rustup.rs/) to be able to select "
"and choose specific toolchains based on the project."
msgstr ""

#: src/contributing.md:23
msgid ""
"[Pyenv](https://github.com/pyenv/pyenv) is also highly recommended for being "
"able to choose a specific Python version."
msgstr ""

#: src/contributing.md:24
msgid ""
"[virtualenv](https://virtualenv.pypa.io/en/latest/) can also be used with or "
"without Pyenv to use specific installed Python versions."
msgstr ""

#: src/contributing.md:25
msgid ""
"[`nox`](https://github.com/theacodes/nox) is used to automate many of our CI "
"tasks."
msgstr ""

#: src/contributing.md:27
msgid "Testing, linting, etc. with nox"
msgstr ""

#: src/contributing.md:29
msgid ""
"[`Nox`](https://github.com/theacodes/nox) is used to automate many of our CI "
"tasks and can be used locally to handle verfication tasks as you code. We "
"recommend running these actions via nox to make use of our prefered "
"configuration options. You can install nox into your global python with pip: "
"`pip install nox` or (recommended) with [`pipx`](https://pipx.pypa.io/"
"stable/) `pip install pipx`, `pipx install nox`"
msgstr ""

#: src/contributing.md:31
msgid "The main nox commands we have implemented are:"
msgstr ""

#: src/contributing.md:33
msgid ""
"`nox -s test` will run the full suite of recommended rust and python tests "
"(>10 minutes)"
msgstr ""

#: src/contributing.md:34
msgid ""
"`nox -s test-rust -- skip-full` will run a short suite of rust tests (2-3 "
"minutes)"
msgstr ""

#: src/contributing.md:35
msgid ""
"`nox -s ruff` will check python linting and apply standard formatting rules"
msgstr ""

#: src/contributing.md:36
msgid ""
"`nox -s rustfmt` will check basic rust linting and apply standard formatting "
"rules"
msgstr ""

#: src/contributing.md:37
msgid "`nox -s rumdl` will check the markdown in the guide"
msgstr ""

#: src/contributing.md:38
msgid "`nox -s clippy` will run clippy to make recommendations on rust style"
msgstr ""

#: src/contributing.md:39
msgid "`nox -s bench` will benchmark your rust code"
msgstr ""

#: src/contributing.md:40
msgid ""
"`nox -s codspeed` will run our suite of rust and python performance tests"
msgstr ""

#: src/contributing.md:41
msgid ""
"`nox -s coverage` will analyse test coverage and output `coverage.json` "
"(alternatively: `nox -s coverage lcov` outputs `lcov.info`)"
msgstr ""

#: src/contributing.md:42
msgid ""
"`nox -s check-guide` will use [`lychee`](https://github.com/lycheeverse/"
"lychee) to check all the links in the guide and doc comments."
msgstr ""

#: src/contributing.md:44
msgid "Use  `nox -l` to list the full set of subcommands you can run."
msgstr ""

#: src/contributing.md:46
msgid "UI Tests"
msgstr ""

#: src/contributing.md:48
msgid ""
"PyO3 uses [`trybuild`](https://github.com/dtolnay/trybuild) to develop UI "
"tests to capture error messages from the Rust compiler for some of the macro "
"functionality."
msgstr ""

#: src/contributing.md:50
msgid ""
"Because there are several feature combinations for these UI tests, when "
"updating them all (e.g. for a new Rust compiler version) it may be helpful "
"to use the `update-ui-tests` nox session:"
msgstr ""

#: src/contributing.md:56
msgid "Ways to help"
msgstr ""

#: src/contributing.md:58
msgid "Help users identify bugs"
msgstr ""

#: src/contributing.md:60
msgid ""
"The [PyO3 Discord server](https://discord.gg/33kcChzH7f) is very active with "
"users who are new to PyO3, and often completely new to Rust. Helping them "
"debug is a great way to get experience with the PyO3 codebase."
msgstr ""

#: src/contributing.md:62
msgid ""
"Helping others often reveals bugs, documentation weaknesses, and missing "
"APIs. It's a good idea to open GitHub issues for these immediately so the "
"resolution can be designed and implemented!"
msgstr ""

#: src/contributing.md:64
msgid "Implement issues ready for development"
msgstr ""

#: src/contributing.md:66
msgid ""
"Issues where the solution is clear and work is not in progress use the "
"[needs-implementer](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Aneeds-implementer) label."
msgstr ""

#: src/contributing.md:68
msgid ""
"Don't be afraid if the solution is not clear to you! The core PyO3 "
"contributors will be happy to mentor you through any questions you have to "
"help you write the solution."
msgstr ""

#: src/contributing.md:70
msgid "Help write great docs"
msgstr ""

#: src/contributing.md:72
msgid ""
"PyO3 has a user guide (using mdbook) as well as the usual Rust API docs. The "
"aim is for both of these to be detailed, easy to understand, and up-to-date. "
"Pull requests are always welcome to fix typos, change wording, add examples, "
"etc."
msgstr ""

#: src/contributing.md:74
msgid ""
"There are some specific areas of focus where help is currently needed for "
"the documentation:"
msgstr ""

#: src/contributing.md:76
msgid ""
"Issues requesting documentation improvements are tracked with the "
"[documentation](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Adocumentation) label."
msgstr ""

#: src/contributing.md:77
msgid ""
"Not all APIs had docs or examples when they were made. The goal is to have "
"documentation on all PyO3 APIs ([\\#306](https://github.com/PyO3/pyo3/"
"issues/306)). If you see an API lacking a doc, please write one and open a "
"PR!"
msgstr ""

#: src/contributing.md:79
msgid ""
"To build the docs (including all features), install [`nox`](https://github."
"com/theacodes/nox) and then run"
msgstr ""

#: src/contributing.md:85
msgid "Doctests"
msgstr ""

#: src/contributing.md:87
msgid ""
"We use lots of code blocks in our docs. Run `cargo test --doc` when making "
"changes to check that the doctests still work, or `cargo test` to run all "
"the Rust tests including doctests. See https://doc.rust-lang.org/rustdoc/"
"documentation-tests.html for a guide on doctests."
msgstr ""

#: src/contributing.md:91
msgid "Building the guide"
msgstr ""

#: src/contributing.md:93
msgid "You can preview the user guide by building it locally with `mdbook`."
msgstr ""

#: src/contributing.md:95
msgid ""
"First, install [`mdbook`](https://rust-lang.github.io/mdBook/cli/index."
"html), the [`mdbook-tabs`](https://mdbook-plugins.rustforweb.org/tabs.html) "
"plugin and [`nox`](https://github.com/theacodes/nox). Then, run"
msgstr ""

#: src/contributing.md:101
msgid ""
"To check all links in the guide are valid, also install [`lychee`](https://"
"github.com/lycheeverse/lychee) and use the `check-guide` session instead:"
msgstr ""

#: src/contributing.md:107
msgid "Help design the next PyO3"
msgstr ""

#: src/contributing.md:109
msgid ""
"Issues which don't yet have a clear solution use the [needs-design](https://"
"github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design) "
"label."
msgstr ""

#: src/contributing.md:111
msgid ""
"If any of these issues interest you, please join in with the conversation on "
"the issue! All opinions are valued, and if you're interested in going "
"further with e.g. draft PRs to experiment with API designs, even better!"
msgstr ""

#: src/contributing.md:113
msgid "Review pull requests"
msgstr ""

#: src/contributing.md:115
msgid ""
"Everybody is welcome to submit comments on open PRs. Please help ensure new "
"PyO3 APIs are safe, performant, tidy, and easy to use!"
msgstr ""

#: src/contributing.md:117
msgid "Writing pull requests"
msgstr ""

#: src/contributing.md:119
msgid "Here are a few things to note when you are writing PRs."
msgstr ""

#: src/contributing.md:121
msgid "Testing and Continuous Integration"
msgstr ""

#: src/contributing.md:123
msgid ""
"The PyO3 repo uses GitHub Actions. PRs are blocked from merging if CI is not "
"successful. Formatting, linting and tests are checked for all Rust and "
"Python code (the pipeline will abort early if formatting fails to save "
"resources). In addition, all warnings in Rust code are disallowed (using "
"`RUSTFLAGS=\"-D warnings\"`)."
msgstr ""

#: src/contributing.md:128
msgid ""
"Tests run with all supported Python versions with the latest stable Rust "
"compiler, as well as for Python 3.9 with the minimum supported Rust version."
msgstr ""

#: src/contributing.md:130
msgid ""
"If you are adding a new feature, you should add it to the `full` feature in "
"our _Cargo.toml_\\* so that it is tested in CI."
msgstr ""

#: src/contributing.md:132
msgid ""
"You can run the CI pipeline components yourself with `nox`, see [the testing "
"section above](#testing-linting-etc-with-nox)."
msgstr ""

#: src/contributing.md:134
msgid "Documenting changes"
msgstr ""

#: src/contributing.md:136
msgid ""
"We use [towncrier](https://towncrier.readthedocs.io/en/stable/index.html) to "
"generate a CHANGELOG for each release."
msgstr ""

#: src/contributing.md:138
msgid ""
"To include your changes in the release notes, you should create one (or "
"more) news items in the `newsfragments` directory. Valid news items should "
"be saved as `<PR>.<CATEGORY>.md` where `<PR>` is the pull request number and "
"`<CATEGORY>` is one of the following:"
msgstr ""

#: src/contributing.md:139
msgid ""
"`packaging` - for dependency changes and Python / Rust version compatibility "
"changes"
msgstr ""

#: src/contributing.md:140
msgid "`added` - for new features"
msgstr ""

#: src/contributing.md:141
msgid ""
"`changed` - for features which already existed but have been altered or "
"deprecated"
msgstr ""

#: src/contributing.md:142
msgid "`removed` - for features which have been removed"
msgstr ""

#: src/contributing.md:143
msgid "`fixed` - for \"changed\" features which were classed as a bugfix"
msgstr ""

#: src/contributing.md:145
msgid ""
"Docs-only PRs do not need news items; start your PR title with `docs:` to "
"skip the check."
msgstr ""

#: src/contributing.md:147
msgid "Style guide"
msgstr ""

#: src/contributing.md:149
msgid "Generic code"
msgstr ""

#: src/contributing.md:151
msgid ""
"PyO3 has a lot of generic APIs to increase usability. These can come at the "
"cost of generic code bloat. Where reasonable, try to implement a concrete "
"sub-portion of generic functions. There are two forms of this:"
msgstr ""

#: src/contributing.md:153
msgid ""
"If the concrete sub-portion doesn't benefit from re-use by other functions, "
"name it `inner` and keep it as a local to the function."
msgstr ""

#: src/contributing.md:154
msgid ""
"If the concrete sub-portion is re-used by other functions, preferably name "
"it `_foo` and place it directly below `foo` in the source code (where `foo` "
"is the original generic function)."
msgstr ""

#: src/contributing.md:156
msgid "FFI calls"
msgstr ""

#: src/contributing.md:158
msgid ""
"PyO3 makes a lot of FFI calls to Python's C API using raw pointers. Where "
"possible try to avoid using pointers-to-temporaries in expressions:"
msgstr ""

#: src/contributing.md:161
msgid "// dangerous\n"
msgstr ""

#: src/contributing.md:163
msgid "// because the following refactoring is a use-after-free error:\n"
msgstr ""

#: src/contributing.md:169
msgid ""
"Instead, prefer to bind the safe owned `PyObject` wrapper before passing to "
"ffi functions:"
msgstr ""

#: src/contributing.md:173
msgid "// name will automatically be freed when it falls out of scope\n"
msgstr ""

#: src/contributing.md:177
msgid "Python and Rust version support policy"
msgstr ""

#: src/contributing.md:179
msgid ""
"PyO3 aims to keep sufficient compatibility to make packaging Python "
"extensions built with PyO3 feasible on most common package managers."
msgstr ""

#: src/contributing.md:181
msgid ""
"To keep package maintainers' lives simpler, PyO3 will commit, wherever "
"possible, to only adjust minimum supported Rust and Python versions at the "
"same time. This bump will only come in an `0.x` release, roughly once per "
"year, after the oldest supported Python version reaches its end-of-life. "
"(Check https://endoflife.date/python for a clear timetable on these.)"
msgstr ""

#: src/contributing.md:183
msgid ""
"Below are guidelines on what compatibility all PRs are expected to deliver "
"for each language."
msgstr ""

#: src/contributing.md:185
msgid "Python"
msgstr ""

#: src/contributing.md:187
msgid ""
"PyO3 supports all officially supported Python versions, as well as the "
"latest PyPy3 release. All of these versions are tested in CI."
msgstr ""

#: src/contributing.md:189
msgid "Adding support for new CPython versions"
msgstr ""

#: src/contributing.md:191
msgid ""
"If you plan to add support for a pre-release version of CPython, here's a "
"(non-exhaustive) checklist:"
msgstr ""

#: src/contributing.md:193
msgid ""
"Wait until the last alpha release (usually alpha7), since ABI is not "
"guaranteed until the first beta release"
msgstr ""

#: src/contributing.md:194
msgid ""
"Add prerelease_ver-dev (e.g. `3.14-dev`) to `.github/workflows/ci.yml`, and "
"bump version in `noxfile.py`, `pyo3-ffi/Cargo.toml` under `max-version` "
"within  `[package.metadata.cpython]`, and `max` within `pyo3-ffi/build.rs`"
msgstr ""

#: src/contributing.md:195
msgid "Add a new abi3-prerelease feature for the version (e.g. `abi3-py314`)"
msgstr ""

#: src/contributing.md:196
msgid ""
"In `pyo3-build-config/Cargo.toml`, set abi3-most_current_stable to \\[\"abi3-"
"prerelease\"\\] and abi3-prerelease to \\[\"abi3\"\\]"
msgstr ""

#: src/contributing.md:197
msgid ""
"In `pyo3-ffi/Cargo.toml`, set abi3-most_current_stable to \\[\"abi3-"
"prerelease\", \"pyo3-build-config/abi3-most_current_stable\"\\] and abi3-"
"prerelease to \\[\"abi3\", \"pyo3-build-config/abi3-prerelease\"\\]"
msgstr ""

#: src/contributing.md:198
msgid ""
"In `Cargo.toml`, set abi3-most_current_stable to \\[\"abi3-prerelease\", "
"\"pyo3-ffi/abi3-most_current_stable\"\\] and abi3-prerelease to \\[\"abi3\", "
"\"pyo3-ffi/abi3-prerelease\"\\]"
msgstr ""

#: src/contributing.md:199
msgid ""
"Use `#[cfg(Py_prerelease])` (e.g. `#[cfg(Py_3_14)]`) and "
"`#[cfg(not(Py_prerelease]))` to indicate changes between the stable branches "
"of CPython and the pre-release"
msgstr ""

#: src/contributing.md:200
msgid ""
"Do not add a Rust binding to any function, struct, or global variable "
"prefixed with `_` in CPython's headers"
msgstr ""

#: src/contributing.md:201
msgid "Ping @ngoldbaum and @davidhewitt for assistance"
msgstr ""

#: src/contributing.md:203
msgid "Rust"
msgstr ""

#: src/contributing.md:205
msgid ""
"PyO3 aims to make use of up-to-date Rust language features to keep the "
"implementation as efficient as possible."
msgstr ""

#: src/contributing.md:207
msgid ""
"The minimum Rust version supported will be decided when the release which "
"bumps Python and Rust versions is made. At the time, the minimum Rust "
"version will be set no higher than the lowest Rust version shipped in the "
"current Debian, RHEL and Alpine Linux distributions."
msgstr ""

#: src/contributing.md:209
msgid ""
"CI tests both the most recent stable Rust version and the minimum supported "
"Rust version. Because of Rust's stability guarantees this is sufficient to "
"confirm support for all Rust versions in between."
msgstr ""

#: src/contributing.md:211
msgid "Benchmarking"
msgstr ""

#: src/contributing.md:213
msgid ""
"PyO3 has two sets of benchmarks for evaluating some aspects of its "
"performance. The benchmark suite is currently very small - please open PRs "
"with new benchmarks if you're interested in helping to expand it!"
msgstr ""

#: src/contributing.md:215
msgid ""
"First, there are Rust-based benchmarks located in the `pyo3-benches` "
"subdirectory. You can run these benchmarks with:"
msgstr ""

#: src/contributing.md:219
msgid ""
"Second, there is a Python-based benchmark contained in the `pytests` "
"subdirectory. You can read more about it [here](https://github.com/PyO3/pyo3/"
"tree/main/pytests)."
msgstr ""

#: src/contributing.md:221
msgid "Code coverage"
msgstr ""

#: src/contributing.md:223
msgid ""
"You can view what code is and isn't covered by PyO3's tests. We aim to have "
"100% coverage - please check coverage and add tests if you notice a lack of "
"coverage!"
msgstr ""

#: src/contributing.md:225
msgid ""
"First, ensure the llvm-cov cargo plugin is installed. You may need to run "
"the plugin through cargo once before using it with `nox`."
msgstr ""

#: src/contributing.md:230
msgid "Then, generate an `lcov.info` file with"
msgstr ""

#: src/contributing.md:234
msgid ""
"You can install an IDE plugin to view the coverage. For example, if you use "
"VSCode:"
msgstr ""

#: src/contributing.md:235
msgid ""
"Add the [coverage-gutters](https://marketplace.visualstudio.com/items?"
"itemName=ryanluker.vscode-coverage-gutters) plugin."
msgstr ""

#: src/contributing.md:236
msgid "Add these settings to VSCode's `settings.json`:"
msgstr ""

#: src/contributing.md:239
msgid "\"coverage-gutters.coverageFileNames\""
msgstr ""

#: src/contributing.md:240
msgid "\"lcov.info\""
msgstr ""

#: src/contributing.md:241
msgid "\"cov.xml\""
msgstr ""

#: src/contributing.md:242
msgid "\"coverage.xml\""
msgstr ""

#: src/contributing.md:244
msgid "\"coverage-gutters.showLineCoverage\""
msgstr ""

#: src/contributing.md:247
msgid ""
"You should now be able to see green highlights for code that is tested, and "
"red highlights for code that is not tested."
msgstr ""

#: src/contributing.md:249
msgid "Sponsor this project"
msgstr ""

#: src/contributing.md:251
msgid ""
"At the moment there is no official organisation that accepts sponsorship on "
"PyO3's behalf. If you're seeking to provide significant funding to the PyO3 "
"ecosystem, please reach out to us on [GitHub](https://github.com/PyO3/pyo3/"
"issues/new) or [Discord](https://discord.gg/33kcChzH7f) and we can discuss."
msgstr ""

#: src/contributing.md:253
msgid ""
"In the meanwhile, some of our maintainers have personal GitHub sponsorship "
"pages and would be grateful for your support:"
msgstr ""

#: src/contributing.md:255
msgid "[davidhewitt](https://github.com/sponsors/davidhewitt)"
msgstr ""

#: src/contributing.md:256
msgid "[messense](https://github.com/sponsors/messense)"
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/debugging.md:3
msgid "Macros"
msgstr ""

#: src/debugging.md:5
msgid ""
"PyO3's attributes (`#[pyclass]`, `#[pymodule]`, etc.) are [procedural macros]"
"(https://doc.rust-lang.org/reference/procedural-macros.html), which means "
"that they rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding `-Z trace-macros`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"Note that those commands require using the nightly build of rust and may "
"occasionally have bugs. See [cargo expand](https://github.com/dtolnay/cargo-"
"expand) for a more elaborate and stable version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of Python, otherwise Valgrind won't "
"produce usable results. In Ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on Linux, use `ldd` with the name of your binary and check that you're "
"linking e.g. `libpython3.7d.so.1.0` instead of `libpython3.7.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for CPython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run Valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace. You can set `RUST_BACKTRACE=1` as an environment variable to get "
"the stack trace on a `panic!`. Alternatively you can use a debugger such as "
"`gdb` to explore the issue. Rust provides a wrapper, `rust-gdb`, which has "
"pretty-printers for inspecting Rust variables. Since PyO3 uses `cdylib` for "
"Python shared objects, it does not receive the pretty-print debug hooks in "
"`rust-gdb` ([rust-lang/rust#96365](https://github.com/rust-lang/rust/"
"issues/96365)). The mentioned issue contains a workaround for enabling "
"pretty-printers in this case."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `rust-gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid ""
"Set a breakpoint (`b`) on `rust_panic` if you are investigating a `panic!`"
msgstr ""

#: src/debugging.md:40
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:41
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/debugging.md:43
msgid ""
"Often it is helpful to run a small piece of Python code to exercise a "
"section of Rust."
msgstr ""

#: src/debugging.md:45
msgid ""
"```console\n"
"rust-gdb --args python -c \"import my_package; my_package.sum_to_string(1, "
"2)\"\n"
"```"
msgstr ""

#: src/debugging.md:49
msgid "Setting breakpoints in your Rust code"
msgstr ""

#: src/debugging.md:51
msgid ""
"One of the preferred ways by developers to debug their code is by setting "
"breakpoints. This can be achieved in PyO3 by using a debugger like `rust-"
"gdb` or `rust-lldb` with your Python interpreter."
msgstr ""

#: src/debugging.md:53
msgid ""
"For more information about how to use both `lldb` and `gdb` you can read the "
"[gdb to lldb command map](https://lldb.llvm.org/use/map.html) from the lldb "
"documentation."
msgstr ""

#: src/debugging.md:55
msgid "Common setup"
msgstr ""

#: src/debugging.md:57
msgid "Compile your extension with debug symbols:"
msgstr ""

#: src/debugging.md:60
msgid ""
"# Debug is the default for maturin, but you can explicitly ensure debug "
"symbols with:\n"
msgstr ""

#: src/debugging.md:61
msgid "\"-g\""
msgstr ""

#: src/debugging.md:63
msgid "# For setuptools-rust users:\n"
msgstr ""

#: src/debugging.md:67
msgid ""
"**Note**: When using debuggers, make sure that `python` resolves to an "
"actual Python binary or symlink and not a shim script. Some tools like pyenv "
"use shim scripts which can interfere with debugging."
msgstr ""

#: src/debugging.md:69
msgid "Debugger specific setup"
msgstr ""

#: src/debugging.md:71
msgid ""
"Depending on your OS and your preferences you can use two different "
"debuggers, `rust-gdb` or `rust-lldb`."
msgstr ""

#: src/debugging.md:80
msgid "Launch rust-gdb with the Python interpreter:"
msgstr ""

#: src/debugging.md:86
msgid "Once in gdb, set a breakpoint in your Rust code:"
msgstr ""

#: src/debugging.md:92
msgid "Run your Python script that imports and uses your Rust extension:"
msgstr ""

#: src/debugging.md:95 src/debugging.md:125
msgid "# Option 1: Run an inline Python command\n"
msgstr ""

#: src/debugging.md:96 src/debugging.md:126
msgid "\"import your_module; your_module.your_function()\""
msgstr ""

#: src/debugging.md:98 src/debugging.md:128
msgid "# Option 2: Run a Python script\n"
msgstr ""

#: src/debugging.md:101 src/debugging.md:131
msgid "# Option 3: Run pytest tests\n"
msgstr ""

#: src/debugging.md:110
msgid "Start rust-lldb with Python:"
msgstr ""

#: src/debugging.md:116
msgid "Set breakpoints in your Rust code:"
msgstr ""

#: src/debugging.md:122
msgid "Run your Python script:"
msgstr ""

#: src/debugging.md:140
msgid "Using VS Code"
msgstr ""

#: src/debugging.md:142
msgid ""
"VS Code with the Rust and Python extensions provides an integrated debugging "
"experience:"
msgstr ""

#: src/debugging.md:144
msgid "First, install the necessary VS Code extensions:"
msgstr ""

#: src/debugging.md:146
msgid ""
"[Rust Analyzer](https://marketplace.visualstudio.com/items?itemName=rust-"
"lang.rust-analyzer)"
msgstr ""

#: src/debugging.md:147
msgid ""
"[CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn."
"vscode-lldb)"
msgstr ""

#: src/debugging.md:148
msgid ""
"[Python](https://marketplace.visualstudio.com/items?itemName=ms-python."
"python)"
msgstr ""

#: src/debugging.md:150
msgid ""
"Create a `.vscode/launch.json` file with a configuration that uses the LLDB "
"Debug Launcher:"
msgstr ""

#: src/debugging.md:154 src/debugging.md:275
msgid "\"version\""
msgstr ""

#: src/debugging.md:154 src/debugging.md:275
msgid "\"0.2.0\""
msgstr ""

#: src/debugging.md:155 src/debugging.md:276 src/debugging.md:309
#: src/debugging.md:316
msgid "\"configurations\""
msgstr ""

#: src/debugging.md:157 src/debugging.md:167 src/debugging.md:176
#: src/debugging.md:185 src/debugging.md:228 src/debugging.md:278
#: src/debugging.md:286 src/debugging.md:310
msgid "\"name\""
msgstr ""

#: src/debugging.md:157
msgid "\"Debug PyO3\""
msgstr ""

#: src/debugging.md:158 src/debugging.md:168 src/debugging.md:177
#: src/debugging.md:186 src/debugging.md:229 src/debugging.md:279
#: src/debugging.md:287
msgid "\"type\""
msgstr ""

#: src/debugging.md:158 src/debugging.md:168 src/debugging.md:177
#: src/debugging.md:186 src/debugging.md:229 src/debugging.md:279
#: src/debugging.md:287
msgid "\"lldb\""
msgstr ""

#: src/debugging.md:159 src/debugging.md:169 src/debugging.md:178
#: src/debugging.md:187 src/debugging.md:230 src/debugging.md:280
#: src/debugging.md:288
msgid "\"request\""
msgstr ""

#: src/debugging.md:159 src/debugging.md:280
msgid "\"attach\""
msgstr ""

#: src/debugging.md:160 src/debugging.md:170 src/debugging.md:179
#: src/debugging.md:188 src/debugging.md:231 src/debugging.md:281
#: src/debugging.md:289 src/debugging.md:312
msgid "\"program\""
msgstr ""

#: src/debugging.md:160 src/debugging.md:170 src/debugging.md:179
#: src/debugging.md:188 src/debugging.md:231
msgid "\"${workspaceFolder}/.venv/bin/python\""
msgstr ""

#: src/debugging.md:161 src/debugging.md:282 src/debugging.md:311
msgid "\"pid\""
msgstr ""

#: src/debugging.md:161
msgid "\"${command:pickProcess}\""
msgstr ""

#: src/debugging.md:162 src/debugging.md:173 src/debugging.md:182
#: src/debugging.md:191 src/debugging.md:237 src/debugging.md:283
#: src/debugging.md:292
msgid "\"sourceLanguages\""
msgstr ""

#: src/debugging.md:163 src/debugging.md:173 src/debugging.md:182
#: src/debugging.md:191 src/debugging.md:237 src/debugging.md:283
#: src/debugging.md:292
msgid "\"rust\""
msgstr ""

#: src/debugging.md:167 src/debugging.md:286
msgid "\"Launch Python with PyO3\""
msgstr ""

#: src/debugging.md:169 src/debugging.md:178 src/debugging.md:187
#: src/debugging.md:230 src/debugging.md:288
msgid "\"launch\""
msgstr ""

#: src/debugging.md:171 src/debugging.md:180 src/debugging.md:189
#: src/debugging.md:232 src/debugging.md:290
msgid "\"args\""
msgstr ""

#: src/debugging.md:171 src/debugging.md:232 src/debugging.md:290
msgid "\"${file}\""
msgstr ""

#: src/debugging.md:172 src/debugging.md:181 src/debugging.md:190
#: src/debugging.md:291
msgid "\"cwd\""
msgstr ""

#: src/debugging.md:172 src/debugging.md:181 src/debugging.md:190
#: src/debugging.md:235 src/debugging.md:291
msgid "\"${workspaceFolder}\""
msgstr ""

#: src/debugging.md:176
msgid "\"Debug PyO3 with Args\""
msgstr ""

#: src/debugging.md:180
msgid "\"path/to/your/script.py\""
msgstr ""

#: src/debugging.md:185
msgid "\"Debug PyO3 Tests\""
msgstr ""

#: src/debugging.md:189
msgid "\"-m\""
msgstr ""

#: src/debugging.md:189
msgid "\"pytest\""
msgstr ""

#: src/debugging.md:189
msgid "\"tests/your_test.py::test_function\""
msgstr ""

#: src/debugging.md:189
msgid "\"-v\""
msgstr ""

#: src/debugging.md:197
msgid "This configuration supports multiple debugging scenarios:"
msgstr ""

#: src/debugging.md:199
msgid "Attaching to a running Python process"
msgstr ""

#: src/debugging.md:200
msgid "Launching the currently open Python file"
msgstr ""

#: src/debugging.md:201
msgid "Running a specific script with command-line arguments"
msgstr ""

#: src/debugging.md:202
msgid "Running pytest tests"
msgstr ""

#: src/debugging.md:206
msgid ""
"Set breakpoints in your Rust code by clicking in the gutter next to line "
"numbers."
msgstr ""

#: src/debugging.md:208
msgid "Start debugging:"
msgstr ""

#: src/debugging.md:209
msgid ""
"For attaching to a running Python process: First start the process, then "
"select the \"Debug PyO3\" configuration and click Start Debugging (F5). "
"You'll be prompted to select the Python process to attach to."
msgstr ""

#: src/debugging.md:210
msgid ""
"For launching a Python script: Open your Python script, select the \"Launch "
"Python with PyO3\" configuration and click Start Debugging (F5)."
msgstr ""

#: src/debugging.md:211
msgid ""
"For running with arguments: Select \"Debug PyO3 with Args\" (remember to "
"edit the configuration with your actual script path and arguments)."
msgstr ""

#: src/debugging.md:212
msgid ""
"For running tests: Select \"Debug PyO3 Tests\" (edit the test path as "
"needed)."
msgstr ""

#: src/debugging.md:214
msgid "When debugging PyO3 code:"
msgstr ""

#: src/debugging.md:215
msgid "You can inspect Rust variables and data structures"
msgstr ""

#: src/debugging.md:216
msgid "Use the debug console to evaluate expressions"
msgstr ""

#: src/debugging.md:217
msgid "Step through Rust code line by line using the step controls"
msgstr ""

#: src/debugging.md:218
msgid "Set conditional breakpoints for more complex debugging scenarios"
msgstr ""

#: src/debugging.md:222
msgid "Advanced Debugging Configurations"
msgstr ""

#: src/debugging.md:224
msgid ""
"For advanced debugging scenarios, you might want to add environment "
"variables or enable specific Rust debug flags:"
msgstr ""

#: src/debugging.md:228
msgid "\"Debug PyO3 with Environment\""
msgstr ""

#: src/debugging.md:233
msgid "\"env\""
msgstr ""

#: src/debugging.md:234
msgid "\"RUST_BACKTRACE\""
msgstr ""

#: src/debugging.md:234
msgid "\"1\""
msgstr ""

#: src/debugging.md:235
msgid "\"PYTHONPATH\""
msgstr ""

#: src/debugging.md:241
msgid "Debugging from Jupyter Notebooks"
msgstr ""

#: src/debugging.md:243
msgid ""
"For Jupyter Notebooks run from VS Code, you can use the following helper "
"functions to automate the launch configuration:"
msgstr ""

#: src/debugging.md:253
msgid ""
"\"\"\"Update VSCode launch.json with the correct Jupyter kernel PID.\n"
"\n"
"    Args:\n"
"        vscode_config_file_path (str, optional): Path to the .vscode/launch."
"json file.\n"
"            If not provided, will use the current working directory.\n"
"    \"\"\""
msgstr ""

#: src/debugging.md:261
msgid "\"Could not determine Jupyter kernel PID.\""
msgstr ""

#: src/debugging.md:264
msgid "# Determine launch.json path\n"
msgstr ""

#: src/debugging.md:268
msgid "\".vscode\""
msgstr ""

#: src/debugging.md:268
msgid "\"launch.json\""
msgstr ""

#: src/debugging.md:270
msgid "# Get Python interpreter path\n"
msgstr ""

#: src/debugging.md:273
msgid "# Default debugger config\n"
msgstr ""

#: src/debugging.md:278 src/debugging.md:310
msgid "\"Debug PyO3 (Jupyter)\""
msgstr ""

#: src/debugging.md:297
msgid "# Create .vscode directory if it doesn't exist\n"
msgstr ""

#: src/debugging.md:301
msgid ""
"# If launch.json already exists, try to update it instead of overwriting\n"
msgstr ""

#: src/debugging.md:304
msgid "\"r\""
msgstr ""

#: src/debugging.md:307
msgid "# Check if our configuration already exists\n"
msgstr ""

#: src/debugging.md:320
msgid "# If reading fails, we'll just overwrite with our new configuration\n"
msgstr ""

#: src/debugging.md:323
msgid "\"w\""
msgstr ""

#: src/debugging.md:325
msgid "\"Updated launch.json with PID: "
msgstr ""

#: src/debugging.md:325
msgid " at "
msgstr ""

#: src/debugging.md:325 src/debugging.md:327 src/debugging.md:339
msgid "\""
msgstr ""

#: src/debugging.md:327
msgid "\"Error updating launch.json: "
msgstr ""

#: src/debugging.md:331
msgid ""
"\"\"\"Find the process ID (PID) of the running Jupyter kernel.\n"
"\n"
"    Returns:\n"
"        int: The process ID of the Jupyter kernel, or None if not found.\n"
"    \"\"\""
msgstr ""

#: src/debugging.md:336
msgid "# Check if we're running in a Jupyter environment\n"
msgstr ""

#: src/debugging.md:337
msgid "'ipykernel'"
msgstr ""

#: src/debugging.md:339
msgid "\"Jupyter kernel PID: "
msgstr ""

#: src/debugging.md:342
msgid "\"Not running in a Jupyter environment.\""
msgstr ""

#: src/debugging.md:346
msgid "To use these functions:"
msgstr ""

#: src/debugging.md:348
msgid "Run the cell containing these functions in your Jupyter notebook"
msgstr ""

#: src/debugging.md:349
msgid "Run `update_launch_json()` in a cell"
msgstr ""

#: src/debugging.md:350
msgid ""
"In VS Code, select the \"Debug PyO3 (Jupyter)\" configuration and start "
"debugging"
msgstr ""

#: src/debugging.md:352
msgid "Thread Safety and Compiler Sanitizers"
msgstr ""

#: src/debugging.md:354
msgid ""
"PyO3 attempts to match the Rust language-level guarantees for thread safety, "
"but that does not preclude other code outside of the control of PyO3 or "
"buggy code managed by a PyO3 extension from creating a thread safety issue. "
"Analyzing whether or not a piece of Rust code that uses the CPython C API is "
"thread safe can be quite complicated, since many Python operations can lead "
"to arbitrary Python code execution. Automated ways to discover thread safety "
"issues can often be more fruitful than code analysis."
msgstr ""

#: src/debugging.md:362
msgid ""
"[ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html) is a "
"thread safety checking runtime that can be used to detect data races "
"triggered by thread safety bugs or incorrect use of thread-unsafe data "
"structures. While it can only detect data races triggered by code at "
"runtime, if it does detect something the reports often point to exactly "
"where the problem is happening."
msgstr ""

#: src/debugging.md:368
msgid ""
"To use `ThreadSanitizer` with a library that depends on PyO3, you will need "
"to install a nightly Rust toolchain, along with the `rust-src` component, "
"since you will need to compile the Rust standard library:"
msgstr ""

#: src/debugging.md:378
msgid ""
"You will also need a version of CPython compiled using LLVM/Clang with the "
"same major version of LLVM as is currently used to compile nightly Rust. As "
"of March 2025, Rust nightly uses LLVM 20."
msgstr ""

#: src/debugging.md:382
msgid ""
"The [cpython_sanity docker images](https://github.com/nascheme/"
"cpython_sanity) contain a development environment with a pre-compiled "
"version of CPython 3.13 or 3.14 as well as optionally NumPy and SciPy, all "
"compiled using LLVM 20 and ThreadSanitizer."
msgstr ""

#: src/debugging.md:387
msgid ""
"After activating a nightly Rust toolchain, you can build your project using "
"`ThreadSanitizer` with the following command:"
msgstr ""

#: src/debugging.md:391
msgid "\"-Zsanitizer=thread\""
msgstr ""

#: src/debugging.md:394
msgid ""
"If you are not running on an x86_64 Linux machine, you should replace "
"`x86_64-unknown-linux-gnu` with the [target triple](https://doc.rust-lang."
"org/rustc/platform-support.html#tier-1-with-host-tools) that is appropriate "
"for your system. You can also replace `maturin develop` with `cargo test` to "
"run `cargo` tests. Note that `cargo` runs tests in a thread pool, so `cargo` "
"tests can be a good way to find thread safety issues."
msgstr ""

#: src/debugging.md:401
msgid ""
"You can also replace `-Zsanitizer=thread` with `-Zsanitizer=address` or any "
"of the other sanitizers that are [supported by Rust](https://doc.rust-lang."
"org/beta/unstable-book/compiler-flags/sanitizer.html). Note that you'll need "
"to build CPython from source with the appropriate [configure script flags]"
"(https://docs.python.org/3/using/configure.html#cmdoption-with-address-"
"sanitizer) to use the same sanitizer environment as you want to use for your "
"Rust code."
msgstr ""

#: src/faq.md:1
msgid "Frequently Asked Questions and troubleshooting"
msgstr ""

#: src/faq.md:3
msgid ""
"Sorry that you're having trouble using PyO3. If you can't find the answer to "
"your problem in the list below, you can also reach out for help on [GitHub "
"Discussions](https://github.com/PyO3/pyo3/discussions) and on [Discord]"
"(https://discord.gg/33kcChzH7f)."
msgstr ""

#: src/faq.md:5
msgid ""
"I'm experiencing deadlocks using PyO3 with `std::sync::OnceLock`, `std::"
"sync::LazyLock`, `lazy_static`, and `once_cell`"
msgstr ""

#: src/faq.md:7
msgid ""
"`OnceLock`, `LazyLock`, and their thirdparty predecessors use blocking to "
"ensure only one thread ever initializes them. Because the Python interpreter "
"can introduce additional locks (the Python GIL and GC can both require all "
"other threads to pause) this can lead to deadlocks in the following way:"
msgstr ""

#: src/faq.md:9
msgid ""
"A thread (thread A) which is attached to the Python interpreter starts "
"initialization of a `OnceLock` value."
msgstr ""

#: src/faq.md:10
msgid ""
"The initialization code calls some Python API which temporarily detaches "
"from the interpreter e.g. `Python::import`."
msgstr ""

#: src/faq.md:11
msgid ""
"Another thread (thread B) attaches to the Python interpreter and attempts to "
"access the same `OnceLock` value."
msgstr ""

#: src/faq.md:12
msgid ""
"Thread B is blocked, because it waits for `OnceLock`'s initialization to "
"lock to release."
msgstr ""

#: src/faq.md:13
msgid ""
"On non-free-threaded Python, thread A is now also blocked, because it waits "
"to re-attach to the interpreter (by taking the GIL which thread B still "
"holds)."
msgstr ""

#: src/faq.md:14
msgid "Deadlock."
msgstr ""

#: src/faq.md:16
msgid ""
"PyO3 provides a struct [`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/"
"struct.PyOnceLock.html) which implements a single-initialization API based "
"on these types that avoids deadlocks. You can also make use of the "
"[`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt.html) and "
"[`OnceLockExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceLockExt.html) "
"extension traits that enable using the standard library types for this "
"purpose by providing new methods for these types that avoid the risk of "
"deadlocking with the Python interpreter. This means they can be used in "
"place of other choices when you are experiencing the deadlock described "
"above. See the documentation for [`PyOnceLock`](https://pyo3.rs/main/doc/"
"pyo3/sync/struct.PyOnceLock.html) and [`OnceExt`](https://pyo3.rs/main/doc/"
"pyo3/sync/trait.OnceExt.html) for further details and an example how to use "
"them."
msgstr ""

#: src/faq.md:22
msgid ""
"I can't run `cargo test`; or I can't build in a Cargo workspace: I'm having "
"linker issues like \"Symbol not found\" or \"Undefined reference to "
"\\_PyExc_SystemError\""
msgstr ""

#: src/faq.md:24
msgid ""
"Currently, [\\#340](https://github.com/PyO3/pyo3/issues/340) causes `cargo "
"test` to fail with linking errors when the `extension-module` feature is "
"activated. Linking errors can also happen when building in a cargo workspace "
"where a different crate also uses PyO3 (see [\\#2521](https://github.com/"
"PyO3/pyo3/issues/2521)). For now, there are three ways we can work around "
"these issues."
msgstr ""

#: src/faq.md:26
msgid ""
"Make the `extension-module` feature optional. Build with `maturin develop --"
"features \"extension-module\"`"
msgstr ""

#: src/faq.md:28
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:36
msgid ""
"Make the `extension-module` feature optional and default. Run tests with "
"`cargo test --no-default-features`:"
msgstr ""

#: src/faq.md:38
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:47
msgid ""
"If you are using a [`pyproject.toml`](https://maturin.rs/metadata.html) file "
"to control maturin settings, add the following section:"
msgstr ""

#: src/faq.md:49
msgid ""
"```toml\n"
"[tool.maturin]\n"
"features = [\"pyo3/extension-module\"]\n"
"# Or for maturin 0.12:\n"
"# cargo-extra-args = [\"--features\", \"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:56
msgid ""
"I can't run `cargo test`: my crate cannot be found for tests in `tests/` "
"directory"
msgstr ""

#: src/faq.md:58
msgid ""
"The Rust book suggests to [put integration tests inside a `tests/` directory]"
"(https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-"
"tests)."
msgstr ""

#: src/faq.md:60
msgid ""
"For a PyO3 `extension-module` project where the `crate-type` is set to "
"`\"cdylib\"` in your `Cargo.toml`, the compiler won't be able to find your "
"crate and will display errors such as `E0432` or `E0463`:"
msgstr ""

#: src/faq.md:71
msgid ""
"The best solution is to make your crate types include both `rlib` and "
"`cdylib`:"
msgstr ""

#: src/faq.md:73
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[lib]\n"
"crate-type = [\"cdylib\", \"rlib\"]\n"
"```"
msgstr ""

#: src/faq.md:79
msgid "Ctrl-C doesn't do anything while my Rust code is executing"
msgstr ""

#: src/faq.md:81
msgid ""
"This is because Ctrl-C raises a SIGINT signal, which is handled by the "
"calling Python process by simply setting a flag to action upon later. This "
"flag isn't checked while Rust code called from Python is executing, only "
"once control returns to the Python interpreter."
msgstr ""

#: src/faq.md:83
msgid ""
"You can give the Python interpreter a chance to process the signal properly "
"by calling `Python::check_signals`. It's good practice to call this function "
"regularly if you have a long-running Rust function so that your users can "
"cancel it."
msgstr ""

#: src/faq.md:85
msgid "`#[pyo3(get)]` clones my field"
msgstr ""

#: src/faq.md:87
msgid "You may have a nested struct similar to this:"
msgstr ""

#: src/faq.md:93 src/faq.md:133
msgid "/* fields omitted */"
msgstr ""

#: src/faq.md:110
msgid ""
"When Python code accesses `Outer`'s field, PyO3 will return a new object on "
"every access (note that their addresses are different):"
msgstr ""

#: src/faq.md:118 src/faq.md:164 src/faq.md:165
msgid "\"a: "
msgstr ""

#: src/faq.md:118 src/faq.md:164 src/faq.md:165
msgid "\\nb: "
msgstr ""

#: src/faq.md:126
msgid ""
"This can be especially confusing if the field is mutable, as getting the "
"field and then mutating it won't persist - you'll just get a fresh clone of "
"the original on the next access. Unfortunately Python and Rust don't agree "
"about ownership - if PyO3 gave out references to (possibly) temporary Rust "
"objects to Python code, Python code could then keep that reference alive "
"indefinitely. Therefore returning Rust objects requires cloning."
msgstr ""

#: src/faq.md:128
msgid ""
"If you don't want that cloning to happen, a workaround is to allocate the "
"field on the Python heap and store a reference to that, by using [`Py<...>`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html):"
msgstr ""

#: src/faq.md:156
msgid "This time `a` and `b` _are_ the same object:"
msgstr ""

#: src/faq.md:173
msgid ""
"The downside to this approach is that any Rust code working on the `Outer` "
"struct potentially has to attach to the Python interpreter to do anything "
"with the `inner` field. (If `Inner` is `#[pyclass(frozen)]` and implements "
"`Sync`, then `Py::get` may be used to access the `Inner` contents from "
"`Py<Inner>` without needing to attach to the interpreter.)"
msgstr ""

#: src/faq.md:176
msgid ""
"I want to use the `pyo3` crate re-exported from dependency but the proc-"
"macros fail"
msgstr ""

#: src/faq.md:178
msgid ""
"All PyO3 proc-macros (`#[pyclass]`, `#[pyfunction]`, "
"`#[derive(FromPyObject)]` and so on) expect the `pyo3` crate to be available "
"under that name in your crate root, which is the normal situation when "
"`pyo3` is a direct dependency of your crate."
msgstr ""

#: src/faq.md:183
msgid ""
"However, when the dependency is renamed, or your crate only indirectly "
"depends on `pyo3`, you need to let the macro code know where to find the "
"crate.  This is done with the `crate` attribute:"
msgstr ""

#: src/faq.md:193
msgid "\"reexported::pyo3\""
msgstr ""

#: src/faq.md:197
msgid ""
"I'm trying to call Python from Rust but I get `STATUS_DLL_NOT_FOUND` or "
"`STATUS_ENTRYPOINT_NOT_FOUND`"
msgstr ""

#: src/faq.md:199
msgid ""
"This happens on Windows when linking to the python DLL fails or the wrong "
"one is linked. The Python DLL on Windows will usually be called something "
"like:"
msgstr ""

#: src/faq.md:201
msgid "`python3X.dll` for Python 3.X, e.g. `python310.dll` for Python 3.10"
msgstr ""

#: src/faq.md:202
msgid "`python3.dll` when using PyO3's `abi3` feature"
msgstr ""

#: src/faq.md:204
msgid ""
"The DLL needs to be locatable using the [Windows DLL search order](https://"
"learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-"
"order#standard-search-order-for-unpackaged-apps). Some ways to achieve this "
"are:"
msgstr ""

#: src/faq.md:206
msgid "Put the Python DLL in the same folder as your build artifacts"
msgstr ""

#: src/faq.md:207
msgid ""
"Add the directory containing the Python DLL to your `PATH` environment "
"variable, for example `C:"
"\\Users\\<You>\\AppData\\Local\\Programs\\Python\\Python310`"
msgstr ""

#: src/faq.md:208
msgid ""
"If this happens when you are _distributing_ your program, consider using "
"[PyOxidizer](https://github.com/indygreg/PyOxidizer) to package it with your "
"binary."
msgstr ""

#: src/faq.md:210
msgid ""
"If the wrong DLL is linked it is possible that this happened because another "
"program added itself and its own Python DLLs to `PATH`. Rearrange your "
"`PATH` variables to give the correct DLL priority."
msgstr ""

#: src/faq.md:212
msgid ""
"**Note**: Changes to `PATH` (or any other environment variable) are not "
"visible to existing shells. Restart it for changes to take effect."
msgstr ""

#: src/faq.md:214
msgid ""
"For advanced troubleshooting, [Dependency Walker](https://www."
"dependencywalker.com/) can be used to diagnose linking errors."
msgstr ""

#: src/features.md:1
msgid "Features reference"
msgstr ""

#: src/features.md:3
msgid ""
"PyO3 provides a number of Cargo features to customize functionality. This "
"chapter of the guide provides detail on each of them."
msgstr ""

#: src/features.md:5
msgid "By default, only the `macros` feature is enabled."
msgstr ""

#: src/features.md:7
msgid "Features for extension module authors"
msgstr ""

#: src/features.md:9
msgid "`extension-module`"
msgstr ""

#: src/features.md:11
msgid ""
"This feature is required when building a Python extension module using PyO3."
msgstr ""

#: src/features.md:13
msgid ""
"It tells PyO3's build script to skip linking against `libpython.so` on Unix "
"platforms, where this must not be done."
msgstr ""

#: src/features.md:15
msgid ""
"See the [building and distribution](building-and-distribution.md#the-"
"extension-module-feature) section for further detail."
msgstr ""

#: src/features.md:17
msgid "`abi3`"
msgstr ""

#: src/features.md:19
msgid ""
"This feature is used when building Python extension modules to create wheels "
"which are compatible with multiple Python versions."
msgstr ""

#: src/features.md:21
msgid ""
"It restricts PyO3's API to a subset of the full Python API which is "
"guaranteed by [PEP 384](https://www.python.org/dev/peps/pep-0384/) to be "
"forwards-compatible with future Python versions."
msgstr ""

#: src/features.md:23
msgid ""
"See the [building and distribution](building-and-distribution."
"md#py_limited_apiabi3) section for further detail."
msgstr ""

#: src/features.md:25
msgid "The `abi3-pyXY` features"
msgstr ""

#: src/features.md:27
msgid "(`abi3-py37`, `abi3-py38`, `abi3-py39`, `abi3-py310` and `abi3-py311`)"
msgstr ""

#: src/features.md:29
msgid ""
"These features are extensions of the `abi3` feature to specify the exact "
"minimum Python version which the multiple-version-wheel will support."
msgstr ""

#: src/features.md:31
msgid ""
"See the [building and distribution](building-and-distribution.md#minimum-"
"python-version-for-abi3) section for further detail."
msgstr ""

#: src/features.md:33
msgid "`generate-import-lib`"
msgstr ""

#: src/features.md:35
msgid ""
"This experimental feature is used to generate import libraries for Python "
"DLL for MinGW-w64 and MSVC (cross-)compile targets."
msgstr ""

#: src/features.md:38
msgid ""
"Enabling it allows to (cross-)compile extension modules to any Windows "
"targets without having to install the Windows Python distribution files for "
"the target."
msgstr ""

#: src/features.md:41
msgid ""
"See the [building and distribution](building-and-distribution.md#building-"
"abi3-extensions-without-a-python-interpreter) section for further detail."
msgstr ""

#: src/features.md:44
msgid "Features for embedding Python in Rust"
msgstr ""

#: src/features.md:46
msgid "`auto-initialize`"
msgstr ""

#: src/features.md:48
msgid ""
"This feature changes [`Python::attach`](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#method.attach) to automatically initialize a Python "
"interpreter (by calling [`Python::initialize`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.initialize)) if needed."
msgstr ""

#: src/features.md:50
msgid ""
"If you do not enable this feature, you should call `Python::initialize()` "
"before attempting to call any other Python APIs."
msgstr ""

#: src/features.md:52
msgid "Advanced Features"
msgstr ""

#: src/features.md:54
msgid "`experimental-async`"
msgstr ""

#: src/features.md:56
msgid ""
"This feature adds support for `async fn` in `#[pyfunction]` and "
"`#[pymethods]`."
msgstr ""

#: src/features.md:58
msgid ""
"The feature has some unfinished refinements and performance improvements. To "
"help finish this off, see [issue #1632](https://github.com/PyO3/pyo3/"
"issues/1632) and its associated draft PRs."
msgstr ""

#: src/features.md:60
msgid "`experimental-inspect`"
msgstr ""

#: src/features.md:62
msgid ""
"This feature adds to the built binaries introspection data that can be then "
"retrieved using the `pyo3-introspection` crate to generate [type stubs]"
"(https://typing.readthedocs.io/en/latest/source/stubs.html)."
msgstr ""

#: src/features.md:64
msgid ""
"Also, this feature adds the `pyo3::inspect` module, as well as `IntoPy::"
"type_output` and `FromPyObject::type_input` APIs to produce Python type "
"\"annotations\" for Rust types."
msgstr ""

#: src/features.md:66
msgid ""
"This is a first step towards adding first-class support for generating type "
"annotations automatically in PyO3, however work is needed to finish this "
"off. All feedback and offers of help welcome on [issue #2454](https://github."
"com/PyO3/pyo3/issues/2454)."
msgstr ""

#: src/features.md:68
msgid "`py-clone`"
msgstr ""

#: src/features.md:70
msgid ""
"This feature was introduced to ease migration. It was found that delayed "
"reference counting (which PyO3 used historically) could not be made sound "
"and hence `Clone`\\-ing an instance of `Py<T>` is impossible when not "
"attached to Python interpreter (it will panic). To avoid migrations "
"introducing new panics without warning, the `Clone` implementation itself is "
"now gated behind this feature."
msgstr ""

#: src/features.md:72
msgid "`pyo3_disable_reference_pool`"
msgstr ""

#: src/features.md:74
msgid ""
"This is a performance-oriented conditional compilation flag, e.g. [set via "
"`$RUSTFLAGS`](https://doc.rust-lang.org/reference/conditional-compilation."
"html#set-configuration-options), which disabled the global reference pool "
"and the associated overhead for the crossing the Python-Rust boundary. "
"However, if enabled, `Drop`ping an instance of `Py<T>` when not attached to "
"the Python interpreter will abort the process."
msgstr ""

#: src/features.md:76
msgid "`macros`"
msgstr ""

#: src/features.md:78
msgid ""
"This feature enables a dependency on the `pyo3-macros` crate, which provides "
"the procedural macros portion of PyO3's API:"
msgstr ""

#: src/features.md:80
msgid "`#[pymodule]`"
msgstr ""

#: src/features.md:81
msgid "`#[pyfunction]`"
msgstr ""

#: src/features.md:82
msgid "`#[pyclass]`"
msgstr ""

#: src/features.md:83
msgid "`#[pymethods]`"
msgstr ""

#: src/features.md:84
msgid "`#[derive(FromPyObject)]`"
msgstr ""

#: src/features.md:86
msgid "It also provides the `py_run!` macro."
msgstr ""

#: src/features.md:88
msgid ""
"These macros require a number of dependencies which may not be needed by "
"users who just need PyO3 for Python FFI. Disabling this feature enables "
"faster builds for those users, as these dependencies will not be built if "
"this feature is disabled."
msgstr ""

#: src/features.md:90
msgid ""
"This feature is enabled by default. To disable it, set `default-features = "
"false` for the `pyo3` entry in your Cargo.toml."
msgstr ""

#: src/features.md:92
msgid "`multiple-pymethods`"
msgstr ""

#: src/features.md:94
msgid ""
"This feature enables each `#[pyclass]` to have more than one `#[pymethods]` "
"block."
msgstr ""

#: src/features.md:96
msgid ""
"Most users should only need a single `#[pymethods]` per `#[pyclass]`. In "
"addition, not all platforms (e.g. Wasm) are supported by `inventory`, which "
"is used in the implementation of the feature. For this reason this feature "
"is not enabled by default, meaning fewer dependencies and faster compilation "
"for the majority of users."
msgstr ""

#: src/features.md:98
msgid ""
"See [the `#[pyclass]` implementation details](class.md#implementation-"
"details) for more information."
msgstr ""

#: src/features.md:100
msgid "`nightly`"
msgstr ""

#: src/features.md:102
msgid ""
"The `nightly` feature needs the nightly Rust compiler. This allows PyO3 to "
"use the `auto_traits` and `negative_impls` features to fix the `Python::"
"detach` function."
msgstr ""

#: src/features.md:104
msgid "`resolve-config`"
msgstr ""

#: src/features.md:106
msgid ""
"The `resolve-config` feature of the `pyo3-build-config` crate controls "
"whether that crate's build script automatically resolves a Python "
"interpreter / build configuration. This feature is primarily useful when "
"building PyO3 itself. By default this feature is not enabled, meaning you "
"can freely use `pyo3-build-config` as a standalone library to read or write "
"PyO3 build configuration files or resolve metadata about a Python "
"interpreter."
msgstr ""

#: src/features.md:110
msgid "Optional Dependencies"
msgstr ""

#: src/features.md:112
msgid ""
"These features enable conversions between Python types and types from other "
"Rust crates, enabling easy access to the rest of the Rust ecosystem."
msgstr ""

#: src/features.md:114
msgid "`anyhow`"
msgstr ""

#: src/features.md:116
msgid ""
"Adds a dependency on [anyhow](https://docs.rs/anyhow). Enables a conversion "
"from [anyhow](https://docs.rs/anyhow)‚Äôs [`Error`](https://docs.rs/anyhow/"
"latest/anyhow/struct.Error.html) type to [`PyErr`](https://pyo3.rs/main/doc/"
"pyo3/struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:118
msgid "`arc_lock`"
msgstr ""

#: src/features.md:120
msgid ""
"Enables Pyo3's `MutexExt` trait for all Mutexes that extend on [`lock_api::"
"Mutex`](https://docs.rs/lock_api/latest/lock_api/struct.Mutex.html) or "
"[`parking_lot::ReentrantMutex`](https://docs.rs/lock_api/latest/lock_api/"
"struct.ReentrantMutex.html) and are wrapped in an [`Arc`](https://doc.rust-"
"lang.org/std/sync/struct.Arc.html) type. Like [`Arc<parking_lot::Mutex>`]"
"(https://docs.rs/parking_lot/latest/parking_lot/type.Mutex.html#method."
"lock_arc)"
msgstr ""

#: src/features.md:122
msgid "`bigdecimal`"
msgstr ""

#: src/features.md:124
msgid ""
"Adds a dependency on [bigdecimal](https://docs.rs/bigdecimal) and enables "
"conversions into its [`BigDecimal`](https://docs.rs/bigdecimal/latest/"
"bigdecimal/struct.BigDecimal.html) type."
msgstr ""

#: src/features.md:126
msgid "`bytes`"
msgstr ""

#: src/features.md:128
msgid ""
"Adds a dependency on [bytes](https://docs.rs/bytes/latest/bytes) and enables "
"conversions into its [`Bytes`](https://docs.rs/bytes/latest/bytes/struct."
"Bytes.html) type."
msgstr ""

#: src/features.md:130
msgid "`chrono`"
msgstr ""

#: src/features.md:132
msgid ""
"Adds a dependency on [chrono](https://docs.rs/chrono). Enables a conversion "
"from [chrono](https://docs.rs/chrono)'s types to python:"
msgstr ""

#: src/features.md:134
msgid ""
"[TimeDelta](https://docs.rs/chrono/latest/chrono/struct.TimeDelta.html) -> "
"[`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:135
msgid ""
"[FixedOffset](https://docs.rs/chrono/latest/chrono/offset/struct.FixedOffset."
"html) -> [`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:136
msgid ""
"[Utc](https://docs.rs/chrono/latest/chrono/offset/struct.Utc.html) -> "
"[`PyTzInfo`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:137
msgid ""
"[NaiveDate](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDate."
"html) -> [`PyDate`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:138
msgid ""
"[NaiveTime](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveTime."
"html) -> [`PyTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTime.html)"
msgstr ""

#: src/features.md:139
msgid ""
"[DateTime](https://docs.rs/chrono/latest/chrono/struct.DateTime.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:141
msgid "`chrono-local`"
msgstr ""

#: src/features.md:143
msgid ""
"Enables conversion from and to [Local](https://docs.rs/chrono/latest/chrono/"
"struct.Local.html) timezones. The current system timezone as determined by "
"[`iana_time_zone::get_timezone()`](https://docs.rs/iana-time-zone/latest/"
"iana_time_zone/fn.get_timezone.html) will be used for conversions."
msgstr ""

#: src/features.md:145
msgid "`chrono::DateTime<Local>` will convert from either of:"
msgstr ""

#: src/features.md:147
msgid ""
"`datetime` objects with `tzinfo` equivalent to the current system timezone."
msgstr ""

#: src/features.md:148
msgid ""
"\"naive\" `datetime` objects (those without a `tzinfo`), as it is a "
"convention that naive datetime objects should be treated as using the system "
"timezone."
msgstr ""

#: src/features.md:150
msgid ""
"When converting to Python, `Local` tzinfo is converted to a `zoneinfo."
"ZoneInfo` matching the current system timezone."
msgstr ""

#: src/features.md:152
msgid "`chrono-tz`"
msgstr ""

#: src/features.md:154
msgid ""
"Adds a dependency on [chrono-tz](https://docs.rs/chrono-tz). Enables "
"conversion from and to [`Tz`](https://docs.rs/chrono-tz/latest/chrono_tz/"
"enum.Tz.html)."
msgstr ""

#: src/features.md:157
msgid "`either`"
msgstr ""

#: src/features.md:159
msgid ""
"Adds a dependency on [either](https://docs.rs/either). Enables a conversions "
"into [either](https://docs.rs/either)‚Äôs [`Either`](https://docs.rs/either/"
"latest/either/enum.Either.html) type."
msgstr ""

#: src/features.md:161
msgid "`eyre`"
msgstr ""

#: src/features.md:163
msgid ""
"Adds a dependency on [eyre](https://docs.rs/eyre). Enables a conversion from "
"[eyre](https://docs.rs/eyre)‚Äôs [`Report`](https://docs.rs/eyre/latest/eyre/"
"struct.Report.html) type to [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct."
"PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:165
msgid "`hashbrown`"
msgstr ""

#: src/features.md:167
msgid ""
"Adds a dependency on [hashbrown](https://docs.rs/hashbrown) and enables "
"conversions into its [`HashMap`](https://docs.rs/hashbrown/latest/hashbrown/"
"struct.HashMap.html) and [`HashSet`](https://docs.rs/hashbrown/latest/"
"hashbrown/struct.HashSet.html) types."
msgstr ""

#: src/features.md:169
msgid "`indexmap`"
msgstr ""

#: src/features.md:171
msgid ""
"Adds a dependency on [indexmap](https://docs.rs/indexmap) and enables "
"conversions into its [`IndexMap`](https://docs.rs/indexmap/latest/indexmap/"
"map/struct.IndexMap.html) type."
msgstr ""

#: src/features.md:173
msgid "`jiff-02`"
msgstr ""

#: src/features.md:175
msgid ""
"Adds a dependency on [jiff@0.2](https://docs.rs/jiff/0.2) and requires MSRV "
"1.70. Enables a conversion from [jiff](https://docs.rs/jiff)'s types to "
"python:"
msgstr ""

#: src/features.md:177
msgid ""
"[SignedDuration](https://docs.rs/jiff/0.2/jiff/struct.SignedDuration.html) -"
"> [`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:178
msgid ""
"[TimeZone](https://docs.rs/jiff/0.2/jiff/tz/struct.TimeZone.html) -> "
"[`PyTzInfo`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:179
msgid ""
"[Offset](https://docs.rs/jiff/0.2/jiff/tz/struct.Offset.html) -> [`PyTzInfo`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:180
msgid ""
"[Date](https://docs.rs/jiff/0.2/jiff/civil/struct.Date.html) -> [`PyDate`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:181
msgid ""
"[Time](https://docs.rs/jiff/0.2/jiff/civil/struct.Time.html) -> [`PyTime`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyTime.html)"
msgstr ""

#: src/features.md:182
msgid ""
"[DateTime](https://docs.rs/jiff/0.2/jiff/civil/struct.DateTime.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:183
msgid ""
"[Zoned](https://docs.rs/jiff/0.2/jiff/struct.Zoned.html) -> [`PyDateTime`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:184
msgid ""
"[Timestamp](https://docs.rs/jiff/0.2/jiff/struct.Timestamp.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:185
msgid ""
"[ISOWeekDate](https://docs.rs/jiff/0.2/jiff/civil/struct.ISOWeekDate.html) -"
"> [`PyDate`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:187
msgid "`lock_api`"
msgstr ""

#: src/features.md:189
msgid ""
"Adds a dependency on [lock_api](https://docs.rs/lock_api) and enables Pyo3's "
"`MutexExt` trait for all mutexes that extend on [`lock_api::Mutex`](https://"
"docs.rs/lock_api/latest/lock_api/struct.Mutex.html) and [`parking_lot::"
"ReentrantMutex`](https://docs.rs/lock_api/latest/lock_api/struct."
"ReentrantMutex.html) (like `parking_lot` or `spin`)."
msgstr ""

#: src/features.md:191
msgid "`num-bigint`"
msgstr ""

#: src/features.md:193
msgid ""
"Adds a dependency on [num-bigint](https://docs.rs/num-bigint) and enables "
"conversions into its [`BigInt`](https://docs.rs/num-bigint/latest/num_bigint/"
"struct.BigInt.html) and [`BigUint`](https://docs.rs/num-bigint/latest/"
"num_bigint/struct.BigUint.html) types."
msgstr ""

#: src/features.md:195
msgid "`num-complex`"
msgstr ""

#: src/features.md:197
msgid ""
"Adds a dependency on [num-complex](https://docs.rs/num-complex) and enables "
"conversions into its [`Complex`](https://docs.rs/num-complex/latest/"
"num_complex/struct.Complex.html) type."
msgstr ""

#: src/features.md:199
msgid "`num-rational`"
msgstr ""

#: src/features.md:201
msgid ""
"Adds a dependency on [num-rational](https://docs.rs/num-rational) and "
"enables conversions into its [`Ratio`](https://docs.rs/num-rational/latest/"
"num_rational/struct.Ratio.html) type."
msgstr ""

#: src/features.md:203
msgid "`ordered-float`"
msgstr ""

#: src/features.md:205
msgid ""
"Adds a dependency on [ordered-float](https://docs.rs/ordered-float) and "
"enables conversions between [ordered-float](https://docs.rs/ordered-float)'s "
"types and Python:"
msgstr ""

#: src/features.md:207
msgid ""
"[NotNan](https://docs.rs/ordered-float/latest/ordered_float/struct.NotNan."
"html) -> [`PyFloat`](https://pyo3.rs/main/doc/pyo3/types/struct.PyFloat.html)"
msgstr ""

#: src/features.md:208
msgid ""
"[OrderedFloat](https://docs.rs/ordered-float/latest/ordered_float/struct."
"OrderedFloat.html) -> [`PyFloat`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFloat.html)"
msgstr ""

#: src/features.md:210
msgid "`parking-lot`"
msgstr ""

#: src/features.md:212
msgid ""
"Adds a dependency on [parking_lot](https://docs.rs/parking_lot) and enables "
"Pyo3's `OnceExt` & `MutexExt` traits for [`parking_lot::Once`](https://docs."
"rs/parking_lot/latest/parking_lot/struct.Once.html) [`parking_lot::Mutex`]"
"(https://docs.rs/parking_lot/latest/parking_lot/type.Mutex.html) and "
"[`parking_lot::ReentrantMutex`](https://docs.rs/parking_lot/latest/"
"parking_lot/type.ReentrantMutex.html) types."
msgstr ""

#: src/features.md:214
msgid "`rust_decimal`"
msgstr ""

#: src/features.md:216
msgid ""
"Adds a dependency on [rust_decimal](https://docs.rs/rust_decimal) and "
"enables conversions into its [`Decimal`](https://docs.rs/rust_decimal/latest/"
"rust_decimal/struct.Decimal.html) type."
msgstr ""

#: src/features.md:218
msgid "`time`"
msgstr ""

#: src/features.md:220
msgid ""
"Adds a dependency on [time](https://docs.rs/time) and requires MSRV 1.67.1. "
"Enables conversions between [time](https://docs.rs/time)'s types and Python:"
msgstr ""

#: src/features.md:222
msgid ""
"[Date](https://docs.rs/time/0.3.38/time/struct.Date.html) -> [`PyDate`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:223
msgid ""
"[Time](https://docs.rs/time/0.3.38/time/struct.Time.html) -> [`PyTime`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyTime.html)"
msgstr ""

#: src/features.md:224
msgid ""
"[OffsetDateTime](https://docs.rs/time/0.3.38/time/struct.OffsetDateTime."
"html) -> [`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyDateTime.html)"
msgstr ""

#: src/features.md:225
msgid ""
"[PrimitiveDateTime](https://docs.rs/time/0.3.38/time/struct."
"PrimitiveDateTime.html) -> [`PyDateTime`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:226
msgid ""
"[Duration](https://docs.rs/time/0.3.38/time/struct.Duration.html) -> "
"[`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:227
msgid ""
"[UtcOffset](https://docs.rs/time/0.3.38/time/struct.UtcOffset.html) -> "
"[`PyTzInfo`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:228
msgid ""
"[UtcDateTime](https://docs.rs/time/0.3.38/time/struct.UtcDateTime.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:230
msgid "`serde`"
msgstr ""

#: src/features.md:232
msgid ""
"Enables (de)serialization of `Py<T>` objects via [serde](https://serde.rs/). "
"This allows to use [`#[derive(Serialize, Deserialize)`](https://serde.rs/"
"derive.html) on structs that hold references to `#[pyclass]` instances"
msgstr ""

#: src/features.md:236
msgid "\"serde\""
msgstr ""

#: src/features.md:257
msgid "`smallvec`"
msgstr ""

#: src/features.md:259
msgid ""
"Adds a dependency on [smallvec](https://docs.rs/smallvec) and enables "
"conversions into its [`SmallVec`](https://docs.rs/smallvec/latest/smallvec/"
"struct.SmallVec.html) type."
msgstr ""

#: src/features.md:263
msgid "`uuid`"
msgstr ""

#: src/features.md:265
msgid ""
"Adds a dependency on [uuid](https://docs.rs/uuid) and enables conversions "
"into its [`Uuid`](https://docs.rs/uuid/latest/uuid/struct.Uuid.html) type."
msgstr ""

#: src/getting-started.md:1
msgid "Installation"
msgstr ""

#: src/getting-started.md:3
msgid ""
"To get started using PyO3 you will need three things: a Rust toolchain, a "
"Python environment, and a way to build. We'll cover each of these below."
msgstr ""

#: src/getting-started.md:5
msgid ""
"If you'd like to chat to the PyO3 maintainers and other PyO3 users, consider "
"joining the [PyO3 Discord server](https://discord.gg/33kcChzH7f). We're keen "
"to hear about your experience getting started, so we can make PyO3 as "
"accessible as possible for everyone!"
msgstr ""

#: src/getting-started.md:9
msgid ""
"First, make sure you have Rust installed on your system. If you haven't "
"already done so, try following the instructions [here](https://www.rust-lang."
"org/tools/install). PyO3 runs on both the `stable` and `nightly` versions so "
"you can choose whichever one fits you best. The minimum required Rust "
"version is 1.74."
msgstr ""

#: src/getting-started.md:11
msgid ""
"If you can run `rustc --version` and the version is new enough you're good "
"to go!"
msgstr ""

#: src/getting-started.md:15
msgid ""
"To use PyO3, you need at least Python 3.7. While you can simply use the "
"default Python interpreter on your system, it is recommended to use a "
"virtual environment."
msgstr ""

#: src/getting-started.md:17
msgid "Virtualenvs"
msgstr ""

#: src/getting-started.md:19
msgid ""
"While you can use any virtualenv manager you like, we recommend the use of "
"`pyenv` in particular if you want to develop or test for multiple different "
"Python versions, so that is what the examples in this book will use. The "
"installation instructions for `pyenv` can be found [here](https://github.com/"
"pyenv/pyenv#a-getting-pyenv). (Note: To get the `pyenv activate` and `pyenv "
"virtualenv` commands, you will also need to install the [`pyenv-virtualenv`]"
"(https://github.com/pyenv/pyenv-virtualenv) plugin. The [pyenv installer]"
"(https://github.com/pyenv/pyenv-installer#installation--update--"
"uninstallation) will install both together.)"
msgstr ""

#: src/getting-started.md:21
msgid ""
"It can be useful to keep the sources used when installing using `pyenv` so "
"that future debugging can see the original source files. This can be done by "
"passing the `--keep` flag as part of the `pyenv install` command."
msgstr ""

#: src/getting-started.md:29
msgid "Building"
msgstr ""

#: src/getting-started.md:31
msgid ""
"There are a number of build and Python package management systems such as "
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) or [manually](./"
"building-and-distribution.md#manual-builds). We recommend the use of "
"`maturin`, which you can install [here](https://maturin.rs/installation."
"html). It is developed to work with PyO3 and provides the most \"batteries "
"included\" experience, especially if you are aiming to publish to PyPI. "
"`maturin` is just a Python package, so you can add it in the same way you "
"already install Python packages."
msgstr ""

#: src/getting-started.md:33
msgid "System Python:"
msgstr ""

#: src/getting-started.md:39
msgid "pipx:"
msgstr ""

#: src/getting-started.md:45
msgid "pyenv:"
msgstr ""

#: src/getting-started.md:52
msgid "poetry:"
msgstr ""

#: src/getting-started.md:58
msgid ""
"After installation, you can run `maturin --version` to check that you have "
"correctly installed it."
msgstr ""

#: src/getting-started.md:60
msgid "Starting a new project"
msgstr ""

#: src/getting-started.md:62
msgid ""
"First you should create the folder and virtual environment that are going to "
"contain your new project. Here we will use the recommended `pyenv`:"
msgstr ""

#: src/getting-started.md:71
msgid ""
"After this, you should install your build manager. In this example, we will "
"use `maturin`. After you've activated your virtualenv, add `maturin` to it:"
msgstr ""

#: src/getting-started.md:77
msgid "Now you can initialize the new project:"
msgstr ""

#: src/getting-started.md:83
msgid ""
"If `maturin` is already installed, you can create a new project using that "
"directly as well:"
msgstr ""

#: src/getting-started.md:92
msgid "Adding to an existing project"
msgstr ""

#: src/getting-started.md:94
msgid ""
"Sadly, `maturin` cannot currently be run in existing projects, so if you "
"want to use Python in an existing project you basically have two options:"
msgstr ""

#: src/getting-started.md:96
msgid ""
"Create a new project as above and move your existing code into that project"
msgstr ""

#: src/getting-started.md:97
msgid "Manually edit your project configuration as necessary"
msgstr ""

#: src/getting-started.md:99
msgid ""
"If you opt for the second option, here are the things you need to pay "
"attention to:"
msgstr ""

#: src/getting-started.md:101
msgid "Cargo.toml"
msgstr ""

#: src/getting-started.md:103
msgid ""
"Make sure that the Rust crate you want to be able to access from Python is "
"compiled into a library. You can have a binary output as well, but the code "
"you want to access from Python has to be in the library part. Also, make "
"sure that the crate type is `cdylib` and add PyO3 as a dependency as so:"
msgstr ""

#: src/getting-started.md:105
msgid ""
"```toml\n"
"# If you already have [package] information in `Cargo.toml`, you can ignore\n"
"# this section!\n"
"[package]\n"
"# `name` here is name of the package.\n"
"name = \"pyo3_start\"\n"
"# these are good defaults:\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"pyo3_example\"\n"
"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"extension-"
"module\"] }\n"
"```"
msgstr ""

#: src/getting-started.md:128
msgid "pyproject.toml"
msgstr ""

#: src/getting-started.md:130
msgid "You should also create a `pyproject.toml` with the following contents:"
msgstr ""

#: src/getting-started.md:132
msgid ""
"```toml\n"
"[build-system]\n"
"requires = [\"maturin>=1,<2\"]\n"
"build-backend = \"maturin\"\n"
"\n"
"[project]\n"
"name = \"pyo3_example\"\n"
"requires-python = \">=3.7\"\n"
"classifiers = [\n"
"    \"Programming Language :: Rust\",\n"
"    \"Programming Language :: Python :: Implementation :: CPython\",\n"
"    \"Programming Language :: Python :: Implementation :: PyPy\",\n"
"]\n"
"```"
msgstr ""

#: src/getting-started.md:147
msgid "Running code"
msgstr ""

#: src/getting-started.md:149
msgid ""
"After this you can setup Rust code to be available in Python as below; for "
"example, you can place this code in `src/lib.rs`:"
msgstr ""

#: src/getting-started.md:152
msgid ""
"/// A Python module implemented in Rust. The name of this function must "
"match\n"
"/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able "
"to\n"
"/// import the module.\n"
msgstr ""

#: src/getting-started.md:159
msgid "/// Formats the sum of two numbers as string.\n"
msgstr ""

#: src/getting-started.md:167
msgid ""
"Now you can run `maturin develop` to prepare the Python package, after which "
"you can use it like so:"
msgstr ""

#: src/getting-started.md:170
msgid "# lots of progress output as maturin runs the compilation...\n"
msgstr ""

#: src/getting-started.md:174
msgid "'25'"
msgstr ""

#: src/getting-started.md:178
msgid ""
"For more instructions on how to use Python code from Rust, see the [Python "
"from Rust](python-from-rust.md) page."
msgstr ""

#: src/getting-started.md:180
msgid "Maturin Import Hook"
msgstr ""

#: src/getting-started.md:182
msgid ""
"In development, any changes in the code would require running `maturin "
"develop` before testing. To streamline the development process, you may want "
"to install [Maturin Import Hook](https://github.com/PyO3/maturin-import-"
"hook) which will run `maturin develop` automatically when the library with "
"code changes is being imported."
msgstr ""

#: src/index.md:1
msgid "The PyO3 user guide"
msgstr ""

#: src/index.md:3
msgid ""
"Welcome to the PyO3 user guide! This book is a companion to [PyO3's API docs]"
"(https://docs.rs/pyo3). It contains examples and documentation to explain "
"all of PyO3's use cases in detail."
msgstr ""

#: src/index.md:5
msgid "The rough order of material in this user guide is as follows:"
msgstr ""

#: src/index.md:6
msgid "Getting started"
msgstr ""

#: src/index.md:7
msgid "Wrapping Rust code for use from Python"
msgstr ""

#: src/index.md:8
msgid "How to use Python code from Rust"
msgstr ""

#: src/index.md:9
msgid "Remaining topics which go into advanced concepts in detail"
msgstr ""

#: src/index.md:11
msgid ""
"Please choose from the chapters on the left to jump to individual topics, or "
"continue below to start with PyO3's README."
msgstr ""

#: src/index.md:15
msgid "PyO3"
msgstr ""

#: src/index.md:17
msgid ""
"[![actions status](https://img.shields.io/github/actions/workflow/status/"
"PyO3/pyo3/ci.yml?branch=main&logo=github&style=)](https://github.com/PyO3/"
"pyo3/actions) [![benchmark](https://img.shields.io/endpoint?url=https://"
"codspeed.io/badge.json)](https://codspeed.io/PyO3/pyo3) [![codecov](https://"
"img.shields.io/codecov/c/gh/PyO3/pyo3?logo=codecov)](https://codecov.io/gh/"
"PyO3/pyo3) [![crates.io](https://img.shields.io/crates/v/pyo3?logo=rust)]"
"(https://crates.io/crates/pyo3) [![minimum rustc 1.74](https://img.shields."
"io/badge/rustc-1.74+-blue?logo=rust)](https://rust-lang.github.io/rfcs/2495-"
"min-rust-version.html) [![discord server](https://img.shields.io/"
"discord/1209263839632424990?logo=discord)](https://discord.gg/33kcChzH7f) [!"
"[contributing notes](https://img.shields.io/badge/contribute-on%20github-"
"Green?logo=github)](https://github.com/PyO3/pyo3/blob/main/Contributing.md)"
msgstr ""

#: src/index.md:25
msgid ""
"[Rust](https://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/), including tools for creating native Python extension modules. Running "
"and interacting with Python code from a Rust binary is also supported."
msgstr ""

#: src/index.md:27
msgid "User Guide: [stable](https://pyo3.rs) | [main](https://pyo3.rs/main)"
msgstr ""

#: src/index.md:29
msgid ""
"API Documentation: [stable](https://docs.rs/pyo3/) | [main](https://pyo3.rs/"
"main/doc)"
msgstr ""

#: src/index.md:31
msgid "Usage"
msgstr ""

#: src/index.md:33
msgid "Requires Rust 1.74 or greater."
msgstr ""

#: src/index.md:35
msgid "PyO3 supports the following Python distributions:"
msgstr ""

#: src/index.md:36
msgid "CPython 3.7 or greater"
msgstr ""

#: src/index.md:37
msgid "PyPy 7.3 (Python 3.11+)"
msgstr ""

#: src/index.md:38
msgid "GraalPy 24.2 or greater (Python 3.11+)"
msgstr ""

#: src/index.md:40
msgid ""
"You can use PyO3 to write a native Python module in Rust, or to embed Python "
"in a Rust binary. The following sections explain each of these in turn."
msgstr ""

#: src/index.md:42
msgid "Using Rust from Python"
msgstr ""

#: src/index.md:44
msgid ""
"PyO3 can be used to generate a native Python module. The easiest way to try "
"this out for the first time is to use [`maturin`](https://github.com/PyO3/"
"maturin). `maturin` is a tool for building and publishing Rust-based Python "
"packages with minimal configuration. The following steps install `maturin`, "
"use it to generate and build a new Python package, and then launch Python to "
"import and execute a function from the package."
msgstr ""

#: src/index.md:46
msgid ""
"First, follow the commands below to create a new directory containing a new "
"Python `virtualenv`, and install `maturin` into the virtualenv using "
"Python's package manager, `pip`:"
msgstr ""

#: src/index.md:49
msgid "# (replace string_sum with the desired package name)\n"
msgstr ""

#: src/index.md:57
msgid ""
"Still inside this `string_sum` directory, now run `maturin init`. This will "
"generate the new package source. When given the choice of bindings to use, "
"select pyo3 bindings:"
msgstr ""

#: src/index.md:65
msgid ""
"The most important files generated by this command are `Cargo.toml` and `lib."
"rs`, which will look roughly like the following:"
msgstr ""

#: src/index.md:67
msgid "**`Cargo.toml`**"
msgstr ""

#: src/index.md:69
msgid ""
"```toml\n"
"[package]\n"
"name = \"string_sum\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"string_sum\"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"#\n"
"# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) "
"will not be able\n"
"# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also "
"included, e.g.:\n"
"# crate-type = [\"cdylib\", \"rlib\"]\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.27.2\", features = [\"extension-module\"] }\n"
"```"
msgstr ""

#: src/index.md:91
msgid "**`src/lib.rs`**"
msgstr ""

#: src/index.md:94
msgid ""
"/// A Python module implemented in Rust. The name of this module must match\n"
"/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able "
"to\n"
"/// import the module.\n"
msgstr ""

#: src/index.md:109
msgid ""
"Finally, run `maturin develop`. This will build the package and install it "
"into the Python virtualenv previously created and activated. The package is "
"then ready to be used from `python`:"
msgstr ""

#: src/index.md:120
msgid ""
"To make changes to the package, just edit the Rust source code and then re-"
"run `maturin develop` to recompile."
msgstr ""

#: src/index.md:122
msgid ""
"To run this all as a single copy-and-paste, use the bash script below "
"(replace `string_sum` in the first command with the desired package name):"
msgstr ""

#: src/index.md:125
msgid "\"$_\""
msgstr ""

#: src/index.md:133
msgid ""
"If you want to be able to run `cargo test` or use this project in a Cargo "
"workspace and are running into linker issues, there are some workarounds in "
"[the FAQ](https://pyo3.rs/latest/faq.html#i-cant-run-cargo-test-or-i-cant-"
"build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-"
"undefined-reference-to-_pyexc_systemerror)."
msgstr ""

#: src/index.md:135
msgid ""
"As well as with `maturin`, it is possible to build using [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) or [manually](https://pyo3.rs/"
"latest/building-and-distribution.html#manual-builds). Both offer more "
"flexibility than `maturin` but require more configuration to get started."
msgstr ""

#: src/index.md:137
msgid "Using Python from Rust"
msgstr ""

#: src/index.md:139
msgid ""
"To embed Python into a Rust binary, you need to ensure that your Python "
"installation contains a shared library. The following steps demonstrate how "
"to ensure this (for Ubuntu), and then give some example code which runs an "
"embedded Python interpreter."
msgstr ""

#: src/index.md:141
msgid "To install the Python shared library on Ubuntu:"
msgstr ""

#: src/index.md:147
msgid ""
"To install the Python shared library on RPM based distributions (e.g. "
"Fedora, Red Hat, SuSE), install the `python3-devel` package."
msgstr ""

#: src/index.md:150
msgid ""
"Start a new project with `cargo new` and add  `pyo3` to the `Cargo.toml` "
"like this:"
msgstr ""

#: src/index.md:152
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.27.2\"\n"
"features = [\"auto-initialize\"]\n"
"```"
msgstr ""

#: src/index.md:158
msgid ""
"Example program displaying the value of `sys.version` and the current user "
"name:"
msgstr ""

#: src/index.md:170
msgid "\"os\""
msgstr ""

#: src/index.md:171
msgid "\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\""
msgstr ""

#: src/index.md:174
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/index.md:180
msgid ""
"The guide has [a section](https://pyo3.rs/latest/python-from-rust.html) with "
"lots of examples about this topic."
msgstr ""

#: src/index.md:183
msgid "Tools and libraries"
msgstr ""

#: src/index.md:185
msgid ""
"[maturin](https://github.com/PyO3/maturin) _Build and publish crates with "
"pyo3, rust-cpython or cffi bindings as well as rust binaries as python "
"packages_"
msgstr ""

#: src/index.md:186
msgid ""
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) _Setuptools "
"plugin for Rust support_."
msgstr ""

#: src/index.md:187
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html)_"
msgstr ""

#: src/index.md:188
msgid ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _Rust binding of NumPy C-"
"API_"
msgstr ""

#: src/index.md:189
msgid ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject to automatically transform Python dicts into Rust structs_"
msgstr ""

#: src/index.md:190
msgid ""
"[pyo3-log](https://github.com/vorner/pyo3-log) _Bridge from Rust to Python "
"logging_"
msgstr ""

#: src/index.md:191
msgid ""
"[pythonize](https://github.com/davidhewitt/pythonize) _Serde serializer for "
"converting Rust objects to JSON-compatible Python objects_"
msgstr ""

#: src/index.md:192
msgid ""
"[pyo3-async-runtimes](https://github.com/PyO3/pyo3-async-runtimes) "
"_Utilities for interoperability with Python's Asyncio library and Rust's "
"async runtimes._"
msgstr ""

#: src/index.md:193
msgid ""
"[rustimport](https://github.com/mityax/rustimport) _Directly import Rust "
"files or crates from Python, without manual compilation step. Provides pyo3 "
"integration by default and generates pyo3 binding code automatically._"
msgstr ""

#: src/index.md:194
msgid ""
"[pyo3-arrow](https://crates.io/crates/pyo3-arrow) _Lightweight [Apache Arrow]"
"(https://arrow.apache.org/) integration for pyo3._"
msgstr ""

#: src/index.md:195
msgid ""
"[pyo3-bytes](https://crates.io/crates/pyo3-bytes) _Integration between "
"[`bytes`](https://crates.io/crates/bytes) and pyo3._"
msgstr ""

#: src/index.md:196
msgid ""
"[pyo3-object_store](https://github.com/developmentseed/obstore/tree/main/"
"pyo3-object_store) _Integration between [`object_store`](https://docs.rs/"
"object_store) and [`pyo3`](https://github.com/PyO3/pyo3)._"
msgstr ""

#: src/index.md:198
msgid "Examples"
msgstr ""

#: src/index.md:200
msgid ""
"[arro3](https://github.com/kylebarron/arro3) _A minimal Python library for "
"Apache Arrow, connecting to the Rust arrow crate._"
msgstr ""

#: src/index.md:201
msgid ""
"[arro3-compute](https://github.com/kylebarron/arro3/tree/main/arro3-compute) "
"_`arro3-compute`_"
msgstr ""

#: src/index.md:202
msgid ""
"[arro3-core](https://github.com/kylebarron/arro3/tree/main/arro3-core) "
"_`arro3-core`_"
msgstr ""

#: src/index.md:203
msgid ""
"[arro3-io](https://github.com/kylebarron/arro3/tree/main/arro3-io) _`arro3-"
"io`_"
msgstr ""

#: src/index.md:204
msgid ""
"[bed-reader](https://github.com/fastlmm/bed-reader) _Read and write the "
"PLINK BED format, simply and efficiently._"
msgstr ""

#: src/index.md:205
msgid ""
"Shows Rayon/ndarray::parallel (including capturing errors, controlling "
"thread num), Python types to Rust generics, Github Actions"
msgstr ""

#: src/index.md:206
msgid ""
"[blake3-py](https://github.com/oconnor663/blake3-py) _Python bindings for "
"the [BLAKE3](https://github.com/BLAKE3-team/BLAKE3) cryptographic hash "
"function._"
msgstr ""

#: src/index.md:207
msgid ""
"Parallelized [builds](https://github.com/oconnor663/blake3-py/blob/master/."
"github/workflows/dists.yml) on GitHub Actions for MacOS, Linux, Windows, "
"including free-threaded 3.13t wheels."
msgstr ""

#: src/index.md:208
msgid ""
"[cellular_raza](https://cellular-raza.com) _A cellular agent-based "
"simulation framework for building complex models from a clean slate._"
msgstr ""

#: src/index.md:209
msgid ""
"[connector-x](https://github.com/sfu-db/connector-x/tree/main/connectorx-"
"python) _Fastest library to load data from DB to DataFrames in Rust and "
"Python._"
msgstr ""

#: src/index.md:210
msgid ""
"[cryptography](https://github.com/pyca/cryptography/tree/main/src/rust) "
"_Python cryptography library with some functionality in Rust._"
msgstr ""

#: src/index.md:211
msgid ""
"[css-inline](https://github.com/Stranger6667/css-inline/tree/master/bindings/"
"python) _CSS inlining for Python implemented in Rust._"
msgstr ""

#: src/index.md:212
msgid ""
"[datafusion-python](https://github.com/apache/arrow-datafusion-python) _A "
"Python library that binds to Apache Arrow in-memory query engine DataFusion._"
msgstr ""

#: src/index.md:213
msgid ""
"[deltalake-python](https://github.com/delta-io/delta-rs/tree/main/python) "
"_Native Delta Lake Python binding based on delta-rs with Pandas integration._"
msgstr ""

#: src/index.md:214
msgid ""
"[fastbloom](https://github.com/yankun1992/fastbloom) _A fast [bloom filter]"
"(https://github.com/yankun1992/fastbloom#BloomFilter) | [counting bloom "
"filter](https://github.com/yankun1992/fastbloom#countingbloomfilter) "
"implemented by Rust for Rust and Python!_"
msgstr ""

#: src/index.md:215
msgid ""
"[fastuuid](https://github.com/thedrow/fastuuid/) _Python bindings to Rust's "
"UUID library._"
msgstr ""

#: src/index.md:216
msgid ""
"[feos](https://github.com/feos-org/feos) _Lightning fast thermodynamic "
"modeling in Rust with fully developed Python interface._"
msgstr ""

#: src/index.md:217
msgid ""
"[finalytics](https://github.com/Nnamdi-sys/finalytics) _Investment Analysis "
"library in Rust | Python._"
msgstr ""

#: src/index.md:218
msgid ""
"[forust](https://github.com/jinlow/forust) _A lightweight gradient boosted "
"decision tree library written in Rust._"
msgstr ""

#: src/index.md:219
msgid ""
"[geo-index](https://github.com/kylebarron/geo-index) _A Rust crate and "
"[Python library](https://github.com/kylebarron/geo-index/tree/main/python) "
"for packed, immutable, zero-copy spatial indexes._"
msgstr ""

#: src/index.md:220
msgid ""
"[granian](https://github.com/emmett-framework/granian) _A Rust HTTP server "
"for Python applications._"
msgstr ""

#: src/index.md:221
msgid ""
"[haem](https://github.com/BooleanCat/haem) _A Python library for working on "
"Bioinformatics problems._"
msgstr ""

#: src/index.md:222
msgid ""
"[html2text-rs](https://github.com/deedy5/html2text_rs) _Python library for "
"converting HTML to markup or plain text._"
msgstr ""

#: src/index.md:223
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/main/examples/"
"html-py-ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""

#: src/index.md:224
msgid ""
"[hudi-rs](https://github.com/apache/hudi-rs) _The native Rust implementation "
"for Apache Hudi, with C++ & Python API bindings._"
msgstr ""

#: src/index.md:225
msgid ""
"[inline-python](https://github.com/m-ou-se/inline-python) _Inline Python "
"code directly in your Rust code._"
msgstr ""

#: src/index.md:226
msgid ""
"[johnnycanencrypt](https://github.com/kushaldas/johnnycanencrypt) OpenPGP "
"library with Yubikey support."
msgstr ""

#: src/index.md:227
msgid ""
"[jsonschema](https://github.com/Stranger6667/jsonschema/tree/master/crates/"
"jsonschema-py) _A high-performance JSON Schema validator for Python._"
msgstr ""

#: src/index.md:228
msgid ""
"[mocpy](https://github.com/cds-astro/mocpy) _Astronomical Python library "
"offering data structures for describing any arbitrary coverage regions on "
"the unit sphere._"
msgstr ""

#: src/index.md:229
msgid ""
"[obstore](https://github.com/developmentseed/obstore) _The simplest, highest-"
"throughput Python interface to Amazon S3, Google Cloud Storage, Azure "
"Storage, & other S3-compliant APIs, powered by Rust._"
msgstr ""

#: src/index.md:230
msgid ""
"[opendal](https://github.com/apache/opendal/tree/main/bindings/python) _A "
"data access layer that allows users to easily and efficiently retrieve data "
"from various storage services in a unified way._"
msgstr ""

#: src/index.md:231
msgid "[orjson](https://github.com/ijl/orjson) _Fast Python JSON library._"
msgstr ""

#: src/index.md:232
msgid ""
"[ormsgpack](https://github.com/aviramha/ormsgpack) _Fast Python msgpack "
"library._"
msgstr ""

#: src/index.md:233
msgid ""
"[polars](https://github.com/pola-rs/polars) _Fast multi-threaded DataFrame "
"library in Rust | Python | Node.js._"
msgstr ""

#: src/index.md:234
msgid ""
"[pycrdt](https://github.com/jupyter-server/pycrdt) _Python bindings for the "
"Rust CRDT implementation [Yrs](https://github.com/y-crdt/y-crdt)._"
msgstr ""

#: src/index.md:235
msgid ""
"[pydantic-core](https://github.com/pydantic/pydantic-core) _Core validation "
"logic for pydantic written in Rust._"
msgstr ""

#: src/index.md:236
msgid ""
"[primp](https://github.com/deedy5/primp) _The fastest python HTTP client "
"that can impersonate web browsers by mimicking their headers and TLS/JA3/JA4/"
"HTTP2 fingerprints._"
msgstr ""

#: src/index.md:237
msgid ""
"[radiate](https://github.com/pkalivas/radiate): _A high-performance "
"evolution engine for genetic programming and evolutionary algorithms._"
msgstr ""

#: src/index.md:238
msgid ""
"[rateslib](https://github.com/attack68/rateslib) _A fixed income library for "
"Python using Rust extensions._"
msgstr ""

#: src/index.md:239
msgid ""
"[river](https://github.com/online-ml/river) _Online machine learning in "
"python, the computationally heavy statistics algorithms are implemented in "
"Rust._"
msgstr ""

#: src/index.md:240
msgid ""
"[robyn](https://github.com/sparckles/Robyn) A Super Fast Async Python Web "
"Framework with a Rust runtime."
msgstr ""

#: src/index.md:241
msgid ""
"[rust-python-coverage](https://github.com/cjermain/rust-python-coverage) "
"_Example PyO3 project with automated test coverage for Rust and Python._"
msgstr ""

#: src/index.md:242
msgid ""
"[rnet](https://github.com/0x676e67/rnet) Asynchronous Python HTTP Client "
"with Black Magic"
msgstr ""

#: src/index.md:243
msgid ""
"[sail](https://github.com/lakehq/sail) _Unifying stream, batch, and AI "
"workloads with Apache Spark compatibility._"
msgstr ""

#: src/index.md:244
msgid ""
"[tiktoken](https://github.com/openai/tiktoken) _A fast BPE tokeniser for use "
"with OpenAI's models._"
msgstr ""

#: src/index.md:245
msgid ""
"[tokenizers](https://github.com/huggingface/tokenizers/tree/main/bindings/"
"python) _Python bindings to the Hugging Face tokenizers (NLP) written in "
"Rust._"
msgstr ""

#: src/index.md:246
msgid ""
"[tzfpy](http://github.com/ringsaturn/tzfpy) _A fast package to convert "
"longitude/latitude to timezone name._"
msgstr ""

#: src/index.md:247
msgid ""
"[utiles](https://github.com/jessekrubin/utiles) _Fast Python web-map tile "
"utilities_"
msgstr ""

#: src/index.md:249
msgid "Articles and other media"
msgstr ""

#: src/index.md:251
msgid ""
"[(Video) Using Rust in Free-Threaded vs Regular Python 3.13](https://www."
"youtube.com/watch?v=J7phN_M4GLM) - Jun 4, 2025"
msgstr ""

#: src/index.md:252
msgid ""
"[(Video) Techniques learned from five years finding the way for Rust in "
"Python](https://www.youtube.com/watch?v=KTQn_PTHNCw) - Feb 26, 2025"
msgstr ""

#: src/index.md:253
msgid ""
"[(Podcast) Bridging Python and Rust: An Interview with PyO3 Maintainer David "
"Hewitt](https://www.youtube.com/watch?v=P47JUMSQagU) - Aug 30, 2024"
msgstr ""

#: src/index.md:254
msgid ""
"[(Video) PyO3: From Python to Rust and Back Again](https://www.youtube.com/"
"watch?v=UmL_CA-v3O8) - Jul 3, 2024"
msgstr ""

#: src/index.md:255
msgid ""
"[Parsing Python ASTs 20x Faster with Rust](https://www.gauge.sh/blog/parsing-"
"python-asts-20x-faster-with-rust) - Jun 17, 2024"
msgstr ""

#: src/index.md:256
msgid ""
"[(Video) How Python Harnesses Rust through PyO3](https://www.youtube.com/"
"watch?v=UilujdubqVU) - May 18, 2024"
msgstr ""

#: src/index.md:257
msgid ""
"[(Video) Combining Rust and Python: The Best of Both Worlds?](https://www."
"youtube.com/watch?v=lyG6AKzu4ew) - Mar 1, 2024"
msgstr ""

#: src/index.md:258
msgid ""
"[(Video) Extending Python with Rust using PyO3](https://www.youtube.com/"
"watch?v=T45ZEmSR1-s) - Dec 16, 2023"
msgstr ""

#: src/index.md:259
msgid ""
"[A Week of PyO3 + rust-numpy (How to Speed Up Your Data Pipeline X Times)]"
"(https://terencezl.github.io/blog/2023/06/06/a-week-of-pyo3-rust-numpy/) - "
"Jun 6, 2023"
msgstr ""

#: src/index.md:260
msgid ""
"[(Podcast) PyO3 with David Hewitt](https://rustacean-station.org/episode/"
"david-hewitt/) - May 19, 2023"
msgstr ""

#: src/index.md:261
msgid ""
"[Making Python 100x faster with less than 100 lines of Rust](https://"
"ohadravid.github.io/posts/2023-03-rusty-python/) - Mar 28, 2023"
msgstr ""

#: src/index.md:262
msgid ""
"[How Pydantic V2 leverages Rust's Superpowers](https://fosdem.org/2023/"
"schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/) - Feb 4, "
"2023"
msgstr ""

#: src/index.md:263
msgid ""
"[How we extended the River stats module with Rust using PyO3](https://boring-"
"guy.sh/posts/river-rust/) - Dec 23, 2022"
msgstr ""

#: src/index.md:264
msgid ""
"[Nine Rules for Writing Python Extensions in Rust](https://"
"towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-"
"d35ea3a4ec29?sk=f8d808d5f414154fdb811e4137011437) - Dec 31, 2021"
msgstr ""

#: src/index.md:265
msgid ""
"[Calling Rust from Python using PyO3](https://saidvandeklundert.net/"
"learn/2021-11-18-calling-rust-from-python-using-pyo3/) - Nov 18, 2021"
msgstr ""

#: src/index.md:266
msgid ""
"[davidhewitt's 2021 talk at Rust Manchester meetup](https://www.youtube.com/"
"watch?v=-XyWG_klSAw&t=320s) - Aug 19, 2021"
msgstr ""

#: src/index.md:267
msgid ""
"[Incrementally porting a small Python project to Rust](https://blog."
"waleedkhan.name/port-python-to-rust/) - Apr 29, 2021"
msgstr ""

#: src/index.md:268
msgid ""
"[Vortexa - Integrating Rust into Python](https://www.vortexa.com/blog/"
"integrating-rust-into-python) - Apr 12, 2021"
msgstr ""

#: src/index.md:269
msgid ""
"[Writing and publishing a Python module in Rust](https://blog.yossarian."
"net/2020/08/02/Writing-and-publishing-a-python-module-in-rust) - Aug 2, 2020"
msgstr ""

#: src/index.md:273
msgid ""
"Everyone is welcomed to contribute to PyO3! There are many ways to support "
"the project, such as:"
msgstr ""

#: src/index.md:275
msgid ""
"help PyO3 users with issues on GitHub and [Discord](https://discord."
"gg/33kcChzH7f)"
msgstr ""

#: src/index.md:276
msgid "improve documentation"
msgstr ""

#: src/index.md:277
msgid "write features and bugfixes"
msgstr ""

#: src/index.md:278
msgid "publish blogs and examples of how to use PyO3"
msgstr ""

#: src/index.md:280
msgid ""
"Our [contributing notes](https://github.com/PyO3/pyo3/blob/main/Contributing."
"md) and [architecture guide](https://github.com/PyO3/pyo3/blob/main/"
"Architecture.md) have more resources if you wish to volunteer time for PyO3 "
"and are searching where to start."
msgstr ""

#: src/index.md:282
msgid ""
"If you don't have time to contribute yourself but still wish to support the "
"project's future success, some of our maintainers have GitHub sponsorship "
"pages:"
msgstr ""

#: src/index.md:287
msgid "License"
msgstr ""

#: src/index.md:289
msgid ""
"PyO3 is licensed under the [Apache-2.0 license](LICENSE-APACHE) or the [MIT "
"license](LICENSE-MIT), at your option."
msgstr ""

#: src/index.md:291
msgid ""
"Python is licensed under the [Python License](https://docs.python.org/3/"
"license.html)."
msgstr ""

#: src/index.md:293
msgid ""
"Unless you explicitly state otherwise, any contribution intentionally "
"submitted for inclusion in PyO3 by you, as defined in the Apache License, "
"shall be dual-licensed as above, without any additional terms or conditions."
msgstr ""

#: src/index.md:295
msgid ""
"<a href=\"https://www.netlify.com\"> <img src=\"https://www.netlify.com/v3/"
"img/components/netlify-color-accent.svg\" alt=\"Deploys by Netlify\" /> </a>"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"Historically, CPython was limited by the [global interpreter lock](https://"
"docs.python.org/3/glossary.html#term-global-interpreter-lock) (GIL), which "
"only allowed a single thread to drive the Python interpreter at a time. This "
"made threading in Python a bad fit for [CPU-bound](https://en.wikipedia.org/"
"wiki/CPU-bound) tasks and often forced developers to accept the overhead of "
"multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"Rust is well-suited to multithreaded code, and libraries like [`rayon`]"
"(https://github.com/rayon-rs/rayon) can help you leverage safe parallelism "
"with minimal effort. The [`Python::detach`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.detach) method can be used to allow the "
"Python interpreter to do other work while the Rust work is ongoing."
msgstr ""

#: src/parallelism.md:7
msgid ""
"To enable full parallelism in your application, consider also using [free-"
"threaded Python](./free-threading.md) which is supported since Python 3.14."
msgstr ""

#: src/parallelism.md:9
msgid "Parallelism under the Python GIL"
msgstr ""

#: src/parallelism.md:11
msgid ""
"Let's take a look at our [word-count](https://github.com/PyO3/pyo3/blob/main/"
"examples/word-count/src/lib.rs) example, where we have a `search` function "
"that utilizes the [`rayon`](https://github.com/rayon-rs/rayon) crate to "
"count words in parallel."
msgstr ""

#: src/parallelism.md:16
msgid "// These traits let us use `par_lines` and `map`.\n"
msgstr ""

#: src/parallelism.md:20
msgid "/// Count the occurrences of needle in line, case insensitive\n"
msgstr ""

#: src/parallelism.md:24 src/parallelism.md:47 src/parallelism.md:68
msgid "' '"
msgstr ""

#: src/parallelism.md:41
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""

#: src/parallelism.md:60
msgid ""
"To enable parallel execution of this function, the [`Python::detach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) "
"method can be used to temporarily release the GIL, thus allowing other "
"Python threads to run. We then have a function exposed to the Python runtime "
"which calls `search_sequential` inside a closure passed to [`Python::detach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) to "
"enable true parallelism:"
msgstr ""

#: src/parallelism.md:85
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""

#: src/parallelism.md:103
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:105
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr ""

#: src/parallelism.md:107
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr ""

#: src/parallelism.md:109
msgid "Pure Python version"
msgstr ""

#: src/parallelism.md:110
msgid "Rust parallel version"
msgstr ""

#: src/parallelism.md:111
msgid "Rust sequential version"
msgstr ""

#: src/parallelism.md:112
msgid "Rust sequential version executed twice with two Python threads"
msgstr ""

#: src/parallelism.md:114
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `nox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""

#: src/parallelism.md:116
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr ""

#: src/parallelism.md:129
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""

#: src/parallelism.md:131
msgid "Sharing Python objects between Rust threads"
msgstr ""

#: src/parallelism.md:133
msgid ""
"In the example above we made a Python interface to a low-level rust "
"function, and then leveraged the python `threading` module to run the low-"
"level function in parallel. It is also possible to spawn threads in Rust "
"that acquire the GIL and operate on Python objects. However, care must be "
"taken to avoid writing code that deadlocks with the GIL in these cases."
msgstr ""

#: src/parallelism.md:139
msgid ""
"Note: This example is meant to illustrate how to drop and re-acquire the GIL "
"to avoid creating deadlocks. Unless the spawned threads subsequently release "
"the GIL or you are using the free-threaded build of CPython, you will not "
"see any speedups due to multi-threaded parallelism using `rayon` to "
"parallelize code that acquires and holds the GIL for the entire execution of "
"the spawned thread."
msgstr ""

#: src/parallelism.md:146
msgid ""
"In the example below, we share a `Vec` of User ID objects defined using the "
"`pyclass` macro and spawn threads to process the collection of data into a "
"`Vec` of booleans based on a predicate using a `rayon` parallel iterator:"
msgstr ""

#: src/parallelism.md:152
msgid "// These traits let us use int_par_iter and map\n"
msgstr ""

#: src/parallelism.md:174
msgid ""
"It's important to note that there is an `outer_py` Python token as well as "
"an `inner_py` token. Sharing Python tokens between threads is not allowed "
"and threads must individually attach to the interpreter to access data "
"wrapped by a Python object."
msgstr ""

#: src/parallelism.md:179
msgid ""
"It's also important to see that this example uses [`Python::detach`](https://"
"pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) to wrap the "
"code that spawns OS threads via `rayon`. If this example didn't use "
"`detach`, a `rayon` worker thread would block on acquiring the GIL while a "
"thread that owns the GIL spins forever waiting for the result of the `rayon` "
"thread. Calling `detach` allows the GIL to be released in the thread "
"collecting the results from the worker threads. You should always call "
"`detach` in situations that spawn worker threads, but especially so in cases "
"where worker threads need to acquire the GIL, to prevent deadlocks."
msgstr ""

#: src/performance.md:1
msgid "Performance"
msgstr ""

#: src/performance.md:3
msgid ""
"To achieve the best possible performance, it is useful to be aware of "
"several tricks and sharp edges concerning PyO3's API."
msgstr ""

#: src/performance.md:5
msgid "`extract` versus `cast`"
msgstr ""

#: src/performance.md:7
msgid ""
"Pythonic API implemented using PyO3 are often polymorphic, i.e. they will "
"accept `&Bound<'_, PyAny>` and try to turn this into multiple more concrete "
"types to which the requested operation is applied. This often leads to "
"chains of calls to `extract`, e.g."
msgstr ""

#: src/performance.md:29 src/performance.md:51
msgid "\"Cannot frobnicate that type.\""
msgstr ""

#: src/performance.md:34
msgid ""
"This suboptimal as the `FromPyObject<T>` trait requires `extract` to have a "
"`Result<T, PyErr>` return type. For native types like `PyList`, it faster to "
"use `cast` (which `extract` calls internally) when the error value is "
"ignored. This avoids the costly conversion of a `PyDowncastError` to a "
"`PyErr` required to fulfil the `FromPyObject` contract, i.e."
msgstr ""

#: src/performance.md:45
msgid ""
"// Use `cast` instead of `extract` as turning `PyDowncastError` into `PyErr` "
"is quite costly.\n"
msgstr ""

#: src/performance.md:56
msgid "Access to Bound implies access to Python token"
msgstr ""

#: src/performance.md:58
msgid ""
"Calling `Python::attach` is effectively a no-op when we're already attached "
"to the interpreter, but checking that this is the case still has a cost. If "
"an existing Python token can not be accessed, for example when implementing "
"a pre-existing trait, but a Python-bound reference is available, this cost "
"can be avoided by exploiting that access to Python-bound reference gives "
"zero-cost access to a Python token via `Bound::py`."
msgstr ""

#: src/performance.md:60
msgid "For example, instead of writing"
msgstr ""

#: src/performance.md:81
msgid "use the more efficient"
msgstr ""

#: src/performance.md:92
msgid "// Access to `&Bound<'py, PyAny>` implies access to `Python<'py>`.\n"
msgstr ""

#: src/performance.md:100
msgid "Calling Python callables (`__call__`)"
msgstr ""

#: src/performance.md:102
msgid ""
"CPython support multiple calling protocols: [`tp_call`](https://docs.python."
"org/3/c-api/call.html#the-tp-call-protocol) and [`vectorcall`](https://docs."
"python.org/3/c-api/call.html#the-vectorcall-protocol). [`vectorcall`]"
"(https://docs.python.org/3/c-api/call.html#the-vectorcall-protocol) is a "
"more efficient protocol unlocking faster calls. PyO3 will try to dispatch "
"Python `call`s using the [`vectorcall`](https://docs.python.org/3/c-api/call."
"html#the-vectorcall-protocol) calling convention to archive maximum "
"performance if possible and falling back to [`tp_call`](https://docs.python."
"org/3/c-api/call.html#the-tp-call-protocol) otherwise. This is implemented "
"using the (internal) `PyCallArgs` trait. It defines how Rust types can be "
"used as Python `call` arguments. This trait is currently implemented for"
msgstr ""

#: src/performance.md:106
msgid "Rust tuples, where each member implements `IntoPyObject`,"
msgstr ""

#: src/performance.md:107
msgid "`Bound<'_, PyTuple>`"
msgstr ""

#: src/performance.md:108
msgid "`Py<PyTuple>`"
msgstr ""

#: src/performance.md:110
msgid ""
"Rust tuples may make use of [`vectorcall`](https://docs.python.org/3/c-api/"
"call.html#the-vectorcall-protocol) where as `Bound<'_, PyTuple>` and "
"`Py<PyTuple>` can only use [`tp_call`](https://docs.python.org/3/c-api/call."
"html#the-tp-call-protocol). For maximum performance prefer using Rust tuples "
"as arguments."
msgstr ""

#: src/performance.md:115
msgid "Detach from the interpreter for long-running Rust-only work"
msgstr ""

#: src/performance.md:117
msgid ""
"When executing Rust code which does not need to interact with the Python "
"interpreter, use [`Python::detach`](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#method.detach) to allow the Python interpreter to proceed "
"without waiting for the current thread."
msgstr ""

#: src/performance.md:119
msgid ""
"On the GIL-enabled build, this is crucial for best performance as only a "
"single thread may ever be attached at a time."
msgstr ""

#: src/performance.md:121
msgid ""
"On the free-threaded build, this is still best practice as there are several "
"\"stop the world\" events (such as garbage collection) where all threads "
"attached to the Python interpreter are forced to wait."
msgstr ""

#: src/performance.md:123
msgid ""
"As a rule of thumb, attaching and detaching from the Python interpreter "
"takes less than a millisecond, so any work which is expected to take "
"multiple milliseconds can likely benefit from detaching from the interpreter."
msgstr ""

#: src/performance.md:127
msgid "Disable the global reference pool"
msgstr ""

#: src/performance.md:129
msgid ""
"PyO3 uses global mutable state to keep track of deferred reference count "
"updates implied by `impl<T> Drop for Py<T>` being called without being "
"attached to the interpreter. The necessary synchronization to obtain and "
"apply these reference count updates when PyO3-based code next attaches to "
"the interpreter is somewhat expensive and can become a significant part of "
"the cost of crossing the Python-Rust boundary."
msgstr ""

#: src/performance.md:131
msgid ""
"This functionality can be avoided by setting the "
"`pyo3_disable_reference_pool` conditional compilation flag. This removes the "
"global reference pool and the associated costs completely. However, it does "
"_not_ remove the `Drop` implementation for `Py<T>` which is necessary to "
"interoperate with existing Rust code written without PyO3-based code in "
"mind. To stay compatible with the wider Rust ecosystem in these cases, we "
"keep the implementation but abort when `Drop` is called without being "
"attached to the interpreter. If `pyo3_leak_on_drop_without_reference_pool` "
"is additionally enabled, objects dropped without being attached to Python "
"will be leaked instead which is always sound but might have determinal "
"effects like resource exhaustion in the long term."
msgstr ""

#: src/performance.md:133
msgid ""
"This limitation is important to keep in mind when this setting is used, "
"especially when embedding Python code into a Rust application as it is quite "
"easy to accidentally drop a `Py<T>` (or types containing it like `PyErr`, "
"`PyBackedStr` or `PyBackedBytes`) returned from `Python::attach` without "
"making sure to re-attach beforehand. For example, the following code"
msgstr ""

#: src/performance.md:149
msgid "will abort if the list not explicitly disposed via"
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:9
msgid "Python modules"
msgstr ""

#: src/SUMMARY.md:10
msgid "Python functions"
msgstr ""

#: src/SUMMARY.md:11
msgid "Function signatures"
msgstr ""

#: src/SUMMARY.md:12
msgid "Error handling"
msgstr ""

#: src/SUMMARY.md:13
msgid "Python classes"
msgstr ""

#: src/SUMMARY.md:14
msgid "Class customizations"
msgstr ""

#: src/SUMMARY.md:15
msgid "Basic object customization"
msgstr ""

#: src/SUMMARY.md:16
msgid "Emulating numeric types"
msgstr ""

#: src/SUMMARY.md:17
msgid "Emulating callable objects"
msgstr ""

#: src/SUMMARY.md:18
msgid "Thread safety"
msgstr ""

#: src/SUMMARY.md:19
msgid "Calling Python from Rust"
msgstr ""

#: src/SUMMARY.md:24
msgid "Type conversions"
msgstr ""

#: src/SUMMARY.md:25
msgid "Mapping of Rust types to Python types"
msgstr ""

#: src/SUMMARY.md:26
msgid "Conversion traits"
msgstr ""

#: src/SUMMARY.md:27 src/SUMMARY.md:40
msgid "Using `async` and `await`"
msgstr ""

#: src/SUMMARY.md:29
msgid "Supporting Free-Threaded Python"
msgstr ""

#: src/SUMMARY.md:33
msgid "Type stub generation and introspection"
msgstr ""

#: src/SUMMARY.md:37
msgid "Useful crates"
msgstr ""

#: src/SUMMARY.md:38
msgid "Logging"
msgstr ""

#: src/SUMMARY.md:39
msgid "Tracing"
msgstr ""

#: src/SUMMARY.md:41
msgid "FAQ and troubleshooting"
msgstr ""

#: src/SUMMARY.md:45
msgid ""
"Appendix A: Migration guide Appendix B: Trait bounds Appendix C: Python "
"typing hints CHANGELOG"
msgstr ""

#: src/free-threading.md:1
msgid "Supporting Free-Threaded CPython"
msgstr ""

#: src/free-threading.md:3
msgid ""
"CPython 3.14 declared support for the \"free-threaded\" build of CPython "
"that does not rely on the [global interpreter lock](https://docs.python."
"org/3/glossary.html#term-global-interpreter-lock) (often referred to as the "
"GIL) for thread safety. Since version 0.23, PyO3 supports building Rust "
"extensions for the free-threaded Python build and calling into free-threaded "
"Python from Rust."
msgstr ""

#: src/free-threading.md:9
msgid ""
"If you want more background on free-threaded Python in general, see the "
"[what's new](https://docs.python.org/3/whatsnew/3.13.html#whatsnew313-free-"
"threaded-cpython) entry in the 3.13 release notes (when the \"free-"
"threaded\" build was first added as an experimental mode), the [free-"
"threading HOWTO guide](https://docs.python.org/3/howto/free-threading-"
"extensions.html#freethreading-extensions-howto) in the CPython docs, the "
"[extension porting guide](https://py-free-threading.github.io/porting-"
"extensions/) in the community-maintained Python free-threading guide, and "
"[PEP 703](https://peps.python.org/pep-0703/), which provides the technical "
"background for the free-threading implementation in CPython."
msgstr ""

#: src/free-threading.md:20
msgid ""
"In the GIL-enabled build (the only choice before the \"free-threaded\" build "
"was introduced), the global interpreter lock serializes access to the Python "
"runtime. The GIL is therefore a fundamental limitation to parallel scaling "
"of multithreaded Python workflows, due to [Amdahl's law](https://en."
"wikipedia.org/wiki/Amdahl%27s_law), because any time spent executing a "
"parallel processing task on only one execution context fundamentally cannot "
"be sped up using parallelism."
msgstr ""

#: src/free-threading.md:27
msgid ""
"The free-threaded build removes this limit on multithreaded Python scaling. "
"This means it's much more straightforward to achieve parallelism using the "
"Python [`threading`](https://docs.python.org/3/library/threading.html) "
"module. If you have ever needed to use [`multiprocessing`](https://docs."
"python.org/3/library/multiprocessing.html) to achieve a parallel speedup for "
"some Python code, free-threading will likely allow the use of Python threads "
"instead for the same workflow."
msgstr ""

#: src/free-threading.md:35
msgid ""
"PyO3's support for free-threaded Python will enable authoring native Python "
"extensions that are thread-safe by construction, with much stronger safety "
"guarantees than C extensions. Our goal is to enable [\"fearless "
"concurrency\"](https://doc.rust-lang.org/book/ch16-00-concurrency.html) in "
"the native Python runtime by building on the Rust [`Send` and `Sync`]"
"(https://doc.rust-lang.org/nomicon/send-and-sync.html) traits."
msgstr ""

#: src/free-threading.md:42
msgid ""
"This document provides advice for porting Rust code using PyO3 to run under "
"free-threaded Python."
msgstr ""

#: src/free-threading.md:45
msgid "Supporting free-threaded Python with PyO3"
msgstr ""

#: src/free-threading.md:47
msgid ""
"Many simple uses of PyO3, like exposing bindings for a \"pure\" Rust "
"function with no side-effects or defining an immutable Python class, will "
"likely work \"out of the box\" on the free-threaded build. All that will be "
"necessary is to annotate Python modules declared by rust code in your "
"project to declare that they support free-threaded Python, for example by "
"declaring the module with `#[pymodule(gil_used = false)]`."
msgstr ""

#: src/free-threading.md:54
msgid ""
"More complicated `#[pyclass]` types may need to deal with thread-safety "
"directly; there is [a dedicated section of the guide](./class/thread-safety."
"md) to discuss this."
msgstr ""

#: src/free-threading.md:56
msgid ""
"At a low-level, annotating a module sets the `Py_MOD_GIL` slot on modules "
"defined by an extension to `Py_MOD_GIL_NOT_USED`, which allows the "
"interpreter to see at runtime that the author of the extension thinks the "
"extension is thread-safe. You should only do this if you know that your "
"extension is thread-safe. Because of Rust's guarantees, this is already true "
"for many extensions, however see below for more discussion about how to "
"evaluate the thread safety of existing Rust extensions and how to think "
"about the PyO3 API using a Python runtime with no GIL."
msgstr ""

#: src/free-threading.md:65
msgid ""
"If you do not explicitly mark that modules are thread-safe, the Python "
"interpreter will re-enable the GIL at runtime while importing your module "
"and print a `RuntimeWarning` with a message containing the name of the "
"module causing it to re-enable the GIL. You can force the GIL to remain "
"disabled by setting the `PYTHON_GIL=0` as an environment variable or passing "
"`-Xgil=0` when starting Python (`0` means the GIL is turned off)."
msgstr ""

#: src/free-threading.md:72
msgid ""
"If you are sure that all data structures exposed in a `PyModule` are thread-"
"safe, then pass `gil_used = false` as a parameter to the `pymodule` "
"procedural macro declaring the module or call `PyModule::gil_used` on a "
"`PyModule` instance.  For example:"
msgstr ""

#: src/free-threading.md:79
msgid "/// This module supports free-threaded Python\n"
msgstr ""

#: src/free-threading.md:83
msgid "// add members to the module that you know are thread-safe\n"
msgstr ""

#: src/free-threading.md:88
msgid "Or for a module that is set up without using the `pymodule` macro:"
msgstr ""

#: src/free-threading.md:95
msgid "\"child_module\""
msgstr ""

#: src/free-threading.md:102
msgid ""
"For now you must explicitly opt in to free-threading support by annotating "
"modules defined in your extension. In a future version of `PyO3`, we plan to "
"make `gil_used = false` the default."
msgstr ""

#: src/free-threading.md:106
msgid ""
"See the [`string-sum`](https://github.com/PyO3/pyo3/tree/main/pyo3-ffi/"
"examples/string-sum) example for how to declare free-threaded support using "
"raw FFI calls for modules using single-phase initialization and the "
"[`sequential`](https://github.com/PyO3/pyo3/tree/main/pyo3-ffi/examples/"
"sequential) example for modules using multi-phase initialization."
msgstr ""

#: src/free-threading.md:113
msgid ""
"If you would like to use conditional compilation to trigger different code "
"paths under the free-threaded build, you can use the `Py_GIL_DISABLED` "
"attribute once you have configured your crate to generate the necessary "
"build configuration data. See [the guide section](./building-and-"
"distribution/multiple-python-versions.md) for more details about supporting "
"multiple different Python versions, including the free-threaded build."
msgstr ""

#: src/free-threading.md:121
msgid "Special considerations for the free-threaded build"
msgstr ""

#: src/free-threading.md:123
msgid ""
"The free-threaded interpreter does not have a GIL. Many existing extensions "
"providing mutable data structures relied on the GIL to lock Python objects "
"and make interior mutability thread-safe."
msgstr ""

#: src/free-threading.md:127
msgid ""
"Calling into the CPython C API is only legal when an OS thread is explicitly "
"attached to the interpreter runtime. In the GIL-enabled build, this happens "
"when the GIL is acquired. In the free-threaded build there is no GIL, but "
"the same C macros that release or acquire the GIL in the GIL-enabled build "
"instead ask the interpreter to attach the thread to the Python runtime, and "
"there can be many threads simultaneously attached. See [PEP 703](https://"
"peps.python.org/pep-0703/#thread-states) for more background about how "
"threads can be attached and detached from the interpreter runtime, in a "
"manner analogous to releasing and acquiring the GIL in the GIL-enabled build."
msgstr ""

#: src/free-threading.md:137
msgid ""
"In the GIL-enabled build, PyO3 uses the [`Python<'py>`](https://pyo3.rs/main/"
"doc/pyo3/marker/struct.Python.html) type and the `'py` lifetime to signify "
"that the global interpreter lock is held. In the freethreaded build, holding "
"a `'py` lifetime means only that the thread is currently attached to the "
"Python interpreter -- other threads can be simultaneously interacting with "
"the interpreter."
msgstr ""

#: src/free-threading.md:143
msgid "Attaching to the runtime"
msgstr ""

#: src/free-threading.md:145
msgid ""
"You still need to obtain a `'py` lifetime to interact with Python objects or "
"call into the CPython C API. If you are not yet attached to the Python "
"runtime, you can register a thread using the [`Python::attach`](https://pyo3."
"rs/main/doc/pyo3/marker/struct.Python.html#method.attach) function. Threads "
"created via the Python [`threading`](https://docs.python.org/3/library/"
"threading.html) module do not need to do this, and pyo3 will handle setting "
"up the [`Python<'py>`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html) token when CPython calls into your extension."
msgstr ""

#: src/free-threading.md:152
msgid "Detaching to avoid hangs and deadlocks"
msgstr ""

#: src/free-threading.md:154
msgid ""
"The free-threaded build triggers global synchronization events in the "
"following situations:"
msgstr ""

#: src/free-threading.md:157
msgid ""
"During garbage collection in order to get a globally consistent view of "
"reference counts and references between objects"
msgstr ""

#: src/free-threading.md:159
msgid ""
"In Python 3.13, when the first background thread is started in order to mark "
"certain objects as immortal"
msgstr ""

#: src/free-threading.md:161
msgid ""
"When either `sys.settrace` or `sys.setprofile` are called in order to "
"instrument running code objects and threads"
msgstr ""

#: src/free-threading.md:163
msgid ""
"During a call to `os.fork()`, to ensure a process-wide consistent state."
msgstr ""

#: src/free-threading.md:165
msgid ""
"This is a non-exhaustive list and there may be other situations in future "
"Python versions that can trigger global synchronization events."
msgstr ""

#: src/free-threading.md:168
msgid ""
"This means that you should detach from the interpreter runtime using "
"[`Python::detach`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.detach) in exactly the same situations as you should detach from "
"the runtime in the GIL-enabled build: when doing long-running tasks that do "
"not require the CPython runtime or when doing any task that needs to re-"
"attach to the runtime (see the [guide section](parallelism.md#sharing-python-"
"objects-between-rust-threads) that covers this). In the former case, you "
"would observe a hang on threads that are waiting on the long-running task to "
"complete, and in the latter case you would see a deadlock while a thread "
"tries to attach after the runtime triggers a global synchronization event, "
"but the spawning thread prevents the synchronization event from completing."
msgstr ""

#: src/free-threading.md:180
msgid ""
"Exceptions and panics for multithreaded access of mutable `pyclass` instances"
msgstr ""

#: src/free-threading.md:182
msgid ""
"Data attached to `pyclass` instances is protected from concurrent access by "
"a `RefCell`\\-like pattern of runtime borrow checking. Like a `RefCell`, "
"PyO3 will raise exceptions (or in some cases panic) to enforce exclusive "
"access for mutable borrows. It was always possible to generate panics like "
"this in PyO3 in code that releases the GIL with [`Python::detach`](https://"
"pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) or calling a "
"python method accepting `&self` from a `&mut self` (see [the docs on "
"interior mutability](./class.md#bound-and-interior-mutability),) but now in "
"free-threaded Python there are more opportunities to trigger these panics "
"from Python because there is no GIL to lock concurrent access to mutably "
"borrowed data from Python."
msgstr ""

#: src/free-threading.md:192
msgid ""
"The most straightforward way to trigger this problem is to use the Python "
"[`threading`](https://docs.python.org/3/library/threading.html) module to "
"simultaneously call a rust function that mutably borrows a [`pyclass`]"
"(https://pyo3.rs/main/doc/pyo3/attr.pyclass.html) in multiple threads. For "
"example, consider the following implementation:"
msgstr ""

#: src/free-threading.md:219
msgid "And then if we do something like this in Python:"
msgstr ""

#: src/free-threading.md:235
msgid "We will see an exception:"
msgstr ""

#: src/free-threading.md:237
msgid ""
"```text\n"
"Traceback (most recent call last)\n"
"  File \"example.py\", line 5, in <module>\n"
"    next(i)\n"
"RuntimeError: Already borrowed\n"
"```"
msgstr ""

#: src/free-threading.md:244
msgid ""
"We may allow user-selectable semantics for mutable pyclass definitions in a "
"future version of PyO3, allowing some form of opt-in locking to emulate the "
"GIL if that is needed. For now you should explicitly add locking, possibly "
"using conditional compilation or using the critical section API, to avoid "
"creating deadlocks with the GIL."
msgstr ""

#: src/free-threading.md:250
msgid "Cannot build extensions using the limited API"
msgstr ""

#: src/free-threading.md:252
msgid ""
"The free-threaded build uses a completely new ABI and there is not yet an "
"equivalent to the limited API for the free-threaded ABI. That means if your "
"crate depends on PyO3 using the `abi3` feature or an an `abi3-pyxx` feature, "
"PyO3 will print a warning and ignore that setting when building extensions "
"using the free-threaded interpreter."
msgstr ""

#: src/free-threading.md:258
msgid ""
"This means that if your package makes use of the ABI forward compatibility "
"provided by the limited API to upload only one wheel for each release of "
"your package, you will need to update your release procedure to also upload "
"a version-specific free-threaded wheel."
msgstr ""

#: src/free-threading.md:263
msgid ""
"See [the guide section](./building-and-distribution/multiple-python-versions."
"md) for more details about supporting multiple different Python versions, "
"including the free-threaded build."
msgstr ""

#: src/free-threading.md:267
msgid "Thread-safe single initialization"
msgstr ""

#: src/free-threading.md:269
msgid ""
"To initialize data exactly once, use the [`PyOnceLock`](https://pyo3.rs/main/"
"doc/pyo3/sync/struct.PyOnceLock.html) type, which is a close equivalent to "
"[`std::sync::OnceLock`](https://doc.rust-lang.org/stable/std/sync/struct."
"OnceLock.html) that also helps avoid deadlocks by detaching from the Python "
"interpreter when threads are blocking waiting for another thread to complete "
"initialization. If already using [`OnceLock`](https://doc.rust-lang.org/"
"stable/std/sync/struct.OnceLock.html) and it is impractical to replace with "
"a [`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/struct.PyOnceLock.html), "
"there is the [`OnceLockExt`](https://pyo3.rs/main/doc/pyo3/sync/trait."
"OnceLockExt.html) extension trait which adds [`OnceLockExt::"
"get_or_init_py_attached`](https://pyo3.rs/main/doc/pyo3/sync/trait."
"OnceLockExt.html#tymethod.get_or_init_py_attached) to detach from the "
"interpreter when blocking in the same fashion as [`PyOnceLock`](https://pyo3."
"rs/main/doc/pyo3/sync/struct.PyOnceLock.html). Here is an example using "
"[`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/struct.PyOnceLock.html) to "
"single-initialize a runtime cache holding a `Py<PyDict>`:"
msgstr ""

#: src/free-threading.md:286 src/free-threading.md:320
msgid "// guaranteed to be called once and only once\n"
msgstr ""

#: src/free-threading.md:291
msgid ""
"In cases where a function must run exactly once, you can bring the "
"[`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt.html) trait "
"into scope. The [`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt."
"html) trait adds [`OnceExt::call_once_py_attached`](https://pyo3.rs/main/doc/"
"pyo3/sync/trait.OnceExt.html#tymethod.call_once_py_attached) and [`OnceExt::"
"call_once_force_py_attached`](https://pyo3.rs/main/doc/pyo3/sync/trait."
"OnceExt.html#tymethod.call_once_force_py_attached) functions to the api of "
"`std::sync::Once`, enabling use of [`Once`](https://doc.rust-lang.org/stable/"
"std/sync/struct.Once.html) in contexts where the thread is attached to the "
"Python interpreter. These functions are analogous to [`Once::call_once`]"
"(https://doc.rust-lang.org/stable/std/sync/struct.Once.html#method."
"call_once), [`Once::call_once_force`](https://doc.rust-lang.org/stable/std/"
"sync/struct.Once.html#method.call_once_force) except they accept a "
"[`Python<'py>`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html) "
"token in addition to an `FnOnce`. All of these functions detach from the "
"interpreter before blocking and re-attach before executing the function, "
"avoiding deadlocks that are possible without using the PyO3 extension "
"traits. Here the same example as above built using a [`Once`](https://doc."
"rust-lang.org/stable/std/sync/struct.Once.html) instead of a [`PyOnceLock`]"
"(https://pyo3.rs/main/doc/pyo3/sync/struct.PyOnceLock.html):"
msgstr ""

#: src/free-threading.md:327
msgid "`GILProtected` is not exposed"
msgstr ""

#: src/free-threading.md:329
msgid ""
"[`GILProtected`](https://docs.rs/pyo3/0.22/pyo3/sync/struct.GILProtected."
"html) is a (deprecated) PyO3 type that allows mutable access to static data "
"by leveraging the GIL to lock concurrent access from other threads. In free-"
"threaded Python there is no GIL, so you will need to replace this type with "
"some other form of locking. In many cases, a type from [`std::sync::atomic`]"
"(https://doc.rust-lang.org/std/sync/atomic/) or a [`std::sync::Mutex`]"
"(https://doc.rust-lang.org/std/sync/struct.Mutex.html) will be sufficient."
msgstr ""

#: src/free-threading.md:352 src/free-threading.md:371
msgid "// stand-in for something that executes arbitrary Python code\n"
msgstr ""

#: src/free-threading.md:374
msgid ""
"// as with any `Mutex` usage, lock the mutex for as little time as possible\n"
"    // in this case, we do it just while pushing into the `Vec`\n"
msgstr ""

#: src/free-threading.md:381
msgid ""
"If you are executing arbitrary Python code while holding the lock, then you "
"should import the [`MutexExt`](https://pyo3.rs/main/doc/pyo3/sync/trait."
"MutexExt.html) trait and use the `lock_py_attached` method instead of "
"`lock`. This ensures that global synchronization events started by the "
"Python runtime can proceed, avoiding possible deadlocks with the interpreter."
msgstr ""

#: src/conversions.md:3
msgid ""
"In this portion of the guide we'll talk about the mapping of Python types to "
"Rust types offered by PyO3, as well as the traits available to perform "
"conversions between them."
msgstr ""

#: src/conversions.md:5
msgid ""
"See also the conversion [tables](conversions/tables.md) and [traits]"
"(conversions/traits.md)."
msgstr ""

#: src/conversions/traits.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions/traits.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr ""

#: src/conversions/traits.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions/traits.md:16 src/conversions/traits.md:457
msgid "b\"foo\""
msgstr ""

#: src/conversions/traits.md:24
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)."
msgstr ""

#: src/conversions/traits.md:28
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](../class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions/traits.md:35
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"
msgstr ""

#: src/conversions/traits.md:37
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) can be automatically derived for many kinds of structs and enums if "
"the member types themselves implement `FromPyObject`. This even includes "
"members with a generic type `T: FromPyObject`. Derivation for empty enums, "
"enum variants and structs is not supported."
msgstr ""

#: src/conversions/traits.md:42
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for structs"
msgstr ""

#: src/conversions/traits.md:44
msgid ""
"The derivation generates code that will attempt to access the attribute  "
"`my_string` on the Python object, i.e. `obj.getattr(\"my_string\")`, and "
"call `extract()` on the attribute."
msgstr ""

#: src/conversions/traits.md:60
msgid ""
"\"class Foo:\n"
"#             def __init__(self):\n"
"#                 self.my_string = 'test'\""
msgstr ""

#: src/conversions/traits.md:63 src/conversions/traits.md:122
#: src/conversions/traits.md:353 src/conversions/traits.md:377
msgid "\"<string>\""
msgstr ""

#: src/conversions/traits.md:67 src/conversions/traits.md:126
#: src/conversions/traits.md:357 src/conversions/traits.md:381
msgid "\"Foo\""
msgstr ""

#: src/conversions/traits.md:76
msgid ""
"By setting the `#[pyo3(item)]` attribute on the field, PyO3 will attempt to "
"extract the value by calling the `get_item` method on the Python object."
msgstr ""

#: src/conversions/traits.md:91
msgid "\"my_string\""
msgstr ""

#: src/conversions/traits.md:100
msgid "The argument passed to `getattr` and `get_item` can also be configured:"
msgstr ""

#: src/conversions/traits.md:118
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.name = 'test'\n"
"#                 self['key'] = 'test2'\""
msgstr ""

#: src/conversions/traits.md:130 src/conversions/traits.md:186
#: src/conversions/traits.md:190
msgid "\"test2\""
msgstr ""

#: src/conversions/traits.md:137
msgid ""
"This tries to extract `string_attr` from the attribute `name` and "
"`string_in_mapping` from a mapping with the key `\"key\"`. The arguments for "
"`attribute` are restricted to non-empty string literals while `item` can "
"take any valid literal that implements `ToBorrowedObject`."
msgstr ""

#: src/conversions/traits.md:142
msgid ""
"You can use `#[pyo3(from_item_all)]` on a struct to extract every field with "
"`get_item` method. In this case, you can't use `#[pyo3(attribute)]` or "
"barely use `#[pyo3(item)]` on any field. However, using "
"`#[pyo3(item(\"key\"))]` to specify the key for a field is still allowed."
msgstr ""

#: src/conversions/traits.md:160
msgid "\"{'foo': 'foo', 'bar': 'bar', 'foobar': 'foobar'}\""
msgstr ""

#: src/conversions/traits.md:163
msgid "\"bar\""
msgstr ""

#: src/conversions/traits.md:164
msgid "\"foobar\""
msgstr ""

#: src/conversions/traits.md:171
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for tuple structs"
msgstr ""

#: src/conversions/traits.md:173
msgid ""
"Tuple structs are also supported but do not allow customizing the "
"extraction. The input is always assumed to be a Python tuple with the same "
"length as the Rust type, the `n`th field is extracted from the `n`th item in "
"the Python tuple."
msgstr ""

#: src/conversions/traits.md:197
msgid ""
"Tuple structs with a single field are treated as wrapper types which are "
"described in the following section. To override this behaviour and ensure "
"that the input is in fact a tuple, specify the struct as"
msgstr ""

#: src/conversions/traits.md:220
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for wrapper types"
msgstr ""

#: src/conversions/traits.md:222
msgid ""
"The `pyo3(transparent)` attribute can be used on structs with exactly one "
"field. This results in extracting directly from the input object, i.e. `obj."
"extract()`, rather than trying to access an item or attribute. This "
"behaviour is enabled per default for newtype structs and tuple-variants with "
"a single field."
msgstr ""

#: src/conversions/traits.md:255
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for enums"
msgstr ""

#: src/conversions/traits.md:257
msgid ""
"The `FromPyObject` derivation for enums generates code that tries to extract "
"the variants in the order of the fields. As soon as a variant can be "
"extracted successfully, that variant is returned. This makes it possible to "
"extract Python union types like `str | int`."
msgstr ""

#: src/conversions/traits.md:261
msgid ""
"The same customizations and restrictions described for struct derivations "
"apply to enum variants, i.e. a tuple variant assumes that the input is a "
"Python tuple, and a struct variant defaults to extracting fields as "
"attributes but can be configured in the same manner. The `transparent` "
"attribute can be applied to single-field-variants."
msgstr ""

#: src/conversions/traits.md:273
msgid "// input is a positive int\n"
msgstr ""

#: src/conversions/traits.md:274
msgid "// input is a string\n"
msgstr ""

#: src/conversions/traits.md:275
msgid "// input is a 2-tuple with positive ints\n"
msgstr ""

#: src/conversions/traits.md:276
msgid "// input is a 2-tuple with String and int\n"
msgstr ""

#: src/conversions/traits.md:278
msgid "// needs to be in front of 2d\n"
msgstr ""

#: src/conversions/traits.md:284
msgid "// only gets checked if the input did not have `z`\n"
msgstr ""

#: src/conversions/traits.md:285
msgid "\"x\""
msgstr ""

#: src/conversions/traits.md:287
msgid "\"y\""
msgstr ""

#: src/conversions/traits.md:291
msgid "// This extraction never fails\n"
msgstr ""

#: src/conversions/traits.md:305 src/conversions/traits.md:317
#: src/conversions/traits.md:329 src/conversions/traits.md:341
#: src/conversions/traits.md:365 src/conversions/traits.md:389
#: src/conversions/traits.md:402 src/conversions/traits.md:438
#: src/conversions/traits.md:451
msgid "\"Error extracting: {:?}\""
msgstr ""

#: src/conversions/traits.md:310 src/conversions/traits.md:314
msgid "\"text\""
msgstr ""

#: src/conversions/traits.md:348
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 0\n"
"#                 self.y = 1\n"
"#                 self.z = 2\""
msgstr ""

#: src/conversions/traits.md:373
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 3\n"
"#                 self.y = 4\""
msgstr ""

#: src/conversions/traits.md:395 src/conversions/traits.md:399
msgid "b\"text\""
msgstr ""

#: src/conversions/traits.md:411
msgid ""
"If none of the enum variants match, a `PyTypeError` containing the names of "
"the tested variants is returned. The names reported in the error message can "
"be customized through the `#[pyo3(annotation = \"name\")]` attribute, e.g. "
"to use conventional Python type names:"
msgstr ""

#: src/conversions/traits.md:422
msgid "\"str\""
msgstr ""

#: src/conversions/traits.md:424
msgid "\"int\""
msgstr ""

#: src/conversions/traits.md:467
msgid ""
"If the input is neither a string nor an integer, the error message will be: "
"`\"'<INPUT_TYPE>' cannot be cast as 'str | int'\"`."
msgstr ""

#: src/conversions/traits.md:470
msgid "`#[derive(FromPyObject)]` Container Attributes"
msgstr ""

#: src/conversions/traits.md:472
msgid "`pyo3(transparent)`"
msgstr ""

#: src/conversions/traits.md:473
msgid ""
"extract the field directly from the object as `obj.extract()` instead of "
"`get_item()` or `getattr()`"
msgstr ""

#: src/conversions/traits.md:475
msgid ""
"Newtype structs and tuple-variants are treated as transparent per default."
msgstr ""

#: src/conversions/traits.md:476
msgid "only supported for single-field structs and enum variants"
msgstr ""

#: src/conversions/traits.md:477
msgid "`pyo3(annotation = \"name\")`"
msgstr ""

#: src/conversions/traits.md:478
msgid ""
"changes the name of the failed variant in the generated error message in "
"case of failure."
msgstr ""

#: src/conversions/traits.md:479
msgid "e.g. `pyo3(\"int\")` reports the variant's type as `int`."
msgstr ""

#: src/conversions/traits.md:480
msgid "only supported for enum variants"
msgstr ""

#: src/conversions/traits.md:481
msgid "`pyo3(rename_all = \"...\")`"
msgstr ""

#: src/conversions/traits.md:482
msgid ""
"renames all attributes/item keys according to the specified renaming rule"
msgstr ""

#: src/conversions/traits.md:483
msgid ""
"Possible values are: \"camelCase\", \"kebab-case\", \"lowercase\", "
"\"PascalCase\", \"SCREAMING-KEBAB-CASE\", \"SCREAMING_SNAKE_CASE\", "
"\"snake_case\", \"UPPERCASE\"."
msgstr ""

#: src/conversions/traits.md:484
msgid ""
"fields with an explicit renaming via `attribute(...)`/`item(...)` are not "
"affected"
msgstr ""

#: src/conversions/traits.md:486
msgid "`#[derive(FromPyObject)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:488
msgid "`pyo3(attribute)`, `pyo3(attribute(\"name\"))`"
msgstr ""

#: src/conversions/traits.md:489
msgid ""
"retrieve the field from an attribute, possibly with a custom name specified "
"as an argument"
msgstr ""

#: src/conversions/traits.md:490
msgid "argument must be a string-literal."
msgstr ""

#: src/conversions/traits.md:491
msgid "`pyo3(item)`, `pyo3(item(\"key\"))`"
msgstr ""

#: src/conversions/traits.md:492
msgid ""
"retrieve the field from a mapping, possibly with the custom key specified as "
"an argument."
msgstr ""

#: src/conversions/traits.md:493
msgid "can be any literal that implements `ToBorrowedObject`"
msgstr ""

#: src/conversions/traits.md:494
msgid "`pyo3(from_py_with = ...)`"
msgstr ""

#: src/conversions/traits.md:495
msgid ""
"apply a custom function to convert the field from Python the desired Rust "
"type."
msgstr ""

#: src/conversions/traits.md:496
msgid "the argument must be the path to the function."
msgstr ""

#: src/conversions/traits.md:497
msgid ""
"the function signature must be `fn(&Bound<PyAny>) -> PyResult<T>` where `T` "
"is the Rust type of the argument."
msgstr ""

#: src/conversions/traits.md:498
msgid "`pyo3(default)`, `pyo3(default = ...)`"
msgstr ""

#: src/conversions/traits.md:499
msgid "if the argument is set, uses the given default value."
msgstr ""

#: src/conversions/traits.md:500
msgid ""
"in this case, the argument must be a Rust expression returning a value of "
"the desired Rust type."
msgstr ""

#: src/conversions/traits.md:501
msgid ""
"if the argument is not set, [`Default::default`](https://doc.rust-lang.org/"
"std/default/trait.Default.html#tymethod.default) is used."
msgstr ""

#: src/conversions/traits.md:502
msgid ""
"note that the default value is only used if the field is not set. If the "
"field is set and the conversion function from Python to Rust fails, an "
"exception is raised and the default value is not used."
msgstr ""

#: src/conversions/traits.md:504
msgid "this attribute is only supported on named fields."
msgstr ""

#: src/conversions/traits.md:506
msgid ""
"For example, the code below applies the given conversion function on the "
"`\"value\"` dict item to compute its length or fall back to the type default "
"value (0):"
msgstr ""

#: src/conversions/traits.md:522
msgid "// Filled case\n"
msgstr ""

#: src/conversions/traits.md:524
msgid "\"value\""
msgstr ""

#: src/conversions/traits.md:525 src/conversions/traits.md:532
msgid "\"other\""
msgstr ""

#: src/conversions/traits.md:530
msgid "// Empty case\n"
msgstr ""

#: src/conversions/traits.md:541
msgid ""
"‚ö† Phase-Out of `FromPyObject` blanket implementation for cloneable PyClasses "
"‚ö†"
msgstr ""

#: src/conversions/traits.md:543
msgid ""
"Historically PyO3 has provided a blanket implementation for `#[pyclass]` "
"types that also implement `Clone`, to allow extraction of such types by "
"value. Over time this has turned out problematic for a few reasons, the "
"major one being the prevention of custom conversions by downstream crates if "
"their type is `Clone`. Over the next few releases the blanket implementation "
"is gradually phased out, and eventually replaced by an opt-in option. As a "
"first step of this migration a new `skip_from_py_object` option for "
"`#[pyclass]` was introduced, to opt-out of the blanket implementation and "
"allow downstream users to provide their own implementation:"
msgstr ""

#: src/conversions/traits.md:549
msgid "// opt-out of the PyO3 FromPyObject blanket\n"
msgstr ""

#: src/conversions/traits.md:557
msgid "// first try extraction via class object\n"
msgstr ""

#: src/conversions/traits.md:560
msgid "// otherwise try integer directly\n"
msgstr ""

#: src/conversions/traits.md:566
msgid ""
"As a second step the `from_py_object` option was introduced. This option "
"also opts-out of the blanket implementation and instead generates a custom "
"`FromPyObject` implementation for the pyclass which is functionally "
"equivalent to the blanket."
msgstr ""

#: src/conversions/traits.md:568
msgid "`IntoPyObject`"
msgstr ""

#: src/conversions/traits.md:570
msgid ""
"The [`IntoPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"IntoPyObject.html) trait defines the to-python conversion for a Rust type. "
"All types in PyO3 implement this trait, as does a `#[pyclass]` which doesn't "
"use `extends`."
msgstr ""

#: src/conversions/traits.md:573
msgid ""
"This trait defines a single method, `into_pyobject()`, which returns a "
"[`Result`](https://doc.rust-lang.org/stable/std/result/enum.Result.html) "
"with `Ok` and `Err` types depending on the input value. For convenience, "
"there is a companion [`IntoPyObjectExt`](https://pyo3.rs/main/doc/pyo3/"
"conversion/trait.IntoPyObjectExt.html) trait which adds methods such as "
"`into_py_any()` which converts the `Ok` and `Err` types to commonly used "
"types (in the case of `into_py_any()`, `Py<PyAny>` and `PyErr` respectively)."
msgstr ""

#: src/conversions/traits.md:575
msgid ""
"Occasionally you may choose to implement this for custom types which are "
"mapped to Python types _without_ having a unique python type."
msgstr ""

#: src/conversions/traits.md:578
msgid "derive macro"
msgstr ""

#: src/conversions/traits.md:580
msgid ""
"`IntoPyObject` can be implemented using our derive macro. Both `struct`s and "
"`enum`s are supported."
msgstr ""

#: src/conversions/traits.md:582
msgid ""
"`struct`s will turn into a `PyDict` using the field names as keys, tuple "
"`struct`s will turn convert into `PyTuple` with the fields in declaration "
"order."
msgstr ""

#: src/conversions/traits.md:590
msgid "// structs convert into `PyDict` with field names as keys\n"
msgstr ""

#: src/conversions/traits.md:597
msgid ""
"// tuple structs convert into `PyTuple`\n"
"// lifetimes and generics are supported, the impl will be bounded by\n"
"// `K: IntoPyObject, V: IntoPyObject`\n"
msgstr ""

#: src/conversions/traits.md:605
msgid ""
"For structs with a single field (newtype pattern) the `#[pyo3(transparent)]` "
"option can be used to forward the implementation to the inner type."
msgstr ""

#: src/conversions/traits.md:611
msgid "// newtype tuple structs are implicitly `transparent`\n"
msgstr ""

#: src/conversions/traits.md:619
msgid "// `'py` lifetime will be used as the Python lifetime\n"
msgstr ""

#: src/conversions/traits.md:623
msgid ""
"For `enum`s each variant is converted according to the rules for `struct`s "
"above."
msgstr ""

#: src/conversions/traits.md:632
msgid "// enums are supported and convert using the same\n"
msgstr ""

#: src/conversions/traits.md:633
msgid "// rules on the variants as the structs above\n"
msgstr ""

#: src/conversions/traits.md:641
msgid ""
"Additionally `IntoPyObject` can be derived for a reference to a struct or "
"enum using the `IntoPyObjectRef` derive macro. All the same rules from above "
"apply as well."
msgstr ""

#: src/conversions/traits.md:644
msgid "`#[derive(IntoPyObject)]`/`#[derive(IntoPyObjectRef)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:646
msgid "`pyo3(into_py_with = ...)`"
msgstr ""

#: src/conversions/traits.md:647
msgid "apply a custom function to convert the field from Rust into Python."
msgstr ""

#: src/conversions/traits.md:648
msgid "the argument must be the function identifier"
msgstr ""

#: src/conversions/traits.md:649
msgid ""
"the function signature must be `fn(Cow<'_, T>, Python<'py>) -> "
"PyResult<Bound<'py, PyAny>>` where `T` is the Rust type of the argument."
msgstr ""

#: src/conversions/traits.md:650
msgid "`#[derive(IntoPyObject)]` will invoke the function with `Cow::Owned`"
msgstr ""

#: src/conversions/traits.md:651
msgid ""
"`#[derive(IntoPyObjectRef)]` will invoke the function with `Cow::Borrowed`"
msgstr ""

#: src/conversions/traits.md:666
msgid "/// Convert `NotIntoPy` into Python\n"
msgstr ""

#: src/conversions/traits.md:672
msgid "manual implementation"
msgstr ""

#: src/conversions/traits.md:674
msgid ""
"If the derive macro is not suitable for your use case, `IntoPyObject` can be "
"implemented manually as demonstrated below."
msgstr ""

#: src/conversions/traits.md:685
msgid "// the conversion error type, has to be convertible to `PyErr`\n"
msgstr ""

#: src/conversions/traits.md:691
msgid "// equivalent to former `ToPyObject` implementations\n"
msgstr ""

#: src/conversions/traits.md:704
msgid "`BoundObject` for conversions that may be `Bound` or `Borrowed`"
msgstr ""

#: src/conversions/traits.md:706
msgid ""
"`IntoPyObject::into_py_object` returns either `Bound` or `Borrowed` "
"depending on the implementation for a concrete type. For example, the "
"`IntoPyObject` implementation for `u32` produces a `Bound<'py, PyInt>` and "
"the `bool` implementation produces a `Borrowed<'py, 'py, PyBool>`:"
msgstr ""

#: src/conversions/traits.md:731
msgid ""
"In this example if we wanted to combine `ints_as_pyints` and "
"`bools_as_pybool` into a single `Vec<Py<PyAny>>` to return from the `Python::"
"attach` closure, we would have to manually convert the concrete types for "
"the smart pointers and the python types."
msgstr ""

#: src/conversions/traits.md:733
msgid ""
"Instead, we can write a function that generically converts vectors of either "
"integers or bools into a vector of `Py<PyAny>` using the [`BoundObject`]"
"(https://pyo3.rs/main/doc/pyo3/instance/trait.BoundObject.html) trait:"
msgstr ""

#: src/conversions/traits.md:750
msgid ""
"// Note: the below is equivalent to `x.into_py_any()`\n"
"                // from the `IntoPyObjectExt` trait\n"
msgstr ""

#: src/conversions/traits.md:771
msgid ""
"In the example above we used `BoundObject::into_any` and `BoundObject::"
"unbind` to manipulate the python types and smart pointers into the result "
"type we wanted to produce from the function."
msgstr ""

#: src/conversions/tables.md:3
msgid ""
"When writing functions callable from Python (such as a `#[pyfunction]` or in "
"a `#[pymethods]` block), the trait `FromPyObject` is required for function "
"arguments, and `IntoPyObject` is required for function return values."
msgstr ""

#: src/conversions/tables.md:5
msgid ""
"Consult the tables in the following section to find the Rust types provided "
"by PyO3 which implement these traits."
msgstr ""

#: src/conversions/tables.md:7
msgid "Argument Types"
msgstr ""

#: src/conversions/tables.md:9
msgid ""
"When accepting a function argument, it is possible to either use Rust "
"library types or PyO3's Python-native types. (See the next section for "
"discussion on when to use each.)"
msgstr ""

#: src/conversions/tables.md:11
msgid ""
"The table below contains the Python type and the corresponding function "
"argument types that will accept them:"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust (Python-native)"
msgstr ""

#: src/conversions/tables.md:15
msgid "`object`"
msgstr ""

#: src/conversions/tables.md:15 src/conversions/tables.md:22
#: src/conversions/tables.md:29 src/conversions/tables.md:30
#: src/conversions/tables.md:31 src/conversions/tables.md:32
#: src/conversions/tables.md:38 src/conversions/tables.md:39
#: src/conversions/tables.md:40 src/conversions/tables.md:41
#: src/conversions/tables.md:44 src/conversions/tables.md:47
#: src/conversions/tables.md:48
msgid "\\-"
msgstr ""

#: src/conversions/tables.md:15
msgid "`PyAny`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:87
#: src/conversions/tables.md:88
msgid "`str`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`String`, `Cow<str>`, `&str`, `char`, `OsString`, `PathBuf`, `Path`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:42
#: src/conversions/tables.md:43
msgid "`PyString`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`Vec<u8>`, `&[u8]`, `Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`PyBytes`"
msgstr ""

#: src/conversions/tables.md:18 src/conversions/tables.md:89
msgid "`bool`"
msgstr ""

#: src/conversions/tables.md:18
msgid "`PyBool`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:90
msgid "`int`"
msgstr ""

#: src/conversions/tables.md:19
msgid ""
"`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, "
"`isize`, `usize`, `num_bigint::BigInt`[^1], `num_bigint::BigUint`[^1]"
msgstr ""

#: src/conversions/tables.md:19
msgid "`PyInt`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:91
msgid "`float`"
msgstr ""

#: src/conversions/tables.md:20
msgid ""
"`f32`, `f64`, `ordered_float::NotNan`[^10], `ordered_float::"
"OrderedFloat`[^10]"
msgstr ""

#: src/conversions/tables.md:20
msgid "`PyFloat`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`complex`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`num_complex::Complex`[^2]"
msgstr ""

#: src/conversions/tables.md:21
msgid "`PyComplex`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`fractions.Fraction`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`num_rational::Ratio`[^8]"
msgstr ""

#: src/conversions/tables.md:23
msgid "`list[T]`"
msgstr ""

#: src/conversions/tables.md:23 src/conversions/tables.md:45
#: src/conversions/tables.md:94
msgid "`Vec<T>`"
msgstr ""

#: src/conversions/tables.md:23
msgid "`PyList`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:24 src/conversions/tables.md:46
msgid ""
"`HashMap<K, V>`, `BTreeMap<K, V>`, `hashbrown::HashMap<K, V>`[^3], "
"`indexmap::IndexMap<K, V>`[^4]"
msgstr ""

#: src/conversions/tables.md:24
msgid "`PyDict`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`(T, U)`, `Vec<T>`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`PyTuple`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`set[T]`"
msgstr ""

#: src/conversions/tables.md:26 src/conversions/tables.md:27
msgid "`HashSet<T>`, `BTreeSet<T>`, `hashbrown::HashSet<T>`[^3]"
msgstr ""

#: src/conversions/tables.md:26
msgid "`PySet`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`frozenset[T]`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`PyFrozenSet`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`bytearray`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`Vec<u8>`, `Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`PyByteArray`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`slice`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`PySlice`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`type`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`PyType`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`module`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`PyModule`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`collections.abc.Buffer`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`PyBuffer<T>`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`datetime.datetime`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`SystemTime`, `chrono::DateTime<Tz>`[^5], `chrono::NaiveDateTime`[^5]"
msgstr ""

#: src/conversions/tables.md:33
msgid "`PyDateTime`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`datetime.date`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`chrono::NaiveDate`[^5]"
msgstr ""

#: src/conversions/tables.md:34
msgid "`PyDate`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`datetime.time`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`chrono::NaiveTime`[^5]"
msgstr ""

#: src/conversions/tables.md:35
msgid "`PyTime`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`datetime.tzinfo`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`chrono::FixedOffset`[^5], `chrono::Utc`[^5], `chrono_tz::TimeZone`[^6]"
msgstr ""

#: src/conversions/tables.md:36
msgid "`PyTzInfo`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`datetime.timedelta`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`Duration`, `chrono::Duration`[^5]"
msgstr ""

#: src/conversions/tables.md:37
msgid "`PyDelta`"
msgstr ""

#: src/conversions/tables.md:38 src/conversions/tables.md:39
msgid "`decimal.Decimal`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`rust_decimal::Decimal`[^7]"
msgstr ""

#: src/conversions/tables.md:39
msgid "`bigdecimal::BigDecimal`[^9]"
msgstr ""

#: src/conversions/tables.md:40
msgid "`ipaddress.IPv4Address`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`std::net::IpAddr`, `std::net::Ipv4Addr`"
msgstr ""

#: src/conversions/tables.md:41
msgid "`ipaddress.IPv6Address`"
msgstr ""

#: src/conversions/tables.md:41
msgid "`std::net::IpAddr`, `std::net::Ipv6Addr`"
msgstr ""

#: src/conversions/tables.md:42
msgid "`os.PathLike`"
msgstr ""

#: src/conversions/tables.md:42 src/conversions/tables.md:43
msgid "`PathBuf`, `Path`"
msgstr ""

#: src/conversions/tables.md:43
msgid "`pathlib.Path`"
msgstr ""

#: src/conversions/tables.md:44
msgid "`typing.Optional[T]`"
msgstr ""

#: src/conversions/tables.md:44 src/conversions/tables.md:92
msgid "`Option<T>`"
msgstr ""

#: src/conversions/tables.md:45
msgid "`typing.Sequence[T]`"
msgstr ""

#: src/conversions/tables.md:45
msgid "`PySequence`"
msgstr ""

#: src/conversions/tables.md:46
msgid "`typing.Mapping[K, V]`"
msgstr ""

#: src/conversions/tables.md:46
msgid "`&PyMapping`"
msgstr ""

#: src/conversions/tables.md:47
msgid "`typing.Iterator[Any]`"
msgstr ""

#: src/conversions/tables.md:47
msgid "`PyIterator`"
msgstr ""

#: src/conversions/tables.md:48
msgid "`typing.Union[...]`"
msgstr ""

#: src/conversions/tables.md:48
msgid ""
"See [`#[derive(FromPyObject)]`](traits.md#deriving-frompyobject-for-enums)"
msgstr ""

#: src/conversions/tables.md:50
msgid "It is also worth remembering the following special types:"
msgstr ""

#: src/conversions/tables.md:52
msgid "What"
msgstr ""

#: src/conversions/tables.md:52
msgid "Description"
msgstr ""

#: src/conversions/tables.md:54
msgid "`Python<'py>`"
msgstr ""

#: src/conversions/tables.md:54
msgid "A token used to prove attachment to the Python interpreter."
msgstr ""

#: src/conversions/tables.md:55
msgid ""
"A Python object with a lifetime which binds it to the attachment to the "
"Python interpreter. This provides access to most of PyO3's APIs."
msgstr ""

#: src/conversions/tables.md:56
msgid ""
"A Python object not connected to any lifetime of attachment to the Python "
"interpreter. This can be sent to other threads."
msgstr ""

#: src/conversions/tables.md:57
msgid "`PyRef<T>`"
msgstr ""

#: src/conversions/tables.md:57
msgid "A `#[pyclass]` borrowed immutably."
msgstr ""

#: src/conversions/tables.md:58
msgid "`PyRefMut<T>`"
msgstr ""

#: src/conversions/tables.md:58
msgid "A `#[pyclass]` borrowed mutably."
msgstr ""

#: src/conversions/tables.md:60
msgid ""
"For more detail on accepting `#[pyclass]` values as function arguments, see "
"[the section of this guide on Python Classes](../class.md)."
msgstr ""

#: src/conversions/tables.md:62
msgid "Using Rust library types vs Python-native types"
msgstr ""

#: src/conversions/tables.md:64
msgid ""
"Using Rust library types as function arguments will incur a conversion cost "
"compared to using the Python-native types. Using the Python-native types is "
"almost zero-cost (they just require a type check similar to the Python "
"builtin function `isinstance()`)."
msgstr ""

#: src/conversions/tables.md:66
msgid ""
"However, once that conversion cost has been paid, the Rust standard library "
"types offer a number of benefits:"
msgstr ""

#: src/conversions/tables.md:68
msgid ""
"You can write functionality in native-speed Rust code (free of Python's "
"runtime costs)."
msgstr ""

#: src/conversions/tables.md:69
msgid "You get better interoperability with the rest of the Rust ecosystem."
msgstr ""

#: src/conversions/tables.md:70
msgid ""
"You can use `Python::detach` to detach from the interpreter and let other "
"Python threads make progress while your Rust code is executing."
msgstr ""

#: src/conversions/tables.md:71
msgid ""
"You also benefit from stricter type checking. For example you can specify "
"`Vec<i32>`, which will only accept a Python `list` containing integers. The "
"Python-native equivalent, `&PyList`, would accept a Python `list` containing "
"Python objects of any type."
msgstr ""

#: src/conversions/tables.md:73
msgid ""
"For most PyO3 usage the conversion cost is worth paying to get these "
"benefits. As always, if you're not sure it's worth it in your case, "
"benchmark it!"
msgstr ""

#: src/conversions/tables.md:75
msgid "Returning Rust values to Python"
msgstr ""

#: src/conversions/tables.md:77
msgid ""
"When returning values from functions callable from Python, [PyO3's smart "
"pointers](../types.md#pyo3s-smart-pointers) (`Py<T>`, `Bound<'py, T>`, and "
"`Borrowed<'a, 'py, T>`) can be used with zero cost."
msgstr ""

#: src/conversions/tables.md:79
msgid ""
"Because `Bound<'py, T>` and `Borrowed<'a, 'py, T>` have lifetime parameters, "
"the Rust compiler may ask for lifetime annotations to be added to your "
"function. See the [section of the guide dedicated to this](../types."
"md#function-argument-lifetimes)."
msgstr ""

#: src/conversions/tables.md:81
msgid ""
"If your function is fallible, it should return `PyResult<T>` or `Result<T, "
"E>` where `E` implements `From<E> for PyErr`. This will raise a `Python` "
"exception if the `Err` variant is returned."
msgstr ""

#: src/conversions/tables.md:83
msgid ""
"Finally, the following Rust types are also able to convert to Python as "
"return values:"
msgstr ""

#: src/conversions/tables.md:85
msgid "Rust type"
msgstr ""

#: src/conversions/tables.md:85
msgid "Resulting Python Type"
msgstr ""

#: src/conversions/tables.md:87
msgid "`String`"
msgstr ""

#: src/conversions/tables.md:88
msgid "`&str`"
msgstr ""

#: src/conversions/tables.md:90
msgid "Any integer type (`i32`, `u32`, `usize`, etc)"
msgstr ""

#: src/conversions/tables.md:91
msgid "`f32`, `f64`"
msgstr ""

#: src/conversions/tables.md:92
msgid "`Optional[T]`"
msgstr ""

#: src/conversions/tables.md:93
msgid "`(T, U)`"
msgstr ""

#: src/conversions/tables.md:93
msgid "`Tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:94
msgid "`List[T]`"
msgstr ""

#: src/conversions/tables.md:95
msgid "`Cow<[u8]>`"
msgstr ""

#: src/conversions/tables.md:96
msgid "`HashMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:96 src/conversions/tables.md:97
msgid "`Dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:97
msgid "`BTreeMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:98
msgid "`HashSet<T>`"
msgstr ""

#: src/conversions/tables.md:98 src/conversions/tables.md:99
msgid "`Set[T]`"
msgstr ""

#: src/conversions/tables.md:99
msgid "`BTreeSet<T>`"
msgstr ""

#: src/conversions/tables.md:100 src/conversions/tables.md:101
#: src/conversions/tables.md:102 src/conversions/tables.md:103
msgid "`T`"
msgstr ""

#: src/conversions/tables.md:101
msgid "`Bound<T>`"
msgstr ""

#: src/conversions/tables.md:102
msgid "`PyRef<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:103
msgid "`PyRefMut<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:105
msgid "Requires the `num-bigint` optional feature."
msgstr ""

#: src/conversions/tables.md:107
msgid "Requires the `num-complex` optional feature."
msgstr ""

#: src/conversions/tables.md:109
msgid "Requires the `hashbrown` optional feature."
msgstr ""

#: src/conversions/tables.md:111
msgid "Requires the `indexmap` optional feature."
msgstr ""

#: src/conversions/tables.md:113
msgid "Requires the `chrono` (and maybe `chrono-local`) optional feature(s)."
msgstr ""

#: src/conversions/tables.md:115
msgid "Requires the `chrono-tz` optional feature."
msgstr ""

#: src/conversions/tables.md:117
msgid "Requires the `rust_decimal` optional feature."
msgstr ""

#: src/conversions/tables.md:119
msgid "Requires the `num-rational` optional feature."
msgstr ""

#: src/conversions/tables.md:121
msgid "Requires the `bigdecimal` optional feature."
msgstr ""

#: src/conversions/tables.md:123
msgid "Requires the `ordered-float` optional feature."
msgstr ""

#: src/type-stub.md:1
msgid "Type stub generation (`*.pyi` files) and introspection"
msgstr ""

#: src/type-stub.md:3
msgid ""
"_This feature is still in active development. See [the related issue]"
"(https://github.com/PyO3/pyo3/issues/5137)._"
msgstr ""

#: src/type-stub.md:5
msgid ""
"_For documentation on type stubs and how to use them with stable PyO3, refer "
"to [this page](python-typing-hints.md)_"
msgstr ""

#: src/type-stub.md:7
msgid ""
"PyO3 has a work in progress support to generate [type stub files](https://"
"typing.python.org/en/latest/spec/distributing.html#stub-files)."
msgstr ""

#: src/type-stub.md:9
msgid "It works using:"
msgstr ""

#: src/type-stub.md:11
msgid ""
"PyO3 macros (`#[pyclass]`) that generate constant JSON strings that are then "
"included in the built binaries by rustc if the `experimental-inspect` "
"feature is enabled."
msgstr ""

#: src/type-stub.md:12
msgid ""
"The `pyo3-introspection` crate that can parse the generated binaries, "
"extract the JSON strings and build stub files from it."
msgstr ""

#: src/type-stub.md:13
msgid ""
"\\[Not done yet\\] Build tools like `maturin` exposing `pyo3-introspection` "
"features in their CLI API."
msgstr ""

#: src/type-stub.md:15
msgid "For example, the following Rust code"
msgstr ""

#: src/type-stub.md:23 src/type-stub.md:57
msgid "\"FOO\""
msgstr ""

#: src/type-stub.md:45
msgid "\"list[int]\""
msgstr ""

#: src/type-stub.md:52
msgid "will generate the following stub file:"
msgstr ""

#: src/type-stub.md:71
msgid ""
"The only piece of added syntax is that the `#[pyo3(signature = ...)]` "
"attribute can now contain type annotations like `#[pyo3(signature = (arg: "
"\"list[int]\") -> \"list[int]\")]` (note the `\"\"` around type "
"annotations). This is useful when PyO3 is not able to derive proper type "
"annotations by itself."
msgstr ""

#: src/type-stub.md:76
msgid "Constraints and limitations"
msgstr ""

#: src/type-stub.md:78
msgid ""
"The `experimental-inspect` feature is required to generate the introspection "
"fragments."
msgstr ""

#: src/type-stub.md:79
msgid ""
"Lots of features are not implemented yet. See [the related issue](https://"
"github.com/PyO3/pyo3/issues/5137) for a list of them."
msgstr ""

#: src/type-stub.md:80
msgid ""
"Introspection only works with Python modules declared with an inline Rust "
"module. Modules declared using a function are not supported."
msgstr ""

#: src/type-stub.md:81
msgid ""
"`FromPyObject::INPUT_TYPE` and `IntoPyObject::OUTPUT_TYPE` must be "
"implemented for PyO3 to get the proper input/output type annotations to use."
msgstr ""

#: src/type-stub.md:82
msgid ""
"Because `FromPyObject::INPUT_TYPE` and `IntoPyObject::OUTPUT_TYPE` are "
"`const` it is not possible to build yet smart generic annotations for "
"containers like `concat!(\"list[\", T::OUTPUT_TYPE, \"]\")`. See [this "
"tracking issue](https://github.com/rust-lang/rust/issues/76560)."
msgstr ""

#: src/type-stub.md:83
msgid ""
"PyO3 is not able to introspect the content of `#[pymodule]` and "
"`#[pymodule_init]` functions. If they are present, the module is tagged as "
"incomplete using a fake `def __getattr__(name: str) -> Incomplete: ...` "
"function [following best practices](https://typing.python.org/en/latest/"
"guides/writing_stubs.html#incomplete-stubs)."
msgstr ""

#: src/ecosystem.md:1
msgid "The PyO3 ecosystem"
msgstr ""

#: src/ecosystem.md:3
msgid ""
"This portion of the guide is dedicated to crates which are external to the "
"main PyO3 project and provide additional functionality you might find useful."
msgstr ""

#: src/ecosystem.md:5
msgid ""
"Because these projects evolve independently of the PyO3 repository the "
"content of these articles may fall out of date over time; please file issues "
"on the PyO3 GitHub to alert maintainers when this is the case."
msgstr ""

#: src/ecosystem/logging.md:3
msgid ""
"It is desirable if both the Python and Rust parts of the application end up "
"logging using the same configuration into the same place."
msgstr ""

#: src/ecosystem/logging.md:6
msgid ""
"This section of the guide briefly discusses how to connect the two "
"languages' logging ecosystems together. The recommended way for Python "
"extension modules is to configure Rust's logger to send log messages to "
"Python using the `pyo3-log` crate. For users who want to do the opposite and "
"send Python log messages to Rust, see the note at the end of this guide."
msgstr ""

#: src/ecosystem/logging.md:12
msgid "Using `pyo3-log` to send Rust log messages to Python"
msgstr ""

#: src/ecosystem/logging.md:14
msgid ""
"The [pyo3-log](https://crates.io/crates/pyo3-log) crate allows sending the "
"messages from the Rust side to Python's [logging](https://docs.python.org/3/"
"library/logging.html) system. This is mostly suitable for writing native "
"extensions for Python programs."
msgstr ""

#: src/ecosystem/logging.md:18
msgid ""
"Use [`pyo3_log::init`](https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html) to "
"install the logger in its default configuration. It's also possible to tweak "
"its configuration (mostly to tune its performance)."
msgstr ""

#: src/ecosystem/logging.md:29
msgid ""
"// This will use the logger installed in `my_module` to send the `info`\n"
"        // message to the Python logging facilities.\n"
msgstr ""

#: src/ecosystem/logging.md:31
msgid "\"Something!\""
msgstr ""

#: src/ecosystem/logging.md:36
msgid "// A good place to install the Rust -> Python logger.\n"
msgstr ""

#: src/ecosystem/logging.md:42
msgid ""
"Then it is up to the Python side to actually output the messages somewhere."
msgstr ""

#: src/ecosystem/logging.md:48
msgid ""
"'%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'"
msgstr ""

#: src/ecosystem/logging.md:54
msgid ""
"It is important to initialize the Python loggers first, before calling any "
"Rust functions that may log. This limitation can be worked around if it is "
"not possible to satisfy, read the documentation about [caching](https://docs."
"rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching)."
msgstr ""

#: src/ecosystem/logging.md:58
msgid "The Python to Rust direction"
msgstr ""

#: src/ecosystem/logging.md:60
msgid ""
"To have python logs be handled by Rust, one need only register a rust "
"function to handle logs emitted from the core python logging module."
msgstr ""

#: src/ecosystem/logging.md:62
msgid ""
"This has been implemented within the [pyo3-pylogger](https://crates.io/"
"crates/pyo3-pylogger) crate."
msgstr ""

#: src/ecosystem/logging.md:69
msgid ""
"// register the host handler with python logger, providing a logger target\n"
"    // set the name here to something appropriate for your application\n"
msgstr ""

#: src/ecosystem/logging.md:71
msgid "\"example_application_py_logger\""
msgstr ""

#: src/ecosystem/logging.md:73
msgid "// initialize up a logger\n"
msgstr ""

#: src/ecosystem/logging.md:74
msgid "\"trace\""
msgstr ""

#: src/ecosystem/logging.md:76
msgid "// Log some messages from Rust.\n"
msgstr ""

#: src/ecosystem/logging.md:77
msgid "\"Just some normal information!\""
msgstr ""

#: src/ecosystem/logging.md:78
msgid "\"Something spooky happened!\""
msgstr ""

#: src/ecosystem/logging.md:80
msgid "// Log some messages from Python\n"
msgstr ""

#: src/ecosystem/logging.md:83
msgid ""
"\"\n"
"import logging\n"
"logging.error('Something bad happened')\n"
"\""
msgstr ""

#: src/ecosystem/tracing.md:3
msgid ""
"Python projects that write extension modules for performance reasons may "
"want to tap into [Rust's `tracing` ecosystem](https://crates.io/crates/"
"tracing) to gain insight into the performance of their extension module."
msgstr ""

#: src/ecosystem/tracing.md:7
msgid ""
"This section of the guide describes a few crates that provide ways to do "
"that. They build on [`tracing_subscriber`](https://docs.rs/tracing-"
"subscriber/*/tracing_subscriber/) and require code changes in both Python "
"and Rust to integrate. Note that each extension module must configure its "
"own `tracing` integration; one extension module will not see `tracing` data "
"from a different module."
msgstr ""

#: src/ecosystem/tracing.md:13
msgid ""
"`pyo3-tracing-subscriber` ([documentation](https://docs.rs/pyo3-tracing-"
"subscriber))"
msgstr ""

#: src/ecosystem/tracing.md:15
msgid ""
"[`pyo3-tracing-subscriber`](https://crates.io/crates/pyo3-tracing-"
"subscriber) provides a way for Python projects to configure "
"`tracing_subscriber`. It exposes a few `tracing_subscriber` layers:"
msgstr ""

#: src/ecosystem/tracing.md:19
msgid ""
"`tracing_subscriber::fmt` for writing human-readable output to file or stdout"
msgstr ""

#: src/ecosystem/tracing.md:20
msgid "`opentelemetry-stdout` for writing OTLP output to file or stdout"
msgstr ""

#: src/ecosystem/tracing.md:21
msgid "`opentelemetry-otlp` for writing OTLP output to an OTLP endpoint"
msgstr ""

#: src/ecosystem/tracing.md:23
msgid ""
"The extension module must call [`pyo3_tracing_subscriber::add_submodule`]"
"(https://docs.rs/pyo3-tracing-subscriber/*/pyo3_tracing_subscriber/fn."
"add_submodule.html) to export the Python classes needed to configure and "
"initialize `tracing`."
msgstr ""

#: src/ecosystem/tracing.md:26
msgid ""
"On the Python side, use the `Tracing` context manager to initialize tracing "
"and run Rust code inside the context manager's block. `Tracing` takes a "
"`GlobalTracingConfig` instance describing the layers to be used."
msgstr ""

#: src/ecosystem/tracing.md:30
msgid ""
"See [the README on crates.io](https://crates.io/crates/pyo3-tracing-"
"subscriber) for example code."
msgstr ""

#: src/ecosystem/tracing.md:33
msgid ""
"`pyo3-python-tracing-subscriber` ([documentation](https://docs.rs/pyo3-"
"python-tracing-subscriber))"
msgstr ""

#: src/ecosystem/tracing.md:35
msgid ""
"The similarly-named [`pyo3-python-tracing-subscriber`](https://crates.io/"
"crates/pyo3-python-tracing-subscriber) implements a shim in Rust that "
"forwards `tracing` data to a `Layer` implementation defined in and passed in "
"from Python."
msgstr ""

#: src/ecosystem/tracing.md:39
msgid ""
"There are many ways an extension module could integrate `pyo3-python-tracing-"
"subscriber` but a simple one may look something like this:"
msgstr ""

#: src/ecosystem/tracing.md:46
msgid "// ...\n"
msgstr ""

#: src/ecosystem/tracing.md:57
msgid ""
"The extension module must provide some way for Python to pass in one or more "
"Python objects that implement [the `Layer` interface](https://docs.rs/"
"tracing-subscriber/*/tracing_subscriber/layer/trait.Layer.html). Then it "
"should construct [`pyo3_python_tracing_subscriber::"
"PythonCallbackLayerBridge`](https://docs.rs/pyo3-python-tracing-subscriber/*/"
"pyo3_python_tracing_subscriber/struct.PythonCallbackLayerBridge.html) "
"instances with each of those Python objects and initialize "
"`tracing_subscriber` as shown above."
msgstr ""

#: src/ecosystem/tracing.md:63
msgid ""
"The Python objects implement a modified version of the `Layer` interface:"
msgstr ""

#: src/ecosystem/tracing.md:65
msgid ""
"`on_new_span()` may return some state that will stored inside the Rust span"
msgstr ""

#: src/ecosystem/tracing.md:66
msgid ""
"other callbacks will be given that state as an additional positional argument"
msgstr ""

#: src/ecosystem/tracing.md:68
msgid "A dummy `Layer` implementation may look like this:"
msgstr ""

#: src/ecosystem/tracing.md:77
msgid "# `on_new_span` can return some state\n"
msgstr ""

#: src/ecosystem/tracing.md:79
msgid "\"[on_new_span]: "
msgstr ""

#: src/ecosystem/tracing.md:79 src/ecosystem/tracing.md:84
#: src/ecosystem/tracing.md:87 src/ecosystem/tracing.md:90
msgid " | "
msgstr ""

#: src/ecosystem/tracing.md:82
msgid ""
"# The state from `on_new_span` is passed back into other trait methods\n"
msgstr ""

#: src/ecosystem/tracing.md:84
msgid "\"[on_event]: "
msgstr ""

#: src/ecosystem/tracing.md:87
msgid "\"[on_close]: "
msgstr ""

#: src/ecosystem/tracing.md:90
msgid "\"[on_record]: "
msgstr ""

#: src/ecosystem/tracing.md:95
msgid "\"10th fibonacci number: \""
msgstr ""

#: src/ecosystem/tracing.md:98
msgid ""
"`pyo3-python-tracing-subscriber` has [working examples](https://github.com/"
"getsentry/pyo3-python-tracing-subscriber/tree/main/demo) showing both the "
"Rust side and the Python side of an integration."
msgstr ""

#: src/ecosystem/async-await.md:3
msgid ""
"_`async`/`await` support is currently being integrated in PyO3. See the "
"[dedicated documentation](../async-await.md)_"
msgstr ""

#: src/ecosystem/async-await.md:5
msgid ""
"If you are working with a Python library that makes use of async functions "
"or wish to provide Python bindings for an async Rust library, [`pyo3-async-"
"runtimes`](https://github.com/PyO3/pyo3-async-runtimes) likely has the tools "
"you need. It provides conversions between async functions in both Python and "
"Rust and was designed with first-class support for popular Rust runtimes "
"such as [`tokio`](https://tokio.rs/) and [`async-std`](https://async.rs/). "
"In addition, all async Python code runs on the default `asyncio` event loop, "
"so `pyo3-async-runtimes` should work just fine with existing Python "
"libraries."
msgstr ""

#: src/ecosystem/async-await.md:13
msgid "Additional Information"
msgstr ""

#: src/ecosystem/async-await.md:15
msgid ""
"Managing event loop references can be tricky with `pyo3-async-runtimes`. See "
"[Event Loop References](https://docs.rs/pyo3-async-runtimes/#event-loop-"
"references-and-contextvars) in the API docs to get a better intuition for "
"how event loop references are managed in this library."
msgstr ""

#: src/ecosystem/async-await.md:16
msgid ""
"Testing `pyo3-async-runtimes` libraries and applications requires a custom "
"test harness since Python requires control over the main thread. You can "
"find a testing guide in the [API docs for the `testing` module](https://docs."
"rs/pyo3-async-runtimes/latest/pyo3_async_runtimes/testing)"
msgstr ""

#: src/async-await.md:3
msgid ""
"_This feature is still in active development. See [the related issue]"
"(https://github.com/PyO3/pyo3/issues/1632)._"
msgstr ""

#: src/async-await.md:5
msgid "`#[pyfunction]` and `#[pymethods]` attributes also support `async fn`."
msgstr ""

#: src/async-await.md:9 src/async-await.md:82
msgid "\"experimental-async\""
msgstr ""

#: src/async-await.md:28
msgid ""
"_Python awaitables instantiated with this method can only be awaited in "
"_asyncio_ context. Other Python async runtime may be supported in the future."
"_"
msgstr ""

#: src/async-await.md:30
msgid "`Send + 'static` constraint"
msgstr ""

#: src/async-await.md:32
msgid ""
"Resulting future of an `async fn` decorated by `#[pyfunction]` must be `Send "
"+ 'static` to be embedded in a Python object."
msgstr ""

#: src/async-await.md:34
msgid ""
"As a consequence, `async fn` parameters and return types must also be `Send "
"+ 'static`, so it is not possible to have a signature like `async fn "
"does_not_compile<'py>(arg: Bound<'py, PyAny>) -> Bound<'py, PyAny>`."
msgstr ""

#: src/async-await.md:36
msgid ""
"However, there is an exception for method receivers, so async methods can "
"accept `&self`/`&mut self`. Note that this means that the class instance is "
"borrowed for as long as the returned future is not completed, even across "
"yield points and while waiting for I/O operations to complete. Hence, other "
"methods cannot obtain exclusive borrows while the future is still being "
"polled. This is the same as how async methods in Rust generally work but it "
"is more problematic for Rust code interfacing with Python code due to "
"pervasive shared mutability. This strongly suggests to prefer shared borrows "
"`&self` over exclusive ones `&mut self` to avoid racy borrow check failures "
"at runtime."
msgstr ""

#: src/async-await.md:38
msgid "Implicitly attached to the interpreter"
msgstr ""

#: src/async-await.md:40
msgid ""
"Even if it is not possible to pass a `py: Python<'py>` token to an `async "
"fn`, we're still attached to the interpreter during the execution of the "
"future ‚Äì the same as for a regular `fn` without `Python<'py>`/`Bound<'py, "
"PyAny>` parameter"
msgstr ""

#: src/async-await.md:42
msgid ""
"It is still possible to get a `Python` marker using [`Python::attach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.attach); "
"because `attach` is reentrant and optimized, the cost will be negligible."
msgstr ""

#: src/async-await.md:44
msgid "Detaching from the interpreter across `.await`"
msgstr ""

#: src/async-await.md:46
msgid ""
"There is currently no simple way to detach from the interpreter when "
"awaiting a future, _but solutions are currently in development_."
msgstr ""

#: src/async-await.md:48
msgid "Here is the advised workaround for now:"
msgstr ""

#: src/async-await.md:76
msgid "Cancellation"
msgstr ""

#: src/async-await.md:78
msgid ""
"Cancellation on the Python side can be caught using [`CancelHandle`](https://"
"pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html) type, by "
"annotating a function parameter with `#[pyo3(cancel_handle)]`."
msgstr ""

#: src/async-await.md:90
msgid "/* _ = ... => println!(\"done\"), */"
msgstr ""

#: src/async-await.md:91
msgid "\"cancelled\""
msgstr ""

#: src/async-await.md:97
msgid "The `Coroutine` type"
msgstr ""

#: src/async-await.md:99
msgid ""
"To make a Rust future awaitable in Python, PyO3 defines a [`Coroutine`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.Coroutine.html) type, which "
"implements the Python [coroutine protocol](https://docs.python.org/3/library/"
"collections.abc.html#collections.abc.Coroutine)."
msgstr ""

#: src/async-await.md:101
msgid ""
"Each `coroutine.send` call is translated to a `Future::poll` call. If a "
"[`CancelHandle`](https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle."
"html) parameter is declared, the exception passed to `coroutine.throw` call "
"is stored in it and can be retrieved with [`CancelHandle::cancelled`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html#method."
"cancelled); otherwise, it cancels the Rust future, and the exception is "
"reraised;"
msgstr ""

#: src/async-await.md:103
msgid ""
"_The type does not yet have a public constructor until the design is "
"finalized._"
msgstr ""

#: src/rust-from-python.md:3
msgid ""
"This chapter of the guide is dedicated to explaining how to wrap Rust code "
"into Python objects."
msgstr ""

#: src/rust-from-python.md:5
msgid ""
"PyO3 uses Rust's \"procedural macros\" to provide a powerful yet simple API "
"to denote what Rust code should map into Python objects."
msgstr ""

#: src/rust-from-python.md:7
msgid "PyO3 can create three types of Python objects:"
msgstr ""

#: src/rust-from-python.md:9
msgid "Python modules, via the `#[pymodule]` macro"
msgstr ""

#: src/rust-from-python.md:10
msgid "Python functions, via the `#[pyfunction]` macro"
msgstr ""

#: src/rust-from-python.md:11
msgid ""
"Python classes, via the `#[pyclass]` macro (plus `#[pymethods]` to define "
"methods for those classes)"
msgstr ""

#: src/rust-from-python.md:13
msgid "The following subchapters go through each of these in turn."
msgstr ""

#: src/class.md:3
msgid ""
"PyO3 exposes a group of attributes powered by Rust's proc macro system for "
"defining Python classes as Rust structs."
msgstr ""

#: src/class.md:5
msgid ""
"The main attribute is `#[pyclass]`, which is placed upon a Rust `struct` or "
"`enum` to generate a Python type for it. They will usually also have _one_ "
"`#[pymethods]`\\-annotated `impl` block for the struct, which is used to "
"define Python methods and constants for the generated Python type. (If the "
"[`multiple-pymethods`](features.md#multiple-pymethods) feature is enabled, "
"each `#[pyclass]` is allowed to have multiple `#[pymethods]` blocks.) "
"`#[pymethods]` may also have implementations for Python magic methods such "
"as `__str__`."
msgstr ""

#: src/class.md:7
msgid ""
"This chapter will discuss the functionality and configuration these "
"attributes offer. Below is a list of links to the relevant section of this "
"chapter for each:"
msgstr ""

#: src/class.md:9
msgid "[`#[pyclass]`](#defining-a-new-class)"
msgstr ""

#: src/class.md:10
msgid "[`#[pyo3(get, set)]`](#object-properties-using-pyo3get-set)"
msgstr ""

#: src/class.md:11
msgid "[`#[pymethods]`](#instance-methods)"
msgstr ""

#: src/class.md:12
msgid "[`#[new]`](#constructor)"
msgstr ""

#: src/class.md:13
msgid "[`#[getter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:14
msgid "[`#[setter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:15
msgid "[`#[staticmethod]`](#static-methods)"
msgstr ""

#: src/class.md:16
msgid "[`#[classmethod]`](#class-methods)"
msgstr ""

#: src/class.md:17
msgid "[`#[classattr]`](#class-attributes)"
msgstr ""

#: src/class.md:18
msgid "[`#[args]`](#method-arguments)"
msgstr ""

#: src/class.md:19
msgid "[Magic methods and slots](class/protocols.md)"
msgstr ""

#: src/class.md:20
msgid "[Classes as function arguments](#classes-as-function-arguments)"
msgstr ""

#: src/class.md:22
msgid "Defining a new class"
msgstr ""

#: src/class.md:24
msgid ""
"To define a custom Python class, add the `#[pyclass]` attribute to a Rust "
"struct or enum."
msgstr ""

#: src/class.md:34
msgid "// A \"tuple\" struct\n"
msgstr ""

#: src/class.md:38
msgid ""
"// PyO3 supports unit-only enums (which contain only unit variants)\n"
"// These simple enums behave similarly to Python's enumerations (enum.Enum)\n"
msgstr ""

#: src/class.md:45
msgid "// PyO3 supports custom discriminants.\n"
msgstr ""

#: src/class.md:47
msgid "// PyO3 supports custom discriminants in unit-only enums\n"
msgstr ""

#: src/class.md:57
msgid ""
"// PyO3 also supports enums with Struct and Tuple variants\n"
"// These complex enums have slightly different behavior from the simple "
"enums above\n"
"// They are meant to work with instance checks and match statement patterns\n"
"// The variants can be mixed and matched\n"
"// Struct variants have named fields while tuple enums generate generic "
"names for fields in order _0, _1, _2, ...\n"
"// Apart from this both types are functionally identical\n"
msgstr ""

#: src/class.md:73
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html) and [`PyClass`](https://"
"pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html) for `MyClass`, `Number`, "
"`MyEnum`, `HttpResponse`, and `Shape`. To see these generated "
"implementations, refer to the [implementation details](#implementation-"
"details) at the end of this chapter."
msgstr ""

#: src/class.md:75
msgid "Restrictions"
msgstr ""

#: src/class.md:77
msgid ""
"To integrate Rust types with Python, PyO3 needs to place some restrictions "
"on the types which can be annotated with `#[pyclass]`. In particular, they "
"must have no lifetime parameters, no generic parameters, and must be thread-"
"safe. The reason for each of these is explained below."
msgstr ""

#: src/class.md:79
msgid "No lifetime parameters"
msgstr ""

#: src/class.md:81
msgid ""
"Rust lifetimes are used by the Rust compiler to reason about a program's "
"memory safety. They are a compile-time only concept; there is no way to "
"access Rust lifetimes at runtime from a dynamic language like Python."
msgstr ""

#: src/class.md:83
msgid ""
"As soon as Rust data is exposed to Python, there is no guarantee that the "
"Rust compiler can make on how long the data will live. Python is a reference-"
"counted language and those references can be held for an arbitrarily long "
"time which is untraceable by the Rust compiler. The only possible way to "
"express this correctly is to require that any `#[pyclass]` does not borrow "
"data for any lifetime shorter than the `'static` lifetime, i.e. the "
"`#[pyclass]` cannot have any lifetime parameters."
msgstr ""

#: src/class.md:85
msgid ""
"When you need to share ownership of data between Python and Rust, instead of "
"using borrowed references with lifetimes consider using reference-counted "
"smart pointers such as [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc."
"html) or [`Py`](https://pyo3.rs/main/doc/pyo3/struct.Py.html)."
msgstr ""

#: src/class.md:87
msgid "No generic parameters"
msgstr ""

#: src/class.md:89
msgid ""
"A Rust `struct Foo<T>` with a generic parameter `T` generates new compiled "
"implementations each time it is used with a different concrete type for `T`. "
"These new implementations are generated by the compiler at each usage site. "
"This is incompatible with wrapping `Foo` in Python, where there needs to be "
"a single compiled implementation of `Foo` which is integrated with the "
"Python interpreter."
msgstr ""

#: src/class.md:91
msgid ""
"Currently, the best alternative is to write a macro which expands to a new "
"`#[pyclass]` for each instantiation you want:"
msgstr ""

#: src/class.md:123
msgid "Must be thread-safe"
msgstr ""

#: src/class.md:125
msgid ""
"Python objects are freely shared between threads by the Python interpreter. "
"This means that:"
msgstr ""

#: src/class.md:127
msgid ""
"Python objects may be created and destroyed by different Python threads; "
"therefore `#[pyclass]` objects must be `Send`."
msgstr ""

#: src/class.md:128
msgid ""
"Python objects may be accessed by multiple Python threads simultaneously; "
"therefore `#[pyclass]` objects must be `Sync`."
msgstr ""

#: src/class.md:130
msgid ""
"For now, don't worry about these requirements; simple classes will already "
"be thread-safe. There is a [detailed discussion on thread-safety](./class/"
"thread-safety.md) later in the guide."
msgstr ""

#: src/class.md:132
msgid "Constructor"
msgstr ""

#: src/class.md:134
msgid ""
"By default, it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:153
msgid ""
"Alternatively, if your `new` method may fail you can return `PyResult<Self>`."
msgstr ""

#: src/class.md:167
msgid "\"cannot be zero\""
msgstr ""

#: src/class.md:175
msgid ""
"If you want to return an existing object (for example, because your `new` "
"method caches the values it returns), `new` can return `pyo3::Py<Self>`."
msgstr ""

#: src/class.md:178
msgid ""
"As you can see, the Rust method name is not important here; this way you can "
"still, use `new()` for a Rust-level constructor."
msgstr ""

#: src/class.md:181
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:184
msgid ""
"For arguments, see the [`Method arguments`](#method-arguments) section below."
msgstr ""

#: src/class.md:186
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:188
msgid "The next step is to create the Python module and add our class to it:"
msgstr ""

#: src/class.md:204
msgid "Bound<T> and interior mutability"
msgstr ""

#: src/class.md:206
msgid ""
"It is often useful to turn a `#[pyclass]` type `T` into a Python object and "
"access it from Rust code. The [`Py<T>`](https://pyo3.rs/main/doc/pyo3/struct."
"Py.html) and [`Bound<'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Bound."
"html) smart pointers are the ways to represent a Python object in PyO3's "
"API. More detail can be found about them [in the Python objects](./types."
"md#pyo3s-smart-pointers) section of the guide."
msgstr ""

#: src/class.md:208
msgid ""
"Most Python objects do not offer exclusive (`&mut`) access (see the [section "
"on Python's memory model](./python-from-rust.md#pythons-memory-model)). "
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"often _do_ need `&mut` access. However, the Rust borrow checker cannot "
"reason about `&mut` references once an object's ownership has been passed to "
"the Python interpreter."
msgstr ""

#: src/class.md:211
msgid ""
"To solve this, PyO3 does borrow checking at runtime using a scheme very "
"similar to `std::cell::RefCell<T>`. This is known as [interior mutability]"
"(https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)."
msgstr ""

#: src/class.md:213
msgid ""
"Users who are familiar with `RefCell<T>` can use `Py<T>` and `Bound<'py, T>` "
"just like `RefCell<T>`."
msgstr ""

#: src/class.md:215
msgid ""
"For users who are not very familiar with `RefCell<T>`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:217
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:218
msgid "References can never outlast the data they refer to."
msgstr ""

#: src/class.md:220
msgid ""
"`Py<T>` and `Bound<'py, T>`, like `RefCell<T>`, ensure these borrowing rules "
"by tracking references at runtime."
msgstr ""

#: src/class.md:232
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:234
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:238
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:240
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:245
msgid "// You can convert `Bound` to a Python object\n"
msgstr ""

#: src/class.md:246
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:250
msgid ""
"A `Bound<'py, T>` is restricted to the Python lifetime `'py`. To make the "
"object longer lived (for example, to store it in a struct on the Rust side), "
"use `Py<T>`. `Py<T>` needs a `Python<'_>` token to allow access:"
msgstr ""

#: src/class.md:267
msgid "// Py<MyClass>::bind returns &Bound<'py, MyClass>\n"
msgstr ""

#: src/class.md:268
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:273
msgid "frozen classes: Opting out of interior mutability"
msgstr ""

#: src/class.md:275
msgid ""
"As detailed above, runtime borrow checking is currently enabled by default. "
"But a class can opt of out it by declaring itself `frozen`. It can still use "
"interior mutability via standard Rust types like `RefCell` or `Mutex`, but "
"it is not bound to the implementation provided by PyO3 and can choose the "
"most appropriate strategy on field-by-field basis."
msgstr ""

#: src/class.md:277
msgid ""
"Classes which are `frozen` and also `Sync`, e.g. they do use `Mutex` but not "
"`RefCell`, can be accessed without needing a `Python` token via the `Bound::"
"get` and `Py::get` methods:"
msgstr ""

#: src/class.md:301
msgid ""
"Frozen classes are likely to become the default thereby guiding the PyO3 "
"ecosystem towards a more deliberate application of interior mutability. "
"Eventually, this should enable further optimizations of PyO3's internals and "
"avoid downstream code paying the cost of interior mutability when it is not "
"actually required."
msgstr ""

#: src/class.md:303
msgid "Customizing the class"
msgstr ""

#: src/class.md:305
msgid "`#[pyclass]` can be used with the following parameters:"
msgstr ""

#: src/class.md:307
msgid "Parameter"
msgstr ""

#: src/class.md:309
msgid "`constructor`"
msgstr ""

#: src/class.md:309
msgid ""
"This is currently only allowed on [variants of complex enums](https://pyo3."
"rs/latest/class.html#complex-enums). It allows customization of the "
"generated class constructor for each variant. It uses the same syntax and "
"supports the same options as the `signature` attribute of functions and "
"methods."
msgstr ""

#: src/class.md:310
msgid "<span style=\"white-space: pre\">`crate = \"some::path\"`</span>"
msgstr ""

#: src/class.md:310
msgid "Path to import the `pyo3` crate, if it's not accessible at `::pyo3`."
msgstr ""

#: src/class.md:311
msgid "`dict`"
msgstr ""

#: src/class.md:311
msgid ""
"Gives instances of this class an empty `__dict__` to store custom attributes."
msgstr ""

#: src/class.md:312
msgid "`eq`"
msgstr ""

#: src/class.md:312
msgid ""
"Implements `__eq__` using the `PartialEq` implementation of the underlying "
"Rust datatype."
msgstr ""

#: src/class.md:313
msgid "`eq_int`"
msgstr ""

#: src/class.md:313
msgid "Implements `__eq__` using `__int__` for simple enums."
msgstr ""

#: src/class.md:314
msgid "<span style=\"white-space: pre\">`extends = BaseType`</span>"
msgstr ""

#: src/class.md:314
msgid ""
"Use a custom baseclass. Defaults to [`PyAny`](https://docs.rs/pyo3/latest/"
"pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/class.md:315
msgid "<span style=\"white-space: pre\">`freelist = N`</span>"
msgstr ""

#: src/class.md:315
msgid ""
"Implements a [free list](https://en.wikipedia.org/wiki/Free_list) of size N. "
"This can improve performance for types that are often created and deleted in "
"quick succession. Profile your code to see whether `freelist` is right for "
"you."
msgstr ""

#: src/class.md:316
msgid "`from_py_object`"
msgstr ""

#: src/class.md:316
msgid ""
"Implement `FromPyObject` for this pyclass. Requires the pyclass to be "
"`Clone`."
msgstr ""

#: src/class.md:317
msgid "<span style=\"white-space: pre\">`frozen`</span>"
msgstr ""

#: src/class.md:317
msgid ""
"Declares that your pyclass is immutable. It removes the borrow checker "
"overhead when retrieving a shared reference to the Rust struct, but disables "
"the ability to get a mutable reference."
msgstr ""

#: src/class.md:318
msgid "`generic`"
msgstr ""

#: src/class.md:318
msgid ""
"Implements runtime parametrization for the class following [PEP 560](https://"
"peps.python.org/pep-0560/)."
msgstr ""

#: src/class.md:319
msgid "`get_all`"
msgstr ""

#: src/class.md:319
msgid "Generates getters for all fields of the pyclass."
msgstr ""

#: src/class.md:320
msgid "`hash`"
msgstr ""

#: src/class.md:320
msgid ""
"Implements `__hash__` using the `Hash` implementation of the underlying Rust "
"datatype. _Requires `eq` and `frozen`_"
msgstr ""

#: src/class.md:321
msgid "`immutable_type`"
msgstr ""

#: src/class.md:321
msgid ""
"Makes the type object immutable. Supported on 3.14+ with the `abi3` feature "
"active, or 3.10+ otherwise."
msgstr ""

#: src/class.md:322
msgid "`mapping`"
msgstr ""

#: src/class.md:322
msgid ""
"Inform PyO3 that this class is a [`Mapping`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its implementation of "
"sequence C-API slots empty."
msgstr ""

#: src/class.md:323
msgid "<span style=\"white-space: pre\">`module = \"module_name\"`</span>"
msgstr ""

#: src/class.md:323
msgid ""
"Python code will see the class as being defined in this module. Defaults to "
"`builtins`."
msgstr ""

#: src/class.md:324
msgid "<span style=\"white-space: pre\">`name = \"python_name\"`</span>"
msgstr ""

#: src/class.md:324
msgid ""
"Sets the name that Python sees this class as. Defaults to the name of the "
"Rust struct."
msgstr ""

#: src/class.md:325
msgid "`ord`"
msgstr ""

#: src/class.md:325
msgid ""
"Implements `__lt__`, `__gt__`, `__le__`, & `__ge__` using the `PartialOrd` "
"implementation of the underlying Rust datatype. _Requires `eq`_"
msgstr ""

#: src/class.md:326
msgid "`rename_all = \"renaming_rule\"`"
msgstr ""

#: src/class.md:326
msgid ""
"Applies renaming rules to every getters and setters of a struct, or every "
"variants of an enum. Possible values are: \"camelCase\", \"kebab-case\", "
"\"lowercase\", \"PascalCase\", \"SCREAMING-KEBAB-CASE\", "
"\"SCREAMING_SNAKE_CASE\", \"snake_case\", \"UPPERCASE\"."
msgstr ""

#: src/class.md:327
msgid "`sequence`"
msgstr ""

#: src/class.md:327
msgid ""
"Inform PyO3 that this class is a [`Sequence`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its C-API mapping "
"length slot empty."
msgstr ""

#: src/class.md:328
msgid "`set_all`"
msgstr ""

#: src/class.md:328
msgid "Generates setters for all fields of the pyclass."
msgstr ""

#: src/class.md:329
msgid "`skip_from_py_object`"
msgstr ""

#: src/class.md:329
msgid ""
"Prevents this PyClass from participating in the `FromPyObject: PyClass + "
"Clone` blanket implementation. This allows a custom `FromPyObject` impl, "
"even if `self` is `Clone`."
msgstr ""

#: src/class.md:330
msgid ""
"Implements `__str__` using the `Display` implementation of the underlying "
"Rust datatype or by passing an optional format string `str=\"<format "
"string>\"`. _Note: The optional format string is only allowed for structs.  "
"`name` and `rename_all` are incompatible with the optional format string.  "
"Additional details can be found in the discussion on this [PR](https://"
"github.com/PyO3/pyo3/pull/4233)._"
msgstr ""

#: src/class.md:331
msgid "`subclass`"
msgstr ""

#: src/class.md:331
msgid ""
"Allows other Python classes and `#[pyclass]` to inherit from this class. "
"Enums cannot be subclassed."
msgstr ""

#: src/class.md:332
msgid "`unsendable`"
msgstr ""

#: src/class.md:332
msgid ""
"Required if your struct is not [`Send`](https://doc.rust-lang.org/std/marker/"
"trait.Send.html). Rather than using `unsendable`, consider implementing your "
"struct in a thread-safe way by e.g. substituting [`Rc`](https://doc.rust-"
"lang.org/std/rc/struct.Rc.html) with [`Arc`](https://doc.rust-lang.org/std/"
"sync/struct.Arc.html). By using `unsendable`, your class will panic when "
"accessed by another thread. Also note the Python's GC is multi-threaded and "
"while unsendable classes will not be traversed on foreign threads to avoid "
"UB, this can lead to memory leaks."
msgstr ""

#: src/class.md:333
msgid "`weakref`"
msgstr ""

#: src/class.md:333
msgid ""
"Allows this class to be [weakly referenceable](https://docs.python.org/3/"
"library/weakref.html)."
msgstr ""

#: src/class.md:335
msgid ""
"All of these parameters can either be passed directly on the "
"`#[pyclass(...)]` annotation, or as one or more accompanying `#[pyo3(...)]` "
"annotations, e.g.:"
msgstr ""

#: src/class.md:339
msgid "// Argument supplied directly to the `#[pyclass]` annotation.\n"
msgstr ""

#: src/class.md:340 src/class.md:345
msgid "\"SomeName\""
msgstr ""

#: src/class.md:342
msgid "// Argument supplied as a separate annotation.\n"
msgstr ""

#: src/class.md:359
msgid "These parameters are covered in various sections of this guide."
msgstr ""

#: src/class.md:361
msgid "Return type"
msgstr ""

#: src/class.md:363
msgid ""
"Generally, `#[new]` methods have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:366
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:369
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:369
msgid "**May fail**"
msgstr ""

#: src/class.md:371
msgid "**No inheritance**"
msgstr ""

#: src/class.md:371
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:372
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:372
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:373
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:373
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/main/doc/pyo3/pyclass_init/struct."
"PyClassInitializer.html)"
msgstr ""

#: src/class.md:373
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:375
msgid "Inheritance"
msgstr ""

#: src/class.md:377
msgid ""
"By default, `object`, i.e. `PyAny` is used as the base class. To override "
"this default, use the `extends` parameter for `pyclass` with the full path "
"to the base class. Currently, only classes defined in Rust and builtins "
"provided by PyO3 can be inherited from; inheriting from other classes "
"defined in Python is not yet supported ([\\#991](https://github.com/PyO3/"
"pyo3/issues/991))."
msgstr ""

#: src/class.md:383
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the base class of `T`. But for a more deeply nested inheritance, you have "
"to return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:388
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/main/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_super()` as `&PyRef<Self::BaseClass>`, or by `self_.into_super()` as "
"`PyRef<Self::BaseClass>` (and similar for the `PyRefMut` case). For "
"convenience, `self_.as_ref()` can also be used to get `&Self::BaseClass` "
"directly; however, this approach does not let you access base classes higher "
"in the inheritance hierarchy, for which you would need to chain multiple "
"`as_super` or `into_super` calls."
msgstr ""

#: src/class.md:430
msgid "// Get &PyRef<BaseClass>\n"
msgstr ""

#: src/class.md:448
msgid "// Get &PyRef<'_, BaseClass>\n"
msgstr ""

#: src/class.md:454
msgid "// Get PyRef<'_, SubClass>\n"
msgstr ""

#: src/class.md:484
msgid "\"assert subsub.method1() == 10\""
msgstr ""

#: src/class.md:485
msgid "\"assert subsub.method2() == 150\""
msgstr ""

#: src/class.md:486
msgid "\"assert subsub.method3() == 200\""
msgstr ""

#: src/class.md:487
msgid "\"assert subsub.method4() == 3000\""
msgstr ""

#: src/class.md:488
msgid "\"assert subsub.get_values() == (10, 15, 20)\""
msgstr ""

#: src/class.md:489
msgid "\"assert subsub.double_values() == None\""
msgstr ""

#: src/class.md:490
msgid "\"assert subsub.get_values() == (20, 30, 40)\""
msgstr ""

#: src/class.md:494
msgid "\"assert not isinstance(subsub, cls)\""
msgstr ""

#: src/class.md:495
msgid "\"assert isinstance(subsubsub, cls)\""
msgstr ""

#: src/class.md:499
msgid ""
"You can inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/main/doc/pyo3/type_object/trait."
"PySizedLayout.html). This is not supported when building for the Python "
"limited API (aka the `abi3` feature of PyO3)."
msgstr ""

#: src/class.md:503
msgid ""
"To convert between the Rust type and its native base class, you can take "
"`slf` as a Python object. To access the Rust fields use `slf.borrow()` or "
"`slf.borrow_mut()`, and to access the base class use `slf.cast::"
"<BaseClass>()`."
msgstr ""

#: src/class.md:534
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:539
msgid ""
"If `SubClass` does not provide a base class initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:563
msgid ""
"The `__new__` constructor of a native base class is called implicitly when "
"creating a new instance from Python.  Be sure to accept arguments in the "
"`#[new]` method that you want the base class to get, even if they are not "
"used in that `fn`:"
msgstr ""

#: src/class.md:587
msgid "// some custom methods that use `private` here...\n"
msgstr ""

#: src/class.md:591
msgid "\"cls(a=1, b=2)\""
msgstr ""

#: src/class.md:596
msgid ""
"Here, the `args` and `kwargs` allow creating instances of the subclass "
"passing initial items, such as `MyDict(item_sequence)` or `MyDict(a=1, b=2)`."
msgstr ""

#: src/class.md:599
msgid "Object properties"
msgstr ""

#: src/class.md:601
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:603
msgid ""
"For simple struct fields with no side effects, a `#[pyo3(get, set)]` "
"attribute can be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:604
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the [`#[pymethods]`](#instance-methods) block."
msgstr ""

#: src/class.md:606
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:608
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:610
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:622
msgid ""
"The above would make the `num` field available for reading and writing as a "
"`self.num` Python property. To expose the property with a different name to "
"the field, specify this alongside the rest of the options, e.g. `#[pyo3(get, "
"set, name = \"custom_name\")]`."
msgstr ""

#: src/class.md:624
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:626
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:628
msgid ""
"For `get` the field type `T` must implement either `&T: IntoPyObject` or `T: "
"IntoPyObject + Clone`."
msgstr ""

#: src/class.md:629
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:631
msgid ""
"For example, implementations of those traits are provided for the `Cell` "
"type, if the inner type also implements the trait. This means you can use "
"`#[pyo3(get, set)]` on fields wrapped in a `Cell`."
msgstr ""

#: src/class.md:633
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:635
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:637
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:655
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:658
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:685
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:687
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:711
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:713
msgid ""
"Attributes defined by `#[setter]` or `#[pyo3(set)]` will always raise "
"`AttributeError` on `del` operations. Support for defining custom `del` "
"behavior is tracked in [\\#1778](https://github.com/PyO3/pyo3/issues/1778)."
msgstr ""

#: src/class.md:717
msgid "Instance methods"
msgstr ""

#: src/class.md:719
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:723
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust. However to have multiple `#[pymethods]`\\-annotated `impl` blocks for "
"the same struct you must enable the [`multiple-pymethods`](features."
"md#multiple-pymethods) feature of PyO3."
msgstr ""

#: src/class.md:746
msgid ""
"Both `&self` and `&mut self` can be used, due to the use of [runtime borrow "
"checking](#bound-and-interior-mutability)."
msgstr ""

#: src/class.md:748
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPyObject`; the latter is allowed if the method cannot raise Python "
"exceptions."
msgstr ""

#: src/class.md:751
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:769
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:771
msgid "Class methods"
msgstr ""

#: src/class.md:773
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:794
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:796
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:798
msgid "The first parameter implicitly has type `&Bound<'_, PyType>`."
msgstr ""

#: src/class.md:799
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:800
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:802
msgid "Constructors which accept a class argument"
msgstr ""

#: src/class.md:804
msgid ""
"To create a constructor which takes a positional class argument, you can "
"combine the `#[classmethod]` and `#[new]` modifiers:"
msgstr ""

#: src/class.md:818
msgid ""
"// Get an abstract attribute (presumably) declared on a subclass of this "
"class.\n"
msgstr ""

#: src/class.md:819
msgid "\"a_class_attr\""
msgstr ""

#: src/class.md:825
msgid "Static methods"
msgstr ""

#: src/class.md:827
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:847
msgid "Class attributes"
msgstr ""

#: src/class.md:849
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute."
msgstr ""

#: src/class.md:860
msgid "\"hello\""
msgstr ""

#: src/class.md:866
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:870
msgid ""
"Note: if the method has a `Result` return type and returns an `Err`, PyO3 "
"will panic during class creation."
msgstr ""

#: src/class.md:873
msgid ""
"Note: `#[classattr]` does not work with [`#[pyo3(warn(...))]`](./function."
"md#warn) attribute."
msgstr ""

#: src/class.md:875
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:889
msgid "Classes as function arguments"
msgstr ""

#: src/class.md:891
msgid ""
"Class objects can be used as arguments to `#[pyfunction]`s and "
"`#[pymethods]` in the same way as the self parameters of instance methods, i."
"e. they can be passed as:"
msgstr ""

#: src/class.md:893
msgid "`Py<T>` or `Bound<'py, T>` smart pointers to the class Python object,"
msgstr ""

#: src/class.md:894
msgid ""
"`&T` or `&mut T` references to the Rust data contained in the Python object, "
"or"
msgstr ""

#: src/class.md:895
msgid "`PyRef<T>` and `PyRefMut<T>` reference wrappers."
msgstr ""

#: src/class.md:897
msgid "Examples of each of these below:"
msgstr ""

#: src/class.md:906
msgid ""
"// Take a reference to Rust data when the Python object is irrelevant.\n"
msgstr ""

#: src/class.md:912
msgid ""
"// Take a reference wrapper when borrowing should be automatic,\n"
"// but access to the Python object is still needed\n"
msgstr ""

#: src/class.md:917 src/class.md:926 src/class.md:933
msgid "\"{}\""
msgstr ""

#: src/class.md:920
msgid ""
"// Take (a reference to) a Python object smart pointer when borrowing needs "
"to be managed manually.\n"
msgstr ""

#: src/class.md:928
msgid ""
"// When the Python object smart pointer needs to be stored elsewhere prefer "
"`Py<T>` over `Bound<'py, T>`\n"
"// to avoid the lifetime restrictions.\n"
msgstr ""

#: src/class.md:937
msgid ""
"Classes can also be passed by value if they can be cloned, i.e. they "
"automatically implement `FromPyObject` if they implement `Clone`, e.g. via "
"`#[derive(Clone)]`:"
msgstr ""

#: src/class.md:955
msgid ""
"Note that `#[derive(FromPyObject)]` on a class is usually not useful as it "
"tries to construct a new Rust value by filling in the fields by looking up "
"attributes of any given Python value."
msgstr ""

#: src/class.md:957
msgid "Method arguments"
msgstr ""

#: src/class.md:959
msgid ""
"Similar to `#[pyfunction]`, the `#[pyo3(signature = (...))]` attribute can "
"be used to specify the way that `#[pymethods]` accept arguments. Consult the "
"documentation for [`function signatures`](./function/signature.md) to see "
"the parameters this attribute accepts."
msgstr ""

#: src/class.md:961
msgid ""
"The following example defines a class `MyClass` with a method `method`. This "
"method has a signature that sets default values for `num` and `name`, and "
"indicates that `py_args` should collect all extra positional arguments and "
"`py_kwargs` all extra keyword arguments:"
msgstr ""

#: src/class.md:979
msgid "\"Hello\""
msgstr ""

#: src/class.md:990
msgid "\"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \""
msgstr ""

#: src/class.md:997
msgid "In Python, this might be used like:"
msgstr ""

#: src/class.md:1002 src/class.md:1004
msgid "\"World\""
msgstr ""

#: src/class.md:1003
msgid "'World'"
msgstr ""

#: src/class.md:1003
msgid "'x'"
msgstr ""

#: src/class.md:1003
msgid "'y'"
msgstr ""

#: src/class.md:1008
msgid ""
"The [`#[pyo3(text_signature = \"...\")`](./function/signature.md#overriding-"
"the-generated-signature) option for `#[pyfunction]` also works for "
"`#[pymethods]`."
msgstr ""

#: src/class.md:1021 src/class.md:1058
msgid "\"(c, d)\""
msgstr ""

#: src/class.md:1025
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/class.md:1026
msgid "\"($self, e, f)\""
msgstr ""

#: src/class.md:1030
msgid "// similarly for classmethod arguments, use $cls\n"
msgstr ""

#: src/class.md:1032
msgid "\"($cls, e, f)\""
msgstr ""

#: src/class.md:1037 src/class.md:1087 src/class.md:1099
msgid "\"(e, f)\""
msgstr ""

#: src/class.md:1045
msgid "\"inspect\""
msgstr ""

#: src/class.md:1045
msgid "\"signature\""
msgstr ""

#: src/class.md:1046
msgid "\"my_module\""
msgstr ""

#: src/class.md:1048 src/class.md:1449
msgid "\"MyClass\""
msgstr ""

#: src/class.md:1051 src/class.md:1060 src/class.md:1069 src/class.md:1081
#: src/class.md:1093
msgid "\"__doc__\""
msgstr ""

#: src/class.md:1056 src/class.md:1073 src/class.md:1085 src/class.md:1097
msgid "\"__str__\""
msgstr ""

#: src/class.md:1063
msgid ""
"\"`text_signature` on classes is not compatible with compilation in `abi3` "
"mode until Python 3.10 or greater\""
msgstr ""

#: src/class.md:1067
msgid "\"my_method\""
msgstr ""

#: src/class.md:1075
msgid "\"(self, /, e, f)\""
msgstr ""

#: src/class.md:1079
msgid "\"my_class_method\""
msgstr ""

#: src/class.md:1087
msgid "// inspect.signature skips the $cls arg\n"
msgstr ""

#: src/class.md:1091
msgid "\"my_static_method\""
msgstr ""

#: src/class.md:1107
msgid ""
"Note that `text_signature` on `#[new]` is not compatible with compilation in "
"`abi3` mode until Python 3.10 or greater."
msgstr ""

#: src/class.md:1110
msgid "Method receivers and lifetime elision"
msgstr ""

#: src/class.md:1112
msgid ""
"PyO3 supports writing instance methods using the normal method receivers for "
"shared `&self` and unique `&mut self` references. This interacts with "
"[lifetime elision](https://doc.rust-lang.org/reference/lifetime-elision."
"html) insofar as the lifetime of a such a receiver is assigned to all elided "
"output lifetime parameters."
msgstr ""

#: src/class.md:1114
msgid ""
"This is a good default for general Rust code where return values are more "
"likely to borrow from the receiver than from the other arguments, if they "
"contain any lifetimes at all. However, when returning bound references "
"`Bound<'py, T>` in PyO3-based code, the Python lifetime `'py` should usually "
"be derived from a `py: Python<'py>` token passed as an argument instead of "
"the receiver."
msgstr ""

#: src/class.md:1116
msgid "Specifically, signatures like"
msgstr ""

#: src/class.md:1122
msgid "will not work as they are inferred as"
msgstr ""

#: src/class.md:1128
msgid "instead of the intended"
msgstr ""

#: src/class.md:1134
msgid "and should usually be written as"
msgstr ""

#: src/class.md:1140
msgid ""
"The same problem does not exist for `#[pyfunction]`s as the special case for "
"receiver lifetimes does not apply and indeed a signature like"
msgstr ""

#: src/class.md:1146
msgid ""
"will yield compiler error [E0106 \"missing lifetime specifier\"](https://doc."
"rust-lang.org/error_codes/E0106.html)."
msgstr ""

#: src/class.md:1148
msgid "`#[pyclass]` enums"
msgstr ""

#: src/class.md:1150
msgid ""
"Enum support in PyO3 comes in two flavors, depending on what kind of "
"variants the enum has: simple and complex."
msgstr ""

#: src/class.md:1152
msgid "Simple enums"
msgstr ""

#: src/class.md:1154
msgid "A simple enum (a.k.a. C-like enum) has only unit variants."
msgstr ""

#: src/class.md:1156
msgid ""
"PyO3 adds a class attribute for each variant, so you can access them in "
"Python without defining `#[new]`. PyO3 also provides default implementations "
"of `__richcmp__` and `__int__`, so they can be compared using `==`:"
msgstr ""

#: src/class.md:1171
msgid ""
"r#\"\n"
"        assert x == cls.Variant\n"
"        assert y == cls.OtherVariant\n"
"        assert x != y\n"
"    \"#"
msgstr ""

#: src/class.md:1179
msgid "You can also convert your simple enums into `int`:"
msgstr ""

#: src/class.md:1192
msgid "// The exact value is assigned by the compiler.\n"
msgstr ""

#: src/class.md:1193
msgid ""
"r#\"\n"
"        assert int(cls.Variant) == x\n"
"        assert int(cls.OtherVariant) == 10\n"
"    \"#"
msgstr ""

#: src/class.md:1200
msgid "PyO3 also provides `__repr__` for enums:"
msgstr ""

#: src/class.md:1214
msgid ""
"r#\"\n"
"        assert repr(x) == 'MyEnum.Variant'\n"
"        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'\n"
"    \"#"
msgstr ""

#: src/class.md:1221
msgid ""
"All methods defined by PyO3 can be overridden. For example here's how you "
"override `__repr__`:"
msgstr ""

#: src/class.md:1234
msgid "\"42\""
msgstr ""

#: src/class.md:1240
msgid "\"assert repr(cls.Answer) == '42'\""
msgstr ""

#: src/class.md:1244
msgid "Enums and their variants can also be renamed using `#[pyo3(name)]`."
msgstr ""

#: src/class.md:1248
msgid "\"RenamedEnum\""
msgstr ""

#: src/class.md:1251
msgid "\"UPPERCASE\""
msgstr ""

#: src/class.md:1258
msgid ""
"r#\"\n"
"        assert repr(x) == 'RenamedEnum.UPPERCASE'\n"
"        assert x == cls.UPPERCASE\n"
"    \"#"
msgstr ""

#: src/class.md:1265
msgid ""
"Ordering of enum variants is optionally added using `#[pyo3(ord)]`. _Note: "
"Implementation of the `PartialOrd` trait is required when passing the `ord` "
"argument.  If not implemented, a compile time error is raised._"
msgstr ""

#: src/class.md:1283
msgid ""
"r#\"\n"
"        assert (a < b) == True\n"
"        assert (c <= b) == False\n"
"        assert (c > a) == True\n"
"    \"#"
msgstr ""

#: src/class.md:1291
msgid ""
"You may not use enums as a base class or let enums inherit from other "
"classes."
msgstr ""

#: src/class.md:1313
msgid ""
"`#[pyclass]` enums are currently not interoperable with `IntEnum` in Python."
msgstr ""

#: src/class.md:1315
msgid "Complex enums"
msgstr ""

#: src/class.md:1317
msgid "An enum is complex if it has any non-unit (struct or tuple) variants."
msgstr ""

#: src/class.md:1319
msgid ""
"PyO3 supports only struct and tuple variants in a complex enum. Unit "
"variants aren't supported at present (the recommendation is to use an empty "
"tuple enum instead)."
msgstr ""

#: src/class.md:1321
msgid ""
"PyO3 adds a class attribute for each variant, which may be used to construct "
"values and in match patterns. PyO3 also provides getter methods for all "
"fields of each variant."
msgstr ""

#: src/class.md:1338
msgid ""
"r#\"\n"
"        assert isinstance(circle, cls)\n"
"        assert isinstance(circle, cls.Circle)\n"
"        assert circle.radius == 10.0\n"
"\n"
"        assert isinstance(square, cls)\n"
"        assert isinstance(square, cls.RegularPolygon)\n"
"        assert square[0] == 4 # Gets _0 field\n"
"        assert square[1] == 10.0 # Gets _1 field\n"
"\n"
"        def count_vertices(cls, shape):\n"
"            match shape:\n"
"                case cls.Circle():\n"
"                    return 0\n"
"                case cls.Rectangle():\n"
"                    return 4\n"
"                case cls.RegularPolygon(n):\n"
"                    return n\n"
"                case cls.Nothing():\n"
"                    return 0\n"
"\n"
"        assert count_vertices(cls, circle) == 0\n"
"        assert count_vertices(cls, square) == 4\n"
"    \"#"
msgstr ""

#: src/class.md:1367
msgid ""
"WARNING: `Py::new` and `.into_pyobject` are currently inconsistent. Note how "
"the constructed value is _not_ an instance of the specific variant. For this "
"reason, constructing values is only recommended using `.into_pyobject`."
msgstr ""

#: src/class.md:1379
msgid ""
"r#\"\n"
"        assert isinstance(x, cls)\n"
"        assert not isinstance(x, cls.Variant)\n"
"    \"#"
msgstr ""

#: src/class.md:1386
msgid ""
"The constructor of each generated class can be customized using the "
"`#[pyo3(constructor = (...))]` attribute. This uses the same syntax as the "
"[`#[pyo3(signature = (...))]`](function/signature.md) attribute on function "
"and methods and supports the same options. To apply this attribute simply "
"place it on top of a variant in a `#[pyclass]` complex enum as shown below:"
msgstr ""

#: src/class.md:1405
msgid ""
"r#\"\n"
"        circle = cls.Circle()\n"
"        assert isinstance(circle, cls)\n"
"        assert isinstance(circle, cls.Circle)\n"
"        assert circle.radius == 1.0\n"
"\n"
"        square = cls.Rectangle(width = 1, height = 1)\n"
"        assert isinstance(square, cls)\n"
"        assert isinstance(square, cls.Rectangle)\n"
"        assert square.width == 1\n"
"        assert square.height == 1\n"
"\n"
"        hexagon = cls.RegularPolygon(6)\n"
"        assert isinstance(hexagon, cls)\n"
"        assert isinstance(hexagon, cls.RegularPolygon)\n"
"        assert hexagon.side_count == 6\n"
"        assert hexagon.radius == 1\n"
"    \"#"
msgstr ""

#: src/class.md:1426
msgid "Implementation details"
msgstr ""

#: src/class.md:1428
msgid ""
"The `#[pyclass]` macros rely on a lot of conditional code generation: each "
"`#[pyclass]` can optionally have a `#[pymethods]` block."
msgstr ""

#: src/class.md:1430
msgid ""
"To support this flexibility the `#[pyclass]` macro expands to a blob of "
"boilerplate code which sets up the structure for [\"dtolnay specialization\"]"
"(https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/"
"README.md). This implementation pattern enables the Rust compiler to use "
"`#[pymethods]` implementations when they are present, and fall back to "
"default (empty) definitions when they are not."
msgstr ""

#: src/class.md:1432
msgid ""
"This simple technique works for the case when there is zero or one "
"implementations. To support multiple `#[pymethods]` for a `#[pyclass]` (in "
"the [`multiple-pymethods`](features.md#multiple-pymethods) feature), a "
"registry mechanism provided by the [`inventory`](https://github.com/dtolnay/"
"inventory) crate is used instead. This collects `impl`s at library load "
"time, but isn't supported on all platforms. See [inventory: how it works]"
"(https://github.com/dtolnay/inventory#how-it-works) for more details."
msgstr ""

#: src/class.md:1434
msgid ""
"The `#[pyclass]` macro expands to roughly the code seen below. The "
"`PyClassImplCollector` is the type used internally by PyO3 for dtolnay "
"specialization:"
msgstr ""

#: src/class.md:1437
msgid "\"multiple-pymethods\""
msgstr ""

#: src/class.md:1438
msgid ""
"// Note: the implementation differs slightly with the `multiple-pymethods` "
"feature enabled.\n"
msgstr ""

#: src/class.md:1481 src/class.md:1482
msgid "\"...\""
msgstr ""

#: src/class.md:1500
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. Python "
"classes support these protocols by implementing \"magic\" methods, such as "
"`__str__` or `__repr__`. Because of the double-underscores surrounding their "
"name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"PyO3 makes it possible for every magic method to be implemented in "
"`#[pymethods]` just as they would be done in a regular Python class, with a "
"few notable differences:"
msgstr ""

#: src/class/protocols.md:7
msgid ""
"`__new__` and `__init__` are replaced by the [`#[new]` attribute](../class."
"md#constructor)."
msgstr ""

#: src/class/protocols.md:8
msgid "`__del__` is not yet supported, but may be in the future."
msgstr ""

#: src/class/protocols.md:9
msgid ""
"`__buffer__` and `__release_buffer__` are currently not supported and "
"instead PyO3 supports [`__getbuffer__` and `__releasebuffer__`](#buffer-"
"objects) methods (these predate [PEP 688](https://peps.python.org/pep-0688/"
"#python-level-buffer-protocol)), again this may change in the future."
msgstr ""

#: src/class/protocols.md:10
msgid ""
"PyO3 adds [`__traverse__` and `__clear__`](#garbage-collector-integration) "
"methods for controlling garbage collection."
msgstr ""

#: src/class/protocols.md:11
msgid ""
"The Python C-API which PyO3 is implemented upon requires many magic methods "
"to have a specific function signature in C and be placed into special "
"\"slots\" on the class type object. This limits the allowed argument and "
"return types for these methods. They are listed in detail in the section "
"below."
msgstr ""

#: src/class/protocols.md:13
msgid ""
"If a magic method is not on the list above (for example "
"`__init_subclass__`), then it should just work in PyO3. If this is not the "
"case, please file a bug report."
msgstr ""

#: src/class/protocols.md:15
msgid "Magic Methods handled by PyO3"
msgstr ""

#: src/class/protocols.md:17
msgid ""
"If a function name in `#[pymethods]` is a magic method which is known to "
"need special handling, it will be automatically placed into the correct slot "
"in the Python type object. The function name is taken from the usual rules "
"for naming `#[pymethods]`: the `#[pyo3(name = \"...\")]` attribute is used "
"if present, otherwise the Rust function name is used."
msgstr ""

#: src/class/protocols.md:19
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the subset which have "
"slots as [defined here](https://docs.python.org/3/c-api/typeobj.html)."
msgstr ""

#: src/class/protocols.md:21
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:23
msgid "The Rust function signature is restricted to match the magic method."
msgstr ""

#: src/class/protocols.md:24
msgid ""
"The `#[pyo3(signature = (...)]` and `#[pyo3(text_signature = \"...\")]` "
"attributes are not allowed."
msgstr ""

#: src/class/protocols.md:26
msgid ""
"The following sections list all magic methods for which PyO3 implements the "
"necessary special handling.  The given signatures should be interpreted as "
"follows:"
msgstr ""

#: src/class/protocols.md:29
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `Bound` reference like `self_: PyRef<'_, Self>` "
"and `self_: PyRefMut<'_, Self>`, as described [here](../class."
"md#inheritance)."
msgstr ""

#: src/class/protocols.md:32
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:33
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:34
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:36
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:38
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:40
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:46
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:47
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:49
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:51
msgid ""
"Objects that compare equal must have the same hash value. Any type up to 64 "
"bits may be returned instead of `isize`, PyO3 will convert to an isize "
"automatically (wrapping unsigned types like `u64` and `usize`)."
msgstr ""

#: src/class/protocols.md:55
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to `None`. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/protocols.md:72
msgid "`__lt__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:73
msgid "`__le__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:74
msgid "`__eq__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:75
msgid "`__ne__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:76
msgid "`__gt__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:77
msgid "`__ge__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:79
msgid ""
"The implementations of Python's \"rich comparison\" operators `<`, `<=`, "
"`==`, `!=`, `>` and `>=` respectively."
msgstr ""

#: src/class/protocols.md:81
msgid ""
"_Note that implementing any of these methods will cause Python not to "
"generate a default XXXXXXXXXX implementation, so consider also implementing "
"XXXXXXXXXX._"
msgstr ""

#: src/class/protocols.md:87
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:89
msgid ""
"Implements Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`) in a single method. The `CompareOp` argument indicates the comparison "
"operation being performed. You can use [`CompareOp::matches`](https://pyo3."
"rs/main/doc/pyo3/pyclass/enum.CompareOp.html#method.matches) to adapt a Rust "
"`std::cmp::Ordering` result to the requested comparison."
msgstr ""

#: src/class/protocols.md:93
msgid ""
"_This method cannot be implemented in combination with any of XXXXXXXX, "
"XXXXXXXX, XXXXXXXX, XXXXXXXX, XXXXXXXX, or XXXXXXXX._"
msgstr ""

#: src/class/protocols.md:95
msgid ""
"_Note that implementing XXXXXXXXXXXXX will cause Python not to generate a "
"default XXXXXXXXXX implementation, so consider implementing XXXXXXXXXX when "
"implementing XXXXXXXXXXXXX._"
msgstr ""

#: src/class/protocols.md:100
msgid ""
"If you want to leave some operations unimplemented, you can return `py."
"NotImplemented()` for some of the operations:"
msgstr ""

#: src/class/protocols.md:125
msgid ""
"If the second argument `object` is not of the type specified in the "
"signature, the generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class/protocols.md:129
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:130
msgid "`__getattribute__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:140
msgid "`__setattr__(<self>, value: object) -> ()`"
msgstr ""

#: src/class/protocols.md:141
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:143
msgid "Overrides attribute access."
msgstr ""

#: src/class/protocols.md:145
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:147
msgid "Determines the \"truthyness\" of an object."
msgstr ""

#: src/class/protocols.md:149
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:152
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:154
msgid "Iterators can be defined using these methods:"
msgstr ""

#: src/class/protocols.md:156
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:157
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:159
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items."
msgstr ""

#: src/class/protocols.md:161 src/class/protocols.md:440
msgid "Example:"
msgstr ""

#: src/class/protocols.md:184
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, the "
"iterable only needs to implement `__iter__()` while the iterator must "
"implement both `__iter__()` and `__next__()`. For example:"
msgstr ""

#: src/class/protocols.md:226
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:227
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:231
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:234
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:236
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration.  In Python a generator can also return a value. "
"This is done by raising a `StopIteration` exception. To express this in "
"Rust, return `PyResult::Err` with a `PyStopIteration` as the error."
msgstr ""

#: src/class/protocols.md:241
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:243
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:244
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:245
msgid "`__anext__(<self>) -> Option<object>`"
msgstr ""

#: src/class/protocols.md:247
msgid "Mapping & Sequence types"
msgstr ""

#: src/class/protocols.md:249
msgid ""
"The magic methods in this section can be used to implement Python container "
"types. They are two main categories of container in Python: \"mappings\" "
"such as `dict`, with arbitrary keys, and \"sequences\" such as `list` and "
"`tuple`, with integer keys."
msgstr ""

#: src/class/protocols.md:251
msgid ""
"The Python C-API which PyO3 is built upon has separate \"slots\" for "
"sequences and mappings. When writing a `class` in pure Python, there is no "
"such distinction in the implementation - a `__getitem__` implementation will "
"fill the slots for both the mapping and sequence forms, for example."
msgstr ""

#: src/class/protocols.md:253
msgid ""
"By default PyO3 reproduces the Python behaviour of filling both mapping and "
"sequence slots. This makes sense for the \"simple\" case which matches "
"Python, and also for sequences, where the mapping slot is used anyway to "
"implement slice indexing."
msgstr ""

#: src/class/protocols.md:255
msgid ""
"Mapping types usually will not want the sequence slots filled. Having them "
"filled will lead to outcomes which may be unwanted, such as:"
msgstr ""

#: src/class/protocols.md:257
msgid ""
"The mapping type will successfully cast to [`PySequence`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PySequence.html). This may lead to consumers of "
"the type handling it incorrectly."
msgstr ""

#: src/class/protocols.md:258
msgid ""
"Python provides a default implementation of `__iter__` for sequences, which "
"calls `__getitem__` with consecutive positive integers starting from 0 until "
"an `IndexError` is returned. Unless the mapping only contains consecutive "
"positive integer keys, this `__iter__` implementation will likely not be the "
"intended behavior."
msgstr ""

#: src/class/protocols.md:260
msgid ""
"Use the `#[pyclass(mapping)]` annotation to instruct PyO3 to only fill the "
"mapping slots, leaving the sequence ones empty. This will apply to "
"`__getitem__`, `__setitem__`, and `__delitem__`."
msgstr ""

#: src/class/protocols.md:262
msgid ""
"Use the `#[pyclass(sequence)]` annotation to instruct PyO3 to fill the "
"`sq_length` slot instead of the `mp_length` slot for `__len__`. This will "
"help libraries such as `numpy` recognise the class as a sequence, however "
"will also cause CPython to automatically add the sequence length to any "
"negative indices before passing them to `__getitem__`. (`__getitem__`, "
"`__setitem__` and `__delitem__` mapping slots are still used for sequences, "
"for slice operations.)"
msgstr ""

#: src/class/protocols.md:264
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:266
msgid "Implements the built-in function `len()`."
msgstr ""

#: src/class/protocols.md:268
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:270
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that don‚Äôt define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:278
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:298
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:300
msgid "Implements retrieval of the `self[a]` element."
msgstr ""

#: src/class/protocols.md:302
msgid ""
"_Note:_ Negative integer indexes are not handled specially by PyO3. However, "
"for classes with `#[pyclass(sequence)]`, when a negative index is accessed "
"via `PySequence::get_item`, the underlying C API already adjusts the index "
"to be positive."
msgstr ""

#: src/class/protocols.md:307
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:309
msgid ""
"Implements assignment to the `self[a]` element. Should only be implemented "
"if elements can be replaced."
msgstr ""

#: src/class/protocols.md:312 src/class/protocols.md:319
msgid "Same behavior regarding negative indices as for `__getitem__`."
msgstr ""

#: src/class/protocols.md:314
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:316
msgid ""
"Implements deletion of the `self[a]` element. Should only be implemented if "
"elements can be deleted."
msgstr ""

#: src/class/protocols.md:321
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:323
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `__add__` and `__radd__` methods."
msgstr ""

#: src/class/protocols.md:327
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:329
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `__mul__` and `__rmul__` methods."
msgstr ""

#: src/class/protocols.md:333
msgid ""
"`fn __inplace_concat__(&self, other: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:335
msgid ""
"Concatenates two sequences. Used by the `+=` operator, after trying the "
"numeric addition via the `__iadd__` method."
msgstr ""

#: src/class/protocols.md:339
msgid ""
"`fn __inplace_repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:341
msgid ""
"Concatenates two sequences. Used by the `*=` operator, after trying the "
"numeric multiplication via the `__imul__` method."
msgstr ""

#: src/class/protocols.md:345
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:347
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:348
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:349
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:351
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:353
msgid ""
"Binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, "
"`divmod()`, `pow()` and `**`, `<<`, `>>`, `&`, `^`, and `|`) and their "
"reflected versions:"
msgstr ""

#: src/class/protocols.md:356
msgid ""
"(If the `object` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`.)"
msgstr ""

#: src/class/protocols.md:359
msgid "`__add__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:360
msgid "`__radd__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:361
msgid "`__sub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:362
msgid "`__rsub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:363
msgid "`__mul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:364
msgid "`__rmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:365
msgid "`__matmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:366
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:367
msgid "`__floordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:368
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:369
msgid "`__truediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:370
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:371
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:372
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:373
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:374
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:375
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:376
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:377
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:378
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:379
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:380
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:381
msgid "`__xor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:382
msgid "`__rxor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:383
msgid "`__or__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:384
msgid "`__ror__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:385
msgid "`__pow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:386
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:388
msgid ""
"In-place assignment operations (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, "
"`**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:391
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:392
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:393
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:394
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:395
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:396
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:397
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:398
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:399
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:400
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:401
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:402
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:403
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:405
msgid "Unary operations (`-`, `+`, `abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:407
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:408
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:409
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:410
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:412
msgid "Coercions:"
msgstr ""

#: src/class/protocols.md:414
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:415
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:416
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:418
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:420
msgid "`__getbuffer__(<self>, *mut ffi::Py_buffer, flags) -> ()`"
msgstr ""

#: src/class/protocols.md:421
msgid ""
"`__releasebuffer__(<self>, *mut ffi::Py_buffer) -> ()` Errors returned from "
"`__releasebuffer__` will be sent to `sys.unraiseablehook`. It is strongly "
"advised to never return an error from `__releasebuffer__`, and if it really "
"is necessary, to make best effort to perform any required freeing operations "
"before returning. `__releasebuffer__` will not be called a second time; "
"anything not freed will be leaked."
msgstr ""

#: src/class/protocols.md:424
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:426
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references.  To do this, implement the two methods `__traverse__` and "
"`__clear__`.  These correspond to the slots `tp_traverse` and `tp_clear` in "
"the Python C API. `__traverse__` must call `visit.call()` for each reference "
"to another Python object.  `__clear__` must clear out any mutable references "
"to other Python objects (thus breaking reference cycles). Immutable "
"references do not have to be cleared, as every cycle must contain at least "
"one mutable reference."
msgstr ""

#: src/class/protocols.md:435
msgid ""
"`__traverse__(<self>, pyo3::class::gc::PyVisit<'_>) -> Result<(), pyo3::"
"class::gc::PyTraverseError>`"
msgstr ""

#: src/class/protocols.md:436
msgid "`__clear__(<self>) -> ()`"
msgstr ""

#: src/class/protocols.md:438
msgid ""
"Note: `__traverse__` does not work with [`#[pyo3(warn(...))]`](../function."
"md#warn)."
msgstr ""

#: src/class/protocols.md:460
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:466
msgid ""
"Usually, an implementation of `__traverse__` should do nothing but calls to "
"`visit.call`. Most importantly, safe access to the interpreter is prohibited "
"inside implementations of `__traverse__`, i.e. `Python::attach` will panic."
msgstr ""

#: src/class/protocols.md:470
msgid ""
"Note: these methods are part of the C API, PyPy does not necessarily honor "
"them. If you are building for PyPy you should measure memory consumption to "
"make sure you do not have runaway memory growth. See [this issue on the PyPy "
"bug tracker](https://github.com/pypy/pypy/issues/3848)."
msgstr ""

#: src/class/object.md:3
msgid "Recall the `Number` class from the previous chapter:"
msgstr ""

#: src/class/object.md:28
msgid ""
"At this point Python code can import the module, access the class and create "
"class instances - but nothing else."
msgstr ""

#: src/class/object.md:42
msgid "String representations"
msgstr ""

#: src/class/object.md:44
msgid ""
"It can't even print an user-readable representation of itself! We can fix "
"that by defining the `__repr__` and `__str__` methods inside a "
"`#[pymethods]` block. We do this by accessing the value contained inside "
"`Number`."
msgstr ""

#: src/class/object.md:56
msgid ""
"// For `__repr__` we want to return a string that Python code could use to "
"recreate\n"
"    // the `Number`, like `Number(5)` for example.\n"
msgstr ""

#: src/class/object.md:59
msgid ""
"// We use the `format!` macro to create a string. Its first argument is a\n"
"        // format string, followed by any number of parameters which replace "
"the\n"
"        // `{}`'s in the format string.\n"
"        //\n"
"        //                       üëá Tuple field access in Rust uses a dot\n"
msgstr ""

#: src/class/object.md:64
msgid "\"Number({})\""
msgstr ""

#: src/class/object.md:66
msgid ""
"// `__str__` is generally used to create an \"informal\" representation, so "
"we\n"
"    // just forward to `i32`'s `ToString` trait implementation to print a "
"bare number.\n"
msgstr ""

#: src/class/object.md:74
msgid ""
"To automatically generate the `__str__` implementation using a `Display` "
"trait implementation, pass the `str` argument to `pyclass`."
msgstr ""

#: src/class/object.md:90
msgid "\"({}, {}, {})\""
msgstr ""

#: src/class/object.md:95
msgid ""
"For convenience, a shorthand format string can be passed to `str` as "
"`str=\"<format string>\"` for **structs only**.  It expands and is passed "
"into the `format!` macro in the following ways:"
msgstr ""

#: src/class/object.md:97
msgid "`\"{x}\"` -> `\"{}\", self.x`"
msgstr ""

#: src/class/object.md:98
msgid "`\"{0}\"` -> `\"{}\", self.0`"
msgstr ""

#: src/class/object.md:99
msgid "`\"{x:?}\"` -> `\"{:?}\", self.x`"
msgstr ""

#: src/class/object.md:101
msgid ""
"_Note: Depending upon the format string you use, this may require "
"implementation of the `Display` or `Debug` traits for the given Rust types._ "
"_Note: the pyclass args `name` and `rename_all` are incompatible with the "
"shorthand format string and will raise a compile time error._"
msgstr ""

#: src/class/object.md:108
msgid "\"({x}, {y}, {z})\""
msgstr ""

#: src/class/object.md:116
msgid "Accessing the class name"
msgstr ""

#: src/class/object.md:118
msgid ""
"In the `__repr__`, we used a hard-coded class name. This is sometimes not "
"ideal, because if the class is subclassed in Python, we would like the repr "
"to reflect the subclass name. This is typically done in Python code by "
"accessing `self.__class__.__name__`. In order to be able to access the "
"Python type information _and_ the Rust struct, we need to use a `Bound` as "
"the `self` argument."
msgstr ""

#: src/class/object.md:135
msgid "// This is the equivalent of `self.__class__.__name__` in Python.\n"
msgstr ""

#: src/class/object.md:137
msgid ""
"// To access fields of the Rust struct, we need to borrow from the Bound "
"object.\n"
msgstr ""

#: src/class/object.md:138 src/class/object.md:358
msgid "\"{}({})\""
msgstr ""

#: src/class/object.md:143
msgid "Hashing"
msgstr ""

#: src/class/object.md:145
msgid ""
"Let's also implement hashing. We'll just hash the `i32`. For that we need a "
"[`Hasher`](https://doc.rust-lang.org/std/hash/trait.Hasher.html). The one "
"provided by `std` is [`DefaultHasher`](https://doc.rust-lang.org/std/"
"collections/hash_map/struct.DefaultHasher.html), which uses the [SipHash]"
"(https://en.wikipedia.org/wiki/SipHash) algorithm."
msgstr ""

#: src/class/object.md:150
msgid ""
"// Required to call the `.hash` and `.finish` methods, which are defined on "
"traits.\n"
msgstr ""

#: src/class/object.md:170
msgid ""
"To implement `__hash__` using the Rust [`Hash`](https://doc.rust-lang.org/"
"std/hash/trait.Hash.html) trait implementation, the `hash` option can be "
"used. This option is only available for `frozen` classes to prevent "
"accidental hash changes from mutating the object. If you need an `__hash__` "
"implementation for a mutable class, use the manual method from above. This "
"option also requires `eq`: According to the [Python docs](https://docs."
"python.org/3/reference/datamodel.html#object.__hash__) \"If a class does not "
"define an `__eq__()` method it should not define a `__hash__()` operation "
"either\""
msgstr ""

#: src/class/object.md:187
msgid ""
"**Note**: When implementing `__hash__` and comparisons, it is important that "
"the following property holds:"
msgstr ""

#: src/class/object.md:193
msgid ""
"In other words, if two keys are equal, their hashes must also be equal. In "
"addition you must take care that your classes' hash doesn't change during "
"its lifetime. In this tutorial we do that by not letting Python code change "
"our `Number` class. In other words, it is immutable."
msgstr ""

#: src/class/object.md:197
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to None. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/object.md:215
msgid "Comparisons"
msgstr ""

#: src/class/object.md:217
msgid ""
"PyO3 supports the usual magic comparison methods available in Python such as "
"`__eq__`, `__lt__` and so on. It is also possible to support all six "
"operations at once with `__richcmp__`. This method will be called with a "
"value of `CompareOp` depending on the operation."
msgstr ""

#: src/class/object.md:245
msgid ""
"If you obtain the result by comparing two Rust values, as in this example, "
"you can take a shortcut using `CompareOp::matches`:"
msgstr ""

#: src/class/object.md:265
msgid ""
"It checks that the `std::cmp::Ordering` obtained from Rust's `Ord` matches "
"the given `CompareOp`."
msgstr ""

#: src/class/object.md:268
msgid "Alternatively, you can implement just equality using `__eq__`:"
msgstr ""

#: src/class/object.md:294
msgid ""
"To implement `__eq__` using the Rust [`PartialEq`](https://doc.rust-lang.org/"
"stable/std/cmp/trait.PartialEq.html) trait implementation, the `eq` option "
"can be used."
msgstr ""

#: src/class/object.md:305
msgid ""
"To implement `__lt__`, `__le__`, `__gt__`, & `__ge__` using the Rust "
"`PartialOrd` trait implementation, the `ord` option can be used. _Note: "
"Requires `eq`._"
msgstr ""

#: src/class/object.md:316
msgid "Truthyness"
msgstr ""

#: src/class/object.md:318
msgid "We'll consider `Number` to be `True` if it is nonzero:"
msgstr ""

#: src/class/object.md:335
msgid "Final code"
msgstr ""

#: src/class/call.md:3
msgid ""
"Classes can be callable if they have a `#[pymethod]` named `__call__`. This "
"allows instances of a class to behave similar to functions."
msgstr ""

#: src/class/call.md:6
msgid ""
"This method's signature must look like `__call__(<self>, ...) -> object` - "
"here, any argument list can be defined as for normal pymethods"
msgstr ""

#: src/class/call.md:9
msgid "Example: Implementing a call counter"
msgstr ""

#: src/class/call.md:11
msgid ""
"The following pyclass is a basic decorator - its constructor takes a Python "
"object as argument and calls that object when called. An equivalent Python "
"implementation is linked at the end."
msgstr ""

#: src/class/call.md:15
msgid ""
"An example crate containing this pyclass can be found [here](https://github."
"com/PyO3/pyo3/tree/main/examples/decorator)"
msgstr ""

#: src/class/call.md:21
msgid ""
"/// A function decorator that keeps track how often it is called.\n"
"///\n"
"/// It otherwise doesn't do anything special.\n"
msgstr ""

#: src/class/call.md:25
msgid "\"Counter\""
msgstr ""

#: src/class/call.md:27
msgid ""
"// Keeps track of how many calls have gone through.\n"
"    //\n"
"    // See the discussion at the end for why `AtomicU64` is used.\n"
msgstr ""

#: src/class/call.md:32
msgid "// This is the actual function being wrapped.\n"
msgstr ""

#: src/class/call.md:38
msgid ""
"// Note that we don't validate whether `wraps` is actually callable.\n"
"    //\n"
"    // While we could use `PyAny::is_callable` for that, it has some flaws:\n"
"    //    1. It doesn't guarantee the object can actually be called "
"successfully\n"
"    //    2. We still need to handle any exceptions that the function might "
"raise\n"
msgstr ""

#: src/class/call.md:66
msgid "\"{name} has been called {new_count} time(s).\""
msgstr ""

#: src/class/call.md:68 src/class/call.md:162
msgid ""
"// After doing something, we finally forward the call to the wrapped "
"function\n"
msgstr ""

#: src/class/call.md:71
msgid ""
"// We could do something with the return value of\n"
"        // the function before returning it\n"
msgstr ""

#: src/class/call.md:84
msgid "Python code:"
msgstr ""

#: src/class/call.md:103
msgid "Output:"
msgstr ""

#: src/class/call.md:116
msgid "Pure Python implementation"
msgstr ""

#: src/class/call.md:118
msgid "A Python implementation of this looks similar to the Rust version:"
msgstr ""

#: src/class/call.md:128 src/class/call.md:140
msgid " has been called "
msgstr ""

#: src/class/call.md:128 src/class/call.md:140
msgid " time(s)\""
msgstr ""

#: src/class/call.md:132
msgid "Note that it can also be implemented as a higher order function:"
msgstr ""

#: src/class/call.md:145
msgid "What is the `AtomicU64` for?"
msgstr ""

#: src/class/call.md:147
msgid ""
"A [previous implementation](https://github.com/PyO3/pyo3/discussions/2598 "
"\"Thread Safe Decorator <Help Wanted> ¬∑ Discussion #2598 ¬∑ PyO3/pyo3\") used "
"a normal `u64`, which meant it required a `&mut self` receiver to update the "
"count:"
msgstr ""

#: src/class/call.md:160
msgid "\"{} has been called {} time(s).\""
msgstr ""

#: src/class/call.md:165
msgid ""
"// We could do something with the return value of\n"
"    // the function before returning it\n"
msgstr ""

#: src/class/call.md:171
msgid ""
"The problem with this is that the `&mut self` receiver means PyO3 has to "
"borrow it exclusively, and hold this borrow across the`self.wraps.call(py, "
"args, kwargs)` call. This call returns control to the user's Python code "
"which is free to call arbitrary things, _including_ the decorated function. "
"If that happens PyO3 is unable to create a second unique borrow and will be "
"forced to raise an exception."
msgstr ""

#: src/class/call.md:175
msgid "As a result, something innocent like this will raise an exception:"
msgstr ""

#: src/class/call.md:181
msgid "\"hello from decorator\""
msgstr ""

#: src/class/call.md:183
msgid "# RuntimeError: Already borrowed\n"
msgstr ""

#: src/class/call.md:187
msgid ""
"The implementation in this chapter fixes that by never borrowing "
"exclusively; all the methods take `&self` as receivers, of which multiple "
"may exist simultaneously. This requires a shared counter and the most "
"straightforward way to implement thread-safe interior mutability (e.g. the "
"type does not need to accept `&mut self` to modify the \"interior\" state) "
"for a `u64` is to use [`AtomicU64`](https://doc.rust-lang.org/std/sync/"
"atomic/struct.AtomicU64.html \"AtomicU64 in std::sync::atomic - Rust\"), so "
"that's what is used here."
msgstr ""

#: src/class/call.md:189
msgid ""
"This shows the dangers of running arbitrary Python code - note that "
"\"running arbitrary Python code\" can be far more subtle than the example "
"above:"
msgstr ""

#: src/class/call.md:191
msgid ""
"Python's asynchronous executor may park the current thread in the middle of "
"Python code, even in Python code that _you_ control, and let other Python "
"code run."
msgstr ""

#: src/class/call.md:192
msgid ""
"Dropping arbitrary Python objects may invoke destructors defined in Python "
"(`__del__` methods)."
msgstr ""

#: src/class/call.md:193
msgid ""
"Calling Python's C-api (most PyO3 apis call C-api functions internally) may "
"raise exceptions, which may allow Python code in signal handlers to run."
msgstr ""

#: src/class/call.md:194
msgid ""
"On the free-threaded build, users might use Python's `threading` module to "
"work with your types simultaneously from multiple OS threads."
msgstr ""

#: src/class/call.md:196
msgid ""
"This is especially important if you are writing unsafe code; Python code "
"must never be able to cause undefined behavior. You must ensure that your "
"Rust code is in a consistent state before doing any of the above things."
msgstr ""

#: src/class/numeric.md:3
msgid ""
"At this point we have a `Number` class that we can't actually do any math on!"
msgstr ""

#: src/class/numeric.md:5
msgid ""
"Before proceeding, we should think about how we want to handle overflows. "
"There are three obvious solutions:"
msgstr ""

#: src/class/numeric.md:7
msgid ""
"We can have infinite precision just like Python's `int`. However that would "
"be quite boring - we'd"
msgstr ""

#: src/class/numeric.md:9
msgid "be reinventing the wheel."
msgstr ""

#: src/class/numeric.md:11
msgid ""
"We can raise exceptions whenever `Number` overflows, but that makes the API "
"painful to use."
msgstr ""

#: src/class/numeric.md:12
msgid ""
"We can wrap around the boundary of `i32`. This is the approach we'll take "
"here. To do that we'll just forward to `i32`'s"
msgstr ""

#: src/class/numeric.md:14
msgid "`wrapping_*` methods."
msgstr ""

#: src/class/numeric.md:16
msgid "Fixing our constructor"
msgstr ""

#: src/class/numeric.md:18
msgid "Let's address the first overflow, in `Number`'s constructor:"
msgstr ""

#: src/class/numeric.md:26
msgid ""
"```text\n"
"Traceback (most recent call last):\n"
"  File \"example.py\", line 3, in <module>\n"
"    n = Number(1 << 1337)\n"
"OverflowError: Python int too large to convert to C long\n"
"```"
msgstr ""

#: src/class/numeric.md:33
msgid ""
"Instead of relying on the default [`FromPyObject`](https://pyo3.rs/main/doc/"
"pyo3/conversion/trait.FromPyObject.html) extraction to parse arguments, we "
"can specify our own extraction function, using the `#[pyo3(from_py_with "
"= ...)]` attribute. Unfortunately PyO3 doesn't provide a way to wrap Python "
"integers out of the box, but we can do a Python call to mask it and cast it "
"to an `i32`."
msgstr ""

#: src/class/numeric.md:43 src/class/numeric.md:57 src/class/numeric.md:221
msgid "\"__and__\""
msgstr ""

#: src/class/numeric.md:45
msgid "//     üëá This intentionally overflows!\n"
msgstr ""

#: src/class/numeric.md:50
msgid ""
"We also add documentation, via `///` comments, which are visible to Python "
"users."
msgstr ""

#: src/class/numeric.md:61 src/class/numeric.md:224
msgid ""
"/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought "
"not.\n"
"/// It's not a story C would tell you. It's a Rust legend.\n"
msgstr ""

#: src/class/numeric.md:76
msgid "With that out of the way, let's implement some operators:"
msgstr ""

#: src/class/numeric.md:103 src/class/numeric.md:110 src/class/numeric.md:283
#: src/class/numeric.md:290
msgid "\"division by zero\""
msgstr ""

#: src/class/numeric.md:117 src/class/numeric.md:124 src/class/numeric.md:297
#: src/class/numeric.md:304
msgid "\"negative shift count\""
msgstr ""

#: src/class/numeric.md:130
msgid "Unary arithmetic operations"
msgstr ""

#: src/class/numeric.md:158
msgid "Support for the `complex()`, `int()` and `float()` built-in functions"
msgstr ""

#: src/class/numeric.md:184
msgid ""
"We do not implement the in-place operations like `__iadd__` because we do "
"not wish to mutate `Number`. Similarly we're not interested in supporting "
"operations with different types, so we do not implement the reflected "
"operations like `__radd__` either."
msgstr ""

#: src/class/numeric.md:188
msgid "Now Python can use our `Number` class:"
msgstr ""

#: src/class/numeric.md:194
msgid ""
"'''\n"
"\tA version of Daniel J. Bernstein's djb2 string hashing algorithm\n"
"\tLike many hashing algorithms, it relies on integer wrapping.\n"
"\t'''"
msgstr ""

#: src/class/numeric.md:206
msgid "'l50_50'"
msgstr ""

#: src/class/numeric.md:238
msgid "// Get the class name dynamically in case `Number` is subclassed\n"
msgstr ""

#: src/class/numeric.md:338
msgid ""
"r#\"\n"
"# def hash_djb2(s: str):\n"
"#     n = Number(0)\n"
"#     five = Number(5)\n"
"#\n"
"#     for x in s:\n"
"#         n = Number(ord(x)) + ((n << five) - n)\n"
"#     return n\n"
"#\n"
"# assert hash_djb2('l50_50') == Number(-1152549421)\n"
"# assert hash_djb2('logo') == Number(3327403)\n"
"# assert hash_djb2('horizon') == Number(1097468315)\n"
"#\n"
"#\n"
"# assert Number(2) + Number(2) == Number(4)\n"
"# assert Number(2) + Number(2) != Number(5)\n"
"#\n"
"# assert Number(13) - Number(7) == Number(6)\n"
"# assert Number(13) - Number(-7) == Number(20)\n"
"#\n"
"# assert Number(13) / Number(7) == Number(1)\n"
"# assert Number(13) // Number(7) == Number(1)\n"
"#\n"
"# assert Number(13) * Number(7) == Number(13*7)\n"
"#\n"
"# assert Number(13) > Number(7)\n"
"# assert Number(13) < Number(20)\n"
"# assert Number(13) == Number(13)\n"
"# assert Number(13) >= Number(7)\n"
"# assert Number(13) <= Number(20)\n"
"# assert Number(13) == Number(13)\n"
"#\n"
"#\n"
"# assert (True if Number(1) else False)\n"
"# assert (False if Number(0) else True)\n"
"#\n"
"#\n"
"# assert int(Number(13)) == 13\n"
"# assert float(Number(13)) == 13\n"
"# assert Number.__doc__ == \"Did you ever hear the tragedy of Darth Signed "
"The Overfloweth? I thought not.\\nIt's not a story C would tell you. It's a "
"Rust legend.\"\n"
"# assert Number(12345234523452) == Number(1498514748)\n"
"# try:\n"
"#     import inspect\n"
"#     assert inspect.signature(Number).__str__() == '(value)'\n"
"# except ValueError:\n"
"#     # Not supported with `abi3` before Python 3.10\n"
"#     pass\n"
"# assert Number(1337).__str__() == '1337'\n"
"# assert Number(1337).__repr__() == 'Number(1337)'\n"
"\"#"
msgstr ""

#: src/class/numeric.md:395
msgid "\"Number\""
msgstr ""

#: src/class/numeric.md:403
msgid "Appendix: Writing some unsafe code"
msgstr ""

#: src/class/numeric.md:405
msgid ""
"At the beginning of this chapter we said that PyO3 doesn't provide a way to "
"wrap Python integers out of the box but that's a half truth. There's not a "
"PyO3 API for it, but there's a Python C API function that does:"
msgstr ""

#: src/class/numeric.md:413
msgid ""
"We can call this function from Rust by using [`pyo3::ffi::"
"PyLong_AsUnsignedLongMask`](https://pyo3.rs/main/doc/pyo3/ffi/fn."
"PyLong_AsUnsignedLongMask.html). This is an _unsafe_ function, which means "
"we have to use an unsafe block to call it and take responsibility for "
"upholding the contracts of this function. Let's review those contracts:"
msgstr ""

#: src/class/numeric.md:417
msgid ""
"We must be attached to the interpreter. If we're not, calling this function "
"causes a data race."
msgstr ""

#: src/class/numeric.md:418
msgid ""
"The pointer must be valid, i.e. it must be properly aligned and point to a "
"valid Python object."
msgstr ""

#: src/class/numeric.md:420
msgid ""
"Let's create that helper function. The signature has to be `fn(&Bound<'_, "
"PyAny>) -> PyResult<T>`."
msgstr ""

#: src/class/numeric.md:422
msgid ""
"`&Bound<'_, PyAny>` represents a checked bound reference, so the pointer "
"derived from it is valid (and not null)."
msgstr ""

#: src/class/numeric.md:423
msgid ""
"Whenever we have bound references to Python objects in scope, it is "
"guaranteed that we're attached to the interpreter. This reference is also "
"where we can get a [`Python`](https://pyo3.rs/main/doc/pyo3/marker/struct."
"Python.html) token to use in our call to [`PyErr::take`](https://pyo3.rs/"
"main/doc/pyo3/prelude/struct.PyErr.html#method.take)."
msgstr ""

#: src/class/thread-safety.md:1
msgid "`#[pyclass]` thread safety"
msgstr ""

#: src/class/thread-safety.md:5
msgid ""
"there is no control which thread might eventually drop the `#[pyclass]` "
"object, meaning `Send` is required."
msgstr ""

#: src/class/thread-safety.md:6
msgid ""
"multiple threads can potentially be reading the `#[pyclass]` data "
"simultaneously, meaning `Sync` is required."
msgstr ""

#: src/class/thread-safety.md:8
msgid ""
"This section of the guide discusses various data structures which can be "
"used to make types satisfy these requirements."
msgstr ""

#: src/class/thread-safety.md:10
msgid ""
"In special cases where it is known that your Python application is never "
"going to use threads (this is rare!), these thread-safety requirements can "
"be opted-out with [`#[pyclass(unsendable)]`](../class.md#customizing-the-"
"class), at the cost of making concurrent access to the Rust data be runtime "
"errors. This is only for very specific use cases; it is almost always better "
"to make proper thread-safe types."
msgstr ""

#: src/class/thread-safety.md:12
msgid "Making `#[pyclass]` types thread-safe"
msgstr ""

#: src/class/thread-safety.md:14
msgid ""
"The general challenge with thread-safety is to make sure that two threads "
"cannot produce a data race, i.e. unsynchronized writes to the same data at "
"the same time. A data race produces an unpredictable result and is forbidden "
"by Rust."
msgstr ""

#: src/class/thread-safety.md:16
msgid ""
"By default, `#[pyclass]` employs an [\"interior mutability\" pattern](../"
"class.md#bound-and-interior-mutability) to allow for either multiple `&T` "
"references or a single exclusive `&mut T` reference to access the data. This "
"allows for simple `#[pyclass]` types to be thread-safe automatically, at the "
"cost of runtime checking for concurrent access. Errors will be raised if the "
"usage overlaps."
msgstr ""

#: src/class/thread-safety.md:18
msgid "For example, the below simple class is thread-safe:"
msgstr ""

#: src/class/thread-safety.md:41
msgid ""
"In the above example, if calls to `get_x` and `set_y` overlap (from two "
"different threads) then at least one of those threads will experience a "
"runtime error indicating that the data was \"already borrowed\"."
msgstr ""

#: src/class/thread-safety.md:43
msgid ""
"To avoid these errors, you can take control of the interior mutability "
"yourself in one of the following ways."
msgstr ""

#: src/class/thread-safety.md:45
msgid "Using atomic data structures"
msgstr ""

#: src/class/thread-safety.md:47
msgid ""
"To remove the possibility of having overlapping `&self` and `&mut self` "
"references produce runtime errors, consider using `#[pyclass(frozen)]` and "
"use [atomic data structures](https://doc.rust-lang.org/std/sync/atomic/) to "
"control modifications directly."
msgstr ""

#: src/class/thread-safety.md:49
msgid ""
"For example, a thread-safe version of the above `MyClass` using atomic "
"integers would be as follows:"
msgstr ""

#: src/class/thread-safety.md:73
msgid "Using locks"
msgstr ""

#: src/class/thread-safety.md:75
msgid ""
"An alternative to atomic data structures is to use [locks](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html) to make threads wait for access to "
"shared data."
msgstr ""

#: src/class/thread-safety.md:77
msgid ""
"For example, a thread-safe version of the above `MyClass` using locks would "
"be as follows:"
msgstr ""

#: src/class/thread-safety.md:96 src/class/thread-safety.md:100
msgid "\"lock not poisoned\""
msgstr ""

#: src/class/thread-safety.md:105
msgid ""
"If you need to lock around state stored in the Python interpreter or "
"otherwise call into the Python C API while a lock is held, you might find "
"the `MutexExt` trait useful. It provides a `lock_py_attached` method for "
"`std::sync::Mutex` that avoids deadlocks with the GIL or other global "
"synchronization events in the interpreter. Additionally, support for the "
"`parking_lot` and `lock_api` synchronization libraries is gated behind the "
"`parking_lot` and `lock_api` features. You can also enable the `arc_lock` "
"feature if you need the `arc_lock` features of either library."
msgstr ""

#: src/class/thread-safety.md:107
msgid "Wrapping unsynchronized data"
msgstr ""

#: src/class/thread-safety.md:109
msgid ""
"In some cases, the data structures stored within a `#[pyclass]` may "
"themselves not be thread-safe. Rust will therefore not implement `Send` and "
"`Sync` on the `#[pyclass]` type."
msgstr ""

#: src/class/thread-safety.md:111
msgid ""
"To achieve thread-safety, a manual `Send` and `Sync` implementation is "
"required which is `unsafe` and should only be done following careful review "
"of the soundness of the implementation. Doing this for PyO3 types is no "
"different than for any other Rust code, [the Rustonomicon](https://doc.rust-"
"lang.org/nomicon/send-and-sync.html) has a great discussion on this."
msgstr ""

#: src/function.md:3
msgid ""
"The `#[pyfunction]` attribute is used to define a Python function from a "
"Rust function. Once defined, the function needs to be added to a [module](./"
"module.md)."
msgstr ""

#: src/function.md:5
msgid ""
"The following example defines a function called `double` in a Python module "
"called `my_extension`:"
msgstr ""

#: src/function.md:19
msgid ""
"This chapter of the guide explains full usage of the `#[pyfunction]` "
"attribute. In this first section, the following topics are covered:"
msgstr ""

#: src/function.md:21
msgid "[Function options](#function-options)"
msgstr ""

#: src/function.md:22
msgid "[`#[pyo3(name = \"...\")]`](#name)"
msgstr ""

#: src/function.md:23
msgid "[`#[pyo3(signature = (...))]`](#signature)"
msgstr ""

#: src/function.md:24
msgid "[`#[pyo3(text_signature = \"...\")]`](#text_signature)"
msgstr ""

#: src/function.md:25
msgid "[`#[pyo3(pass_module)]`](#pass_module)"
msgstr ""

#: src/function.md:26
msgid "[`#[pyo3(warn(message = \"...\", category = ...))]`](#warn)"
msgstr ""

#: src/function.md:27
msgid "[Per-argument options](#per-argument-options)"
msgstr ""

#: src/function.md:28
msgid "[Advanced function patterns](#advanced-function-patterns)"
msgstr ""

#: src/function.md:30
msgid "There are also additional sections on the following topics:"
msgstr ""

#: src/function.md:32
msgid "[Function Signatures](./function/signature.md)"
msgstr ""

#: src/function.md:33
msgid "[Error Handling](./function/error-handling.md)"
msgstr ""

#: src/function.md:35
msgid "Function options"
msgstr ""

#: src/function.md:37
msgid ""
"The `#[pyo3]` attribute can be used to modify properties of the generated "
"Python function. It can take any combination of the following options:"
msgstr ""

#: src/function.md:39
msgid "<a id=\"name\"></a> `#[pyo3(name = \"...\")]`"
msgstr ""

#: src/function.md:41
msgid "Overrides the name exposed to Python."
msgstr ""

#: src/function.md:43
msgid ""
"In the following example, the Rust function `no_args_py` will be added to "
"the Python module `module_with_functions` as the Python function `no_args`:"
msgstr ""

#: src/function.md:53 src/function.md:61
msgid "\"no_args\""
msgstr ""

#: src/function.md:62
msgid "\"no_args_py\""
msgstr ""

#: src/function.md:66
msgid "<a id=\"signature\"></a> `#[pyo3(signature = (...))]`"
msgstr ""

#: src/function.md:68
msgid ""
"Defines the function signature in Python. See [Function Signatures](./"
"function/signature.md)."
msgstr ""

#: src/function.md:70
msgid "<a id=\"text_signature\"></a> `#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function.md:72
msgid ""
"Overrides the PyO3-generated function signature visible in Python tooling "
"(such as via [`inspect.signature`](https://docs.python.org/3/library/inspect."
"html#inspect.signature)). See the [corresponding topic in the Function "
"Signatures subchapter](./function/signature.md#making-the-function-signature-"
"available-to-python)."
msgstr ""

#: src/function.md:74
msgid "<a id=\"pass_module\" ></a> `#[pyo3(pass_module)]`"
msgstr ""

#: src/function.md:76
msgid ""
"Set this option to make PyO3 pass the containing module as the first "
"argument to the function. It is then possible to use the module in the "
"function body. The first argument **must** be of type `&Bound<'_, "
"PyModule>`, `Bound<'_, PyModule>`, or `Py<PyModule>`."
msgstr ""

#: src/function.md:78
msgid ""
"The following example creates a function `pyfunction_with_module` which "
"returns the containing module's name (i.e. `module_with_fn`):"
msgstr ""

#: src/function.md:96
msgid "<a id=\"warn\"></a> `#[pyo3(warn(message = \"...\", category = ...))]`"
msgstr ""

#: src/function.md:98
msgid ""
"This option is used to display a warning when the function is used in "
"Python. It is equivalent to [`warnings.warn(message, category)`](https://"
"docs.python.org/3/library/warnings.html#warnings.warn). The `message` "
"parameter is a string that will be displayed when the function is called, "
"and the `category` parameter is optional and has to be a subclass of "
"[`Warning`](https://docs.python.org/3/library/exceptions.html#Warning). When "
"the `category` parameter is not provided, the warning will be defaulted to "
"[`UserWarning`](https://docs.python.org/3/library/exceptions."
"html#UserWarning)."
msgstr ""

#: src/function.md:102
msgid ""
"Note: when used with `#[pymethods]`, this attribute does not work with "
"`#[classattr]` nor `__traverse__` magic method."
msgstr ""

#: src/function.md:104
msgid "The following are examples of using the `#[pyo3(warn)]` attribute:"
msgstr ""

#: src/function.md:115 src/function.md:174
msgid "\"This is a warning message\""
msgstr ""

#: src/function.md:121 src/function.md:177
msgid "\"This function is warning with FutureWarning\""
msgstr ""

#: src/function.md:132
msgid "\"warnings\""
msgstr ""

#: src/function.md:133
msgid "\"record\""
msgstr ""

#: src/function.md:135
msgid "\"catch_warnings\""
msgstr ""

#: src/function.md:138
msgid "\"simplefilter\""
msgstr ""

#: src/function.md:138
msgid "\"always\""
msgstr ""

#: src/function.md:138
msgid "// show all warnings\n"
msgstr ""

#: src/function.md:153
msgid "\"category\""
msgstr ""

#: src/function.md:155
msgid "\"message\""
msgstr ""

#: src/function.md:168
msgid "\"function_with_warning\""
msgstr ""

#: src/function.md:169
msgid "\"function_with_warning_and_custom_category\""
msgstr ""

#: src/function.md:184
msgid ""
"When the functions are called as the following, warnings will be displayed."
msgstr ""

#: src/function.md:194
msgid "The warning output will be:"
msgstr ""

#: src/function.md:201
msgid "Per-argument options"
msgstr ""

#: src/function.md:203
msgid ""
"The `#[pyo3]` attribute can be used on individual arguments to modify "
"properties of them in the generated function. It can take any combination of "
"the following options:"
msgstr ""

#: src/function.md:205
msgid "<a id=\"from_py_with\"></a> `#[pyo3(from_py_with = ...)]`"
msgstr ""

#: src/function.md:207
msgid ""
"Set this on an option to specify a custom function to convert the function "
"argument from Python to the desired Rust type, instead of using the default "
"`FromPyObject` extraction. The function signature must be `fn(&Bound<'_, "
"PyAny>) -> PyResult<T>` where `T` is the Rust type of the argument."
msgstr ""

#: src/function.md:209
msgid ""
"The following example uses `from_py_with` to convert the input Python object "
"to its length:"
msgstr ""

#: src/function.md:229
msgid "Advanced function patterns"
msgstr ""

#: src/function.md:231
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:233
msgid ""
"You can pass Python `def`'d functions and built-in functions to Rust "
"functions [`PyFunction`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFunction.html) corresponds to regular Python functions while "
"[`PyCFunction`](https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html) "
"describes built-ins such as `repr()`."
msgstr ""

#: src/function.md:237
msgid ""
"You can also use [`Bound<'_, PyAny>::is_callable`](https://pyo3.rs/main/doc/"
"pyo3/prelude/trait.PyAnyMethods.html#tymethod.is_callable) to check if you "
"have a callable object. `is_callable` will return `true` for functions "
"(including lambdas), methods and objects with a `__call__` method. You can "
"call the object with [`Bound<'_, PyAny>::call`](https://pyo3.rs/main/doc/"
"pyo3/prelude/trait.PyAnyMethods.html#tymethod.call) with the args as first "
"parameter and the kwargs (or `None`) as second parameter. There are also "
"[`Bound<'_, PyAny>::call0`](https://pyo3.rs/main/doc/pyo3/prelude/trait."
"PyAnyMethods.html#tymethod.call0) with no args and [`Bound<'_, PyAny>::"
"call1`](https://pyo3.rs/main/doc/pyo3/prelude/trait.PyAnyMethods."
"html#tymethod.call1) with only positional args."
msgstr ""

#: src/function.md:243
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:245
msgid ""
"The ways to convert a Rust function into a Python object vary depending on "
"the function:"
msgstr ""

#: src/function.md:247
msgid ""
"Named functions, e.g. `fn foo()`: add `#[pyfunction]` and then use "
"[`wrap_pyfunction!`](https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction."
"html) to get the corresponding [`PyCFunction`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyCFunction.html)."
msgstr ""

#: src/function.md:248
msgid "Anonymous functions (or closures), e.g. `foo: fn()` either:"
msgstr ""

#: src/function.md:249
msgid ""
"use a `#[pyclass]` struct which stores the function as a field and implement "
"`__call__` to call the stored function."
msgstr ""

#: src/function.md:250
msgid ""
"use `PyCFunction::new_closure` to create an object directly from the "
"function."
msgstr ""

#: src/function.md:252
msgid "Accessing the FFI functions"
msgstr ""

#: src/function.md:254
msgid ""
"In order to make Rust functions callable from Python, PyO3 generates an "
"`extern \"C\"` function whose exact signature depends on the Rust "
"signature.  (PyO3 chooses the optimal Python argument passing convention.) "
"It then embeds the call to the Rust function inside this FFI-wrapper "
"function. This wrapper handles extraction of the regular arguments and the "
"keyword arguments from the input `PyObject`s."
msgstr ""

#: src/function.md:260
msgid ""
"The `wrap_pyfunction` macro can be used to directly get a "
"`Bound<PyCFunction>` given a `#[pyfunction]` and a `Bound<PyModule>`: "
"`wrap_pyfunction!(rust_fun, module)`."
msgstr ""

#: src/function/error-handling.md:3
msgid ""
"This chapter contains a little background of error handling in Rust and how "
"PyO3 integrates this with Python exceptions."
msgstr ""

#: src/function/error-handling.md:5
msgid ""
"This covers enough detail to create a `#[pyfunction]` which raises Python "
"exceptions from errors originating in Rust."
msgstr ""

#: src/function/error-handling.md:7
msgid ""
"There is a later section of the guide on [Python exceptions](../exception."
"md) which covers exception types in more detail."
msgstr ""

#: src/function/error-handling.md:9
msgid "Representing Python exceptions"
msgstr ""

#: src/function/error-handling.md:11
msgid ""
"Rust code uses the generic [`Result<T, E>`](https://doc.rust-lang.org/stable/"
"std/result/enum.Result.html) enum to propagate errors. The error type `E` is "
"chosen by the code author to describe the possible errors which can happen."
msgstr ""

#: src/function/error-handling.md:13
msgid ""
"PyO3 has the [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct.PyErr.html) type "
"which represents a Python exception. If a PyO3 API could result in a Python "
"exception being raised, the return type of that `API` will be [`PyResult<T>`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/function/error-handling.md:15
msgid "In summary:"
msgstr ""

#: src/function/error-handling.md:17
msgid ""
"When Python exceptions are raised and caught by PyO3, the exception will be "
"stored in the `Err` variant of the `PyResult`."
msgstr ""

#: src/function/error-handling.md:18
msgid ""
"Passing Python exceptions through Rust code then uses all the \"normal\" "
"techniques such as the `?` operator, with `PyErr` as the error type."
msgstr ""

#: src/function/error-handling.md:19
msgid ""
"Finally, when a `PyResult` crosses from Rust back to Python via PyO3, if the "
"result is an `Err` variant the contained exception will be raised."
msgstr ""

#: src/function/error-handling.md:21
msgid ""
"(There are many great tutorials on Rust error handling and the `?` operator, "
"so this guide will not go into detail on Rust-specific topics.)"
msgstr ""

#: src/function/error-handling.md:23
msgid "Raising an exception from a function"
msgstr ""

#: src/function/error-handling.md:25
msgid ""
"As indicated in the previous section, when a `PyResult` containing an `Err` "
"crosses from Rust to Python, PyO3 will raise the exception contained within."
msgstr ""

#: src/function/error-handling.md:27
msgid ""
"Accordingly, to raise an exception from a `#[pyfunction]`, change the return "
"type `T` to `PyResult<T>`. When the function returns an `Err` it will raise "
"a Python exception. (Other `Result<T, E>` types can be used as long as the "
"error `E` has a `From` conversion for `PyErr`, see [custom Rust error types]"
"(#custom-rust-error-types) below.)"
msgstr ""

#: src/function/error-handling.md:29
msgid "This also works for functions in `#[pymethods]`."
msgstr ""

#: src/function/error-handling.md:31
msgid ""
"For example, the following `check_positive` function raises a `ValueError` "
"when the input is negative:"
msgstr ""

#: src/function/error-handling.md:40
msgid "\"x is negative\""
msgstr ""

#: src/function/error-handling.md:55
msgid ""
"All built-in Python exception types are defined in the [`pyo3::exceptions`]"
"(https://pyo3.rs/main/doc/pyo3/exceptions/index.html) module. They have a "
"`new_err` constructor to directly build a `PyErr`, as seen in the example "
"above."
msgstr ""

#: src/function/error-handling.md:57
msgid "Custom Rust error types"
msgstr ""

#: src/function/error-handling.md:59
msgid ""
"PyO3 will automatically convert a `Result<T, E>` returned by a "
"`#[pyfunction]` into a `PyResult<T>` as long as there is an implementation "
"of `std::from::From<E> for PyErr`. Many error types in the Rust standard "
"library have a [`From`](https://doc.rust-lang.org/stable/std/convert/trait."
"From.html) conversion defined in this way."
msgstr ""

#: src/function/error-handling.md:61
msgid ""
"If the type `E` you are handling is defined in a third-party crate, see the "
"section on [foreign rust error types](#foreign-rust-error-types) below for "
"ways to work with this error."
msgstr ""

#: src/function/error-handling.md:63
msgid ""
"The following example makes use of the implementation of "
"`From<ParseIntError> for PyErr` to raise exceptions encountered when parsing "
"strings as integers:"
msgstr ""

#: src/function/error-handling.md:77
msgid "\"5\""
msgstr ""

#: src/function/error-handling.md:83
msgid ""
"When passed a string which doesn't contain a floating-point number, the "
"exception raised will look like the below:"
msgstr ""

#: src/function/error-handling.md:88
msgid "\"<stdin>\""
msgstr ""

#: src/function/error-handling.md:92
msgid ""
"As a more complete example, the following snippet defines a Rust error named "
"`CustomIOError`. It then defines a `From<CustomIOError> for PyErr`, which "
"returns a `PyErr` representing Python's `OSError`. Therefore, it can use "
"this error in the result of a `#[pyfunction]` directly, relying on the "
"conversion if it has to be propagated into a Python exception."
msgstr ""

#: src/function/error-handling.md:107
msgid "\"Oh no!\""
msgstr ""

#: src/function/error-handling.md:120 src/function/error-handling.md:137
msgid "\"0.0.0.0\""
msgstr ""

#: src/function/error-handling.md:130
msgid "// etc.\n"
msgstr ""

#: src/function/error-handling.md:143
msgid ""
"If lazy construction of the Python exception instance is desired, the "
"[`PyErrArguments`](https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html) "
"trait can be implemented instead of `From`. In that case, actual exception "
"argument creation is delayed until the `PyErr` is needed."
msgstr ""

#: src/function/error-handling.md:148
msgid ""
"A final note is that any errors `E` which have a `From` conversion can be "
"used with the `?` (\"try\") operator with them. An alternative "
"implementation of the above `parse_int` which instead returns `PyResult` is "
"below:"
msgstr ""

#: src/function/error-handling.md:164
msgid "\"1337\""
msgstr ""

#: src/function/error-handling.md:166
msgid "\"-1\""
msgstr ""

#: src/function/error-handling.md:172
msgid "\"13.37\""
msgstr ""

#: src/function/error-handling.md:179
msgid "Foreign Rust error types"
msgstr ""

#: src/function/error-handling.md:181
msgid ""
"The Rust compiler will not permit implementation of traits for types outside "
"of the crate where the type is defined. (This is known as the \"orphan "
"rule\".)"
msgstr ""

#: src/function/error-handling.md:183
msgid ""
"Given a type `OtherError` which is defined in third-party code, there are "
"two main strategies available to integrate it with PyO3:"
msgstr ""

#: src/function/error-handling.md:185
msgid ""
"Create a newtype wrapper, e.g. `MyOtherError`. Then implement "
"`From<MyOtherError> for PyErr` (or `PyErrArguments`), as well as "
"`From<OtherError>` for `MyOtherError`."
msgstr ""

#: src/function/error-handling.md:186
msgid ""
"Use Rust's Result combinators such as `map_err` to write code freely to "
"convert `OtherError` into whatever is needed. This requires boilerplate at "
"every usage however gives unlimited flexibility."
msgstr ""

#: src/function/error-handling.md:188
msgid ""
"To detail the newtype strategy a little further, the key trick is to return "
"`Result<T, MyOtherError>` from the `#[pyfunction]`. This means that PyO3 "
"will make use of `From<MyOtherError> for PyErr` to create Python exceptions "
"while the `#[pyfunction]` implementation can use `?` to convert `OtherError` "
"to `MyOtherError` automatically."
msgstr ""

#: src/function/error-handling.md:190
msgid ""
"The following example demonstrates this for some imaginary third-party crate "
"`some_crate` with a function `get_x` returning `Result<i32, OtherError>`:"
msgstr ""

#: src/function/error-handling.md:196
msgid "\"some error occurred\""
msgstr ""

#: src/function/error-handling.md:221
msgid "// get_x is a function returning Result<i32, OtherError>\n"
msgstr ""

#: src/function/error-handling.md:235
msgid "Notes"
msgstr ""

#: src/function/error-handling.md:237
msgid ""
"In Python 3.11 and up, notes can be added to Python exceptions to provide "
"additional debugging information when printing the exception. In PyO3, you "
"can use the `add_note` method on `PyErr` to accomplish this functionality."
msgstr ""

#: src/function/signature.md:3
msgid ""
"The `#[pyfunction]` attribute also accepts parameters to control how the "
"generated Python function accepts arguments. Just like in Python, arguments "
"can be positional-only, keyword-only, or accept either. `*args` lists and "
"`**kwargs` dicts can also be accepted. These parameters also work for "
"`#[pymethods]` which will be introduced in the [Python Classes](../class.md) "
"section of the guide."
msgstr ""

#: src/function/signature.md:5
msgid ""
"Like Python, by default PyO3 accepts all arguments as either positional or "
"keyword arguments. All arguments are required by default. This behaviour can "
"be configured by the `#[pyo3(signature = (...))]` option which allows "
"writing a signature in Python syntax."
msgstr ""

#: src/function/signature.md:7
msgid ""
"This section of the guide goes into detail about use of the "
"`#[pyo3(signature = (...))]` option and its related option "
"`#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function/signature.md:9
msgid "Using `#[pyo3(signature = (...))]`"
msgstr ""

#: src/function/signature.md:11
msgid ""
"For example, below is a function that accepts arbitrary keyword arguments "
"(`**kwargs` in Python syntax) and returns the number that was passed:"
msgstr ""

#: src/function/signature.md:27
msgid ""
"Just like in Python, the following constructs can be part of the signature::"
msgstr ""

#: src/function/signature.md:29
msgid ""
"`/`: positional-only arguments separator, each parameter defined before `/` "
"is a positional-only parameter."
msgstr ""

#: src/function/signature.md:30
msgid ""
"`*`: var arguments separator, each parameter defined after `*` is a keyword-"
"only parameter."
msgstr ""

#: src/function/signature.md:31
msgid ""
"`*args`: \"args\" is var args. Type of the `args` parameter has to be "
"`&Bound<'_, PyTuple>`."
msgstr ""

#: src/function/signature.md:32
msgid ""
"`**kwargs`: \"kwargs\" receives keyword arguments. The type of the `kwargs` "
"parameter has to be `Option<&Bound<'_, PyDict>>`."
msgstr ""

#: src/function/signature.md:33
msgid ""
"`arg=Value`: arguments with default value. If the `arg` argument is defined "
"after var arguments, it is treated as a keyword-only argument. Note that "
"`Value` has to be valid rust code, PyO3 just inserts it into the generated "
"code unmodified."
msgstr ""

#: src/function/signature.md:74
msgid "\"num={}\""
msgstr ""

#: src/function/signature.md:79
msgid "Arguments of type `Python` must not be part of the signature:"
msgstr ""

#: src/function/signature.md:91
msgid ""
"N.B. the position of the `/` and `*` arguments (if included) control the "
"system of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/function/signature.md:102
msgid "Produces output:"
msgstr ""

#: src/function/signature.md:112
msgid ""
"Note: to use keywords like `struct` as a function argument, use \"raw "
"identifier\" syntax `r#struct` in both the signature and the function "
"definition:"
msgstr ""

#: src/function/signature.md:126
msgid "Making the function signature available to Python"
msgstr ""

#: src/function/signature.md:128
msgid ""
"The function signature is exposed to Python via the `__text_signature__` "
"attribute. PyO3 automatically generates this for every `#[pyfunction]` and "
"all `#[pymethods]` directly from the Rust function, taking into account any "
"override done with the `#[pyo3(signature = (...))]` option."
msgstr ""

#: src/function/signature.md:130
msgid ""
"This automatic generation can only display the value of default arguments "
"for strings, integers, boolean types, and `None`. Any other default "
"arguments will be displayed as `...`. (`.pyi` type stub files commonly also "
"use `...` for default arguments in the same way.)"
msgstr ""

#: src/function/signature.md:132
msgid ""
"In cases where the automatically-generated signature needs adjusting, it can "
"[be overridden](#overriding-the-generated-signature) using the "
"`#[pyo3(text_signature)]` option.)"
msgstr ""

#: src/function/signature.md:134
msgid ""
"The example below creates a function `add` which accepts two positional-only "
"arguments `a` and `b`, where `b` has a default value of zero."
msgstr ""

#: src/function/signature.md:138 src/function/signature.md:186
#: src/function/signature.md:228
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function/signature.md:151 src/function/signature.md:199
#: src/function/signature.md:241
msgid "\"This function adds two unsigned 64-bit integers.\""
msgstr ""

#: src/function/signature.md:159
msgid "// on 3.7 the signature doesn't render b, upstream bug?\n"
msgstr ""

#: src/function/signature.md:160 src/function/signature.md:189
#: src/function/signature.md:206
msgid "\"(a, b=0, /)\""
msgstr ""

#: src/function/signature.md:167
msgid ""
"The following IPython output demonstrates how this generated signature will "
"be seen from Python tooling:"
msgstr ""

#: src/function/signature.md:178
msgid "Overriding the generated signature"
msgstr ""

#: src/function/signature.md:180
msgid ""
"The `#[pyo3(text_signature = \"(<some signature>)\")]` attribute can be used "
"to override the default generated signature."
msgstr ""

#: src/function/signature.md:182
msgid ""
"In the snippet below, the text signature attribute is used to include the "
"default value of `0` for the argument `b`, instead of the automatically-"
"generated default value of `...`:"
msgstr ""

#: src/function/signature.md:213
msgid ""
"PyO3 will include the contents of the annotation unmodified as the "
"`__text_signature__`. Below shows how IPython will now present this (see the "
"default value of 0 for b):"
msgstr ""

#: src/function/signature.md:224
msgid ""
"If no signature is wanted at all, `#[pyo3(text_signature = None)]` will "
"disable the built-in signature. The snippet below demonstrates use of this:"
msgstr ""

#: src/function/signature.md:249
msgid ""
"Now the function's `__text_signature__` will be set to `None`, and IPython "
"will not display any signature in the help:"
msgstr ""

#: src/function/signature.md:259
msgid "Type annotations in the signature"
msgstr ""

#: src/function/signature.md:261
msgid ""
"When the `experimental-inspect` Cargo feature is enabled, the `signature` "
"attribute can also contain type hints:"
msgstr ""

#: src/function/signature.md:264
msgid "\"experimental-inspect\""
msgstr ""

#: src/function/signature.md:280
msgid ""
"It enables the [work-in-progress capacity of PyO3 to autogenerate type stubs]"
"(../type-stub.md) to generate a file with the correct type hints:"
msgstr ""

#: src/function/signature.md:286
msgid "instead of the generic:"
msgstr ""

#: src/function/signature.md:294
msgid "Note that currently type annotations must be written as Rust strings."
msgstr ""

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr ""

#: src/module.md:13
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:20
msgid ""
"// The double function is made available from Python, works also with "
"classes\n"
msgstr ""

#: src/module.md:22
msgid "// Inline definition of a pyfunction, also made availlable to Python\n"
msgstr ""

#: src/module.md:30
msgid ""
"The `#[pymodule]` procedural macro takes care of creating the initialization "
"function of your module and exposing it to Python."
msgstr ""

#: src/module.md:33
msgid ""
"The module's name defaults to the name of the Rust module. You can override "
"the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:45
msgid "\"custom_name\""
msgstr ""

#: src/module.md:53
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:57
msgid "To import the module, either:"
msgstr ""

#: src/module.md:59
msgid ""
"copy the shared library as described in [Manual builds](building-and-"
"distribution.md#manual-builds), or"
msgstr ""

#: src/module.md:60
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:63
msgid "Documentation"
msgstr ""

#: src/module.md:65
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the Rust module will be applied automatically as the "
"Python docstring of your module."
msgstr ""

#: src/module.md:67
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:75
msgid "Python submodules"
msgstr ""

#: src/module.md:77
msgid ""
"You can create a module hierarchy within a single extension module by just "
"`use`ing modules like functions or classes. For example, you could define "
"the modules `parent_module` and `parent_module.child_module`:"
msgstr ""

#: src/module.md:97
msgid "\"func\""
msgstr ""

#: src/module.md:106
msgid "\"parent_module\""
msgstr ""

#: src/module.md:108
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:113
msgid ""
"Note that this does not define a package, so this won‚Äôt allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:118
msgid ""
"You can provide the `submodule` argument to `#[pymodule()]` for modules that "
"are not top-level modules in order for them to properly generate the "
"`#[pyclass]` `module` attribute automatically."
msgstr ""

#: src/module.md:120
msgid "Inline declaration"
msgstr ""

#: src/module.md:122
msgid ""
"It is possible to declare functions, classes, sub-modules and constants "
"inline in a module:"
msgstr ""

#: src/module.md:133
msgid "// Exports PI constant as part of the module\n"
msgstr ""

#: src/module.md:135 src/module.md:140
msgid "// This will be part of the module\n"
msgstr ""

#: src/module.md:145
msgid "// This is a submodule\n"
msgstr ""

#: src/module.md:155
msgid ""
"In this case, `#[pymodule]` macro automatically sets the `module` attribute "
"of the `#[pyclass]` macros declared inside of it with its name. For nested "
"modules, the name of the parent module is automatically added. In the "
"previous example, the `Nested` class will have for `module` `my_extension."
"submodule`."
msgstr ""

#: src/module.md:159
msgid "Procedural initialization"
msgstr ""

#: src/module.md:161
msgid ""
"If the macros provided by PyO3 are not enough, it is possible to run code at "
"the module initialization:"
msgstr ""

#: src/module.md:176
msgid "// Arbitrary code to run at the module initialization\n"
msgstr ""

#: src/module.md:177
msgid "\"double2\""
msgstr ""

#: src/module.md:177
msgid "\"double\""
msgstr ""
