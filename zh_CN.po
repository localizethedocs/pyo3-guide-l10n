msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:40:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr ""

#: src/advanced.md:3
msgid "FFI"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of Python's C API through the `ffi` module."
msgstr ""

#: src/advanced.md:7
msgid ""
"The C API is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that API."
msgstr ""

#: src/advanced.md:9
msgid "Memory Management"
msgstr ""

#: src/advanced.md:11
msgid ""
"PyO3's `&PyAny` \"owned references\" and `Py<PyAny>` smart pointers are used "
"to access memory stored in Python's heap.  This memory sometimes lives for "
"longer than expected because of differences in Rust and Python's memory "
"models.  See the chapter on [memory management](./memory.md) for more "
"information."
msgstr ""

#: src/migration.md:1
msgid "Migrating from older PyO3 versions"
msgstr ""

#: src/migration.md:3
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see the [CHANGELOG]"
"(changelog.md)."
msgstr ""

#: src/migration.md:6
msgid "from 0.14.\\* to 0.15"
msgstr ""

#: src/migration.md:8
msgid "Changes in sequence indexing"
msgstr ""

#: src/migration.md:10
msgid ""
"For all types that take sequence indices (`PyList`, `PyTuple` and "
"`PySequence`), the API has been made consistent to only take `usize` "
"indices, for consistency with Rust's indexing conventions.  Negative "
"indices, which were only sporadically supported even in APIs that took "
"`isize`, now aren't supported anywhere."
msgstr ""

#: src/migration.md:16
msgid ""
"Further, the `get_item` methods now always return a `PyResult` instead of "
"panicking on invalid indices.  The `Index` trait has been implemented "
"instead, and provides the same panic behavior as on Rust vectors."
msgstr ""

#: src/migration.md:20
msgid ""
"Note that _slice_ indices (accepted by `PySequence::get_slice` and other) "
"still inherit the Python behavior of clamping the indices to the actual "
"length, and not panicking/returning an error on out of range indices."
msgstr ""

#: src/migration.md:24
msgid ""
"An additional advantage of using Rust's indexing conventions for these types "
"is that these types can now also support Rust's indexing operators as part "
"of a consistent API:"
msgstr ""

#: src/migration.md:33
msgid "\"[1, 2]\""
msgstr ""

#: src/migration.md:37
msgid "from 0.13.\\* to 0.14"
msgstr ""

#: src/migration.md:39
msgid "`auto-initialize` feature is now opt-in"
msgstr ""

#: src/migration.md:41
msgid ""
"For projects embedding Python in Rust, PyO3 no longer automatically "
"initializes a Python interpreter on the first call to `Python::with_gil` (or "
"`Python::acquire_gil`) unless the [`auto-initialize` feature](features."
"md#auto-initialize) is enabled."
msgstr ""

#: src/migration.md:43
msgid "New `multiple-pymethods` feature"
msgstr ""

#: src/migration.md:45
msgid ""
"`#[pymethods]` have been reworked with a simpler default implementation "
"which removes the dependency on the `inventory` crate. This reduces "
"dependencies and compile times for the majority of users."
msgstr ""

#: src/migration.md:47
msgid ""
"The limitation of the new default implementation is that it cannot support "
"multiple `#[pymethods]` blocks for the same `#[pyclass]`. If you need this "
"functionality, you must enable the `multiple-pymethods` feature which will "
"switch `#[pymethods]` to the inventory-based implementation."
msgstr ""

#: src/migration.md:49
msgid "Deprecated `#[pyproto]` methods"
msgstr ""

#: src/migration.md:51
msgid ""
"Some protocol (aka `__dunder__`) methods such as `__bytes__` and "
"`__format__` have been possible to implement two ways in PyO3 for some time: "
"via a `#[pyproto]` (e.g. `PyBasicProtocol` for the methods listed here), or "
"by writing them directly in `#[pymethods]`. This is only true for a handful "
"of the `#[pyproto]` methods (for technical reasons to do with the way PyO3 "
"currently interacts with the Python C-API)."
msgstr ""

#: src/migration.md:53
msgid ""
"In the interest of having onle one way to do things, the `#[pyproto]` forms "
"of these methods have been deprecated."
msgstr ""

#: src/migration.md:55
msgid ""
"To migrate just move the affected methods from a `#[pyproto]` to a "
"`#[pymethods]` block."
msgstr ""

#: src/migration.md:57 src/migration.md:142 src/migration.md:191
#: src/migration.md:217 src/migration.md:245 src/migration.md:280
#: src/migration.md:315 src/migration.md:341 src/migration.md:363
#: src/migration.md:393 src/migration.md:479 src/migration.md:506
#: src/migration.md:541
msgid "Before:"
msgstr ""

#: src/migration.md:69 src/migration.md:85
msgid "b\"hello, world\""
msgstr ""

#: src/migration.md:74 src/migration.md:165 src/migration.md:225
#: src/migration.md:254 src/migration.md:293 src/migration.md:325
#: src/migration.md:348 src/migration.md:374 src/migration.md:407
#: src/migration.md:489 src/migration.md:513 src/migration.md:559
msgid "After:"
msgstr ""

#: src/migration.md:90
msgid "from 0.12.\\* to 0.13"
msgstr ""

#: src/migration.md:92
msgid "Minimum Rust version increased to Rust 1.45"
msgstr ""

#: src/migration.md:94
msgid ""
"PyO3 `0.13` makes use of new Rust language features stabilised between Rust "
"1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, "
"you will need to update your toolchain to be able to continue using PyO3."
msgstr ""

#: src/migration.md:96
msgid "Runtime changes to support the CPython limited API"
msgstr ""

#: src/migration.md:98
msgid ""
"In PyO3 `0.13` support was added for compiling against the CPython limited "
"API. This had a number of implications for _all_ PyO3 users, described here."
msgstr ""

#: src/migration.md:100
msgid ""
"The largest of these is that all types created from PyO3 are what CPython "
"calls \"heap\" types. The specific implications of this are:"
msgstr ""

#: src/migration.md:102
msgid ""
"If you wish to subclass one of these types _from Rust_ you must mark it "
"`#[pyclass(subclass)]`, as you would if you wished to allow subclassing it "
"from Python code."
msgstr ""

#: src/migration.md:103
msgid "Type objects are now mutable - Python code can set attributes on them."
msgstr ""

#: src/migration.md:104
msgid ""
"`__module__` on types without `#[pyclass(module=\"mymodule\")]` no longer "
"returns `builtins`, it now raises `AttributeError`."
msgstr ""

#: src/migration.md:106
msgid "from 0.11.\\* to 0.12"
msgstr ""

#: src/migration.md:108
msgid "`PyErr` has been reworked"
msgstr ""

#: src/migration.md:110
msgid ""
"In PyO3 `0.12` the `PyErr` type has been re-implemented to be significantly "
"more compatible with the standard Rust error handling ecosystem. "
"Specifically `PyErr` now implements `Error + Send + Sync`, which are the "
"standard traits used for error types."
msgstr ""

#: src/migration.md:114
msgid ""
"While this has necessitated the removal of a number of APIs, the resulting "
"`PyErr` type should now be much more easier to work with. The following "
"sections list the changes in detail and how to migrate to the new APIs."
msgstr ""

#: src/migration.md:118
msgid ""
"`PyErr::new` and `PyErr::from_type` now require `Send + Sync` for their "
"argument"
msgstr ""

#: src/migration.md:120
msgid ""
"For most uses no change will be needed. If you are trying to construct "
"`PyErr` from a value that is not `Send + Sync`, you will need to first "
"create the Python object and then use `PyErr::from_instance`."
msgstr ""

#: src/migration.md:124
msgid ""
"Similarly, any types which implemented `PyErrArguments` will now need to be "
"`Send + Sync`."
msgstr ""

#: src/migration.md:126
msgid "`PyErr`'s contents are now private"
msgstr ""

#: src/migration.md:128
msgid ""
"It is no longer possible to access the fields `.ptype`, `.pvalue` and `."
"ptraceback` of a `PyErr`. You should instead now use the new methods `PyErr::"
"ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/migration.md:131
msgid "`PyErrValue` and `PyErr::from_value` have been removed"
msgstr ""

#: src/migration.md:133
msgid ""
"As these were part the internals of `PyErr` which have been reworked, these "
"APIs no longer exist."
msgstr ""

#: src/migration.md:135
msgid ""
"If you used this API, it is recommended to use `PyException::new_err` (see "
"[the section on Exception types](#exception-types-have-been-reworked))."
msgstr ""

#: src/migration.md:138
msgid "`Into<PyResult<T>>` for `PyErr` has been removed"
msgstr ""

#: src/migration.md:140
msgid ""
"This implementation was redundant. Just construct the `Result::Err` variant "
"directly."
msgstr ""

#: src/migration.md:144 src/migration.md:150 src/migration.md:162
#: src/migration.md:171
msgid "\"error message\""
msgstr ""

#: src/migration.md:147
msgid ""
"After (also using the new reworked exception types; see the following "
"section):"
msgstr ""

#: src/migration.md:153
msgid "Exception types have been reworked"
msgstr ""

#: src/migration.md:155
msgid ""
"Previously exception types were zero-sized marker types purely used to "
"construct `PyErr`. In PyO3 0.12, these types have been replaced with full "
"definitions and are usable in the same way as `PyAny`, `PyDict` etc. This "
"makes it possible to interact with Python exception objects."
msgstr ""

#: src/migration.md:159
msgid ""
"The new types also have names starting with the \"Py\" prefix. For example, "
"before:"
msgstr ""

#: src/migration.md:172
msgid "// Uses Display for PyErr, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:174
msgid "\"TypeError: error message\""
msgstr ""

#: src/migration.md:175
msgid ""
"// Now possible to interact with exception instances, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:178
msgid "\"__class__\""
msgstr ""

#: src/migration.md:183
msgid "`FromPy` has been removed"
msgstr ""

#: src/migration.md:184
msgid ""
"To simplify the PyO3 conversion traits, the `FromPy` trait has been removed. "
"Previously there were two ways to define the to-Python conversion for a "
"type: `FromPy<T> for PyObject` and `IntoPy<PyObject> for T`."
msgstr ""

#: src/migration.md:188
msgid ""
"Now there is only one way to define the conversion, `IntoPy`, so downstream "
"crates may need to adjust accordingly."
msgstr ""

#: src/migration.md:203
msgid "After"
msgstr ""

#: src/migration.md:215
msgid ""
"Similarly, code which was using the `FromPy` trait can be trivially "
"rewritten to use `IntoPy`."
msgstr ""

#: src/migration.md:233
msgid "`PyObject` is now a type alias of `Py<PyAny>`"
msgstr ""

#: src/migration.md:234
msgid ""
"This should change very little from a usage perspective. If you implemented "
"traits for both `PyObject` and `Py<T>`, you may find you can just remove the "
"`PyObject` implementation."
msgstr ""

#: src/migration.md:237
msgid "`AsPyRef` has been removed"
msgstr ""

#: src/migration.md:238
msgid ""
"As `PyObject` has been changed to be just a type alias, the only remaining "
"implementor of `AsPyRef` was `Py<T>`. This removed the need for a trait, so "
"the `AsPyRef::as_ref` method has been moved to `Py::as_ref`."
msgstr ""

#: src/migration.md:242
msgid ""
"This should require no code changes except removing `use pyo3::AsPyRef` for "
"code which did not use `pyo3::prelude::*`."
msgstr ""

#: src/migration.md:263
msgid "from 0.10.\\* to 0.11"
msgstr ""

#: src/migration.md:265
msgid "Stable Rust"
msgstr ""

#: src/migration.md:266
msgid ""
"PyO3 now supports the stable Rust toolchain. The minimum required version is "
"1.39.0."
msgstr ""

#: src/migration.md:268
msgid "`#[pyclass]` structs must now be `Send` or `unsendable`"
msgstr ""

#: src/migration.md:269
msgid ""
"Because `#[pyclass]` structs can be sent between threads by the Python "
"interpreter, they must implement `Send` or declared as `unsendable` (by "
"`#[pyclass(unsendable)]`). Note that `unsendable` is added in PyO3 `0.11.1` "
"and `Send` is always required in PyO3 `0.11.0`."
msgstr ""

#: src/migration.md:273
msgid ""
"This may \"break\" some code which previously was accepted, even though it "
"could be unsound. There can be two fixes:"
msgstr ""

#: src/migration.md:276
msgid ""
"If you think that your `#[pyclass]` actually must be `Send`able, then let's "
"implement `Send`. A common, safer way is using thread-safe types. E.g., "
"`Arc` instead of `Rc`, `Mutex` instead of `RefCell`, and `Box<dyn Send + T>` "
"instead of `Box<dyn T>`."
msgstr ""

#: src/migration.md:306
msgid ""
"In situations where you cannot change your `#[pyclass]` to automatically "
"implement `Send` (e.g., when it contains a raw pointer), you can use `unsafe "
"impl Send`. In such cases, care should be taken to ensure the struct is "
"actually thread safe. See [the Rustnomicon](https://doc.rust-lang.org/"
"nomicon/send-and-sync.html) for more."
msgstr ""

#: src/migration.md:311
msgid ""
"If you think that your `#[pyclass]` should not be accessed by another "
"thread, you can use `unsendable` flag. A class marked with `unsendable` "
"panics when accessed by another thread, making it thread-safe to expose an "
"unsendable object to the Python interpreter."
msgstr ""

#: src/migration.md:336
msgid "All `PyObject` and `Py<T>` methods now take `Python` as an argument"
msgstr ""

#: src/migration.md:337
msgid ""
"Previously, a few methods such as `Object::get_refcnt` did not take `Python` "
"as an argument (to ensure that the Python GIL was held by the current "
"thread). Technically, this was not sound. To migrate, just pass a `py` "
"argument to any calls to these methods."
msgstr ""

#: src/migration.md:355
msgid "from 0.9.\\* to 0.10"
msgstr ""

#: src/migration.md:357
msgid "`ObjectProtocol` is removed"
msgstr ""

#: src/migration.md:358
msgid ""
"All methods are moved to [`PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html). And since now all native types (e.g., `PyList`) "
"implements `Deref<Target=PyAny>`, all you need to do is remove "
"`ObjectProtocol` from your code. Or if you use `ObjectProtocol` by `use "
"pyo3::prelude::*`, you have to do nothing."
msgstr ""

#: src/migration.md:368 src/migration.md:377
msgid "\"lambda: 'Hi :)'\""
msgstr ""

#: src/migration.md:383
msgid "No `#![feature(specialization)]` in user code"
msgstr ""

#: src/migration.md:384
msgid ""
"While PyO3 itself still requires specialization and nightly Rust, now you "
"don't have to use `#![feature(specialization)]` in your crate."
msgstr ""

#: src/migration.md:387
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:389
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:390
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:422
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](class.html#constructor) of this guide."
msgstr ""

#: src/migration.md:425
msgid "PyCell"
msgstr ""

#: src/migration.md:426
msgid ""
"PyO3 0.9 introduces [`PyCell`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyCell.html), which is a [`RefCell`](https://doc.rust-lang.org/std/cell/"
"struct.RefCell.html)\\-like object wrapper for ensuring Rust's rules "
"regarding aliasing of references are upheld. For more detail, see the [Rust "
"Book's section on Rust's rules of references](https://doc.rust-lang.org/book/"
"ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:431
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:435
msgid "Here is an example."
msgstr ""

#: src/migration.md:456
msgid ""
"r\"\n"
"#     try:\n"
"#        names.merge(names)\n"
"#        assert False, 'Unreachable'\n"
"#     except RuntimeError as e:\n"
"#        assert str(e) == 'Already borrowed'\n"
"#     \""
msgstr ""

#: src/migration.md:465
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/main/doc/pyo3/pycell/"
"struct.PyBorrowMutError.html) exception, since it requires two mutable "
"borrows of `names`."
msgstr ""

#: src/migration.md:469
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:471
msgid "Object creation"
msgstr ""

#: src/migration.md:472
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use [`PyCell::new`]"
"(https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html#method.new) "
"instead. If you need [`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html), just call `.borrow()` or `.borrow_mut()` on the newly-created "
"`PyCell`."
msgstr ""

#: src/migration.md:500
msgid "Object extraction"
msgstr ""

#: src/migration.md:501
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:521
msgid "\"c\""
msgstr ""

#: src/migration.md:522
msgid "\"c()\""
msgstr ""

#: src/migration.md:525
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:528
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:535
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:536
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) implementation. So if your protocol methods take `&T` or `&mut T` "
"(where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) instead."
msgstr ""

#: src/rust_cpython.md:1
msgid "PyO3 and rust-cpython"
msgstr ""

#: src/rust_cpython.md:3
msgid ""
"PyO3 began as fork of [rust-cpython](https://github.com/dgrunwald/rust-"
"cpython) when rust-cpython wasn't maintained. Over time PyO3 has become "
"fundamentally different from rust-cpython."
msgstr ""

#: src/rust_cpython.md:5
msgid "Macros"
msgstr ""

#: src/rust_cpython.md:7
msgid ""
"While rust-cpython has a `macro_rules!` based dsl for declaring modules and "
"classes, PyO3 uses proc macros. PyO3 also doesn't change your struct and "
"functions so you can still use them as normal Rust functions."
msgstr ""

#: src/rust_cpython.md:9 src/rust_cpython.md:53
msgid "**rust-cpython**"
msgstr ""

#: src/rust_cpython.md:23 src/rust_cpython.md:64
msgid "**pyo3**"
msgstr ""

#: src/rust_cpython.md:46
msgid "Ownership and lifetimes"
msgstr ""

#: src/rust_cpython.md:48
msgid ""
"While in rust-cpython you always own python objects, PyO3 allows efficient "
"_borrowed objects_ and most APIs are available with references."
msgstr ""

#: src/rust_cpython.md:51
msgid "Here is an example of the PyList API:"
msgstr ""

#: src/rust_cpython.md:75
msgid ""
"In PyO3, all object references are bounded by the GIL lifetime. So the owned "
"Python object is not required, and it is safe to have functions like `fn "
"py<'p>(&'p self) -> Python<'p> {}`."
msgstr ""

#: src/rust_cpython.md:78
msgid "Error handling"
msgstr ""

#: src/rust_cpython.md:80
msgid ""
"rust-cpython requires a `Python` parameter for constructing a `PyErr`, so "
"error handling ergonomics is pretty bad. It is not possible to use `?` with "
"Rust errors."
msgstr ""

#: src/rust_cpython.md:82
msgid ""
"PyO3 on other hand does not require `Python` for constructing a `PyErr`, it "
"is only required if you want to raise an exception in Python with the "
"`PyErr::restore()` method. Due to various `std::convert::From<E> for PyErr` "
"implementations for Rust standard error types `E`, propagating `?` is "
"supported automatically."
msgstr ""

#: src/trait_bounds.md:1
msgid "Using in Python a Rust function with trait bounds"
msgstr ""

#: src/trait_bounds.md:3
msgid ""
"PyO3 allows for easy conversion from Rust to Python for certain functions "
"and classes (see the [conversion table](conversions/tables.html). However, "
"it is not always straightforward to convert Rust code that requires a given "
"trait implementation as an argument."
msgstr ""

#: src/trait_bounds.md:6
msgid ""
"This tutorial explains how to convert a Rust function that takes a trait as "
"argument for use in Python with classes implementing the same methods as the "
"trait."
msgstr ""

#: src/trait_bounds.md:8
msgid "Why is this useful?"
msgstr ""

#: src/trait_bounds.md:10
msgid "Pros"
msgstr ""

#: src/trait_bounds.md:11
msgid "Make your Rust code available to Python users"
msgstr ""

#: src/trait_bounds.md:12
msgid "Code complex algorithms in Rust with the help of the borrow checker"
msgstr ""

#: src/trait_bounds.md:14
msgid "Cons"
msgstr ""

#: src/trait_bounds.md:15
msgid ""
"Not as fast as native Rust (type conversion has to be performed and one part "
"of the code runs in Python)"
msgstr ""

#: src/trait_bounds.md:16
msgid "You need to adapt your code to expose it"
msgstr ""

#: src/trait_bounds.md:18
msgid "Example"
msgstr ""

#: src/trait_bounds.md:20
msgid ""
"Let's work with the following basic example of an implementation of a "
"optimization solver operating on a given model."
msgstr ""

#: src/trait_bounds.md:22
msgid ""
"Let's say we have a function `solve` that operates on a model and mutates "
"its state. The argument of the function can be any model that implements the "
"`Model` trait :"
msgstr ""

#: src/trait_bounds.md:34 src/trait_bounds.md:475
msgid "\"Magic solver that mutates the model into a resolved state\""
msgstr ""

#: src/trait_bounds.md:37
msgid "Let's assume we have the following constraints:"
msgstr ""

#: src/trait_bounds.md:38
msgid "We cannot change that code as it runs on many Rust models."
msgstr ""

#: src/trait_bounds.md:39
msgid ""
"We also have many Python models that cannot be solved as this solver is not "
"available in that language. Rewriting it in Python would be cumbersome and "
"error-prone, as everything is already available in Rust."
msgstr ""

#: src/trait_bounds.md:42
msgid "How could we expose this solver to Python thanks to PyO3 ?"
msgstr ""

#: src/trait_bounds.md:44
msgid "Implementation of the trait bounds for the Python class"
msgstr ""

#: src/trait_bounds.md:46
msgid ""
"If a Python class implements the same three methods as the `Model` trait, it "
"seems logical it could be adapted to use the solver. However, it is not "
"possible to pass a `PyObject` to it as it does not implement the Rust trait "
"(even if the Python model has the required methods)."
msgstr ""

#: src/trait_bounds.md:49
msgid ""
"In order to implement the trait, we must write a wrapper around the calls in "
"Rust to the Python model. The method signatures must be the same as the "
"trait, keeping in mind that the Rust trait cannot be changed for the purpose "
"of making the code available in Python."
msgstr ""

#: src/trait_bounds.md:52
msgid ""
"The Python model we want to expose is the following one, which already "
"contains all the required methods:"
msgstr ""

#: src/trait_bounds.md:64
msgid ""
"The following wrapper will call the Python model from Rust, using a struct "
"to hold the model as a `PyAny` object:"
msgstr ""

#: src/trait_bounds.md:82 src/trait_bounds.md:183 src/trait_bounds.md:363
#: src/trait_bounds.md:421 src/trait_bounds.md:520
msgid "\"Rust calling Python to set the variables\""
msgstr ""

#: src/trait_bounds.md:88 src/trait_bounds.md:189 src/trait_bounds.md:369
#: src/trait_bounds.md:427 src/trait_bounds.md:526
msgid "\"set_variables\""
msgstr ""

#: src/trait_bounds.md:94 src/trait_bounds.md:195 src/trait_bounds.md:352
msgid "\"Rust calling Python to get the results\""
msgstr ""

#: src/trait_bounds.md:98 src/trait_bounds.md:199 src/trait_bounds.md:356
#: src/trait_bounds.md:410 src/trait_bounds.md:537
msgid "\"get_results\""
msgstr ""

#: src/trait_bounds.md:106 src/trait_bounds.md:207 src/trait_bounds.md:375
#: src/trait_bounds.md:433 src/trait_bounds.md:549
msgid "\"Rust calling Python to perform the computation\""
msgstr ""

#: src/trait_bounds.md:110 src/trait_bounds.md:211 src/trait_bounds.md:379
#: src/trait_bounds.md:437 src/trait_bounds.md:553
msgid "\"compute\""
msgstr ""

#: src/trait_bounds.md:117
msgid ""
"Now that this bit is implemented, let's expose the model wrapper to Python. "
"Let's add the PyO3 annotations and add a constructor:"
msgstr ""

#: src/trait_bounds.md:150
msgid "Now we add the PyO3 annotations to the trait implementation:"
msgstr ""

#: src/trait_bounds.md:155
msgid "// the previous trait implementation\n"
msgstr ""

#: src/trait_bounds.md:159
msgid ""
"However, the previous code will not compile. The compilation error is the "
"following one: `error: #[pymethods] cannot be used on trait impl blocks`"
msgstr ""

#: src/trait_bounds.md:162
msgid ""
"That's a bummer! However, we can write a second wrapper around these "
"functions to call them directly. This wrapper will also perform the type "
"conversions between Python and Rust."
msgstr ""

#: src/trait_bounds.md:221 src/trait_bounds.md:504
msgid "\"Set variables from Python calling Rust\""
msgstr ""

#: src/trait_bounds.md:226 src/trait_bounds.md:509
msgid "\"Get results from Python calling Rust\""
msgstr ""

#: src/trait_bounds.md:231
msgid "\"Compute from Python calling Rust\""
msgstr ""

#: src/trait_bounds.md:236
msgid ""
"This wrapper handles the type conversion between the PyO3 requirements and "
"the trait. In order to meet PyO3 requirements, this wrapper must:"
msgstr ""

#: src/trait_bounds.md:238
msgid "return an object of type `PyResult`"
msgstr ""

#: src/trait_bounds.md:239
msgid "use only values, not references in the method signatures"
msgstr ""

#: src/trait_bounds.md:241
msgid "Let's run the file python file:"
msgstr ""

#: src/trait_bounds.md:252
msgid "\"__main__\""
msgstr ""

#: src/trait_bounds.md:258
msgid "\"Print value from Python: \""
msgstr ""

#: src/trait_bounds.md:260
msgid "\"Print value from Python through Rust: \""
msgstr ""

#: src/trait_bounds.md:261
msgid "\"Print value directly from Python: \""
msgstr ""

#: src/trait_bounds.md:264
msgid "This outputs:"
msgstr ""

#: src/trait_bounds.md:278
msgid ""
"We have now successfully exposed a Rust model that implements the `Model` "
"trait to Python!"
msgstr ""

#: src/trait_bounds.md:280
msgid ""
"We will now expose the `solve` function, but before, let's talk about types "
"errors."
msgstr ""

#: src/trait_bounds.md:282
msgid "Type errors in Python"
msgstr ""

#: src/trait_bounds.md:284
msgid ""
"What happens if you have type errors when using Python and how can you "
"improve the error messages?"
msgstr ""

#: src/trait_bounds.md:287
msgid "Wrong types in Python function arguments"
msgstr ""

#: src/trait_bounds.md:289
msgid ""
"Let's assume in the first case that you will use in your Python file "
"`my_rust_model.set_variables(2.0)` instead of `my_rust_model."
"set_variables([2.0])`."
msgstr ""

#: src/trait_bounds.md:291
msgid ""
"The Rust signature expects a vector, which corresponds to a list in Python. "
"What happens if instead of a vector, we pass a single value ?"
msgstr ""

#: src/trait_bounds.md:294
msgid "At the execution of Python, we get :"
msgstr ""

#: src/trait_bounds.md:296
msgid ""
"```block\n"
"File \"main.py\", line 15, in <module>\n"
"   my_rust_model.set_variables(2)\n"
"TypeError\n"
"```"
msgstr ""

#: src/trait_bounds.md:302
msgid ""
"It is a type error and Python points to it, so it's easy to identify and "
"solve."
msgstr ""

#: src/trait_bounds.md:304
msgid "Wrong types in Python method signatures"
msgstr ""

#: src/trait_bounds.md:306
msgid ""
"Let's assume now that the return type of one of the methods of our Model "
"class is wrong, for example the `get_results` method that is expected to "
"return a `Vec<f64>` in Rust, a list in Python."
msgstr ""

#: src/trait_bounds.md:316
msgid "#return self.results <-- this is the expected output\n"
msgstr ""

#: src/trait_bounds.md:319
msgid "This call results in the following panic:"
msgstr ""

#: src/trait_bounds.md:325
msgid ""
"This error code is not helpful for a Python user that does not know anything "
"about Rust, or someone that does not know PyO3 was used to interface the "
"Rust code."
msgstr ""

#: src/trait_bounds.md:327
msgid ""
"However, as we are responsible for making the Rust code available to Python, "
"we can do something about it."
msgstr ""

#: src/trait_bounds.md:329
msgid ""
"The issue is that we called `unwrap` anywhere we could, and therefore any "
"panic from PyO3 will be directly forwarded to the end user."
msgstr ""

#: src/trait_bounds.md:331
msgid ""
"Let's modify the code performing the type conversion to give a helpful error "
"message to the Python user:"
msgstr ""

#: src/trait_bounds.md:333
msgid ""
"We used in our `get_results` method the following call that performs the "
"type conversion:"
msgstr ""

#: src/trait_bounds.md:386
msgid "Let's break it down in order to perform better error handling:"
msgstr ""

#: src/trait_bounds.md:405 src/trait_bounds.md:532
msgid "\"Get results from Rust calling Python\""
msgstr ""

#: src/trait_bounds.md:413 src/trait_bounds.md:540
msgid "\"list\""
msgstr ""

#: src/trait_bounds.md:414 src/trait_bounds.md:541
msgid "\"Expected a list for the get_results() method signature, got {}\""
msgstr ""

#: src/trait_bounds.md:444
msgid ""
"By doing so, you catch the result of the Python computation and check its "
"type in order to be able to deliver a better error message before performing "
"the unwrapping."
msgstr ""

#: src/trait_bounds.md:446
msgid ""
"Of course, it does not cover all the possible wrong outputs: the user could "
"return a list of strings instead of a list of floats. In this case, a "
"runtime panic would still occur due to PyO3, but with an error message much "
"more difficult to decipher for non-rust user."
msgstr ""

#: src/trait_bounds.md:450
msgid ""
"It is up to the developer exposing the rust code to decide how much effort "
"to invest into Python type error handling and improved error messages."
msgstr ""

#: src/trait_bounds.md:452
msgid "The final code"
msgstr ""

#: src/trait_bounds.md:454
msgid ""
"Now let's expose the `solve()` function to make it available from Python."
msgstr ""

#: src/trait_bounds.md:456
msgid ""
"It is not possible to directly expose the `solve` function to Python, as the "
"type conversion cannot be performed. It requires an object implementing the "
"`Model` trait as input."
msgstr ""

#: src/trait_bounds.md:459
msgid ""
"However, the `UserModel` already implements this trait. Because of this, we "
"can write a function wrapper that takes the `UserModel`\\--which has already "
"been exposed to Python--as an argument in order to call the core function "
"`solve`."
msgstr ""

#: src/trait_bounds.md:462
msgid "It is also required to make the struct public."
msgstr ""

#: src/trait_bounds.md:479
msgid "\"solve\""
msgstr ""

#: src/python_typing_hints.md:1
msgid "Typing and IDE hints for you Python package"
msgstr ""

#: src/python_typing_hints.md:3
msgid ""
"PyO3 provides an easy to use interface to code native Python libraries in "
"Rust. The accompanying Maturin allows you to build and publish them as a "
"package. Yet, for the better user experience, Python libraries should "
"provide typing hints and documentation for all public entities, so that IDEs "
"can show them during development and type analyzing tools such as `mypy` can "
"use them to properly verify the code."
msgstr ""

#: src/python_typing_hints.md:5
msgid ""
"Currently the best solution for the problem is to maintain manually the `*."
"pyi` files and ship them along with the package."
msgstr ""

#: src/python_typing_hints.md:7
msgid "The `pyi` files introduction"
msgstr ""

#: src/python_typing_hints.md:9
msgid ""
"`pyi` (an abbreviation for `Python Interface`) is called a `Stub File` in "
"most of the documentations related to them. Very good definition of what it "
"is can be found in [old MyPy documentation](https://github.com/python/mypy/"
"wiki/Creating-Stubs-For-Python-Modules):"
msgstr ""

#: src/python_typing_hints.md:11
msgid ""
"A stubs file only contains a description of the public interface of the "
"module without any implementations."
msgstr ""

#: src/python_typing_hints.md:13
msgid ""
"Probably most Python developers encountered them already when trying to use "
"the IDE \"Go to Definition\" function on any builtin type. For example the "
"definitions of few standard exceptions look like this:"
msgstr ""

#: src/python_typing_hints.md:36
msgid ""
"As we can see those are not full definitions containing implementation, but "
"just a description of interface. It is usually all that is needed by the "
"user of the library."
msgstr ""

#: src/python_typing_hints.md:38
msgid "What does the PEPs say?"
msgstr ""

#: src/python_typing_hints.md:40
msgid ""
"As of the time of writing this documentation the `pyi` files are referenced "
"in three PEPs."
msgstr ""

#: src/python_typing_hints.md:42
msgid ""
"[PEP8 - Style Guide for Python Code - #Function Annotations](https://www."
"python.org/dev/peps/pep-0008/#function-annotations) (last point) recommends "
"all third party library creators to provide stub files as the source of "
"knowledge about the package for type checker tools."
msgstr ""

#: src/python_typing_hints.md:44
msgid ""
"(...) it is expected that users of third party library packages may want to "
"run type checkers over those packages. For this purpose [PEP 484](https://"
"www.python.org/dev/peps/pep-0484) recommends the use of stub files: .pyi "
"files that are read by the type checker in preference of the corresponding ."
"py files. (...)"
msgstr ""

#: src/python_typing_hints.md:46
msgid ""
"[PEP484 - Type Hints - #Stub Files](https://www.python.org/dev/peps/pep-0484/"
"#stub-files) defines stub files as follows."
msgstr ""

#: src/python_typing_hints.md:48
msgid ""
"Stub files are files containing type hints that are only for use by the type "
"checker, not at runtime."
msgstr ""

#: src/python_typing_hints.md:50
msgid ""
"It contains a specification for them (highly recommended reading, since it "
"contains at least one thing that is not used in normal Python code) and also "
"some general information about where to store the stub files."
msgstr ""

#: src/python_typing_hints.md:52
msgid ""
"[PEP561 - Distributing and Packaging Type Information](https://www.python."
"org/dev/peps/pep-0561/) describes in detail how to build packages that will "
"enable type checking. In particular it contains information about how the "
"stub files must be distributed in order for type checkers to use them."
msgstr ""

#: src/python_typing_hints.md:54
msgid "How to do it?"
msgstr ""

#: src/python_typing_hints.md:56
msgid ""
"[PEP561](https://www.python.org/dev/peps/pep-0561/) recognizes three ways of "
"distributing type information:"
msgstr ""

#: src/python_typing_hints.md:58
msgid "`inline` - the typing is placed directly in source (`py`) files;"
msgstr ""

#: src/python_typing_hints.md:59
msgid ""
"`separate package with stub files` - the typing is placed in `pyi` files "
"distributed in their own, separate package;"
msgstr ""

#: src/python_typing_hints.md:60
msgid ""
"`in-package stub files` - the typing is placed in `pyi` files distributed in "
"the same package as source files."
msgstr ""

#: src/python_typing_hints.md:62
msgid ""
"The first way is tricky with PyO3 since we do not have `py` files. When it "
"will be investigated and necessary changes are implemented, this document "
"will be updated."
msgstr ""

#: src/python_typing_hints.md:64
msgid ""
"The second way is easy to do, and the whole work can be fully separated from "
"the main library code. The example repo for the package with stub files can "
"be found in [PEP561 references section](https://www.python.org/dev/peps/"
"pep-0561/#references): [Stub package repository](https://github.com/ethanhs/"
"stub-package)"
msgstr ""

#: src/python_typing_hints.md:66
msgid "The third way is described below."
msgstr ""

#: src/python_typing_hints.md:68
msgid "Including `pyi` files in your PyO3/Maturin build package"
msgstr ""

#: src/python_typing_hints.md:70
msgid ""
"When source files are in the same package as stub files, they should be "
"placed next to each other. We need a way to do that with Maturin. Also, in "
"order to mark our package as typing-enabled we need to add an empty file "
"named `py.typed` to the package."
msgstr ""

#: src/python_typing_hints.md:72
msgid "If you do not have other Python files"
msgstr ""

#: src/python_typing_hints.md:74
msgid ""
"If you do not need to add any other Python files apart from `pyi` to the "
"package, the Maturin provides a way to do most of the work for you. As "
"documented in [Maturin Guide](https://github.com/PyO3/maturin/"
"blob/084cfaced651b28616aeea1f818bdc933a536bfe/guide/src/project_layout."
"md#adding-python-type-information) the only thing you need to do is create a "
"stub file for your module named `<module_name>.pyi` in your project root and "
"Maturin will do the rest."
msgstr ""

#: src/python_typing_hints.md:85
msgid ""
"For example of `pyi` file see [`my_project.pyi` content](#my_projectpyi-"
"content) section."
msgstr ""

#: src/python_typing_hints.md:87
msgid "If you need other Python files"
msgstr ""

#: src/python_typing_hints.md:89
msgid ""
"If you need to add other Python files apart from `pyi` to the package, you "
"can do it also, but that requires some more work. Maturin provides easy way "
"to add files to package ([documentation](https://github.com/PyO3/maturin/"
"blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-rustpython-"
"projects)). You just need to create a folder with the name of your module "
"next to the `Cargo.toml` file (for customization see documentation linked "
"above)."
msgstr ""

#: src/python_typing_hints.md:91
msgid "The folder structure would be:"
msgstr ""

#: src/python_typing_hints.md:107
msgid ""
"Let's go a little bit more into details on the files inside the package "
"folder."
msgstr ""

#: src/python_typing_hints.md:109
msgid "`__init__.py` content"
msgstr ""

#: src/python_typing_hints.md:111
msgid ""
"As we now specify our own package content, we have to provide the `__init__."
"py` file, so the folder is treated as a package and we can import things "
"from it. We can always use the same content that the Maturin creates for us "
"if we do not specify a python source folder. For PyO3 bindings it would be:"
msgstr ""

#: src/python_typing_hints.md:117
msgid ""
"That way everything that is exposed by our native module can be imported "
"directly from the package."
msgstr ""

#: src/python_typing_hints.md:119
msgid "`py.typed` requirement"
msgstr ""

#: src/python_typing_hints.md:121
msgid "As stated in [PEP561](https://www.python.org/dev/peps/pep-0561/):"
msgstr ""

#: src/python_typing_hints.md:122
msgid ""
"Package maintainers who wish to support type checking of their code MUST add "
"a marker file named py.typed to their package supporting typing. This marker "
"applies recursively: if a top-level package includes it, all its sub-"
"packages MUST support type checking as well."
msgstr ""

#: src/python_typing_hints.md:124
msgid ""
"If we do not include that file, some IDEs might still use our `pyi` files to "
"show hints, but the type checkers might not. MyPy will raise an error in "
"this situation:"
msgstr ""

#: src/python_typing_hints.md:126
msgid ""
"```text\n"
"error: Skipping analyzing \"my_project\": found module but no type hints or "
"library stubs\n"
"```"
msgstr ""

#: src/python_typing_hints.md:130
msgid "The file is just a marker file, so it should be empty."
msgstr ""

#: src/python_typing_hints.md:132
msgid "`my_project.pyi` content"
msgstr ""

#: src/python_typing_hints.md:134
msgid ""
"Our module stub file. This document does not aim at describing how to write "
"them, since you can find a lot of documentation on it, starting from already "
"quoted [PEP484](https://www.python.org/dev/peps/pep-0484/#stub-files)."
msgstr ""

#: src/python_typing_hints.md:136
msgid "The example can look like this:"
msgstr ""

#: src/python_typing_hints.md:140
msgid ""
"\"\"\"\n"
"    A class representing a car.\n"
"\n"
"    :param body_type: the name of body type, e.g. hatchback, sedan\n"
"    :param horsepower: power of the engine in horsepower\n"
"    \"\"\""
msgstr ""

#: src/python_typing_hints.md:149
msgid "'Car'"
msgstr ""

#: src/python_typing_hints.md:150
msgid ""
"\"\"\"\n"
"        Creates a Car based on unique name\n"
"\n"
"        :param name: model name of a car to be created\n"
"        :return: a Car instance with default data\n"
"        \"\"\""
msgstr ""

#: src/python_typing_hints.md:158
msgid ""
"\"\"\"\n"
"        Gets the best color for the car.\n"
"\n"
"        :return: the name of the color our great algorithm thinks is the "
"best for this car\n"
"        \"\"\""
msgstr ""

#: src/building_and_distribution.md:1
msgid "Building and Distribution"
msgstr ""

#: src/building_and_distribution.md:3
msgid ""
"This chapter of the guide goes into detail on how to build and distribute "
"projects using PyO3. The way to achieve this is very different depending on "
"whether the project is a Python module implemented in Rust, or a Rust binary "
"embedding Python. For both types of project there are also common problems "
"such as the Python version to build for and the [linker](https://en."
"wikipedia.org/wiki/Linker_(computing)) arguments to use."
msgstr ""

#: src/building_and_distribution.md:5
msgid ""
"The material in this chapter is intended for users who have already read the "
"PyO3 [README](#index.md). It covers in turn the choices that can be made for "
"Python modules and for Rust binaries. There is also a section at the end "
"about cross-compiling projects using PyO3."
msgstr ""

#: src/building_and_distribution.md:7
msgid ""
"There is an additional sub-chapter dedicated to [supporting multiple Python "
"versions](./building_and_distribution/multiple_python_versions.html)."
msgstr ""

#: src/building_and_distribution.md:9
msgid "Configuring the Python version"
msgstr ""

#: src/building_and_distribution.md:11
msgid ""
"PyO3 uses a build script (backed by the [`pyo3-build-config`](https://github."
"com/PyO3/pyo3/tree/main/pyo3-build-config) crate) to determine the Python "
"version and set the correct linker arguments. By default it will attempt to "
"use the following in order:"
msgstr ""

#: src/building_and_distribution.md:12
msgid "Any active Python virtualenv."
msgstr ""

#: src/building_and_distribution.md:13
msgid "The `python` executable (if it's a Python 3 interpreter)."
msgstr ""

#: src/building_and_distribution.md:14
msgid "The `python3` executable."
msgstr ""

#: src/building_and_distribution.md:16
msgid ""
"You can override the Python interpreter by setting the `PYO3_PYTHON` "
"environment variable, e.g. `PYO3_PYTHON=python3.6`, `PYO3_PYTHON=/usr/bin/"
"python3.9`, or even a PyPy interpreter `PYO3_PYTHON=pypy3`."
msgstr ""

#: src/building_and_distribution.md:18
msgid ""
"Once the Python interpreter is located, `pyo3-build-config` executes it to "
"query the information in the `sysconfig` module which is needed to configure "
"the rest of the compilation."
msgstr ""

#: src/building_and_distribution.md:20
msgid ""
"To validate the configuration which PyO3 will use, you can run a compilation "
"with the environment variable `PYO3_PRINT_CONFIG=1` set. An example output "
"of doing this is shown below:"
msgstr ""

#: src/building_and_distribution.md:47
msgid "Advanced: config files"
msgstr ""

#: src/building_and_distribution.md:49
msgid ""
"If you save the above output config from `PYO3_PRINT_CONFIG` to a file, it "
"is possible to manually override the contents and feed it back into PyO3 "
"using the `PYO3_CONFIG_FILE` env var."
msgstr ""

#: src/building_and_distribution.md:51
msgid ""
"If your build environment is unusual enough that PyO3's regular "
"configuration detection doesn't work, using a config file like this will "
"give you the flexibility to make PyO3 work for you. To see the full set of "
"options supported, see the documentation for the [`InterpreterConfig` struct]"
"(https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct."
"InterpreterConfig.html)."
msgstr ""

#: src/building_and_distribution.md:53
msgid "Building Python extension modules"
msgstr ""

#: src/building_and_distribution.md:55
msgid ""
"Python extension modules need to be compiled differently depending on the OS "
"(and architecture) that they are being compiled for. As well as multiple "
"OSes (and architectures), there are also many different Python versions "
"which are actively supported. Packages uploaded to [PyPI](https://pypi.org/) "
"usually want to upload prebuilt \"wheels\" covering many OS/arch/version "
"combinations so that users on all these different platforms don't have to "
"compile the package themselves. Package vendors can opt-in to the \"abi3\" "
"limited Python API which allows their wheels to be used on multiple Python "
"versions, reducing the number of wheels they need to compile, but restricts "
"the functionality they can use."
msgstr ""

#: src/building_and_distribution.md:57
msgid ""
"There are many ways to go about this: it is possible to use `cargo` to build "
"the extension module (along with some manual work, which varies with OS). "
"The PyO3 ecosystem has two packaging tools, [`maturin`](https://github.com/"
"PyO3/maturin) and [`setuptools-rust`](https://github.com/PyO3/setuptools-"
"rust), which abstract over the OS difference and also support building "
"wheels for PyPI upload."
msgstr ""

#: src/building_and_distribution.md:59
msgid ""
"PyO3 has some Cargo features to configure projects for building Python "
"extension modules:"
msgstr ""

#: src/building_and_distribution.md:60
msgid ""
"The `extension-module` feature, which must be enabled when building Python "
"extension modules."
msgstr ""

#: src/building_and_distribution.md:61
msgid ""
"The `abi3` feature and its version-specific `abi3-pyXY` companions, which "
"are used to opt-in to the limited Python API in order to support multiple "
"Python versions in a single wheel."
msgstr ""

#: src/building_and_distribution.md:63
msgid ""
"This section describes each of these packaging tools before describiing how "
"to build manually without them. It then proceeds with an explanation of the "
"`extension-module` feature. Finally, there is a section describing PyO3's "
"`abi3` features."
msgstr ""

#: src/building_and_distribution.md:65
msgid "Packaging tools"
msgstr ""

#: src/building_and_distribution.md:67
msgid ""
"The PyO3 ecosystem has two main choices to abstract the process of "
"developing Python extension modules:"
msgstr ""

#: src/building_and_distribution.md:68
msgid ""
"[`maturin`](https://github.com/PyO3/maturin) is a command-line tool to "
"build, package and upload Python modules. It makes opinionated choices about "
"project layout meaning it needs very little configuration. This makes it a "
"great choice for users who are building a Python extension from scratch and "
"don't need flexibility."
msgstr ""

#: src/building_and_distribution.md:69
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is an add-on "
"for `setuptools` which adds extra keyword arguments to the `setup.py` "
"configuration file. It requires more configuration than `maturin`, however "
"this gives additional flexibility for users adding Rust to an existing "
"Python package that can't satisfy `maturin`'s constraints."
msgstr ""

#: src/building_and_distribution.md:71
msgid ""
"Consult each project's documentation for full details on how to get started "
"using them and how to upload wheels to PyPI."
msgstr ""

#: src/building_and_distribution.md:73
msgid ""
"There are also [`maturin-starter`](https://github.com/PyO3/pyo3/tree/main/"
"examples/maturin-starter) and [`setuptools-rust-starter`](https://github.com/"
"PyO3/pyo3/tree/main/examples/setuptools-rust-starter) examples in the PyO3 "
"repository."
msgstr ""

#: src/building_and_distribution.md:75
msgid "Manual builds"
msgstr ""

#: src/building_and_distribution.md:77
msgid ""
"To build a PyO3-based Python extension manually, start by running `cargo "
"build` as normal in a library project which uses PyO3's `extension-module` "
"feature and has the [`cdylib` crate type](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#the-crate-type-field)."
msgstr ""

#: src/building_and_distribution.md:79
msgid ""
"Once built, symlink (or copy) and rename the shared library from Cargo's "
"`target/` directory to your desired output directory:"
msgstr ""

#: src/building_and_distribution.md:80
msgid "on macOS, rename `libyour_module.dylib` to `your_module.so`."
msgstr ""

#: src/building_and_distribution.md:81
msgid "on Windows, rename  `libyour_module.dll` to `your_module.pyd`."
msgstr ""

#: src/building_and_distribution.md:82
msgid "on Linux, rename `libyour_module.so` to `your_module.so`."
msgstr ""

#: src/building_and_distribution.md:84
msgid ""
"You can then open a Python shell in the output directory and you'll be able "
"to run `import your_module`."
msgstr ""

#: src/building_and_distribution.md:86
msgid ""
"See, as an example, Bazel rules to build PyO3 on Linux at https://github.com/"
"TheButlah/rules_pyo3."
msgstr ""

#: src/building_and_distribution.md:88
msgid "macOS"
msgstr ""

#: src/building_and_distribution.md:90
msgid ""
"On macOS, because the `extension-module` feature disables linking to "
"`libpython` ([see the next section](#the-extension-module-feature)), some "
"additional linker arguments need to be set. `maturin` and `setuptools-rust` "
"both pass these arguments for PyO3 automatically, but projects using manual "
"builds will need to set these directly in order to support macOS."
msgstr ""

#: src/building_and_distribution.md:92
msgid ""
"The easiest way to set the correct linker arguments is to add a [`build.rs`]"
"(https://doc.rust-lang.org/cargo/reference/build-scripts.html) with the "
"following content:"
msgstr ""

#: src/building_and_distribution.md:100
msgid ""
"Remember to also add `pyo3-build-config` to the `build-dependencies` section "
"in `Cargo.toml`."
msgstr ""

#: src/building_and_distribution.md:102
msgid ""
"An alternative to using `pyo3-build-config` is add the following to a cargo "
"configuration file (e.g. `.cargo/config.toml`):"
msgstr ""

#: src/building_and_distribution.md:104
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"\n"
"[target.aarch64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/building_and_distribution.md:118
msgid "The `extension-module` feature"
msgstr ""

#: src/building_and_distribution.md:120
msgid ""
"PyO3's `extension-module` feature is used to disable [linking](https://en."
"wikipedia.org/wiki/Linker_(computing)) to `libpython` on unix targets."
msgstr ""

#: src/building_and_distribution.md:122
msgid ""
"This is necessary because by default PyO3 links to `libpython`. This makes "
"binaries, tests, and examples \"just work\". However, Python extensions on "
"unix must not link to libpython for [manylinux](https://www.python.org/dev/"
"peps/pep-0513/) compliance."
msgstr ""

#: src/building_and_distribution.md:124
msgid ""
"The downside of not linking to `libpython` is that binaries, tests, and "
"examples (which usually embed Python) will fail to build. If you have an "
"extension module as well as other outputs in a single project, you need to "
"use optional Cargo features to disable the `extension-module` when you're "
"not building the extension module. See [the FAQ](faq.md#i-cant-run-cargo-"
"test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-"
"_pyexc_systemerror) for an example workaround."
msgstr ""

#: src/building_and_distribution.md:126
msgid "`Py_LIMITED_API`/`abi3`"
msgstr ""

#: src/building_and_distribution.md:128
msgid ""
"By default, Python extension modules can only be used with the same Python "
"version they were compiled against. For example, an extension module built "
"for Python 3.5 can't be imported in Python 3.8. [PEP 384](https://www.python."
"org/dev/peps/pep-0384/) introduced the idea of the limited Python API, which "
"would have a stable ABI enabling extension modules built with it to be used "
"against multiple Python versions. This is also known as `abi3`."
msgstr ""

#: src/building_and_distribution.md:130
msgid ""
"The advantage of building extension modules using the limited Python API is "
"that package vendors only need to build and distribute a single copy (for "
"each OS / architecture), and users can install it on all Python versions "
"from the [minimum version](#minimum-python-version-for-abi3) and up. The "
"downside of this is that PyO3 can't use optimizations which rely on being "
"compiled against a known exact Python version. It's up to you to decide "
"whether this matters for your extension module. It's also possible to design "
"your extension module such that you can distribute `abi3` wheels but allow "
"users compiling from source to benefit from additional optimizations - see "
"the [support for multiple python versions](./building_and_distribution/"
"multiple_python_versions.html) section of this guide, in particular the "
"`#[cfg(Py_LIMITED_API)]` flag."
msgstr ""

#: src/building_and_distribution.md:132
msgid ""
"There are three steps involved in making use of `abi3` when building Python "
"packages as wheels:"
msgstr ""

#: src/building_and_distribution.md:134
msgid ""
"Enable the `abi3` feature in `pyo3`. This ensures `pyo3` only calls Python C-"
"API functions which are part of the stable API, and on Windows also ensures "
"that the project links against the correct shared object (no special "
"behavior is required on other platforms):"
msgstr ""

#: src/building_and_distribution.md:136
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"abi3\"] }\n"
"```"
msgstr ""

#: src/building_and_distribution.md:141
msgid ""
"Ensure that the built shared objects are correctly marked as `abi3`. This is "
"accomplished by telling your build system that you're using the limited API. "
"[`maturin`](https://github.com/PyO3/maturin) >= 0.9.0 and [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) >= 0.11.4 support `abi3` wheels. "
"See the [corresponding](https://github.com/PyO3/maturin/pull/353) [PRs]"
"(https://github.com/PyO3/setuptools-rust/pull/82) for more."
msgstr ""

#: src/building_and_distribution.md:144
msgid ""
"Ensure that the `.whl` is correctly marked as `abi3`. For projects using "
"`setuptools`, this is accomplished by passing `--py-limited-api=cp3x` (where "
"`x` is the minimum Python version supported by the wheel, e.g. `--py-limited-"
"api=cp35` for Python 3.5) to `setup.py bdist_wheel`."
msgstr ""

#: src/building_and_distribution.md:146
msgid "Minimum Python version for `abi3`"
msgstr ""

#: src/building_and_distribution.md:148
msgid ""
"Because a single `abi3` wheel can be used with many different Python "
"versions, PyO3 has feature flags `abi3-py36`, `abi3-py37`, `abi-py38` etc. "
"to set the minimum required Python version for your `abi3` wheel. For "
"example, if you set the `abi3-py36` feature, your extension wheel can be "
"used on all Python 3 versions from Python 3.6 and up. `maturin` and "
"`setuptools-rust` will give the wheel a name like `my-extension-1.0-cp36-"
"abi3-manylinux2020_x86_64.whl`."
msgstr ""

#: src/building_and_distribution.md:151
msgid ""
"As your extension module may be run with multiple different Python versions "
"you may occasionally find you need to check the Python version at runtime to "
"customize behavior. See [the relevant section of this guide](./"
"building_and_distribution/multiple_python_versions.html#checking-the-python-"
"version-at-runtime) on supporting multiple Python versions at runtime."
msgstr ""

#: src/building_and_distribution.md:153
msgid ""
"PyO3 is only able to link your extension module to api3 version up to and "
"including your host Python version. E.g., if you set `abi3-py38` and try to "
"compile the crate with a host of Python 3.6, the build will fail."
msgstr ""

#: src/building_and_distribution.md:155
msgid ""
"As an advanced feature, you can build PyO3 wheel without calling Python "
"interpreter with the environment variable `PYO3_NO_PYTHON` set. On unix "
"systems this works unconditionally; on Windows you must also set the "
"`RUSTFLAGS` evironment variable to contain `-L native=/path/to/python/libs` "
"so that the linker can find `python3.lib`."
msgstr ""

#: src/building_and_distribution.md:157
msgid ""
"Note: If you set more that one of these api version feature flags the "
"highest version always wins. For example, with both `abi3-py36` and `abi3-"
"py38` set, PyO3 would build a wheel which supports Python 3.8 and up."
msgstr ""

#: src/building_and_distribution.md:159
msgid "Missing features"
msgstr ""

#: src/building_and_distribution.md:161
msgid ""
"Due to limitations in the Python API, there are a few `pyo3` features that "
"do not work when compiling for `abi3`. These are:"
msgstr ""

#: src/building_and_distribution.md:164
msgid ""
"`#[pyo3(text_signature = \"...\")]` does not work on classes until Python "
"3.10 or greater."
msgstr ""

#: src/building_and_distribution.md:165
msgid ""
"The `dict` and `weakref` options on classes are not supported until Python "
"3.9 or greater."
msgstr ""

#: src/building_and_distribution.md:166
msgid "The buffer API is not supported."
msgstr ""

#: src/building_and_distribution.md:167
msgid ""
"Optimizations which rely on knowledge of the exact Python version compiled "
"against."
msgstr ""

#: src/building_and_distribution.md:169
msgid "Embedding Python in Rust"
msgstr ""

#: src/building_and_distribution.md:171
msgid ""
"If you want to embed the Python interpreter inside a Rust program, there are "
"two modes in which this can be done: dynamically and statically. We'll cover "
"each of these modes in the following sections. Each of them affect how you "
"must distribute your program. Instead of learning how to do this yourself, "
"you might want to consider using a project like [PyOxidizer](https://github."
"com/indygreg/PyOxidizer) to ship your application and all of its "
"dependencies in a single file."
msgstr ""

#: src/building_and_distribution.md:173
msgid ""
"PyO3 automatically switches between the two linking modes depending on "
"whether the Python distribution you have configured PyO3 to use ([see above]"
"(#python-version)) contains a shared library or a static library. The static "
"library is most often seen in Python distributions compiled from source "
"without the `--enable-shared` configuration option. For example, this is the "
"default for `pyenv` on macOS."
msgstr ""

#: src/building_and_distribution.md:175
msgid "Dynamically embedding the Python interpreter"
msgstr ""

#: src/building_and_distribution.md:177
msgid ""
"Embedding the Python interpreter dynamically is much easier than doing so "
"statically. This is done by linking your program against a Python shared "
"library (such as `libpython.3.9.so` on UNIX, or `python39.dll` on Windows). "
"The implementation of the Python interpreter resides inside the shared "
"library. This means that when the OS runs your Rust program it also needs to "
"be able to find the Python shared library."
msgstr ""

#: src/building_and_distribution.md:179
msgid ""
"This mode of embedding works well for Rust tests which need access to the "
"Python interpreter. It is also great for Rust software which is installed "
"inside a Python virtualenv, because the virtualenv sets up appropriate "
"environment variables to locate the correct Python shared library."
msgstr ""

#: src/building_and_distribution.md:181
msgid ""
"For distributing your program to non-technical users, you will have to "
"consider including the Python shared library in your distribution as well as "
"setting up wrapper scripts to set the right environment variables (such as "
"`LD_LIBRARY_PATH` on UNIX, or `PATH` on Windows)."
msgstr ""

#: src/building_and_distribution.md:183
msgid ""
"Note that PyPy cannot be embedded in Rust (or any other software). Support "
"for this is tracked on the [PyPy issue tracker](https://foss.heptapod.net/"
"pypy/pypy/-/issues/3286)."
msgstr ""

#: src/building_and_distribution.md:185
msgid "Statically embedding the Python interpreter"
msgstr ""

#: src/building_and_distribution.md:187
msgid ""
"Embedding the Python interpreter statically means including the contents of "
"a Python static library directly inside your Rust binary. This means that to "
"distribute your program you only need to ship your binary file: it contains "
"the Python interpreter inside the binary!"
msgstr ""

#: src/building_and_distribution.md:189
msgid ""
"On Windows static linking is almost never done, so Python distributions "
"don't usually include a static library. The information below applies only "
"to UNIX."
msgstr ""

#: src/building_and_distribution.md:191
msgid "The Python static library is usually called `libpython.a`."
msgstr ""

#: src/building_and_distribution.md:193
msgid ""
"Static linking has a lot of complications, listed below. For these reasons "
"PyO3 does not yet have first-class support for this embedding mode. See "
"[issue 416 on PyO3's Github](https://github.com/PyO3/pyo3/issues/416) for "
"more information and to discuss any issues you encounter."
msgstr ""

#: src/building_and_distribution.md:195
msgid ""
"The [`auto-initialize`](features.md#auto-initialize) feature is deliberately "
"disabled when embedding the interpreter statically because this is often "
"unintentionally done by new users to PyO3 running test programs. Trying out "
"PyO3 is much easier using dynamic embedding."
msgstr ""

#: src/building_and_distribution.md:197
msgid "The known complications are:"
msgstr ""

#: src/building_and_distribution.md:198
msgid ""
"To import compiled extension modules (such as other Rust extension modules, "
"or those written in C), your binary must have the correct linker flags set "
"during compilation to export the original contents of `libpython.a` so that "
"extensions can use them (e.g. `-Wl,--export-dynamic`)."
msgstr ""

#: src/building_and_distribution.md:199
msgid ""
"The C compiler and flags which were used to create `libpython.a` must be "
"compatible with your Rust compiler and flags, else you will experience "
"compilation failures."
msgstr ""

#: src/building_and_distribution.md:201
msgid "Significantly different compiler versions may see errors like this:"
msgstr ""

#: src/building_and_distribution.md:207
msgid "Mismatching flags may lead to errors like this:"
msgstr ""

#: src/building_and_distribution.md:213
msgid ""
"If you encounter these or other complications when linking the interpreter "
"statically, discuss them on [issue 416 on PyO3's Github](https://github.com/"
"PyO3/pyo3/issues/416). It is hoped that eventually that discussion will "
"contain enough information and solutions that PyO3 can offer first-class "
"support for static embedding."
msgstr ""

#: src/building_and_distribution.md:215
msgid "Cross Compiling"
msgstr ""

#: src/building_and_distribution.md:217
msgid ""
"Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 "
"is relatively straightforward. To get started, you'll need a few pieces of "
"software:"
msgstr ""

#: src/building_and_distribution.md:219
msgid "A toolchain for your target."
msgstr ""

#: src/building_and_distribution.md:220
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building_and_distribution.md:221
msgid "A Python interpreter that's already been compiled for your target."
msgstr ""

#: src/building_and_distribution.md:222
msgid ""
"A Python interpreter that is built for your host and available through the "
"`PATH` or setting the [`PYO3_PYTHON`](#python-version) variable."
msgstr ""

#: src/building_and_distribution.md:224
msgid ""
"After you've obtained the above, you can build a cross-compiled PyO3 module "
"by using Cargo's `--target` flag. PyO3's build script will detect that you "
"are attempting a cross-compile based on your host machine and the desired "
"target."
msgstr ""

#: src/building_and_distribution.md:226
msgid ""
"When cross-compiling, PyO3's build script cannot execute the target Python "
"interpreter to query the configuration, so there are a few additional "
"environment variables you may need to set:"
msgstr ""

#: src/building_and_distribution.md:228
msgid ""
"`PYO3_CROSS`: If present this variable forces PyO3 to configure as a cross-"
"compilation."
msgstr ""

#: src/building_and_distribution.md:229
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable must be set to the directory containing "
"the target's libpython DSO and the associated `_sysconfigdata*.py` file for "
"Unix-like targets, or the Python DLL import libraries for the Windows target."
msgstr ""

#: src/building_and_distribution.md:230
msgid ""
"`PYO3_CROSS_PYTHON_VERSION`: Major and minor version (e.g. 3.9) of the "
"target Python installation. This variable is only needed if PyO3 cannot "
"determine the version to target from `abi3-py3*` features, or if there are "
"multiple versions of Python present in `PYO3_CROSS_LIB_DIR`."
msgstr ""

#: src/building_and_distribution.md:232
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building_and_distribution.md:235 src/building_and_distribution.md:243
#: src/building_and_distribution.md:251
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/building_and_distribution.md:240
msgid ""
"If there are multiple python versions at the cross lib directory and you "
"cannot set a more precise location to include both the `libpython` DSO and "
"`_sysconfigdata*.py` files, you can set the required version:"
msgstr ""

#: src/building_and_distribution.md:242
msgid "3.8"
msgstr ""

#: src/building_and_distribution.md:248
msgid "Or another example with the same sys root but building for Windows:"
msgstr ""

#: src/building_and_distribution.md:250
msgid "3.9"
msgstr ""

#: src/building_and_distribution.md:256
msgid ""
"Any of the `abi3-py3*` features can be enabled instead of setting "
"`PYO3_CROSS_PYTHON_VERSION` in the above examples."
msgstr ""

#: src/building_and_distribution.md:258
msgid "The following resources may also be useful for cross-compiling:"
msgstr ""

#: src/building_and_distribution.md:259
msgid ""
"[github.com/japaric/rust-cross](https://github.com/japaric/rust-cross) is a "
"primer on cross compiling Rust."
msgstr ""

#: src/building_and_distribution.md:260
msgid ""
"[github.com/rust-embedded/cross](https://github.com/rust-embedded/cross) "
"uses Docker to make Rust cross-compilation easier."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:1
msgid "Supporting multiple Python versions"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:3
msgid ""
"PyO3 supports all actively-supported Python 3 and PyPy versions. As much as "
"possible, this is done internally to PyO3 so that your crate's code does not "
"need to adapt to the differences between each version. However, as Python "
"features grow and change between versions, PyO3 cannot a completely "
"identical API for every Python version. This may require you to add "
"conditional compilation to your crate or runtime checks for the Python "
"version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:5
msgid ""
"This section of the guide first introduces the `pyo3-build-config` crate, "
"which you can use as a `build-dependency` to add additional `#[cfg]` flags "
"which allow you to support multiple Python versions at compile-time."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:7
msgid ""
"Second, we'll show how to check the Python version at runtime. This can be "
"useful when building for multiple versions with the `abi3` feature, where "
"the Python API compiled against is not always the same as the one in use."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:9
msgid "Conditional compilation for different Python versions"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:11
msgid ""
"The `pyo3-build-config` exposes multiple [`#[cfg]` flags](https://doc.rust-"
"lang.org/rust-by-example/attribute/cfg.html) which can be used to "
"conditionally compile code for a given Python version. PyO3 itself depends "
"on this crate, so by using it you can be sure that you are configured "
"correctly for the Python version PyO3 is building against."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:13
msgid "This allows us to write code like the following"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:26
msgid ""
"The following sections first show how to add these `#[cfg]` flags to your "
"build process, and then cover some common patterns flags in a little more "
"detail."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:28
msgid ""
"To see a full reference of all the `#[cfg]` flags provided, see the [`pyo3-"
"build-cfg` docs](https://docs.rs/pyo3-build-config)."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:30
msgid "Using `pyo3-build-config`"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:32
msgid "You can use the `#[cfg]` flags in just two steps:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:34
msgid ""
"Add `pyo3-build-config` it to your crate's build dependencies in `Cargo."
"toml`:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:36
msgid ""
"```toml\n"
"[build-dependencies]\n"
"pyo3-build-config = \"git = \"https://github.com/pyo3/pyo3\"\"\n"
"```"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:41
msgid ""
"Add a [`build.rs`](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html) file to your crate with the following contents:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:45
msgid "// If you have an existing build.rs file, just add this line to it.\n"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:50
msgid "After these steps you are ready to annotate your code!"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:52
msgid "Common usages of `pyo3-build-cfg` flags"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:54
msgid ""
"The `#[cfg]` flags added by `pyo3-build-cfg` can be combined with all of "
"Rust's logic in the `#[cfg]` attribute to create very precise conditional "
"code generation. The following are some common patterns implemented using "
"these flags:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:60
msgid ""
"This `#[cfg]` marks code that will only be present on Python 3.7 and "
"upwards. There are similar options `Py_3_8`, `Py_3_9`, `Py_3_10` and so on "
"for each minor version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:66
msgid ""
"This `#[cfg]` marks code that will only be present on Python versions before "
"(but not including) Python 3.7."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:72
msgid ""
"This `#[cfg]` marks code that is only available when building for the "
"unlimited Python API (i.e. PyO3's `abi3` feature is not enabled). This might "
"be useful if you want to ship your extension module as an `abi3` wheel and "
"also allow users to compile it from source to make use of optimizations only "
"possible with the unlimited API."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:78
msgid ""
"This `#[cfg]` marks code which is available when running Python 3.9 or "
"newer, or when using the unlimited API with an older Python version. "
"Patterns like this are commonly seen on Python APIs which were added to the "
"limited Python API in a specific minor version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:84
msgid "This `#[cfg]` marks code which is running on PyPy."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:86
msgid "Checking the Python version at runtime"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:88
msgid ""
"When building with PyO3's `abi3` feature, your extension module will be "
"compiled against a specific [minimum version](../building_and_distribution."
"html#minimum-python-version-for-abi3) of Python, but may be running on newer "
"Python versions."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:90
msgid ""
"For example with PyO3's `abi3-py38` feature, your extension will be compiled "
"as if it were for Python 3.8. If you were using `pyo3-build-config`, "
"`#[cfg(Py_3_8)]` would be present. Your user could freely install and run "
"your abi3 extension on Python 3.9."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:92
msgid ""
"There's no way to detect your user doing that at compile time, so instead "
"you need to fall back to runtime checks."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:94
msgid ""
"PyO3 provides the APIs [`Python::version()`](https://pyo3.rs/main/doc/pyo3/"
"struct.Python.html#method.version) and [`Python::version_info()`](https://"
"pyo3.rs/main/doc/pyo3/struct.Python.html#method.version_info) to query the "
"running Python version. This allows you to do the following, for example:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:98
msgid "// run this code only if Python 3.9 or up\n"
msgstr ""

#: src/python_from_rust.md:1
msgid "Calling Python in Rust code"
msgstr ""

#: src/python_from_rust.md:3
msgid ""
"This chapter of the guide documents some ways to interact with Python code "
"from Rust:"
msgstr ""

#: src/python_from_rust.md:4
msgid "How to call Python functions"
msgstr ""

#: src/python_from_rust.md:5
msgid "How to execute existing Python code"
msgstr ""

#: src/python_from_rust.md:7
msgid "Calling Python functions"
msgstr ""

#: src/python_from_rust.md:9
msgid ""
"Any Python-native object reference (such as `&PyAny`, `&PyList`, or "
"`&PyCell<MyClass>`) can be used to call Python functions."
msgstr ""

#: src/python_from_rust.md:11
msgid "PyO3 offers two APIs to make function calls:"
msgstr ""

#: src/python_from_rust.md:13
msgid ""
"[`call`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call) - "
"call any callable Python object."
msgstr ""

#: src/python_from_rust.md:14
msgid ""
"[`call_method`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method."
"call_method) - call a method on the Python object."
msgstr ""

#: src/python_from_rust.md:16
msgid ""
"Both of these APIs take `args` and `kwargs` arguments (for positional and "
"keyword arguments respectively). There are variants for less complex calls:"
msgstr ""

#: src/python_from_rust.md:18
msgid ""
"[`call1`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call1) "
"and [`call_method1`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny."
"html#method.call_method1) to call only with positional `args`."
msgstr ""

#: src/python_from_rust.md:19
msgid ""
"[`call0`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call0) "
"and [`call_method0`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny."
"html#method.call_method0) to call with no arguments."
msgstr ""

#: src/python_from_rust.md:21
msgid ""
"For convenience the [`Py<T>`](types.html#pyt-and-pyobject) smart pointer "
"also exposes these same six API methods, but needs a `Python` token as an "
"additional first argument to prove the GIL is held."
msgstr ""

#: src/python_from_rust.md:23
msgid ""
"The example below calls a Python function behind a `PyObject` (aka "
"`Py<PyAny>`) reference:"
msgstr ""

#: src/python_from_rust.md:30
msgid "\"arg1\""
msgstr ""

#: src/python_from_rust.md:31
msgid "\"arg2\""
msgstr ""

#: src/python_from_rust.md:32
msgid "\"arg3\""
msgstr ""

#: src/python_from_rust.md:37 src/python_from_rust.md:81
msgid ""
"\"def example(*args, **kwargs):\n"
"                if args != ():\n"
"                    print('called with args', args)\n"
"                if kwargs != {}:\n"
"                    print('called with kwargs', kwargs)\n"
"                if args == () and kwargs == {}:\n"
"                    print('called with no arguments')\""
msgstr ""

#: src/python_from_rust.md:44 src/python_from_rust.md:45
#: src/python_from_rust.md:88 src/python_from_rust.md:89
msgid "\"\""
msgstr ""

#: src/python_from_rust.md:46 src/python_from_rust.md:90
msgid "\"example\""
msgstr ""

#: src/python_from_rust.md:48
msgid "// call object without empty arguments\n"
msgstr ""

#: src/python_from_rust.md:51
msgid "// call object with PyTuple\n"
msgstr ""

#: src/python_from_rust.md:55
msgid "// pass arguments as rust tuple\n"
msgstr ""

#: src/python_from_rust.md:63
msgid "Creating keyword arguments"
msgstr ""

#: src/python_from_rust.md:65
msgid ""
"For the `call` and `call_method` APIs, `kwargs` can be `None` or "
"`Some(&PyDict)`. You can use the [`IntoPyDict`](https://pyo3.rs/main/doc/"
"pyo3/types/trait.IntoPyDict.html) trait to convert other dict-like "
"containers, e.g. `HashMap` or `BTreeMap`, as well as tuples with up to 10 "
"elements and `Vec`s where each element is a two-element tuple."
msgstr ""

#: src/python_from_rust.md:73
msgid "\"key1\""
msgstr ""

#: src/python_from_rust.md:75
msgid "\"key2\""
msgstr ""

#: src/python_from_rust.md:93
msgid "// call object with PyDict\n"
msgstr ""

#: src/python_from_rust.md:97
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/python_from_rust.md:101
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/python_from_rust.md:111
msgid "Executing existing Python code"
msgstr ""

#: src/python_from_rust.md:113
msgid ""
"If you already have some existing Python code that you need to execute from "
"Rust, the following FAQs can help you select the right PyO3 functionality "
"for your situation:"
msgstr ""

#: src/python_from_rust.md:115
msgid "Want to access Python APIs? Then use `PyModule::import`."
msgstr ""

#: src/python_from_rust.md:117
msgid ""
"[`Pymodule::import`](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.import) can be used to get handle to a Python module from Rust. "
"You can use this to import and use any Python module available in your "
"environment."
msgstr ""

#: src/python_from_rust.md:126
msgid "\"builtins\""
msgstr ""

#: src/python_from_rust.md:127
msgid "\"sum\""
msgstr ""

#: src/python_from_rust.md:134
msgid "Want to run just an expression? Then use `eval`."
msgstr ""

#: src/python_from_rust.md:136
msgid ""
"[`Python::eval`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method."
"eval) is a method to execute a [Python expression](https://docs.python."
"org/3.7/reference/expressions.html) and return the evaluated value as a "
"`&PyAny` object."
msgstr ""

#: src/python_from_rust.md:145
msgid "\"[i * 10 for i in range(5)]\""
msgstr ""

#: src/python_from_rust.md:155
msgid "Want to run statements? Then use `run`."
msgstr ""

#: src/python_from_rust.md:157
msgid ""
"[`Python::run`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.run) "
"is a method to execute one or more [Python statements](https://docs.python."
"org/3.7/reference/simple_stmts.html). This method returns nothing (like any "
"Python statement), but you can get access to manipulated objects via the "
"`locals` dict."
msgstr ""

#: src/python_from_rust.md:162
msgid ""
"You can also use the [`py_run!`](https://pyo3.rs/main/doc/pyo3/macro.py_run."
"html) macro, which is a shorthand for [`Python::run`](https://pyo3.rs/main/"
"doc/pyo3/struct.Python.html#method.run). Since [`py_run!`](https://pyo3.rs/"
"main/doc/pyo3/macro.py_run.html) panics on exceptions, we recommend you use "
"this macro only for quickly testing your Python extensions."
msgstr ""

#: src/python_from_rust.md:187
msgid "\"User {}(id: {})\""
msgstr ""

#: src/python_from_rust.md:194 src/python_from_rust.md:197
msgid "\"Yu\""
msgstr ""

#: src/python_from_rust.md:198
msgid ""
"r#\"\n"
"assert repr(userdata) == \"User Yu(id: 34)\"\n"
"assert userdata.as_tuple() == userdata_as_tuple\n"
"    \"#"
msgstr ""

#: src/python_from_rust.md:206
msgid "You have a Python file or code snippet? Then use `PyModule::from_code`."
msgstr ""

#: src/python_from_rust.md:208
msgid ""
"[PyModule::from_code](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.from_code) can be used to generate a Python module which can "
"then be used just as if it was imported with `PyModule::import`."
msgstr ""

#: src/python_from_rust.md:217
msgid ""
"r#\"\n"
"def relu(x):\n"
"    \"\"\"see https://en.wikipedia.org/wiki/"
"Rectifier_(neural_networks)\"\"\"\n"
"    return max(0.0, x)\n"
"\n"
"def leaky_relu(x, slope=0.01):\n"
"    return x if x >= 0 else x * slope\n"
"    \"#"
msgstr ""

#: src/python_from_rust.md:224
msgid "\"activators.py\""
msgstr ""

#: src/python_from_rust.md:224
msgid "\"activators\""
msgstr ""

#: src/python_from_rust.md:226
msgid "\"relu\""
msgstr ""

#: src/python_from_rust.md:229
msgid "\"slope\""
msgstr ""

#: src/python_from_rust.md:231
msgid "\"leaky_relu\""
msgstr ""

#: src/python_from_rust.md:242
msgid "Need to use a context manager from Rust?"
msgstr ""

#: src/python_from_rust.md:244
msgid "Use context managers by directly invoking `__enter__` and `__exit__`."
msgstr ""

#: src/python_from_rust.md:252
msgid ""
"r#\"\n"
"class House(object):\n"
"    def __init__(self, address):\n"
"        self.address = address\n"
"    def __enter__(self):\n"
"        print(f\"Welcome to {self.address}!\")\n"
"    def __exit__(self, type, value, traceback):\n"
"        if type:\n"
"            print(f\"Sorry you had {type} trouble at {self.address}\")\n"
"        else:\n"
"            print(f\"Thank you for visiting {self.address}, come again soon!"
"\")\n"
"\n"
"        \"#"
msgstr ""

#: src/python_from_rust.md:264
msgid "\"house.py\""
msgstr ""

#: src/python_from_rust.md:264
msgid "\"house\""
msgstr ""

#: src/python_from_rust.md:266
msgid "\"House\""
msgstr ""

#: src/python_from_rust.md:267
msgid "\"123 Main Street\""
msgstr ""

#: src/python_from_rust.md:269
msgid "\"__enter__\""
msgstr ""

#: src/python_from_rust.md:271
msgid "\"undefined_variable + 1\""
msgstr ""

#: src/python_from_rust.md:273
msgid ""
"// If the eval threw an exception we'll pass it through to the context "
"manager.\n"
"        // Otherwise, __exit__  is called with empty arguments (Python "
"\"None\").\n"
msgstr ""

#: src/python_from_rust.md:278 src/python_from_rust.md:282
msgid "\"__exit__\""
msgstr ""

#: src/changelog.md:1
msgid "Changelog"
msgstr ""

#: src/changelog.md:3
msgid ""
"All notable changes to this project will be documented in this file. For "
"help with updating to new PyO3 versions, please see the [migration guide]"
"(https://pyo3.rs/latest/migration.html)."
msgstr ""

#: src/changelog.md:6
msgid ""
"The format is based on [Keep a Changelog](https://keepachangelog.com/"
"en/1.0.0/) and this project adheres to [Semantic Versioning](https://semver."
"org/spec/v2.0.0.html)."
msgstr ""

#: src/changelog.md:9
msgid ""
"\\##[0.15.2](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2) - "
"2022-04-14"
msgstr ""

#: src/changelog.md:11 src/changelog.md:36 src/changelog.md:157
#: src/changelog.md:253 src/changelog.md:314
msgid "Packaging"
msgstr ""

#: src/changelog.md:13
msgid ""
"Backport of PyPy 3.9 support from PyO3 0.16. [\\#2262](https://github.com/"
"PyO3/pyo3/pull/2262)"
msgstr ""

#: src/changelog.md:15
msgid ""
"[0.15.1](https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1) - 2021-11-19"
msgstr ""

#: src/changelog.md:17 src/changelog.md:44 src/changelog.md:91
#: src/changelog.md:108 src/changelog.md:124 src/changelog.md:147
#: src/changelog.md:164 src/changelog.md:257 src/changelog.md:282
#: src/changelog.md:322 src/changelog.md:382 src/changelog.md:402
#: src/changelog.md:469 src/changelog.md:479 src/changelog.md:525
#: src/changelog.md:567 src/changelog.md:584 src/changelog.md:632
#: src/changelog.md:639 src/changelog.md:656 src/changelog.md:672
#: src/changelog.md:684 src/changelog.md:710 src/changelog.md:753
#: src/changelog.md:815 src/changelog.md:894 src/changelog.md:923
#: src/changelog.md:936 src/changelog.md:975 src/changelog.md:992
msgid "Added"
msgstr ""

#: src/changelog.md:19
msgid ""
"Add implementations for `Py::as_ref()` and `Py::into_ref()` for "
"`Py<PySequence>`, `Py<PyIterator>` and `Py<PyMapping>`. [\\#1682](https://"
"github.com/PyO3/pyo3/pull/1682)"
msgstr ""

#: src/changelog.md:20
msgid ""
"Add `PyTraceback` type to represent and format Python tracebacks. [\\#1977]"
"(https://github.com/PyO3/pyo3/pull/1977)"
msgstr ""

#: src/changelog.md:22 src/changelog.md:60 src/changelog.md:102
#: src/changelog.md:130 src/changelog.md:184 src/changelog.md:265
#: src/changelog.md:337 src/changelog.md:418 src/changelog.md:473
#: src/changelog.md:488 src/changelog.md:537 src/changelog.md:598
#: src/changelog.md:692 src/changelog.md:718 src/changelog.md:761
#: src/changelog.md:824 src/changelog.md:856 src/changelog.md:870
#: src/changelog.md:882 src/changelog.md:899 src/changelog.md:949
#: src/changelog.md:963 src/changelog.md:985
msgid "Changed"
msgstr ""

#: src/changelog.md:24
msgid ""
"`#[classattr]` constants with a known magic method name (which is lowercase) "
"no longer trigger lint warnings expecting constants to be uppercase. "
"[\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:26 src/changelog.md:78 src/changelog.md:96
#: src/changelog.md:112 src/changelog.md:135 src/changelog.md:151
#: src/changelog.md:231 src/changelog.md:270 src/changelog.md:304
#: src/changelog.md:358 src/changelog.md:370 src/changelog.md:376
#: src/changelog.md:387 src/changelog.md:395 src/changelog.md:453
#: src/changelog.md:510 src/changelog.md:519 src/changelog.md:554
#: src/changelog.md:571 src/changelog.md:577 src/changelog.md:619
#: src/changelog.md:649 src/changelog.md:660 src/changelog.md:676
#: src/changelog.md:704 src/changelog.md:724 src/changelog.md:791
#: src/changelog.md:799 src/changelog.md:805 src/changelog.md:846
#: src/changelog.md:860 src/changelog.md:888 src/changelog.md:911
#: src/changelog.md:917 src/changelog.md:927 src/changelog.md:942
#: src/changelog.md:953 src/changelog.md:969
msgid "Fixed"
msgstr ""

#: src/changelog.md:28
msgid ""
"Fix creating `#[classattr]` by functions with the name of a known magic "
"method. [\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:29
msgid ""
"Fix use of `catch_unwind` in `allow_threads` which can cause fatal crashes. "
"[\\#1989](https://github.com/PyO3/pyo3/pull/1989)"
msgstr ""

#: src/changelog.md:30
msgid ""
"Fix build failure on PyPy when abi3 features are activated. [\\#1991]"
"(https://github.com/PyO3/pyo3/pull/1991)"
msgstr ""

#: src/changelog.md:31
msgid ""
"Fix mingw platform detection. [\\#1993](https://github.com/PyO3/pyo3/"
"pull/1993)"
msgstr ""

#: src/changelog.md:32
msgid ""
"Fix panic in `__get__` implementation when accessing descriptor on type "
"object. [\\#1997](https://github.com/PyO3/pyo3/pull/1997)"
msgstr ""

#: src/changelog.md:34
msgid ""
"[0.15.0](https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0) - 2021-11-03"
msgstr ""

#: src/changelog.md:38
msgid ""
"`pyo3`'s `Cargo.toml` now advertises `links = \"python\"` to inform Cargo "
"that it links against _libpython_. [\\#1819](https://github.com/PyO3/pyo3/"
"pull/1819)"
msgstr ""

#: src/changelog.md:39
msgid ""
"Added optional `anyhow` feature to convert `anyhow::Error` into `PyErr`. "
"[\\#1822](https://github.com/PyO3/pyo3/pull/1822)"
msgstr ""

#: src/changelog.md:40
msgid "Support Python 3.10. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:41
msgid ""
"Added optional `eyre` feature to convert `eyre::Report` into `PyErr`. "
"[\\#1893](https://github.com/PyO3/pyo3/pull/1893)"
msgstr ""

#: src/changelog.md:42
msgid "Support PyPy 3.8. [\\#1948](https://github.com/PyO3/pyo3/pull/1948)"
msgstr ""

#: src/changelog.md:46
msgid ""
"Add `PyList::get_item_unchecked` and `PyTuple::get_item_unchecked` to get "
"items without bounds checks. [\\#1733](https://github.com/PyO3/pyo3/"
"pull/1733)"
msgstr ""

#: src/changelog.md:47
msgid ""
"Support `#[doc = include_str!(...)]` attributes on Rust 1.54 and up. "
"[\\#1746](https://github.com/PyO3/pyo3/issues/1746)"
msgstr ""

#: src/changelog.md:48
msgid ""
"Add `PyAny::py` as a convenience for `PyNativeType::py`. [\\#1751](https://"
"github.com/PyO3/pyo3/pull/1751)"
msgstr ""

#: src/changelog.md:49
msgid ""
"Add implementation of `std::ops::Index<usize>` for `PyList`, `PyTuple` and "
"`PySequence`. [\\#1825](https://github.com/PyO3/pyo3/pull/1825)"
msgstr ""

#: src/changelog.md:50
msgid ""
"Add range indexing implementations of `std::ops::Index` for `PyList`, "
"`PyTuple` and `PySequence`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:51
msgid ""
"Add `PyMapping` type to represent the Python mapping protocol. [\\#1844]"
"(https://github.com/PyO3/pyo3/pull/1844)"
msgstr ""

#: src/changelog.md:52
msgid ""
"Add commonly-used sequence methods to `PyList` and `PyTuple`. [\\#1849]"
"(https://github.com/PyO3/pyo3/pull/1849)"
msgstr ""

#: src/changelog.md:53
msgid ""
"Add `as_sequence` methods to `PyList` and `PyTuple`. [\\#1860](https://"
"github.com/PyO3/pyo3/pull/1860)"
msgstr ""

#: src/changelog.md:54
msgid ""
"Add support for magic methods in `#[pymethods]`, intended as a replacement "
"for `#[pyproto]`. [\\#1864](https://github.com/PyO3/pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:55
msgid ""
"Add `abi3-py310` feature. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:56
msgid ""
"Add `PyCFunction::new_closure` to create a Python function from a Rust "
"closure. [\\#1901](https://github.com/PyO3/pyo3/pull/1901)"
msgstr ""

#: src/changelog.md:57
msgid ""
"Add support for positional-only arguments in `#[pyfunction]`. [\\#1925]"
"(https://github.com/PyO3/pyo3/pull/1925)"
msgstr ""

#: src/changelog.md:58
msgid ""
"Add `PyErr::take` to attempt to fetch a Python exception if present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:62
msgid ""
"`PyList`, `PyTuple` and `PySequence`'s APIs now accepts only `usize` indices "
"instead of `isize`. [\\#1733](https://github.com/PyO3/pyo3/pull/1733), "
"[\\#1802](https://github.com/PyO3/pyo3/pull/1802), [\\#1803](https://github."
"com/PyO3/pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:65
msgid ""
"`PyList::get_item` and `PyTuple::get_item` now return `PyResult<&PyAny>` "
"instead of panicking. [\\#1733](https://github.com/PyO3/pyo3/pull/1733)"
msgstr ""

#: src/changelog.md:66
msgid ""
"`PySequence::in_place_repeat` and `PySequence::in_place_concat` now return "
"`PyResult<&PySequence>` instead of `PyResult<()>`, which is needed in case "
"of immutable sequences such as tuples. [\\#1803](https://github.com/PyO3/"
"pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:67
msgid ""
"`PySequence::get_slice` now returns `PyResult<&PySequence>` instead of "
"`PyResult<&PyAny>`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:68
msgid ""
"Deprecate `PyTuple::split_from`. [\\#1804](https://github.com/PyO3/pyo3/"
"pull/1804)"
msgstr ""

#: src/changelog.md:69
msgid ""
"Deprecate `PyTuple::slice`, new method `PyTuple::get_slice` added with "
"`usize` indices. [\\#1828](https://github.com/PyO3/pyo3/pull/1828)"
msgstr ""

#: src/changelog.md:70
msgid ""
"Deprecate FFI definitions `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags` "
"when building for Python 3.9. [\\#1830](https://github.com/PyO3/pyo3/"
"pull/1830)"
msgstr ""

#: src/changelog.md:71
msgid ""
"Mark FFI definitions removed in Python 3.10 `PyParser_ASTFromString`, "
"`PyParser_ASTFromStringObject`, `PyParser_ASTFromFile`, "
"`PyParser_ASTFromFileObject`, `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags`, "
"`PyParser_SimpleParseString`, `PyParser_SimpleParseFile`, "
"`Py_SymtableString`, and `Py_SymtableStringObject`. [\\#1830](https://github."
"com/PyO3/pyo3/pull/1830)"
msgstr ""

#: src/changelog.md:72
msgid ""
"`#[pymethods]` now handles magic methods similarly to `#[pyproto]`. In the "
"future, `#[pyproto]` may be deprecated. [\\#1864](https://github.com/PyO3/"
"pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:73
msgid ""
"Deprecate FFI definitions `PySys_AddWarnOption`, "
"`PySys_AddWarnOptionUnicode` and `PySys_HasWarnOptions`. [\\#1887](https://"
"github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:74
msgid ""
"Deprecate `#[call]` attribute in favor of using `fn __call__`. [\\#1929]"
"(https://github.com/PyO3/pyo3/pull/1929)"
msgstr ""

#: src/changelog.md:75 src/changelog.md:87
msgid ""
"Fix missing FFI definition `_PyImport_FindExtensionObject` on Python 3.10. "
"[\\#1942](https://github.com/PyO3/pyo3/pull/1942)"
msgstr ""

#: src/changelog.md:76
msgid ""
"Change `PyErr::fetch` to panic in debug mode if no exception is present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:80
msgid ""
"Fix building with a conda environment on Windows. [\\#1873](https://github."
"com/PyO3/pyo3/pull/1873)"
msgstr ""

#: src/changelog.md:81
msgid ""
"Fix panic on Python 3.6 when calling `Python::with_gil` with Python "
"initialized but threading not initialized. [\\#1874](https://github.com/PyO3/"
"pyo3/pull/1874)"
msgstr ""

#: src/changelog.md:82
msgid ""
"Fix incorrect linking to version-specific DLL instead of `python3.dll` when "
"cross-compiling to Windows with `abi3`. [\\#1880](https://github.com/PyO3/"
"pyo3/pull/1880)"
msgstr ""

#: src/changelog.md:83
msgid ""
"Fix FFI definition for `PyTuple_ClearFreeList` incorrectly being present for "
"Python 3.9 and up. [\\#1887](https://github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:84
msgid ""
"Fix panic in generated `#[derive(FromPyObject)]` for enums. [\\#1888]"
"(https://github.com/PyO3/pyo3/pull/1888)"
msgstr ""

#: src/changelog.md:85
msgid ""
"Fix cross-compiling to Python 3.7 builds with the \"m\" abi flag. [\\#1908]"
"(https://github.com/PyO3/pyo3/pull/1908)"
msgstr ""

#: src/changelog.md:86
msgid ""
"Fix `__mod__` magic method fallback to `__rmod__`. [\\#1934](https://github."
"com/PyO3/pyo3/pull/1934)."
msgstr ""

#: src/changelog.md:89
msgid ""
"[0.14.5](https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5) - 2021-09-05"
msgstr ""

#: src/changelog.md:93
msgid ""
"Make `pyo3_build_config::InterpreterConfig` and subfields public. [\\#1848]"
"(https://github.com/PyO3/pyo3/pull/1848)"
msgstr ""

#: src/changelog.md:94
msgid ""
"Add `resolve-config` feature to the `pyo3-build-config` to control whether "
"its build script does anything. [\\#1856](https://github.com/PyO3/pyo3/"
"pull/1856)"
msgstr ""

#: src/changelog.md:98
msgid ""
"Fix 0.14.4 compile regression on `s390x-unknown-linux-gnu` target. [\\#1850]"
"(https://github.com/PyO3/pyo3/pull/1850)"
msgstr ""

#: src/changelog.md:100
msgid ""
"[0.14.4](https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4) - 2021-08-29"
msgstr ""

#: src/changelog.md:104
msgid ""
"Mark `PyString::data` as `unsafe` and disable it and some supporting "
"PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. "
"[\\#1834](https://github.com/PyO3/pyo3/pull/1834)"
msgstr ""

#: src/changelog.md:106
msgid ""
"[0.14.3](https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3) - 2021-08-22"
msgstr ""

#: src/changelog.md:110
msgid ""
"Add `PyString::data` to access the raw bytes stored in a Python string. "
"[\\#1794](https://github.com/PyO3/pyo3/pull/1794)"
msgstr ""

#: src/changelog.md:114
msgid ""
"Raise `AttributeError` to avoid panic when calling `del` on a `#[setter]` "
"defined class property. [\\#1779](https://github.com/PyO3/pyo3/pull/1779)"
msgstr ""

#: src/changelog.md:115
msgid ""
"Restrict FFI definitions `PyGILState_Check` and `Py_tracefunc` to the "
"unlimited API. [\\#1787](https://github.com/PyO3/pyo3/pull/1787)"
msgstr ""

#: src/changelog.md:116
msgid ""
"Add missing `_type` field to `PyStatus` struct definition. [\\#1791](https://"
"github.com/PyO3/pyo3/pull/1791)"
msgstr ""

#: src/changelog.md:117
msgid ""
"Reduce lower bound `num-complex` optional dependency to support interop with "
"`rust-numpy` and `ndarray` when building with the MSRV of 1.41 [\\#1799]"
"(https://github.com/PyO3/pyo3/pull/1799)"
msgstr ""

#: src/changelog.md:118
msgid ""
"Fix memory leak in `Python::run_code`. [\\#1806](https://github.com/PyO3/"
"pyo3/pull/1806)"
msgstr ""

#: src/changelog.md:119
msgid ""
"Fix memory leak in `PyModule::from_code`. [\\#1810](https://github.com/PyO3/"
"pyo3/pull/1810)"
msgstr ""

#: src/changelog.md:120
msgid ""
"Remove use of `pyo3::` in `pyo3::types::datetime` which broke builds using `-"
"Z avoid-dev-deps` [\\#1811](https://github.com/PyO3/pyo3/pull/1811)"
msgstr ""

#: src/changelog.md:122
msgid ""
"[0.14.2](https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2) - 2021-08-09"
msgstr ""

#: src/changelog.md:126
msgid ""
"Add `indexmap` feature to add `ToPyObject`, `IntoPy` and `FromPyObject` "
"implementations for `indexmap::IndexMap`. [\\#1728](https://github.com/PyO3/"
"pyo3/pull/1728)"
msgstr ""

#: src/changelog.md:127
msgid ""
"Add `pyo3_build_config::add_extension_module_link_args` to use in build "
"scripts to set linker arguments (for macOS). [\\#1755](https://github.com/"
"PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:128
msgid ""
"Add `Python::with_gil_unchecked` unsafe variation of `Python::with_gil` to "
"allow obtaining a `Python` in scenarios where `Python::with_gil` would fail. "
"[\\#1769](https://github.com/PyO3/pyo3/pull/1769)"
msgstr ""

#: src/changelog.md:132
msgid ""
"`PyErr::new` no longer acquires the Python GIL internally. [\\#1724](https://"
"github.com/PyO3/pyo3/pull/1724)"
msgstr ""

#: src/changelog.md:133
msgid ""
"Reverted PyO3 0.14.0's use of `cargo:rustc-cdylib-link-arg` in its build "
"script, as Cargo unintentionally allowed crates to pass linker args to "
"downstream crates in this way. Projects supporting macOS may need to restore "
"`.cargo/config.toml` files. [\\#1755](https://github.com/PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:137
msgid ""
"Fix regression in 0.14.0 rejecting usage of `#[doc(hidden)]` on structs and "
"functions annotated with PyO3 macros. [\\#1722](https://github.com/PyO3/pyo3/"
"pull/1722)"
msgstr ""

#: src/changelog.md:138
msgid ""
"Fix regression in 0.14.0 leading to incorrect code coverage being computed "
"for `#[pyfunction]`s. [\\#1726](https://github.com/PyO3/pyo3/pull/1726)"
msgstr ""

#: src/changelog.md:139
msgid ""
"Fix incorrect FFI definition of `Py_Buffer` on PyPy. [\\#1737](https://"
"github.com/PyO3/pyo3/pull/1737)"
msgstr ""

#: src/changelog.md:140
msgid ""
"Fix incorrect calculation of `dictoffset` on 32-bit Windows. [\\#1475]"
"(https://github.com/PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:141
msgid ""
"Fix regression in 0.13.2 leading to linking to incorrect Python library on "
"Windows \"gnu\" targets. [\\#1759](https://github.com/PyO3/pyo3/pull/1759)"
msgstr ""

#: src/changelog.md:142
msgid ""
"Fix compiler warning: deny trailing semicolons in expression macro. [\\#1762]"
"(https://github.com/PyO3/pyo3/pull/1762)"
msgstr ""

#: src/changelog.md:143
msgid ""
"Fix incorrect FFI definition of `Py_DecodeLocale`. The 2nd argument is now "
"`*mut Py_ssize_t` instead of `Py_ssize_t`. [\\#1766](https://github.com/PyO3/"
"pyo3/pull/1766)"
msgstr ""

#: src/changelog.md:145
msgid ""
"[0.14.1](https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1) - 2021-07-04"
msgstr ""

#: src/changelog.md:149
msgid ""
"Implement `IntoPy<PyObject>` for `&PathBuf` and `&OsString`. [\\#1712]"
"(https://github.com/PyO3/pyo3/pull/1712)"
msgstr ""

#: src/changelog.md:153
msgid ""
"Fix crashes on PyPy due to incorrect definitions of `PyList_SET_ITEM`. "
"[\\#1713](https://github.com/PyO3/pyo3/pull/1713)"
msgstr ""

#: src/changelog.md:155
msgid ""
"[0.14.0](https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0) - 2021-07-03"
msgstr ""

#: src/changelog.md:159
msgid ""
"Update `num-bigint` optional dependency to 0.4. [\\#1481](https://github.com/"
"PyO3/pyo3/pull/1481)"
msgstr ""

#: src/changelog.md:160
msgid ""
"Update `num-complex` optional dependency to 0.4. [\\#1482](https://github."
"com/PyO3/pyo3/pull/1482)"
msgstr ""

#: src/changelog.md:161
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.11. "
"[\\#1496](https://github.com/PyO3/pyo3/pull/1496)"
msgstr ""

#: src/changelog.md:162
msgid "Support PyPy 3.7. [\\#1538](https://github.com/PyO3/pyo3/pull/1538)"
msgstr ""

#: src/changelog.md:166
msgid ""
"Extend conversions for `[T; N]` to all `N` using const generics (on Rust "
"1.51 and up). [\\#1128](https://github.com/PyO3/pyo3/pull/1128)"
msgstr ""

#: src/changelog.md:167
msgid ""
"Add conversions between `OsStr`/ `OsString` and Python strings. [\\#1379]"
"(https://github.com/PyO3/pyo3/pull/1379)"
msgstr ""

#: src/changelog.md:168
msgid ""
"Add conversions between `Path`/ `PathBuf` and Python strings (and `pathlib."
"Path` objects). [\\#1379](https://github.com/PyO3/pyo3/pull/1379) [\\#1654]"
"(https://github.com/PyO3/pyo3/pull/1654)"
msgstr ""

#: src/changelog.md:169
msgid ""
"Add a new set of `#[pyo3(...)]` attributes to control various PyO3 macro "
"functionality:"
msgstr ""

#: src/changelog.md:170
msgid ""
"`#[pyo3(from_py_with = \"...\")]` function arguments and struct fields to "
"override the default from-Python conversion. [\\#1411](https://github.com/"
"PyO3/pyo3/pull/1411)"
msgstr ""

#: src/changelog.md:171
msgid ""
"`#[pyo3(name = \"...\")]` for setting Python names. [\\#1567](https://github."
"com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:172
msgid ""
"`#[pyo3(text_signature = \"...\")]` for setting text signature. [\\#1658]"
"(https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:173
msgid ""
"Add FFI definition `PyCFunction_CheckExact` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:174
msgid ""
"Add FFI definition `Py_IS_TYPE`. [\\#1429](https://github.com/PyO3/pyo3/"
"pull/1429)"
msgstr ""

#: src/changelog.md:175
msgid ""
"Add FFI definition `_Py_InitializeMain`. [\\#1473](https://github.com/PyO3/"
"pyo3/pull/1473)"
msgstr ""

#: src/changelog.md:176
msgid ""
"Add FFI definitions from `cpython/import.h`.[\\#1475](https://github.com/"
"PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:177
msgid ""
"Add tuple and unit struct support for `#[pyclass]` macro. [\\#1504](https://"
"github.com/PyO3/pyo3/pull/1504)"
msgstr ""

#: src/changelog.md:178
msgid ""
"Add FFI definition `PyDateTime_TimeZone_UTC`. [\\#1572](https://github.com/"
"PyO3/pyo3/pull/1572)"
msgstr ""

#: src/changelog.md:179
msgid ""
"Add support for `#[pyclass(extends=Exception)]`. [\\#1591](https://github."
"com/PyO3/pyo3/pull/1591)"
msgstr ""

#: src/changelog.md:180
msgid ""
"Add `PyErr::cause` and `PyErr::set_cause`. [\\#1679](https://github.com/PyO3/"
"pyo3/pull/1679)"
msgstr ""

#: src/changelog.md:181
msgid ""
"Add FFI definitions from `cpython/pystate.h`. [\\#1687](https://github.com/"
"PyO3/pyo3/pull/1687/)"
msgstr ""

#: src/changelog.md:182
msgid ""
"Add `wrap_pyfunction!` macro to `pyo3::prelude`. [\\#1695](https://github."
"com/PyO3/pyo3/pull/1695)"
msgstr ""

#: src/changelog.md:186
msgid ""
"Allow only one `#[pymethods]` block per `#[pyclass]` by default, to remove "
"the dependency on `inventory`. Add a `multiple-pymethods` feature to opt-in "
"the original behavior and dependency on `inventory`. [\\#1457](https://"
"github.com/PyO3/pyo3/pull/1457)"
msgstr ""

#: src/changelog.md:187
msgid ""
"Change `PyTimeAccess::get_fold` to return a `bool` instead of a `u8`. "
"[\\#1397](https://github.com/PyO3/pyo3/pull/1397)"
msgstr ""

#: src/changelog.md:188
msgid ""
"Deprecate FFI definition `PyCFunction_Call` for Python 3.9 and up. [\\#1425]"
"(https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:189
msgid ""
"Deprecate FFI definition `PyModule_GetFilename`. [\\#1425](https://github."
"com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:190
msgid ""
"The `auto-initialize` feature is no longer enabled by default. [\\#1443]"
"(https://github.com/PyO3/pyo3/pull/1443)"
msgstr ""

#: src/changelog.md:191
msgid ""
"Change `PyCFunction::new` and `PyCFunction::new_with_keywords` to take "
"`&'static str` arguments rather than implicitly copying (and leaking) them. "
"[\\#1450](https://github.com/PyO3/pyo3/pull/1450)"
msgstr ""

#: src/changelog.md:192
msgid ""
"Deprecate `PyModule::call`, `PyModule::call0`, `PyModule::call1` and "
"`PyModule::get`. [\\#1492](https://github.com/PyO3/pyo3/pull/1492)"
msgstr ""

#: src/changelog.md:193
msgid ""
"Add length information to `PyBufferError`s raised from `PyBuffer::"
"copy_to_slice` and `PyBuffer::copy_from_slice`. [\\#1534](https://github.com/"
"PyO3/pyo3/pull/1534)"
msgstr ""

#: src/changelog.md:194
msgid ""
"Automatically set `-undefined` and `dynamic_lookup` linker arguments on "
"macOS with the `extension-module` feature. [\\#1539](https://github.com/PyO3/"
"pyo3/pull/1539)"
msgstr ""

#: src/changelog.md:195
msgid ""
"Deprecate `#[pyproto]` methods which are easier to implement as "
"`#[pymethods]`: [\\#1560](https://github.com/PyO3/pyo3/pull/1560)"
msgstr ""

#: src/changelog.md:196
msgid "`PyBasicProtocol::__bytes__` and `PyBasicProtocol::__format__`"
msgstr ""

#: src/changelog.md:197
msgid "`PyContextProtocol::__enter__` and `PyContextProtocol::__exit__`"
msgstr ""

#: src/changelog.md:198
msgid "`PyDescrProtocol::__delete__` and `PyDescrProtocol::__set_name__`"
msgstr ""

#: src/changelog.md:199
msgid "`PyMappingProtocol::__reversed__`"
msgstr ""

#: src/changelog.md:200
msgid "`PyNumberProtocol::__complex__` and `PyNumberProtocol::__round__`"
msgstr ""

#: src/changelog.md:201
msgid "`PyAsyncProtocol::__aenter__` and `PyAsyncProtocol::__aexit__`"
msgstr ""

#: src/changelog.md:202
msgid ""
"Deprecate several attributes in favor of the new `#[pyo3(...)]` options:"
msgstr ""

#: src/changelog.md:203
msgid ""
"`#[name = \"...\"]`, replaced by `#[pyo3(name = \"...\")]` [\\#1567](https://"
"github.com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:204
msgid ""
"`#[pyfn(m, \"name\")]`, replaced by `#[pyfn(m)] #[pyo3(name = \"...\")]`. "
"[\\#1610](https://github.com/PyO3/pyo3/pull/1610)"
msgstr ""

#: src/changelog.md:205
msgid ""
"`#[pymodule(name)]`, replaced by `#[pymodule] #[pyo3(name = \"...\")]` "
"[\\#1650](https://github.com/PyO3/pyo3/pull/1650)"
msgstr ""

#: src/changelog.md:206
msgid ""
"`#[text_signature = \"...\"]`, replaced by `#[pyo3(text_signature = \"..."
"\")]`. [\\#1658](https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:207
msgid ""
"Reduce LLVM line counts to improve compilation times. [\\#1604](https://"
"github.com/PyO3/pyo3/pull/1604)"
msgstr ""

#: src/changelog.md:208
msgid ""
"No longer call `PyEval_InitThreads` in `#[pymodule]` init code. [\\#1630]"
"(https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:209
msgid ""
"Use `METH_FASTCALL` argument passing convention, when possible, to improve "
"`#[pyfunction]` and method performance. [\\#1619](https://github.com/PyO3/"
"pyo3/pull/1619), [\\#1660](https://github.com/PyO3/pyo3/pull/1660)"
msgstr ""

#: src/changelog.md:211
msgid ""
"Filter sysconfigdata candidates by architecture when cross-compiling. "
"[\\#1626](https://github.com/PyO3/pyo3/pull/1626)"
msgstr ""

#: src/changelog.md:213 src/changelog.md:298 src/changelog.md:353
#: src/changelog.md:443 src/changelog.md:506 src/changelog.md:546
#: src/changelog.md:609 src/changelog.md:645 src/changelog.md:699
#: src/changelog.md:784 src/changelog.md:838 src/changelog.md:864
#: src/changelog.md:876 src/changelog.md:957
msgid "Removed"
msgstr ""

#: src/changelog.md:215
msgid ""
"Remove deprecated exception names `BaseException` etc. [\\#1426](https://"
"github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:216
msgid ""
"Remove deprecated methods `Python::is_instance`, `Python::is_subclass`, "
"`Python::release`, `Python::xdecref`, and `Py::from_owned_ptr_or_panic`. "
"[\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:217
msgid "Remove many FFI definitions which never existed in the Python C-API:"
msgstr ""

#: src/changelog.md:218
msgid ""
"(previously deprecated) `PyGetSetDef_INIT`, `PyGetSetDef_DICT`, "
"`PyCoro_Check`, `PyCoroWrapper_Check`, and `PyAsyncGen_Check` [\\#1426]"
"(https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:219
msgid "`PyMethodDef_INIT` [\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:220
msgid "`PyTypeObject_INIT` [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:221
msgid ""
"`PyObject_Check`, `PySuper_Check`, and `FreeFunc` [\\#1438](https://github."
"com/PyO3/pyo3/pull/1438)"
msgstr ""

#: src/changelog.md:222
msgid "`PyModuleDef_INIT` [\\#1630](https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:223
msgid "Remove pyclass implementation details from `PyTypeInfo`:"
msgstr ""

#: src/changelog.md:224
msgid ""
"`Type`, `DESCRIPTION`, and `FLAGS` [\\#1456](https://github.com/PyO3/pyo3/"
"pull/1456)"
msgstr ""

#: src/changelog.md:225
msgid ""
"`BaseType`, `BaseLayout`, `Layout`, `Initializer` [\\#1596](https://github."
"com/PyO3/pyo3/pull/1596)"
msgstr ""

#: src/changelog.md:226
msgid ""
"Remove `PYO3_CROSS_INCLUDE_DIR` environment variable and the associated C "
"header parsing functionality. [\\#1521](https://github.com/PyO3/pyo3/"
"pull/1521)"
msgstr ""

#: src/changelog.md:227
msgid ""
"Remove `raw_pycfunction!` macro. [\\#1619](https://github.com/PyO3/pyo3/"
"pull/1619)"
msgstr ""

#: src/changelog.md:228
msgid ""
"Remove `PyClassAlloc` trait. [\\#1657](https://github.com/PyO3/pyo3/"
"pull/1657)"
msgstr ""

#: src/changelog.md:229
msgid ""
"Remove `PyList::get_parked_item`. [\\#1664](https://github.com/PyO3/pyo3/"
"pull/1664)"
msgstr ""

#: src/changelog.md:233
msgid ""
"Remove FFI definition `PyCFunction_ClearFreeList` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:234
msgid ""
"`PYO3_CROSS_LIB_DIR` enviroment variable no long required when compiling for "
"x86-64 Python from macOS arm64 and reverse. [\\#1428](https://github.com/"
"PyO3/pyo3/pull/1428)"
msgstr ""

#: src/changelog.md:235
msgid ""
"Fix FFI definition `_PyEval_RequestCodeExtraIndex`, which took an argument "
"of the wrong type. [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:236
msgid ""
"Fix FFI definition `PyIndex_Check` missing with the `abi3` feature. [\\#1436]"
"(https://github.com/PyO3/pyo3/pull/1436)"
msgstr ""

#: src/changelog.md:237
msgid ""
"Fix incorrect `TypeError` raised when keyword-only argument passed along "
"with a positional argument in `*args`. [\\#1440](https://github.com/PyO3/"
"pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:238
msgid ""
"Fix inability to use a named lifetime for `&PyTuple` of `*args` in "
"`#[pyfunction]`. [\\#1440](https://github.com/PyO3/pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:239
msgid ""
"Fix use of Python argument for `#[pymethods]` inside macro expansions. "
"[\\#1505](https://github.com/PyO3/pyo3/pull/1505)"
msgstr ""

#: src/changelog.md:240
msgid ""
"No longer include `__doc__` in `__all__` generated for `#[pymodule]`. "
"[\\#1509](https://github.com/PyO3/pyo3/pull/1509)"
msgstr ""

#: src/changelog.md:241
msgid ""
"Always use cross-compiling configuration if any of the `PYO3_CROSS` family "
"of environment variables are set. [\\#1514](https://github.com/PyO3/pyo3/"
"pull/1514)"
msgstr ""

#: src/changelog.md:242
msgid ""
"Support `EnvironmentError`, `IOError`, and `WindowsError` on PyPy. [\\#1533]"
"(https://github.com/PyO3/pyo3/pull/1533)"
msgstr ""

#: src/changelog.md:243
msgid ""
"Fix unneccessary rebuilds when cycling between `cargo check` and `cargo "
"clippy` in a Python virtualenv. [\\#1557](https://github.com/PyO3/pyo3/"
"pull/1557)"
msgstr ""

#: src/changelog.md:244
msgid ""
"Fix segfault when dereferencing `ffi::PyDateTimeAPI` without the GIL. "
"[\\#1563](https://github.com/PyO3/pyo3/pull/1563)"
msgstr ""

#: src/changelog.md:245
msgid ""
"Fix memory leak in `FromPyObject` implementations for `u128` and `i128`. "
"[\\#1638](https://github.com/PyO3/pyo3/pull/1638)"
msgstr ""

#: src/changelog.md:246
msgid ""
"Fix `#[pyclass(extends=PyDict)]` leaking the dict contents on drop. [\\#1657]"
"(https://github.com/PyO3/pyo3/pull/1657)"
msgstr ""

#: src/changelog.md:247
msgid ""
"Fix segfault when calling `PyList::get_item` with negative indices. [\\#1668]"
"(https://github.com/PyO3/pyo3/pull/1668)"
msgstr ""

#: src/changelog.md:248
msgid ""
"Fix FFI definitions of `PyEval_SetProfile`/`PyEval_SetTrace` to take "
"`Option<Py_tracefunc>` parameters. [\\#1692](https://github.com/PyO3/pyo3/"
"pull/1692)"
msgstr ""

#: src/changelog.md:249
msgid ""
"Fix `ToPyObject` impl for `HashSet` to accept non-default hashers. [\\#1702]"
"(https://github.com/PyO3/pyo3/pull/1702)"
msgstr ""

#: src/changelog.md:251
msgid ""
"[0.13.2](https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2) - 2021-02-12"
msgstr ""

#: src/changelog.md:255
msgid ""
"Lower minimum supported Rust version to 1.41. [\\#1421](https://github.com/"
"PyO3/pyo3/pull/1421)"
msgstr ""

#: src/changelog.md:259
msgid ""
"Add unsafe API `with_embedded_python_interpreter` to initialize a Python "
"interpreter, execute a closure, and finalize the interpreter. [\\#1355]"
"(https://github.com/PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:260
msgid ""
"Add `serde` feature which provides implementations of `Serialize` and "
"`Deserialize` for `Py<T>`. [\\#1366](https://github.com/PyO3/pyo3/pull/1366)"
msgstr ""

#: src/changelog.md:261
msgid ""
"Add FFI definition `_PyCFunctionFastWithKeywords` on Python 3.7 and up. "
"[\\#1384](https://github.com/PyO3/pyo3/pull/1384)"
msgstr ""

#: src/changelog.md:262
msgid ""
"Add `PyDateTime::new_with_fold` method. [\\#1398](https://github.com/PyO3/"
"pyo3/pull/1398)"
msgstr ""

#: src/changelog.md:263
msgid ""
"Add `size_hint` impls for `{PyDict,PyList,PySet,PyTuple}Iterator`s. [\\#1699]"
"(https://github.com/PyO3/pyo3/pull/1699)"
msgstr ""

#: src/changelog.md:267
msgid ""
"`prepare_freethreaded_python` will no longer register an `atexit` handler to "
"call `Py_Finalize`. This resolves a number of issues with incompatible C "
"extensions causing crashes at finalization. [\\#1355](https://github.com/"
"PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:268
msgid ""
"Mark `PyLayout::py_init`, `PyClassDict::clear_dict`, and `opt_to_pyobj` "
"safe, as they do not perform any unsafe operations. [\\#1404](https://github."
"com/PyO3/pyo3/pull/1404)"
msgstr ""

#: src/changelog.md:272
msgid ""
"Fix support for using `r#raw_idents` as argument names in pyfunctions. "
"[\\#1383](https://github.com/PyO3/pyo3/pull/1383)"
msgstr ""

#: src/changelog.md:273
msgid ""
"Fix typo in FFI definition for `PyFunction_GetCode` (was incorrectly "
"`PyFunction_Code`). [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:274
msgid ""
"Fix FFI definitions `PyMarshal_WriteObjectToString` and "
"`PyMarshal_ReadObjectFromString` as available in limited API. [\\#1387]"
"(https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:275
msgid ""
"Fix FFI definitions `PyListObject` and those from `funcobject.h` as "
"requiring non-limited API. [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:276
msgid ""
"Fix unqualified `Result` usage in `pyobject_native_type_base`. [\\#1402]"
"(https://github.com/PyO3/pyo3/pull/1402)"
msgstr ""

#: src/changelog.md:277
msgid ""
"Fix build on systems where the default Python encoding is not UTF-8. "
"[\\#1405](https://github.com/PyO3/pyo3/pull/1405)"
msgstr ""

#: src/changelog.md:278
msgid ""
"Fix build on mingw / MSYS2. [\\#1423](https://github.com/PyO3/pyo3/pull/1423)"
msgstr ""

#: src/changelog.md:280
msgid ""
"[0.13.1](https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1) - 2021-01-10"
msgstr ""

#: src/changelog.md:284
msgid ""
"Add support for `#[pyclass(dict)]` and `#[pyclass(weakref)]` with the `abi3` "
"feature on Python 3.9 and up. [\\#1342](https://github.com/PyO3/pyo3/"
"pull/1342)"
msgstr ""

#: src/changelog.md:285
msgid ""
"Add FFI definitions `PyOS_BeforeFork`, `PyOS_AfterFork_Parent`, "
"`PyOS_AfterFork_Child` for Python 3.7 and up. [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:286
msgid ""
"Add an `auto-initialize` feature to control whether PyO3 should "
"automatically initialize an embedded Python interpreter. For compatibility "
"this feature is enabled by default in PyO3 0.13.1, but is planned to become "
"opt-in from PyO3 0.14.0. [\\#1347](https://github.com/PyO3/pyo3/pull/1347)"
msgstr ""

#: src/changelog.md:287
msgid ""
"Add support for cross-compiling to Windows without needing "
"`PYO3_CROSS_INCLUDE_DIR`. [\\#1350](https://github.com/PyO3/pyo3/pull/1350)"
msgstr ""

#: src/changelog.md:289 src/changelog.md:349
msgid "Deprecated"
msgstr ""

#: src/changelog.md:291
msgid ""
"Deprecate FFI definitions `PyEval_CallObjectWithKeywords`, "
"`PyEval_CallObject`, `PyEval_CallFunction`, `PyEval_CallMethod` when "
"building for Python 3.9. [\\#1338](https://github.com/PyO3/pyo3/pull/1338)"
msgstr ""

#: src/changelog.md:292
msgid ""
"Deprecate FFI definitions `PyGetSetDef_DICT` and `PyGetSetDef_INIT` which "
"have never been in the Python API. [\\#1341](https://github.com/PyO3/pyo3/"
"pull/1341)"
msgstr ""

#: src/changelog.md:293
msgid ""
"Deprecate FFI definitions `PyGen_NeedsFinalizing`, `PyImport_Cleanup` "
"(removed in 3.9), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github."
"com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:294
msgid ""
"Deprecate FFI definition `PyOS_AfterFork` for Python 3.7 and up. [\\#1348]"
"(https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:295
msgid ""
"Deprecate FFI definitions `PyCoro_Check`, `PyAsyncGen_Check`, and "
"`PyCoroWrapper_Check`, which have never been in the Python API (for the "
"first two, it is possible to use `PyCoro_CheckExact` and "
"`PyAsyncGen_CheckExact` instead; these are the actual functions provided by "
"the Python API). [\\#1348](https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:296
msgid ""
"Deprecate FFI definitions for `PyUnicode_FromUnicode`, `PyUnicode_AsUnicode` "
"and `PyUnicode_AsUnicodeAndSize`, which will be removed from 3.12 and up due "
"to [PEP 613](https://www.python.org/dev/peps/pep-0623/). [\\#1370](https://"
"github.com/PyO3/pyo3/pull/1370)"
msgstr ""

#: src/changelog.md:300
msgid ""
"Remove FFI definition `PyFrame_ClearFreeList` when building for Python 3.9. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:301
msgid ""
"Remove FFI definition `_PyDict_Contains` when building for Python 3.10. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:302
msgid ""
"Remove FFI definitions `PyGen_NeedsFinalizing` and `PyImport_Cleanup` (for "
"3.9 and up), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:306
msgid ""
"Stop including `Py_TRACE_REFS` config setting automatically if `Py_DEBUG` is "
"set on Python 3.8 and up. [\\#1334](https://github.com/PyO3/pyo3/pull/1334)"
msgstr ""

#: src/changelog.md:307
msgid ""
"Remove `#[deny(warnings)]` attribute (and instead refuse warnings only in "
"CI). [\\#1340](https://github.com/PyO3/pyo3/pull/1340)"
msgstr ""

#: src/changelog.md:308
msgid ""
"Fix deprecation warning for missing `__module__` with `#[pyclass]`. [\\#1343]"
"(https://github.com/PyO3/pyo3/pull/1343)"
msgstr ""

#: src/changelog.md:309
msgid ""
"Correct return type of `PyFrozenSet::empty` to `&PyFrozenSet` (was "
"incorrectly `&PySet`). [\\#1351](https://github.com/PyO3/pyo3/pull/1351)"
msgstr ""

#: src/changelog.md:310
msgid ""
"Fix missing `Py_INCREF` on heap type objects on Python versions before 3.8. "
"[\\#1365](https://github.com/PyO3/pyo3/pull/1365)"
msgstr ""

#: src/changelog.md:312
msgid ""
"[0.13.0](https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0) - 2020-12-22"
msgstr ""

#: src/changelog.md:316
msgid ""
"Drop support for Python 3.5 (as it is now end-of-life). [\\#1250](https://"
"github.com/PyO3/pyo3/pull/1250)"
msgstr ""

#: src/changelog.md:317
msgid ""
"Bump minimum supported Rust version to 1.45. [\\#1272](https://github.com/"
"PyO3/pyo3/pull/1272)"
msgstr ""

#: src/changelog.md:318
msgid ""
"Bump indoc dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:319
msgid ""
"Bump paste dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:320
msgid ""
"Rename internal crates `pyo3cls` and `pyo3-derive-backend` to `pyo3-macros` "
"and `pyo3-macros-backend` respectively. [\\#1317](https://github.com/PyO3/"
"pyo3/pull/1317)"
msgstr ""

#: src/changelog.md:324
msgid ""
"Add support for building for CPython limited API. Opting-in to the limited "
"API enables a single extension wheel built with PyO3 to be installable on "
"multiple Python versions. This required a few minor changes to runtime "
"behaviour of of PyO3 `#[pyclass]` types. See the migration guide for full "
"details. [\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:325
msgid ""
"Add feature flags `abi3-py36`, `abi3-py37`, `abi3-py38` etc. to set the "
"minimum Python version when using the limited API. [\\#1263](https://github."
"com/PyO3/pyo3/pull/1263)"
msgstr ""

#: src/changelog.md:326
msgid ""
"Add argument names to `TypeError` messages generated by pymethod wrappers. "
"[\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:327
msgid ""
"Add FFI definitions for PEP 587 \"Python Initialization Configuration\". "
"[\\#1247](https://github.com/PyO3/pyo3/pull/1247)"
msgstr ""

#: src/changelog.md:328
msgid ""
"Add FFI definitions for `PyEval_SetProfile` and `PyEval_SetTrace`. [\\#1255]"
"(https://github.com/PyO3/pyo3/pull/1255)"
msgstr ""

#: src/changelog.md:329
msgid ""
"Add FFI definitions for context.h functions (`PyContext_New`, etc). [\\#1259]"
"(https://github.com/PyO3/pyo3/pull/1259)"
msgstr ""

#: src/changelog.md:330
msgid ""
"Add `PyAny::is_instance` method. [\\#1276](https://github.com/PyO3/pyo3/"
"pull/1276)"
msgstr ""

#: src/changelog.md:331
msgid ""
"Add support for conversion between `char` and `PyString`. [\\#1282](https://"
"github.com/PyO3/pyo3/pull/1282)"
msgstr ""

#: src/changelog.md:332
msgid ""
"Add FFI definitions for `PyBuffer_SizeFromFormat`, `PyObject_LengthHint`, "
"`PyObject_CallNoArgs`, `PyObject_CallOneArg`, `PyObject_CallMethodNoArgs`, "
"`PyObject_CallMethodOneArg`, `PyObject_VectorcallDict`, and "
"`PyObject_VectorcallMethod`. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1287)"
msgstr ""

#: src/changelog.md:333
msgid ""
"Add conversions between `u128`/`i128` and `PyLong` for PyPy. [\\#1310]"
"(https://github.com/PyO3/pyo3/pull/1310)"
msgstr ""

#: src/changelog.md:334
msgid ""
"Add `Python::version` and `Python::version_info` to get the running "
"interpreter version. [\\#1322](https://github.com/PyO3/pyo3/pull/1322)"
msgstr ""

#: src/changelog.md:335
msgid ""
"Add conversions for tuples of length 10, 11, and 12. [\\#1454](https://"
"github.com/PyO3/pyo3/pull/1454)"
msgstr ""

#: src/changelog.md:339
msgid ""
"Change return type of `PyType::name` from `Cow<str>` to `PyResult<&str>`. "
"[\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:340
msgid ""
"`#[pyclass(subclass)]` is now required for subclassing from Rust (was "
"previously just required for subclassing from Python). [\\#1152](https://"
"github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:341
msgid ""
"Change `PyIterator` to be consistent with other native types: it is now used "
"as `&PyIterator` instead of `PyIterator<'a>`. [\\#1176](https://github.com/"
"PyO3/pyo3/pull/1176)"
msgstr ""

#: src/changelog.md:342
msgid ""
"Change formatting of `PyDowncastError` messages to be closer to Python's "
"builtin error messages. [\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:343
msgid ""
"Change `Debug` and `Display` impls for `PyException` to be consistent with "
"`PyAny`. [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:344
msgid ""
"Change `Debug` impl of `PyErr` to output more helpful information (acquiring "
"the GIL if necessary). [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:345
msgid ""
"Rename `PyTypeInfo::is_instance` and `PyTypeInfo::is_exact_instance` to "
"`PyTypeInfo::is_type_of` and `PyTypeInfo::is_exact_type_of`. [\\#1278]"
"(https://github.com/PyO3/pyo3/pull/1278)"
msgstr ""

#: src/changelog.md:346
msgid ""
"Optimize `PyAny::call0`, `Py::call0` and `PyAny::call_method0` and `Py::"
"call_method0` on Python 3.9 and up. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1285)"
msgstr ""

#: src/changelog.md:347
msgid ""
"Require double-quotes for pyclass name argument e.g `#[pyclass(name = "
"\"MyClass\")]`. [\\#1303](https://github.com/PyO3/pyo3/pull/1303)"
msgstr ""

#: src/changelog.md:351
msgid ""
"Deprecate `Python::is_instance`, `Python::is_subclass`, `Python::release`, "
"and `Python::xdecref`. [\\#1292](https://github.com/PyO3/pyo3/pull/1292)"
msgstr ""

#: src/changelog.md:355
msgid ""
"Remove deprecated ffi definitions `PyUnicode_AsUnicodeCopy`, "
"`PyUnicode_GetMax`, `_Py_CheckRecursionLimit`, `PyObject_AsCharBuffer`, "
"`PyObject_AsReadBuffer`, `PyObject_CheckReadBuffer` and "
"`PyObject_AsWriteBuffer`, which will be removed in Python 3.10. [\\#1217]"
"(https://github.com/PyO3/pyo3/pull/1217)"
msgstr ""

#: src/changelog.md:356
msgid ""
"Remove unused `python3` feature. [\\#1235](https://github.com/PyO3/pyo3/"
"pull/1235)"
msgstr ""

#: src/changelog.md:360
msgid ""
"Fix missing field in `PyCodeObject` struct (`co_posonlyargcount`) - caused "
"invalid access to other fields in Python >3.7. [\\#1260](https://github.com/"
"PyO3/pyo3/pull/1260)"
msgstr ""

#: src/changelog.md:361
msgid ""
"Fix building for `x86_64-unknown-linux-musl` target from `x86_64-unknown-"
"linux-gnu` host. [\\#1267](https://github.com/PyO3/pyo3/pull/1267)"
msgstr ""

#: src/changelog.md:362
msgid ""
"Fix `#[text_signature]` interacting badly with rust `r#raw_identifiers`. "
"[\\#1286](https://github.com/PyO3/pyo3/pull/1286)"
msgstr ""

#: src/changelog.md:363
msgid ""
"Fix FFI definitions for `PyObject_Vectorcall` and `PyVectorcall_Call`. "
"[\\#1287](https://github.com/PyO3/pyo3/pull/1285)"
msgstr ""

#: src/changelog.md:364
msgid ""
"Fix building with Anaconda python inside a virtualenv. [\\#1290](https://"
"github.com/PyO3/pyo3/pull/1290)"
msgstr ""

#: src/changelog.md:365
msgid ""
"Fix definition of opaque FFI types. [\\#1312](https://github.com/PyO3/pyo3/"
"pull/1312)"
msgstr ""

#: src/changelog.md:366
msgid ""
"Fix using custom error type in pyclass `#[new]` methods. [\\#1319](https://"
"github.com/PyO3/pyo3/pull/1319)"
msgstr ""

#: src/changelog.md:368
msgid ""
"[0.12.4](https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4) - 2020-11-28"
msgstr ""

#: src/changelog.md:372
msgid ""
"Fix reference count bug in implementation of `From<Py<T>>` for `PyObject`, a "
"regression introduced in PyO3 0.12. [\\#1297](https://github.com/PyO3/pyo3/"
"pull/1297)"
msgstr ""

#: src/changelog.md:374
msgid ""
"[0.12.3](https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3) - 2020-10-12"
msgstr ""

#: src/changelog.md:378
msgid ""
"Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal "
"update to paste 1.0 which was done in PyO3 0.12.2. [\\#1234](https://github."
"com/PyO3/pyo3/pull/1234)"
msgstr ""

#: src/changelog.md:380
msgid ""
"[0.12.2](https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2) - 2020-10-12"
msgstr ""

#: src/changelog.md:384
msgid ""
"Add support for keyword-only arguments without default values in "
"`#[pyfunction]`. [\\#1209](https://github.com/PyO3/pyo3/pull/1209)"
msgstr ""

#: src/changelog.md:385
msgid ""
"Add `Python::check_signals` as a safe a wrapper for `PyErr_CheckSignals`. "
"[\\#1214](https://github.com/PyO3/pyo3/pull/1214)"
msgstr ""

#: src/changelog.md:389
msgid ""
"Fix invalid document for protocol methods. [\\#1169](https://github.com/PyO3/"
"pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:390
msgid ""
"Hide docs of PyO3 private implementation details in `pyo3::class::methods`. "
"[\\#1169](https://github.com/PyO3/pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:391
msgid ""
"Fix unnecessary rebuild on PATH changes when the python interpreter is "
"provided by PYO3_PYTHON. [\\#1231](https://github.com/PyO3/pyo3/pull/1231)"
msgstr ""

#: src/changelog.md:393
msgid ""
"[0.12.1](https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1) - 2020-09-16"
msgstr ""

#: src/changelog.md:397
msgid ""
"Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust "
"toolchain. [\\#1179](https://github.com/PyO3/pyo3/pull/1179)"
msgstr ""

#: src/changelog.md:398
msgid ""
"Fix building on platforms where `c_char` is `u8`. [\\#1182](https://github."
"com/PyO3/pyo3/pull/1182)"
msgstr ""

#: src/changelog.md:400
msgid ""
"[0.12.0](https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0) - 2020-09-12"
msgstr ""

#: src/changelog.md:404
msgid ""
"Add FFI definitions `Py_FinalizeEx`, `PyOS_getsig`, and `PyOS_setsig`. "
"[\\#1021](https://github.com/PyO3/pyo3/pull/1021)"
msgstr ""

#: src/changelog.md:405
msgid ""
"Add `PyString::to_str` for accessing `PyString` as `&str`. [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:406
msgid ""
"Add `Python::with_gil` for executing a closure with the Python GIL. [\\#1037]"
"(https://github.com/PyO3/pyo3/pull/1037)"
msgstr ""

#: src/changelog.md:407
msgid ""
"Add type information to failures in `PyAny::downcast`. [\\#1050](https://"
"github.com/PyO3/pyo3/pull/1050)"
msgstr ""

#: src/changelog.md:408
msgid ""
"Implement `Debug` for `PyIterator`. [\\#1051](https://github.com/PyO3/pyo3/"
"pull/1051)"
msgstr ""

#: src/changelog.md:409
msgid ""
"Add `PyBytes::new_with` and `PyByteArray::new_with` for initialising `bytes` "
"and `bytearray` objects using a closure. [\\#1074](https://github.com/PyO3/"
"pyo3/pull/1074)"
msgstr ""

#: src/changelog.md:410
msgid ""
"Add `#[derive(FromPyObject)]` macro for enums and structs. [\\#1065](https://"
"github.com/PyO3/pyo3/pull/1065)"
msgstr ""

#: src/changelog.md:411
msgid ""
"Add `Py::as_ref` and `Py::into_ref` for converting `Py<T>` to `&T`. [\\#1098]"
"(https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:412
msgid ""
"Add ability to return `Result` types other than `PyResult` from "
"`#[pyfunction]`, `#[pymethod]` and `#[pyproto]` functions. [\\#1106](https://"
"github.com/PyO3/pyo3/pull/1118)."
msgstr ""

#: src/changelog.md:413
msgid ""
"Implement `ToPyObject`, `IntoPy`, and `FromPyObject` for [hashbrown](https://"
"crates.io/crates/hashbrown)'s `HashMap` and `HashSet` types (requires the "
"`hashbrown` feature). [\\#1114](https://github.com/PyO3/pyo3/pull/1114)"
msgstr ""

#: src/changelog.md:414
msgid ""
"Add `#[pyfunction(pass_module)]` and `#[pyfn(pass_module)]` to pass the "
"module object as the first function argument. [\\#1143](https://github.com/"
"PyO3/pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:415
msgid ""
"Add `PyModule::add_function` and `PyModule::add_submodule` as typed "
"alternatives to `PyModule::add_wrapped`. [\\#1143](https://github.com/PyO3/"
"pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:416
msgid ""
"Add native `PyCFunction` and `PyFunction` types. [\\#1163](https://github."
"com/PyO3/pyo3/pull/1163)"
msgstr ""

#: src/changelog.md:420
msgid ""
"Rework exception types: [\\#1024](https://github.com/PyO3/pyo3/pull/1024) "
"[\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:421
msgid ""
"Rename exception types from e.g. `RuntimeError` to `PyRuntimeError`. The old "
"names continue to exist but are deprecated."
msgstr ""

#: src/changelog.md:422
msgid ""
"Exception objects are now accessible as `&T` or `Py<T>`, just like other "
"Python-native types."
msgstr ""

#: src/changelog.md:423
msgid "Rename `PyException::py_err` to `PyException::new_err`."
msgstr ""

#: src/changelog.md:424
msgid "Rename `PyUnicodeDecodeErr::new_err` to `PyUnicodeDecodeErr::new`."
msgstr ""

#: src/changelog.md:425
msgid "Remove `PyStopIteration::stop_iteration`."
msgstr ""

#: src/changelog.md:426
msgid ""
"Require `T: Send` for the return value `T` of `Python::allow_threads`. "
"[\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:427
msgid ""
"Rename `PYTHON_SYS_EXECUTABLE` to `PYO3_PYTHON`. The old name will continue "
"to work (undocumented) but will be removed in a future release. [\\#1039]"
"(https://github.com/PyO3/pyo3/pull/1039)"
msgstr ""

#: src/changelog.md:428
msgid ""
"Remove `unsafe` from signature of `PyType::as_type_ptr`. [\\#1047](https://"
"github.com/PyO3/pyo3/pull/1047)"
msgstr ""

#: src/changelog.md:429
msgid ""
"Change return type of `PyIterator::from_object` to `PyResult<PyIterator>` "
"(was `Result<PyIterator, PyDowncastError>`). [\\#1051](https://github.com/"
"PyO3/pyo3/pull/1051)"
msgstr ""

#: src/changelog.md:430
msgid ""
"`IntoPy` is no longer implied by `FromPy`. [\\#1063](https://github.com/PyO3/"
"pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:431
msgid ""
"Change `PyObject` to be a type alias for `Py<PyAny>`. [\\#1063](https://"
"github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:432
msgid ""
"Rework `PyErr` to be compatible with the `std::error::Error` trait: [\\#1067]"
"(https://github.com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/"
"pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:433
msgid ""
"Implement `Display`, `Error`, `Send` and `Sync` for `PyErr` and "
"`PyErrArguments`."
msgstr ""

#: src/changelog.md:434
msgid "Add `PyErr::instance` for accessing `PyErr` as `&PyBaseException`."
msgstr ""

#: src/changelog.md:435
msgid ""
"`PyErr`'s fields are now an implementation detail. The equivalent values can "
"be accessed with `PyErr::ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/changelog.md:436
msgid ""
"Change receiver of `PyErr::print` and `PyErr::print_and_set_sys_last_vars` "
"to `&self` (was `self`)."
msgstr ""

#: src/changelog.md:437
msgid ""
"Remove `PyErrValue`, `PyErr::from_value`, `PyErr::into_normalized`, and "
"`PyErr::normalize`."
msgstr ""

#: src/changelog.md:438
msgid "Remove `PyException::into`."
msgstr ""

#: src/changelog.md:439
msgid "Remove `Into<PyResult<T>>` for `PyErr` and `PyException`."
msgstr ""

#: src/changelog.md:440
msgid ""
"Change methods generated by `#[pyproto]` to return `NotImplemented` if "
"Python should try a reversed operation. #[1072](https://github.com/PyO3/pyo3/"
"pull/1072)"
msgstr ""

#: src/changelog.md:441
msgid ""
"Change argument to `PyModule::add` to `impl IntoPy<PyObject>` (was `impl "
"ToPyObject`). #[1124](https://github.com/PyO3/pyo3/pull/1124)"
msgstr ""

#: src/changelog.md:445
msgid ""
"Remove many exception and `PyErr` APIs; see the \"changed\" section above. "
"[\\#1024](https://github.com/PyO3/pyo3/pull/1024) [\\#1067](https://github."
"com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:446
msgid ""
"Remove `PyString::to_string` (use new `PyString::to_str`). [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:447
msgid ""
"Remove `PyString::as_bytes`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:448
msgid ""
"Remove `Python::register_any`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:449
msgid ""
"Remove `GILGuard::acquire` from the public API. Use `Python::acquire_gil` or "
"`Python::with_gil`. [\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:450
msgid ""
"Remove the `FromPy` trait. [\\#1063](https://github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:451
msgid ""
"Remove the `AsPyRef` trait. [\\#1098](https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:455
msgid ""
"Correct FFI definitions `Py_SetProgramName` and `Py_SetPythonHome` to take "
"`*const` arguments (was `*mut`). [\\#1021](https://github.com/PyO3/pyo3/"
"pull/1021)"
msgstr ""

#: src/changelog.md:456
msgid ""
"Fix `FromPyObject` for `num_bigint::BigInt` for Python objects with an "
"`__index__` method. [\\#1027](https://github.com/PyO3/pyo3/pull/1027)"
msgstr ""

#: src/changelog.md:457
msgid ""
"Correct FFI definition `_PyLong_AsByteArray` to take `*mut c_uchar` argument "
"(was `*const c_uchar`). [\\#1029](https://github.com/PyO3/pyo3/pull/1029)"
msgstr ""

#: src/changelog.md:458
msgid ""
"Fix segfault with `#[pyclass(dict, unsendable)]`. [\\#1058](https://github."
"com/PyO3/pyo3/pull/1058) [\\#1059](https://github.com/PyO3/pyo3/pull/1059)"
msgstr ""

#: src/changelog.md:459
msgid ""
"Fix using `&Self` as an argument type for functions in a `#[pymethods]` "
"block. [\\#1071](https://github.com/PyO3/pyo3/pull/1071)"
msgstr ""

#: src/changelog.md:460
msgid ""
"Fix best-effort build against PyPy 3.6. [\\#1092](https://github.com/PyO3/"
"pyo3/pull/1092)"
msgstr ""

#: src/changelog.md:461
msgid ""
"Fix many cases of lifetime elision in `#[pyproto]` implementations. [\\#1093]"
"(https://github.com/PyO3/pyo3/pull/1093)"
msgstr ""

#: src/changelog.md:462
msgid ""
"Fix detection of Python build configuration when cross-compiling. [\\#1095]"
"(https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:463
msgid ""
"Always link against libpython on android with the `extension-module` "
"feature. [\\#1095](https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:464
msgid ""
"Fix the `+` operator not trying `__radd__` when both `__add__` and "
"`__radd__` are defined in `PyNumberProtocol` (and similar for all other "
"reversible operators). [\\#1107](https://github.com/PyO3/pyo3/pull/1107)"
msgstr ""

#: src/changelog.md:465
msgid ""
"Fix building with Anaconda python. [\\#1175](https://github.com/PyO3/pyo3/"
"pull/1175)"
msgstr ""

#: src/changelog.md:467
msgid ""
"[0.11.1](https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1) - 2020-06-30"
msgstr ""

#: src/changelog.md:471
msgid ""
"`#[pyclass(unsendable)]`. [\\#1009](https://github.com/PyO3/pyo3/pull/1009)"
msgstr ""

#: src/changelog.md:475
msgid ""
"Update `parking_lot` dependency to `0.11`. [\\#1010](https://github.com/PyO3/"
"pyo3/pull/1010)"
msgstr ""

#: src/changelog.md:477
msgid ""
"[0.11.0](https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0) - 2020-06-28"
msgstr ""

#: src/changelog.md:481
msgid ""
"Support stable versions of Rust (>=1.39). [\\#969](https://github.com/PyO3/"
"pyo3/pull/969)"
msgstr ""

#: src/changelog.md:482
msgid ""
"Add FFI definition `PyObject_AsFileDescriptor`. [\\#938](https://github.com/"
"PyO3/pyo3/pull/938)"
msgstr ""

#: src/changelog.md:483
msgid ""
"Add `PyByteArray::data`, `PyByteArray::as_bytes`, and `PyByteArray::"
"as_bytes_mut`. [\\#967](https://github.com/PyO3/pyo3/pull/967)"
msgstr ""

#: src/changelog.md:484
msgid ""
"Add `GILOnceCell` to use in situations where `lazy_static` or `once_cell` "
"can deadlock. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:485
msgid ""
"Add `Py::borrow`, `Py::borrow_mut`, `Py::try_borrow`, and `Py::"
"try_borrow_mut` for accessing `#[pyclass]` values. [\\#976](https://github."
"com/PyO3/pyo3/pull/976)"
msgstr ""

#: src/changelog.md:486
msgid ""
"Add `IterNextOutput` and `IterANextOutput` for returning from `__next__` / "
"`__anext__`. [\\#997](https://github.com/PyO3/pyo3/pull/997)"
msgstr ""

#: src/changelog.md:490
msgid ""
"Simplify internals of `#[pyo3(get)]` attribute. (Remove the hidden API "
"`GetPropertyValue`.) [\\#934](https://github.com/PyO3/pyo3/pull/934)"
msgstr ""

#: src/changelog.md:491
msgid ""
"Call `Py_Finalize` at exit to flush buffers, etc. [\\#943](https://github."
"com/PyO3/pyo3/pull/943)"
msgstr ""

#: src/changelog.md:492
msgid ""
"Add type parameter to PyBuffer. #[951](https://github.com/PyO3/pyo3/pull/951)"
msgstr ""

#: src/changelog.md:493
msgid ""
"Require `Send` bound for `#[pyclass]`. [\\#966](https://github.com/PyO3/pyo3/"
"pull/966)"
msgstr ""

#: src/changelog.md:494
msgid ""
"Add `Python` argument to most methods on `PyObject` and `Py<T>` to ensure "
"GIL safety. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:495
msgid ""
"Change signature of `PyTypeObject::type_object` - now takes `Python` "
"argument and returns `&PyType`. [\\#970](https://github.com/PyO3/pyo3/"
"pull/970)"
msgstr ""

#: src/changelog.md:496
msgid ""
"Change return type of `PyTuple::slice` and `PyTuple::split_from` from "
"`Py<PyTuple>` to `&PyTuple`. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:497
msgid ""
"Change return type of `PyTuple::as_slice` to `&[&PyAny]`. [\\#971](https://"
"github.com/PyO3/pyo3/pull/971)"
msgstr ""

#: src/changelog.md:498
msgid ""
"Rename `PyTypeInfo::type_object` to `type_object_raw`, and add `Python` "
"argument. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:499
msgid ""
"Update `num-complex` optional dependendency from `0.2` to `0.3`. [\\#977]"
"(https://github.com/PyO3/pyo3/pull/977)"
msgstr ""

#: src/changelog.md:500
msgid ""
"Update `num-bigint` optional dependendency from `0.2` to `0.3`. [\\#978]"
"(https://github.com/PyO3/pyo3/pull/978)"
msgstr ""

#: src/changelog.md:501
msgid ""
"`#[pyproto]` is re-implemented without specialization. [\\#961](https://"
"github.com/PyO3/pyo3/pull/961)"
msgstr ""

#: src/changelog.md:502
msgid ""
"`PyClassAlloc::alloc` is renamed to `PyClassAlloc::new`. [\\#990](https://"
"github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:503
msgid ""
"`#[pyproto]` methods can now have return value `T` or `PyResult<T>` "
"(previously only `PyResult<T>` was supported). [\\#996](https://github.com/"
"PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:504
msgid ""
"`#[pyproto]` methods can now skip annotating the return type if it is `()`. "
"[\\#998](https://github.com/PyO3/pyo3/pull/998)"
msgstr ""

#: src/changelog.md:508
msgid ""
"Remove `ManagedPyRef` (unused, and needs specialization) [\\#930](https://"
"github.com/PyO3/pyo3/pull/930)"
msgstr ""

#: src/changelog.md:512
msgid ""
"Fix passing explicit `None` to `Option<T>` argument `#[pyfunction]` with a "
"default value. [\\#936](https://github.com/PyO3/pyo3/pull/936)"
msgstr ""

#: src/changelog.md:513
msgid ""
"Fix `PyClass.__new__`'s not respecting subclasses when inherited by a Python "
"class. [\\#990](https://github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:514
msgid ""
"Fix returning `Option<T>` from `#[pyproto]` methods. [\\#996](https://github."
"com/PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:515
msgid ""
"Fix accepting `PyRef<Self>` and `PyRefMut<Self>` to `#[getter]` and "
"`#[setter]` methods. [\\#999](https://github.com/PyO3/pyo3/pull/999)"
msgstr ""

#: src/changelog.md:517
msgid ""
"[0.10.1](https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1) - 2020-05-14"
msgstr ""

#: src/changelog.md:521
msgid ""
"Fix deadlock in `Python::acquire_gil` after dropping a `PyObject` or "
"`Py<T>`. [\\#924](https://github.com/PyO3/pyo3/pull/924)"
msgstr ""

#: src/changelog.md:523
msgid ""
"[0.10.0](https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0) - 2020-05-13"
msgstr ""

#: src/changelog.md:527
msgid ""
"Add FFI definition `_PyDict_NewPresized`. [\\#849](https://github.com/PyO3/"
"pyo3/pull/849)"
msgstr ""

#: src/changelog.md:528
msgid ""
"Implement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`. [\\#864](https://"
"github.com/PyO3/pyo3/pull/864)"
msgstr ""

#: src/changelog.md:529
msgid ""
"Add `PyAny::dir` method. [\\#886](https://github.com/PyO3/pyo3/pull/886)"
msgstr ""

#: src/changelog.md:530
msgid ""
"Gate macros behind a `macros` feature (enabled by default). [\\#897](https://"
"github.com/PyO3/pyo3/pull/897)"
msgstr ""

#: src/changelog.md:531
msgid ""
"Add ability to define class attributes using `#[classattr]` on functions in "
"`#[pymethods]`. [\\#905](https://github.com/PyO3/pyo3/pull/905)"
msgstr ""

#: src/changelog.md:532
msgid ""
"Implement `Clone` for `PyObject` and `Py<T>`. [\\#908](https://github.com/"
"PyO3/pyo3/pull/908)"
msgstr ""

#: src/changelog.md:533
msgid ""
"Implement `Deref<Target = PyAny>` for all builtin types. (`PyList`, "
"`PyTuple`, `PyDict` etc.) [\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:534
msgid ""
"Implement `Deref<Target = PyAny>` for `PyCell<T>`. [\\#911](https://github."
"com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:535
msgid ""
"Add `#[classattr]` support for associated constants in `#[pymethods]`. "
"[\\#914](https://github.com/PyO3/pyo3/pull/914)"
msgstr ""

#: src/changelog.md:539
msgid ""
"Panics will now be raised as a Python `PanicException`. [\\#797](https://"
"github.com/PyO3/pyo3/pull/797)"
msgstr ""

#: src/changelog.md:540
msgid ""
"Change `PyObject` and `Py<T>` reference counts to decrement immediately upon "
"drop when the GIL is held. [\\#851](https://github.com/PyO3/pyo3/pull/851)"
msgstr ""

#: src/changelog.md:541
msgid ""
"Allow `PyIterProtocol` methods to use either `PyRef` or `PyRefMut` as the "
"receiver type. [\\#856](https://github.com/PyO3/pyo3/pull/856)"
msgstr ""

#: src/changelog.md:542
msgid ""
"Change the implementation of `FromPyObject` for `Py<T>` to apply to a wider "
"range of `T`, including all `T: PyClass`. [\\#880](https://github.com/PyO3/"
"pyo3/pull/880)"
msgstr ""

#: src/changelog.md:543
msgid ""
"Move all methods from the `ObjectProtocol` trait to the `PyAny` struct. "
"[\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:544
msgid ""
"Remove need for `#![feature(specialization)]` in crates depending on PyO3. "
"[\\#917](https://github.com/PyO3/pyo3/pull/917)"
msgstr ""

#: src/changelog.md:548
msgid ""
"Remove `PyMethodsProtocol` trait. [\\#889](https://github.com/PyO3/pyo3/"
"pull/889)"
msgstr ""

#: src/changelog.md:549
msgid ""
"Remove `num-traits` dependency. [\\#895](https://github.com/PyO3/pyo3/"
"pull/895)"
msgstr ""

#: src/changelog.md:550
msgid ""
"Remove `ObjectProtocol` trait. [\\#911](https://github.com/PyO3/pyo3/"
"pull/911)"
msgstr ""

#: src/changelog.md:551
msgid ""
"Remove `PyAny::None`. Users should use `Python::None` instead. [\\#911]"
"(https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:552
msgid ""
"Remove all `*ProtocolImpl` traits. [\\#917](https://github.com/PyO3/pyo3/"
"pull/917)"
msgstr ""

#: src/changelog.md:556
msgid ""
"Fix support for `__radd__` and other `__r*__` methods as implementations for "
"Python mathematical operators. [\\#839](https://github.com/PyO3/pyo3/"
"pull/839)"
msgstr ""

#: src/changelog.md:557
msgid ""
"Fix panics during garbage collection when traversing objects that were "
"already mutably borrowed. [\\#855](https://github.com/PyO3/pyo3/pull/855)"
msgstr ""

#: src/changelog.md:558
msgid ""
"Prevent `&'static` references to Python objects as arguments to "
"`#[pyfunction]` and `#[pymethods]`. [\\#869](https://github.com/PyO3/pyo3/"
"pull/869)"
msgstr ""

#: src/changelog.md:559
msgid ""
"Fix lifetime safety bug with `AsPyRef::as_ref`. [\\#876](https://github.com/"
"PyO3/pyo3/pull/876)"
msgstr ""

#: src/changelog.md:560
msgid ""
"Fix `#[pyo3(get)]` attribute on `Py<T>` fields. [\\#880](https://github.com/"
"PyO3/pyo3/pull/880)"
msgstr ""

#: src/changelog.md:561
msgid ""
"Fix segmentation faults caused by functions such as `PyList::get_item` "
"returning borrowed objects when it was not safe to do so. [\\#890](https://"
"github.com/PyO3/pyo3/pull/890)"
msgstr ""

#: src/changelog.md:562
msgid ""
"Fix segmentation faults caused by nested `Python::acquire_gil` calls "
"creating dangling references. [\\#893](https://github.com/PyO3/pyo3/pull/893)"
msgstr ""

#: src/changelog.md:563
msgid ""
"Fix segmentatation faults when a panic occurs during a call to `Python::"
"allow_threads`. [\\#912](https://github.com/PyO3/pyo3/pull/912)"
msgstr ""

#: src/changelog.md:565
msgid ""
"[0.9.2](https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2) - 2020-04-09"
msgstr ""

#: src/changelog.md:569
msgid ""
"`FromPyObject` implementations for `HashSet` and `BTreeSet`. [\\#842]"
"(https://github.com/PyO3/pyo3/pull/842)"
msgstr ""

#: src/changelog.md:573
msgid ""
"Correctly detect 32bit architecture. [\\#830](https://github.com/PyO3/pyo3/"
"pull/830)"
msgstr ""

#: src/changelog.md:575
msgid ""
"[0.9.1](https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1) - 2020-03-23"
msgstr ""

#: src/changelog.md:579
msgid ""
"Error messages for `#[pyclass]`. [\\#826](https://github.com/PyO3/pyo3/"
"pull/826)"
msgstr ""

#: src/changelog.md:580
msgid ""
"`FromPyObject` implementation for `PySequence`. [\\#827](https://github.com/"
"PyO3/pyo3/pull/827)"
msgstr ""

#: src/changelog.md:582
msgid ""
"[0.9.0](https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0) - 2020-03-19"
msgstr ""

#: src/changelog.md:586
msgid ""
"`PyCell`, which has RefCell-like features. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:587
msgid ""
"`PyClass`, `PyLayout`, `PyClassInitializer`. [\\#683](https://github.com/"
"PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:588
msgid ""
"Implemented `IntoIterator` for `PySet` and `PyFrozenSet`. [\\#716](https://"
"github.com/PyO3/pyo3/pull/716)"
msgstr ""

#: src/changelog.md:589
msgid ""
"`FromPyObject` is now automatically implemented for `T: Clone` pyclasses. "
"[\\#730](https://github.com/PyO3/pyo3/pull/730)"
msgstr ""

#: src/changelog.md:590
msgid ""
"`#[pyo3(get)]` and `#[pyo3(set)]` will now use the Rust doc-comment from the "
"field for the Python property. [\\#755](https://github.com/PyO3/pyo3/"
"pull/755)"
msgstr ""

#: src/changelog.md:591
msgid ""
"`#[setter]` functions may now take an argument of `Pyo3::Python`. [\\#760]"
"(https://github.com/PyO3/pyo3/pull/760)"
msgstr ""

#: src/changelog.md:592
msgid ""
"`PyTypeInfo::BaseLayout` and `PyClass::BaseNativeType`. [\\#770](https://"
"github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:593
msgid "`PyDowncastImpl`. [\\#770](https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:594
msgid ""
"Implement `FromPyObject` and `IntoPy<PyObject>` traits for arrays (up to "
"32). [\\#778](https://github.com/PyO3/pyo3/pull/778)"
msgstr ""

#: src/changelog.md:595
msgid ""
"`migration.md` and `types.md` in the guide. [\\#795](https://github.com/PyO3/"
"pyo3/pull/795), #[802](https://github.com/PyO3/pyo3/pull/802)"
msgstr ""

#: src/changelog.md:596
msgid ""
"`ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}"
"`. #[820](https://github.com/PyO3/pyo3/pull/820)"
msgstr ""

#: src/changelog.md:600
msgid ""
"`#[new]` does not take `PyRawObject` and can return `Self`. [\\#683](https://"
"github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:601
msgid ""
"The blanket implementations for `FromPyObject` for `&T` and `&mut T` are no "
"longer specializable. Implement `PyTryFrom` for your type to control the "
"behavior of `FromPyObject::extract` for your types. [\\#713](https://github."
"com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:602
msgid ""
"The implementation for `IntoPy<U> for T` where `U: FromPy<T>` is no longer "
"specializable. Control the behavior of this via the implementation of "
"`FromPy`. [\\#713](https://github.com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:603
msgid ""
"Use `parking_lot::Mutex` instead of `spin::Mutex`. [\\#734](https://github."
"com/PyO3/pyo3/pull/734)"
msgstr ""

#: src/changelog.md:604
msgid ""
"Bumped minimum Rust version to `1.42.0-nightly 2020-01-21`. [\\#761](https://"
"github.com/PyO3/pyo3/pull/761)"
msgstr ""

#: src/changelog.md:605
msgid ""
"`PyRef` and `PyRefMut` are renewed for `PyCell`. [\\#770](https://github.com/"
"PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:606
msgid ""
"Some new FFI functions for Python 3.8. [\\#784](https://github.com/PyO3/pyo3/"
"pull/784)"
msgstr ""

#: src/changelog.md:607
msgid ""
"`PyAny` is now on the top level module and prelude. [\\#816](https://github."
"com/PyO3/pyo3/pull/816)"
msgstr ""

#: src/changelog.md:611
msgid "`PyRawObject`. [\\#683](https://github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:612
msgid "`PyNoArgsFunction`. [\\#741](https://github.com/PyO3/pyo3/pull/741)"
msgstr ""

#: src/changelog.md:613
msgid ""
"`initialize_type`. To set the module name for a `#[pyclass]`, use the "
"`module` argument to the macro. #[751](https://github.com/PyO3/pyo3/pull/751)"
msgstr ""

#: src/changelog.md:614
msgid ""
"`AsPyRef::as_mut/with/with_mut/into_py/into_mut_py`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:615
msgid ""
"`PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked`. [\\#770]"
"(https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:616
msgid ""
"`Python::mut_from_owned_ptr/mut_from_borrowed_ptr`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:617
msgid ""
"`ObjectProtocol::get_base/get_mut_base`. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:621
msgid ""
"Fixed unsoundness of subclassing. [\\#683](https://github.com/PyO3/pyo3/"
"pull/683)."
msgstr ""

#: src/changelog.md:622
msgid ""
"Clear error indicator when the exception is handled on the Rust side. "
"[\\#719](https://github.com/PyO3/pyo3/pull/719)"
msgstr ""

#: src/changelog.md:623
msgid ""
"Usage of raw identifiers with `#[pyo3(set)]`. [\\#745](https://github.com/"
"PyO3/pyo3/pull/745)"
msgstr ""

#: src/changelog.md:624
msgid ""
"Usage of `PyObject` with `#[pyo3(get)]`. [\\#760](https://github.com/PyO3/"
"pyo3/pull/760)"
msgstr ""

#: src/changelog.md:625
msgid ""
"`#[pymethods]` used in conjunction with `#[cfg]`. #[769](https://github.com/"
"PyO3/pyo3/pull/769)"
msgstr ""

#: src/changelog.md:626
msgid ""
"`\"*\"` in a `#[pyfunction()]` argument list incorrectly accepting any "
"number of positional arguments (use `args = \"*\"` when this behaviour is "
"desired). #[792](https://github.com/PyO3/pyo3/pull/792)"
msgstr ""

#: src/changelog.md:627
msgid "`PyModule::dict`. #[809](https://github.com/PyO3/pyo3/pull/809)"
msgstr ""

#: src/changelog.md:628
msgid ""
"Fix the case where `DESCRIPTION` is not null-terminated. #[822](https://"
"github.com/PyO3/pyo3/pull/822)"
msgstr ""

#: src/changelog.md:630
msgid "\\[0.8.5\\] - 2020-01-05"
msgstr ""

#: src/changelog.md:634
msgid "Implemented `FromPyObject` for `HashMap` and `BTreeMap`"
msgstr ""

#: src/changelog.md:635
msgid ""
"Support for `#[name = \"foo\"]` attribute for `#[pyfunction]` and in "
"`#[pymethods]`. [\\#692](https://github.com/PyO3/pyo3/pull/692)"
msgstr ""

#: src/changelog.md:637
msgid ""
"[0.8.4](https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5) - 2019-12-14"
msgstr ""

#: src/changelog.md:641
msgid ""
"Support for `#[text_signature]` attribute. [\\#675](https://github.com/PyO3/"
"pyo3/pull/675)"
msgstr ""

#: src/changelog.md:643
msgid ""
"[0.8.3](https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3) - 2019-11-23"
msgstr ""

#: src/changelog.md:647
msgid "`#[init]` is removed. [\\#658](https://github.com/PyO3/pyo3/pull/658)"
msgstr ""

#: src/changelog.md:651
msgid ""
"Now all `&Py~` types have `!Send` bound. [\\#655](https://github.com/PyO3/"
"pyo3/pull/655)"
msgstr ""

#: src/changelog.md:652
msgid ""
"Fix a compile error raised by the stabilization of `!` type. [\\#672]"
"(https://github.com/PyO3/pyo3/issues/672)."
msgstr ""

#: src/changelog.md:654
msgid ""
"[0.8.2](https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2) - 2019-10-27"
msgstr ""

#: src/changelog.md:658
msgid ""
"FFI compatibility for PEP 590 Vectorcall. [\\#641](https://github.com/PyO3/"
"pyo3/pull/641)"
msgstr ""

#: src/changelog.md:662
msgid ""
"Fix PySequenceProtocol::set_item. [\\#624](https://github.com/PyO3/pyo3/"
"pull/624)"
msgstr ""

#: src/changelog.md:663
msgid ""
"Fix a corner case of BigInt::FromPyObject. [\\#630](https://github.com/PyO3/"
"pyo3/pull/630)"
msgstr ""

#: src/changelog.md:664
msgid ""
"Fix index errors in parameter conversion. [\\#631](https://github.com/PyO3/"
"pyo3/pull/631)"
msgstr ""

#: src/changelog.md:665
msgid ""
"Fix handling of invalid utf-8 sequences in `PyString::as_bytes`. [\\#639]"
"(https://github.com/PyO3/pyo3/pull/639) and `PyString::to_string_lossy` "
"[\\#642](https://github.com/PyO3/pyo3/pull/642)."
msgstr ""

#: src/changelog.md:667
msgid ""
"Remove `__contains__` and `__iter__` from PyMappingProtocol. [\\#644]"
"(https://github.com/PyO3/pyo3/pull/644)"
msgstr ""

#: src/changelog.md:668
msgid ""
"Fix proc-macro definition of PySetAttrProtocol. [\\#645](https://github.com/"
"PyO3/pyo3/pull/645)"
msgstr ""

#: src/changelog.md:670
msgid ""
"[0.8.1](https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1) - 2019-10-08"
msgstr ""

#: src/changelog.md:674
msgid ""
"Conversion between [num-bigint](https://github.com/rust-num/num-bigint) and "
"Python int. [\\#608](https://github.com/PyO3/pyo3/pull/608)"
msgstr ""

#: src/changelog.md:678
msgid ""
"Make sure the right Python interpreter is used in OSX builds. [\\#604]"
"(https://github.com/PyO3/pyo3/pull/604)"
msgstr ""

#: src/changelog.md:679
msgid ""
"Patch specialization being broken by Rust 1.40. [\\#614](https://github.com/"
"PyO3/pyo3/issues/614)"
msgstr ""

#: src/changelog.md:680
msgid ""
"Fix a segfault around PyErr. [\\#597](https://github.com/PyO3/pyo3/pull/597)"
msgstr ""

#: src/changelog.md:682
msgid ""
"[0.8.0](https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0) - 2019-09-16"
msgstr ""

#: src/changelog.md:686
msgid ""
"`module` argument to `pyclass` macro. [\\#499](https://github.com/PyO3/pyo3/"
"pull/499)"
msgstr ""

#: src/changelog.md:687
msgid "`py_run!` macro [\\#512](https://github.com/PyO3/pyo3/pull/512)"
msgstr ""

#: src/changelog.md:688
msgid ""
"Use existing fields and methods before calling custom **getattr**. [\\#505]"
"(https://github.com/PyO3/pyo3/pull/505)"
msgstr ""

#: src/changelog.md:689
msgid "`PyBytes` can now be indexed just like `Vec<u8>`"
msgstr ""

#: src/changelog.md:690
msgid "Implement `IntoPy<PyObject>` for `PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:694
msgid ""
"Implementing the Using the `gc` parameter for `pyclass` (e.g. "
"`#[pyclass(gc)]`) without implementing the `class::PyGCProtocol` trait is "
"now a compile-time error. Failing to implement this trait could lead to "
"segfaults. [\\#532](https://github.com/PyO3/pyo3/pull/532)"
msgstr ""

#: src/changelog.md:695
msgid ""
"`PyByteArray::data` has been replaced with `PyDataArray::to_vec` because "
"returning a `&[u8]` is unsound. (See [this comment](https://github.com/PyO3/"
"pyo3/issues/373#issuecomment-512332696) for a great write-up for why that "
"was unsound)"
msgstr ""

#: src/changelog.md:696
msgid "Replace `mashup` with `paste`."
msgstr ""

#: src/changelog.md:697
msgid ""
"`GILPool` gained a `Python` marker to prevent it from being misused to "
"release Python objects without the GIL held."
msgstr ""

#: src/changelog.md:701
msgid "`IntoPyObject` was replaced with `IntoPy<PyObject>`"
msgstr ""

#: src/changelog.md:702
msgid ""
"`#[pyclass(subclass)]` is hidden a `unsound-subclass` feature because it's "
"causing segmentation faults."
msgstr ""

#: src/changelog.md:706
msgid ""
"More readable error message for generics in pyclass [\\#503](https://github."
"com/PyO3/pyo3/pull/503)"
msgstr ""

#: src/changelog.md:708
msgid ""
"[0.7.0](https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0) - 2019-05-26"
msgstr ""

#: src/changelog.md:712
msgid ""
"PyPy support by omerbenamram in [\\#393](https://github.com/PyO3/pyo3/"
"pull/393)"
msgstr ""

#: src/changelog.md:713
msgid "Have `PyModule` generate an index of its members (`__all__` list)."
msgstr ""

#: src/changelog.md:714
msgid "Allow `slf: PyRef<T>` for pyclass(#419)"
msgstr ""

#: src/changelog.md:715
msgid "Allow to use lifetime specifiers in `pymethods`"
msgstr ""

#: src/changelog.md:716
msgid "Add `marshal` module. [\\#460](https://github.com/PyO3/pyo3/pull/460)"
msgstr ""

#: src/changelog.md:720
msgid "`Python::run` returns `PyResult<()>` instead of `PyResult<&PyAny>`."
msgstr ""

#: src/changelog.md:721
msgid ""
"Methods decorated with `#[getter]` and `#[setter]` can now omit wrapping the "
"result type in `PyResult` if they don't raise exceptions."
msgstr ""

#: src/changelog.md:726
msgid ""
"`type_object::PyTypeObject` has been marked unsafe because breaking the "
"contract `type_object::PyTypeObject::init_type` can lead to UB."
msgstr ""

#: src/changelog.md:727
msgid ""
"Fixed automatic derive of `PySequenceProtocol` implementation in [\\#423]"
"(https://github.com/PyO3/pyo3/pull/423)."
msgstr ""

#: src/changelog.md:728
msgid "Capitalization & better wording to README.md."
msgstr ""

#: src/changelog.md:729
msgid ""
"Docstrings of properties is now properly set using the doc of the "
"`#[getter]` method."
msgstr ""

#: src/changelog.md:730
msgid ""
"Fixed issues with `pymethods` crashing on doc comments containing double "
"quotes."
msgstr ""

#: src/changelog.md:731
msgid ""
"`PySet::new` and `PyFrozenSet::new` now return `PyResult<&Py[Frozen]Set>`; "
"exceptions are raised if the items are not hashable."
msgstr ""

#: src/changelog.md:733
msgid "Fixed building using `venv` on Windows."
msgstr ""

#: src/changelog.md:734
msgid "`PyTuple::new` now returns `&PyTuple` instead of `Py<PyTuple>`."
msgstr ""

#: src/changelog.md:735
msgid ""
"Fixed several issues with argument parsing; notable, the `*args` and "
"`**kwargs` tuple/dict now doesn't contain arguments that are otherwise "
"assigned to parameters."
msgstr ""

#: src/changelog.md:738
msgid ""
"[0.6.0](https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0) - 2019-03-28"
msgstr ""

#: src/changelog.md:740
msgid "Regressions"
msgstr ""

#: src/changelog.md:742
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For now you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/changelog.md:744
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/changelog.md:755
msgid ""
"Added a `wrap_pymodule!` macro similar to the existing `wrap_pyfunction!` "
"macro. Only available on python 3"
msgstr ""

#: src/changelog.md:756
msgid ""
"Added support for cross compiling (e.g. to arm v7) by mtp401 in [\\#327]"
"(https://github.com/PyO3/pyo3/pull/327). See the \"Cross Compiling\" section "
"in the \"Building and Distribution\" chapter of the guide for more details."
msgstr ""

#: src/changelog.md:757
msgid ""
"The `PyRef` and `PyRefMut` types, which allow to differentiate between an "
"instance of a rust struct on the rust heap and an instance that is embedded "
"inside a python object. By kngwyu in [\\#335](https://github.com/PyO3/pyo3/"
"pull/335)"
msgstr ""

#: src/changelog.md:758
msgid ""
"Added `FromPy<T>` and `IntoPy<T>` which are equivalent to `From<T>` and "
"`Into<T>` except that they require a gil token."
msgstr ""

#: src/changelog.md:759
msgid ""
"Added `ManagedPyRef`, which should eventually replace `ToBorrowedObject`."
msgstr ""

#: src/changelog.md:763
msgid "Renamed `PyObjectRef` to `PyAny` in #388"
msgstr ""

#: src/changelog.md:764
msgid ""
"Renamed `add_function` to `add_wrapped` as it now also supports modules."
msgstr ""

#: src/changelog.md:765
msgid "Renamed `#[pymodinit]` to `#[pymodule]`"
msgstr ""

#: src/changelog.md:766
msgid "`py.init(|| value)` becomes `Py::new(value)`"
msgstr ""

#: src/changelog.md:767
msgid "`py.init_ref(|| value)` becomes `PyRef::new(value)`"
msgstr ""

#: src/changelog.md:768
msgid "`py.init_mut(|| value)` becomes `PyRefMut::new(value)`."
msgstr ""

#: src/changelog.md:769
msgid ""
"`PyRawObject::init` is now infallible, e.g. it returns `()` instead of "
"`PyResult<()>`."
msgstr ""

#: src/changelog.md:770
msgid ""
"Renamed `py_exception!` to `create_exception!` and refactored the error "
"macros."
msgstr ""

#: src/changelog.md:771
msgid "Renamed `wrap_function!` to `wrap_pyfunction!`"
msgstr ""

#: src/changelog.md:772
msgid "Renamed `#[prop(get, set)]` to `#[pyo3(get, set)]`"
msgstr ""

#: src/changelog.md:773
msgid "`#[pyfunction]` now supports the same arguments as `#[pyfn()]`"
msgstr ""

#: src/changelog.md:774
msgid "Some macros now emit proper spanned errors instead of panics."
msgstr ""

#: src/changelog.md:775
msgid "Migrated to the 2018 edition"
msgstr ""

#: src/changelog.md:776
msgid "`crate::types::exceptions` moved to `crate::exceptions`"
msgstr ""

#: src/changelog.md:777
msgid "Replace `IntoPyTuple` with `IntoPy<Py<PyTuple>>`."
msgstr ""

#: src/changelog.md:778
msgid "`IntoPyPointer` and `ToPyPointer` moved into the crate root."
msgstr ""

#: src/changelog.md:779
msgid "`class::CompareOp` moved into `class::basic::CompareOp`"
msgstr ""

#: src/changelog.md:780
msgid ""
"PyTypeObject is now a direct subtrait PyTypeCreate, removing the old "
"cyclical implementation in [\\#350](https://github.com/PyO3/pyo3/pull/350)"
msgstr ""

#: src/changelog.md:781
msgid ""
"Add `PyList::{sort, reverse}` by chr1sj0nes in [\\#357](https://github.com/"
"PyO3/pyo3/pull/357) and [\\#358](https://github.com/PyO3/pyo3/pull/358)"
msgstr ""

#: src/changelog.md:782
msgid "Renamed the `typeob` module to `type_object`"
msgstr ""

#: src/changelog.md:786
msgid ""
"`PyToken` was removed due to unsoundness (See [\\#94](https://github.com/"
"PyO3/pyo3/issues/94))."
msgstr ""

#: src/changelog.md:787
msgid "Removed the unnecessary type parameter from `PyObjectAlloc`"
msgstr ""

#: src/changelog.md:788
msgid "`NoArgs`. Just use an empty tuple"
msgstr ""

#: src/changelog.md:789
msgid ""
"`PyObjectWithGIL`. `PyNativeType` is sufficient now that PyToken is removed."
msgstr ""

#: src/changelog.md:793
msgid ""
"A soudness hole where every instances of a `#[pyclass]` struct was "
"considered to be part of a python object, even though you can create "
"instances that are not part of the python heap. This was fixed through "
"`PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:794
msgid "Fix kwargs support in [\\#328](https://github.com/PyO3/pyo3/pull/328)."
msgstr ""

#: src/changelog.md:795
msgid ""
"Add full support for `__dict__` in [\\#403](https://github.com/PyO3/pyo3/"
"pull/403)."
msgstr ""

#: src/changelog.md:797
msgid ""
"[0.5.3](https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3) - 2019-01-04"
msgstr ""

#: src/changelog.md:801
msgid ""
"Fix memory leak in ArrayList by kngwyu [\\#316](https://github.com/PyO3/pyo3/"
"pull/316)"
msgstr ""

#: src/changelog.md:803
msgid ""
"[0.5.2](https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.2) - 2018-11-25"
msgstr ""

#: src/changelog.md:807
msgid ""
"Fix undeterministic segfaults when creating many objects by kngwyu in "
"[\\#281](https://github.com/PyO3/pyo3/pull/281)"
msgstr ""

#: src/changelog.md:809
msgid "\\[0.5.1\\] - 2018-11-24"
msgstr ""

#: src/changelog.md:811
msgid "Yanked"
msgstr ""

#: src/changelog.md:813
msgid ""
"[0.5.0](https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0) - 2018-11-11"
msgstr ""

#: src/changelog.md:817
msgid "`#[pyclass]` objects can now be returned from rust functions"
msgstr ""

#: src/changelog.md:818
msgid ""
"`PyComplex` by kngwyu in [\\#226](https://github.com/PyO3/pyo3/pull/226)"
msgstr ""

#: src/changelog.md:819
msgid "`PyDict::from_sequence`, equivalent to `dict([(key, val), ...])`"
msgstr ""

#: src/changelog.md:820
msgid ""
"Bindings for the `datetime` standard library types: `PyDate`, `PyTime`, "
"`PyDateTime`, `PyTzInfo`, `PyDelta` with associated `ffi` types, by pganssle "
"[\\#200](https://github.com/PyO3/pyo3/pull/200)."
msgstr ""

#: src/changelog.md:821
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` now have an `as_bytes` method that "
"returns `&[u8]`."
msgstr ""

#: src/changelog.md:822
msgid ""
"`PyObjectProtocol::get_type_ptr` by ijl in [\\#242](https://github.com/PyO3/"
"pyo3/pull/242)"
msgstr ""

#: src/changelog.md:826
msgid ""
"Removes the types from the root module and the prelude. They now live in "
"`pyo3::types` instead."
msgstr ""

#: src/changelog.md:827
msgid ""
"All exceptions are consturcted with `py_err` instead of `new`, as they "
"return `PyErr` and not `Self`."
msgstr ""

#: src/changelog.md:828
msgid "`as_mut` and friends take and `&mut self` instead of `&self`"
msgstr ""

#: src/changelog.md:829
msgid ""
"`ObjectProtocol::call` now takes an `Option<&PyDict>` for the kwargs instead "
"of an `IntoPyDictPointer`."
msgstr ""

#: src/changelog.md:830
msgid ""
"`IntoPyDictPointer` was replace by `IntoPyDict` which doesn't convert "
"`PyDict` itself anymore and returns a `PyDict` instead of `*mut PyObject`."
msgstr ""

#: src/changelog.md:831
msgid "`PyTuple::new` now takes an `IntoIterator` instead of a slice"
msgstr ""

#: src/changelog.md:832
msgid "Updated to syn 0.15"
msgstr ""

#: src/changelog.md:833
msgid ""
"Splitted `PyTypeObject` into `PyTypeObject` without the create method and "
"`PyTypeCreate` with requires `PyObjectAlloc<Self> + PyTypeInfo + Sized`."
msgstr ""

#: src/changelog.md:834
msgid ""
"Ran `cargo edition --fix` which prefixed path with `crate::` for rust 2018"
msgstr ""

#: src/changelog.md:835
msgid ""
"Renamed `async` to `pyasync` as async will be a keyword in the 2018 edition."
msgstr ""

#: src/changelog.md:836
msgid ""
"Starting to use `NonNull<*mut PyObject>` for Py and PyObject by ijl [\\#260]"
"(https://github.com/PyO3/pyo3/pull/260)"
msgstr ""

#: src/changelog.md:840
msgid ""
"Removed most entries from the prelude. The new prelude is small and clear."
msgstr ""

#: src/changelog.md:841
msgid "Slowly removing specialization uses"
msgstr ""

#: src/changelog.md:842
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` no longer have a `data` method "
"(replaced by `as_bytes`) and `PyStringData` has been removed."
msgstr ""

#: src/changelog.md:844
msgid "The pyobject_extract macro"
msgstr ""

#: src/changelog.md:848
msgid ""
"Added an explanation that the GIL can temporarily be released even while "
"holding a GILGuard."
msgstr ""

#: src/changelog.md:849
msgid "Lots of clippy errors"
msgstr ""

#: src/changelog.md:850
msgid "Fix segfault on calling an unknown method on a PyObject"
msgstr ""

#: src/changelog.md:851
msgid ""
"Work around a [bug](https://github.com/rust-lang/rust/issues/55380) in the "
"rust compiler by kngwyu [\\#252](https://github.com/PyO3/pyo3/pull/252)"
msgstr ""

#: src/changelog.md:852
msgid ""
"Fixed a segfault with subclassing pyo3 create classes and using `__class__` "
"by kngwyu [\\#263](https://github.com/PyO3/pyo3/pull/263)"
msgstr ""

#: src/changelog.md:854
msgid ""
"[0.4.1](https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1) - 2018-08-20"
msgstr ""

#: src/changelog.md:858
msgid "PyTryFrom's error is always to `PyDowncastError`"
msgstr ""

#: src/changelog.md:862
msgid "Fixed compilation on nightly since `use_extern_macros` was stabilized"
msgstr ""

#: src/changelog.md:866
msgid "The pyobject_downcast macro"
msgstr ""

#: src/changelog.md:868
msgid ""
"[0.4.0](https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0) - 2018-07-30"
msgstr ""

#: src/changelog.md:872
msgid "Merged both examples into one"
msgstr ""

#: src/changelog.md:873
msgid "Rustfmt all the things :heavy_check_mark:"
msgstr ""

#: src/changelog.md:874
msgid "Switched to [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)"
msgstr ""

#: src/changelog.md:878
msgid ""
"Conversions from tuples to PyDict due to [rust-lang/rust#52050](https://"
"github.com/rust-lang/rust/issues/52050)"
msgstr ""

#: src/changelog.md:880
msgid ""
"[0.3.2](https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2) - 2018-07-22"
msgstr ""

#: src/changelog.md:884
msgid "Replaced `concat_idents` with mashup"
msgstr ""

#: src/changelog.md:886
msgid ""
"[0.3.1](https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1) - 2018-07-18"
msgstr ""

#: src/changelog.md:890
msgid "Fixed scoping bug in pyobject_native_type that would break rust-numpy"
msgstr ""

#: src/changelog.md:892
msgid ""
"[0.3.0](https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0) - 2018-07-18"
msgstr ""

#: src/changelog.md:896
msgid ""
"A few internal macros became part of the public api ([\\#155](https://github."
"com/PyO3/pyo3/pull/155), [\\#186](https://github.com/PyO3/pyo3/pull/186))"
msgstr ""

#: src/changelog.md:897
msgid ""
"Always clone in getters. This allows using the get-annotation on all Clone-"
"Types"
msgstr ""

#: src/changelog.md:901
msgid "Upgraded to syn 0.14 which means much better error messages :tada:"
msgstr ""

#: src/changelog.md:902
msgid ""
"128 bit integer support by [kngwyu](https://github.com/kngwyu) ([\\#137]"
"(https://github.com/PyO3/pyo3/pull/173))"
msgstr ""

#: src/changelog.md:903
msgid ""
"`proc_macro` has been stabilized on nightly ([rust-lang/rust#52081](https://"
"github.com/rust-lang/rust/pull/52081)). This means that we can remove the "
"`proc_macro` feature, but now we need the `use_extern_macros` from the 2018 "
"edition instead."
msgstr ""

#: src/changelog.md:904
msgid ""
"All proc macro are now prefixed with `py` and live in the prelude. This "
"means you can use `#[pyclass]`, `#[pymethods]`, `#[pyproto]`, "
"`#[pyfunction]` and `#[pymodinit]` directly, at least after a `use pyo3::"
"prelude::*`. They were also moved into a module called `proc_macro`. You "
"shouldn't use `#[pyo3::proc_macro::pyclass]` or other longer paths in "
"attributes because `proc_macro_path_invoc` isn't going to be stabilized soon."
msgstr ""

#: src/changelog.md:905
msgid "Renamed the `base` option in the `pyclass` macro to `extends`."
msgstr ""

#: src/changelog.md:906
msgid ""
"`#[pymodinit]` uses the function name as module name, unless the name is "
"overrriden with `#[pymodinit(name)]`"
msgstr ""

#: src/changelog.md:907
msgid "The guide is now properly versioned."
msgstr ""

#: src/changelog.md:909
msgid ""
"[0.2.7](https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7) - 2018-05-18"
msgstr ""

#: src/changelog.md:913
msgid "Fix nightly breakage with proc_macro_path"
msgstr ""

#: src/changelog.md:915
msgid ""
"[0.2.6](https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6) - 2018-04-03"
msgstr ""

#: src/changelog.md:919
msgid "Fix compatibility with TryFrom trait #137"
msgstr ""

#: src/changelog.md:921
msgid ""
"[0.2.5](https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5) - 2018-02-21"
msgstr ""

#: src/changelog.md:925
msgid "CPython 3.7 support"
msgstr ""

#: src/changelog.md:929
msgid "Embedded CPython 3.7b1 crashes on initialization #110"
msgstr ""

#: src/changelog.md:930
msgid "Generated extension functions are weakly typed #108"
msgstr ""

#: src/changelog.md:931
msgid "call_method\\* crashes when the method does not exist #113"
msgstr ""

#: src/changelog.md:932
msgid "Allow importing exceptions from nested modules #116"
msgstr ""

#: src/changelog.md:934
msgid ""
"[0.2.4](https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4) - 2018-01-19"
msgstr ""

#: src/changelog.md:938
msgid "Allow to get mutable ref from PyObject #106"
msgstr ""

#: src/changelog.md:939
msgid "Drop `RefFromPyObject` trait"
msgstr ""

#: src/changelog.md:940
msgid "Add Python::register_any method"
msgstr ""

#: src/changelog.md:944
msgid "Fix impl `FromPyObject` for `Py<T>`"
msgstr ""

#: src/changelog.md:945
msgid "Mark method that work with raw pointers as unsafe #95"
msgstr ""

#: src/changelog.md:947
msgid ""
"[0.2.3](https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3) - 11-27-2017"
msgstr ""

#: src/changelog.md:951
msgid "Rustup to 1.23.0-nightly 2017-11-07"
msgstr ""

#: src/changelog.md:955
msgid "Proper `c_char` usage #93"
msgstr ""

#: src/changelog.md:959
msgid "Remove use of now unneeded 'AsciiExt' trait"
msgstr ""

#: src/changelog.md:961
msgid ""
"[0.2.2](https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2) - 09-26-2017"
msgstr ""

#: src/changelog.md:965
msgid "Rustup to 1.22.0-nightly 2017-09-30"
msgstr ""

#: src/changelog.md:967
msgid ""
"[0.2.1](https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1) - 09-26-2017"
msgstr ""

#: src/changelog.md:971
msgid "Fix rustc const_fn nightly breakage"
msgstr ""

#: src/changelog.md:973
msgid ""
"[0.2.0](https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0) - 08-12-2017"
msgstr ""

#: src/changelog.md:977
msgid "Added inheritance support #15"
msgstr ""

#: src/changelog.md:978
msgid "Added weakref support #56"
msgstr ""

#: src/changelog.md:979
msgid "Added subclass support #64"
msgstr ""

#: src/changelog.md:980
msgid "Added `self.__dict__` supoort #68"
msgstr ""

#: src/changelog.md:981
msgid "Added `pyo3::prelude` module #70"
msgstr ""

#: src/changelog.md:982
msgid "Better `Iterator` support for PyTuple, PyList, PyDict #75"
msgstr ""

#: src/changelog.md:983
msgid "Introduce IntoPyDictPointer similar to IntoPyTuple #69"
msgstr ""

#: src/changelog.md:987
msgid "Allow to add gc support without implementing PyGCProtocol #57"
msgstr ""

#: src/changelog.md:988
msgid "Refactor `PyErr` implementation. Drop `py` parameter from constructor."
msgstr ""

#: src/changelog.md:990
msgid "[0.1.0](https://github.com/PyO3/pyo3/tree/0.1.0) - 07-23-2017"
msgstr ""

#: src/changelog.md:994
msgid "Initial release"
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/debugging.md:5
msgid ""
"PyO3's attributes (`#[pyclass]`, `#[pymodule]`, etc.) are [procedural macros]"
"(https://doc.rust-lang.org/reference/procedural-macros.html), which means "
"that they rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding `-Z trace-macros`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"See [cargo expand](https://github.com/dtolnay/cargo-expand) for a more "
"elaborate version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of Python, otherwise Valgrind won't "
"produce usable results. In Ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on Linux, use `ldd` with the name of your binary and check that you're "
"linking e.g. `libpython3.6dm.so.1.0` instead of `libpython3.6m.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for cpython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run Valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:40
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/faq.md:1
msgid "Frequently Asked Questions / Troubleshooting"
msgstr ""

#: src/faq.md:3
msgid "I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!"
msgstr ""

#: src/faq.md:5
msgid ""
"`lazy_static` and `once_cell::sync` both use locks to ensure that "
"initialization is performed only by a single thread. Because the Python GIL "
"is an additional lock this can lead to deadlocks in the following way:"
msgstr ""

#: src/faq.md:7
msgid ""
"A thread (thread A) which has acquired the Python GIL starts initialization "
"of a `lazy_static` value."
msgstr ""

#: src/faq.md:8
msgid ""
"The initialization code calls some Python API which temporarily releases the "
"GIL e.g. `Python::import`."
msgstr ""

#: src/faq.md:9
msgid ""
"Another thread (thread B) acquires the Python GIL and attempts to access the "
"same `lazy_static` value."
msgstr ""

#: src/faq.md:10
msgid ""
"Thread B is blocked, because it waits for `lazy_static`'s initialization to "
"lock to release."
msgstr ""

#: src/faq.md:11
msgid ""
"Thread A is blocked, because it waits to re-aquire the GIL which thread B "
"still holds."
msgstr ""

#: src/faq.md:12
msgid "Deadlock."
msgstr ""

#: src/faq.md:14
msgid ""
"PyO3 provides a struct [`GILOnceCell`](https://pyo3.rs/main/doc/pyo3/"
"once_cell/struct.GILOnceCell.html) which works equivalently to `OnceCell` "
"but relies solely on the Python GIL for thread safety. This means it can be "
"used in place of `lazy_static` or `once_cell` where you are experiencing the "
"deadlock described above. See the documentation for [`GILOnceCell`](https://"
"pyo3.rs/main/doc/pyo3/once_cell/struct.GILOnceCell.html) for an example how "
"to use it."
msgstr ""

#: src/faq.md:18
msgid ""
"I can't run `cargo test`: I'm having linker issues like \"Symbol not found\" "
"or \"Undefined reference to \\_PyExc_SystemError\"!"
msgstr ""

#: src/faq.md:20
msgid ""
"Currently, [\\#340](https://github.com/PyO3/pyo3/issues/340) causes `cargo "
"test` to fail with linking errors when the `extension-module` feature is "
"activated. For now you can work around this by making the `extension-module` "
"feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/faq.md:22
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:31
msgid ""
"I can't run `cargo test`: my crate cannot be found for tests in `tests/` "
"directory!"
msgstr ""

#: src/faq.md:33
msgid ""
"The Rust book suggests to [put integration tests inside a `tests/` directory]"
"(https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-"
"tests)."
msgstr ""

#: src/faq.md:35
msgid ""
"For a PyO3 `extension-module` project where the `crate-type` is set to "
"`\"cdylib\"` in your `Cargo.toml`, the compiler won't be able to find your "
"crate and will display errors such as `E0432` or `E0463`:"
msgstr ""

#: src/faq.md:46
msgid ""
"The best solution is to make your crate types include both `rlib` and "
"`cdylib`:"
msgstr ""

#: src/faq.md:48
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[lib]\n"
"crate-type = [\"cdylib\", \"rlib\"]\n"
"```"
msgstr ""

#: src/faq.md:54
msgid "Ctrl-C doesn't do anything while my Rust code is executing!"
msgstr ""

#: src/faq.md:56
msgid ""
"This is because Ctrl-C raises a SIGINT signal, which is handled by the "
"calling Python process by simply setting a flag to action upon later. This "
"flag isn't checked while Rust code called from Python is executing, only "
"once control returns to the Python interpreter."
msgstr ""

#: src/faq.md:58
msgid ""
"You can give the Python interpreter a chance to process the signal properly "
"by calling `Python::check_signals`. It's good practice to call this function "
"regularly if you have a long-running Rust function so that your users can "
"cancel it."
msgstr ""

#: src/faq.md:60
msgid "`#[pyo3(get)]` clones my field!"
msgstr ""

#: src/faq.md:62
msgid "You may have a nested struct similar to this:"
msgstr ""

#: src/faq.md:68 src/faq.md:108
msgid "/* fields omitted */"
msgstr ""

#: src/faq.md:85
msgid ""
"When Python code accesses `Outer`'s field, PyO3 will return a new object on "
"every access (note that their addresses are different):"
msgstr ""

#: src/faq.md:93 src/faq.md:133 src/faq.md:134
msgid "\"a: "
msgstr ""

#: src/faq.md:93 src/faq.md:133 src/faq.md:134
msgid "\\nb: "
msgstr ""

#: src/faq.md:93 src/faq.md:133 src/faq.md:134
msgid "\""
msgstr ""

#: src/faq.md:101
msgid ""
"This can be especially confusing if the field is mutable, as getting the "
"field and then mutating it won't persist - you'll just get a fresh clone of "
"the original on the next access. Unfortunately Python and Rust don't agree "
"about ownership - if PyO3 gave out references to (possibly) temporary Rust "
"objects to Python code, Python code could then keep that reference alive "
"indefinitely. Therefore returning Rust objects requires cloning."
msgstr ""

#: src/faq.md:103
msgid ""
"If you don't want that cloning to happen, a workaround is to allocate the "
"field on the Python heap and store a reference to that, by using [`Py<...>`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html):"
msgstr ""

#: src/faq.md:126
msgid "This time `a` and `b` _are_ the same object:"
msgstr ""

#: src/faq.md:141
msgid ""
"The downside to this approach is that any Rust code working on the `Outer` "
"struct now has to acquire the GIL to do anything with its field."
msgstr ""

#: src/features.md:1
msgid "Features Reference"
msgstr ""

#: src/features.md:3
msgid ""
"PyO3 provides a number of Cargo features to customise functionality. This "
"chapter of the guide provides detail on each of them."
msgstr ""

#: src/features.md:5
msgid "By default, only the `macros` feature is enabled."
msgstr ""

#: src/features.md:7
msgid "Features for extension module authors"
msgstr ""

#: src/features.md:9
msgid "`extension-module`"
msgstr ""

#: src/features.md:11
msgid ""
"This feature is required when building a Python extension module using PyO3."
msgstr ""

#: src/features.md:13
msgid ""
"It tells PyO3's build script to skip linking against `libpython.so` on Unix "
"platforms, where this must not be done."
msgstr ""

#: src/features.md:15
msgid ""
"See the [building and distribution](building_and_distribution.md#linking) "
"section for further detail."
msgstr ""

#: src/features.md:17
msgid "`abi3`"
msgstr ""

#: src/features.md:19
msgid ""
"This feature is used when building Python extension modules to create wheels "
"which are compatible with multiple Python versions."
msgstr ""

#: src/features.md:21
msgid ""
"It restricts PyO3's API to a subset of the full Python API which is "
"guaranteed by [PEP 384](https://www.python.org/dev/peps/pep-0384/) to be "
"forwards-compatible with future Python versions."
msgstr ""

#: src/features.md:23
msgid ""
"See the [building and distribution](building_and_distribution."
"md#py_limited_apiabi3) section for further detail."
msgstr ""

#: src/features.md:25
msgid "The `abi3-pyXY` features"
msgstr ""

#: src/features.md:27
msgid "(`abi3-py36`, `abi3-py37`, `abi3-py38`, `abi3-py39`, and `abi3-py310`)"
msgstr ""

#: src/features.md:29
msgid ""
"These features are extensions of the `abi3` feature to specify the exact "
"minimum Python version which the multiple-version-wheel will support."
msgstr ""

#: src/features.md:31
msgid ""
"See the [building and distribution](building_and_distribution.md#minimum-"
"python-version-for-abi3) section for further detail."
msgstr ""

#: src/features.md:33
msgid "Features for embedding Python in Rust"
msgstr ""

#: src/features.md:35
msgid "`auto-initialize`"
msgstr ""

#: src/features.md:37
msgid ""
"This feature changes [`Python::with_gil`](https://pyo3.rs/main/doc/pyo3/"
"struct.Python.html#method.with_gil) and [`Python::acquire_gil`](https://pyo3."
"rs/main/doc/pyo3/struct.Python.html#method.acquire_gil) to automatically "
"initialize a Python interpreter (by calling [`prepare_freethreaded_python`]"
"(https://pyo3.rs/main/doc/pyo3/fn.prepare_freethreaded_python.html)) if "
"needed."
msgstr ""

#: src/features.md:39
msgid ""
"If you do not enable this feature, you should call `pyo3::"
"prepare_freethreaded_python()` before attempting to call any other Python "
"APIs."
msgstr ""

#: src/features.md:41
msgid "Advanced Features"
msgstr ""

#: src/features.md:43
msgid "`macros`"
msgstr ""

#: src/features.md:45
msgid ""
"This feature enables a dependency on the `pyo3-macros` crate, which provides "
"the procedural macros portion of PyO3's API:"
msgstr ""

#: src/features.md:47
msgid "`#[pymodule]`"
msgstr ""

#: src/features.md:48
msgid "`#[pyfunction]`"
msgstr ""

#: src/features.md:49
msgid "`#[pyclass]`"
msgstr ""

#: src/features.md:50
msgid "`#[pymethods]`"
msgstr ""

#: src/features.md:52
msgid "`#[derive(FromPyObject)]`"
msgstr ""

#: src/features.md:54
msgid "It also provides the `py_run!` macro."
msgstr ""

#: src/features.md:56
msgid ""
"These macros require a number of dependencies which may not be needed by "
"users who just need PyO3 for Python FFI. Disabling this feature enables "
"faster builds for those users, as these dependencies will not be built if "
"this feature is disabled."
msgstr ""

#: src/features.md:58
msgid ""
"This feature is enabled by default. To disable it, set `default-features = "
"false` for the `pyo3` entry in your Cargo.toml."
msgstr ""

#: src/features.md:60
msgid "`multiple-pymethods`"
msgstr ""

#: src/features.md:62
msgid ""
"This feature enables a dependency on `inventory`, which enables each "
"`#[pyclass]` to have more than one `#[pymethods]` block."
msgstr ""

#: src/features.md:64
msgid ""
"Most users should only need a single `#[pymethods]` per `#[pyclass]`. In "
"addition, not all platforms (e.g. Wasm) are supported by `inventory`. For "
"this reason this feature is not enabled by default, meaning fewer "
"dependencies and faster compilation for the majority of users."
msgstr ""

#: src/features.md:66
msgid ""
"See [the `#[pyclass]` implementation details](class.md#implementation-"
"details) for more information."
msgstr ""

#: src/features.md:68
msgid "`nightly`"
msgstr ""

#: src/features.md:70
msgid ""
"The `nightly` feature needs the nightly Rust compiler. This allows PyO3 to "
"use Rust's unstable specialization feature to apply the following "
"optimizations:"
msgstr ""

#: src/features.md:71
msgid ""
"`FromPyObject` for `Vec` and `[T;N]` can perform a `memcpy` when the object "
"supports the Python buffer protocol."
msgstr ""

#: src/features.md:72
msgid ""
"`ToBorrowedObject` can skip a reference count increase when the provided "
"object is a Python native type."
msgstr ""

#: src/features.md:74
msgid "`resolve-config`"
msgstr ""

#: src/features.md:76
msgid ""
"The `resolve-config` feature of the `pyo3-build-config` crate controls "
"whether that crate's build script automatically resolves a Python "
"interpreter / build configuration. Disabling this feature enables this crate "
"to be used in _library mode_. This may be desirable for use cases where you "
"want to read or write PyO3 build configuration files or resolve metadata "
"about a Python interpreter."
msgstr ""

#: src/features.md:82
msgid "Optional Dependencies"
msgstr ""

#: src/features.md:84
msgid ""
"These features enable conversions between Python types and types from other "
"Rust crates, enabling easy access to the rest of the Rust ecosystem."
msgstr ""

#: src/features.md:86
msgid "`anyhow`"
msgstr ""

#: src/features.md:88
msgid ""
"Adds a dependency on [anyhow](https://docs.rs/anyhow). Enables a conversion "
"from [anyhow](https://docs.rs/anyhow)s \\[`Error`\\]https://docs.rs/anyhow/"
"latest/anyhow/struct.Error.html) type to [`PyErr`](https://docs.rs/pyo3/"
"latest/pyo3/struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:90
msgid "`eyre`"
msgstr ""

#: src/features.md:92
msgid ""
"Adds a dependency on [eyre](https://docs.rs/eyre). Enables a conversion from "
"[eyre](https://docs.rs/eyre)s [`Report`](https://docs.rs/eyre/latest/eyre/"
"struct.Report.html) type to [`PyErr`](https://docs.rs/pyo3/latest/pyo3/"
"struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:94
msgid "`hashbrown`"
msgstr ""

#: src/features.md:96
msgid ""
"Adds a dependency on [hashbrown](https://docs.rs/hashbrown) and enables "
"conversions into its [`HashMap`](https://docs.rs/hashbrown/latest/hashbrown/"
"struct.HashMap.html) and [`HashSet`](https://docs.rs/hashbrown/latest/"
"hashbrown/struct.HashSet.html) types."
msgstr ""

#: src/features.md:98
msgid "`indexmap`"
msgstr ""

#: src/features.md:100
msgid ""
"Adds a dependency on [indexmap](https://docs.rs/indexmap) and enables "
"conversions into its [`IndexMap`](https://docs.rs/indexmap/latest/indexmap/"
"map/struct.IndexMap.html) type."
msgstr ""

#: src/features.md:102
msgid "`num-bigint`"
msgstr ""

#: src/features.md:104
msgid ""
"Adds a dependency on [num-bigint](https://docs.rs/num-bigint) and enables "
"conversions into its [`BigInt`](https://docs.rs/num-bigint/latest/num_bigint/"
"struct.BigInt.html) and [`BigUint`](https://docs.rs/num-bigint/latest/"
"num_bigint/struct.BigUInt.html) types."
msgstr ""

#: src/features.md:106
msgid "`num-complex`"
msgstr ""

#: src/features.md:108
msgid ""
"Adds a dependency on [num-complex](https://docs.rs/num-complex) and enables "
"conversions into its [`Complex`](https://docs.rs/num-complex/latest/"
"num_complex/struct.Complex.html) type."
msgstr ""

#: src/features.md:110
msgid "`serde`"
msgstr ""

#: src/features.md:112
msgid ""
"Enables (de)serialization of Py<T> objects via [serde](https://serde.rs/). "
"This allows to use [`#[derive(Serialize, Deserialize)`](https://serde.rs/"
"derive.html) on structs that hold references to `#[pyclass]` instances"
msgstr ""

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "Mutability and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`Py::clone_ref`](https://pyo3.rs/main/doc/pyo3/struct.Py.html#method."
"clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe acces to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:47
msgid "Object types"
msgstr ""

#: src/types.md:49
msgid "[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/types.md:51
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, `&PyAny`."
msgstr ""

#: src/types.md:54
msgid ""
"**Used:** Whenever you want to refer to some Python object and will have the "
"GIL for the whole duration you need to access that object. For example, "
"intermediate values and arguments to `pyfunction`s or `pymethod`s "
"implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:59
msgid ""
"Many general methods for interacting with Python objects are on the `PyAny` "
"struct, such as `getattr`, `setattr`, and `.call`."
msgstr ""

#: src/types.md:62 src/types.md:128 src/types.md:166 src/types.md:233
msgid "**Conversions:**"
msgstr ""

#: src/types.md:64
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"Python-native type such as a list:"
msgstr ""

#: src/types.md:72
msgid "// To &PyList with PyAny::downcast\n"
msgstr ""

#: src/types.md:75 src/types.md:96 src/types.md:183
msgid "// To Py<PyAny> (aka PyObject) with .into()\n"
msgstr ""

#: src/types.md:78
msgid "// To Py<PyList> with PyAny::extract\n"
msgstr ""

#: src/types.md:85
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"`#[pyclass]`:"
msgstr ""

#: src/types.md:93
msgid "// To &PyCell<MyClass> with PyAny::downcast\n"
msgstr ""

#: src/types.md:99
msgid "// To Py<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:102
msgid "// To MyClass with PyAny::extract, if MyClass: Clone\n"
msgstr ""

#: src/types.md:105
msgid "// To PyRef<MyClass> or PyRefMut<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:113
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:115
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:118
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:122
msgid ""
"These types all implement `Deref<Target = PyAny>`, so they all expose the "
"same methods which can be found on `PyAny`."
msgstr ""

#: src/types.md:125
msgid ""
"To see all Python types exposed by `PyO3` you should consult the [`pyo3::"
"types`](https://pyo3.rs/main/doc/pyo3/types/index.html) module."
msgstr ""

#: src/types.md:135
msgid ""
"// Use methods from PyAny on all Python types with Deref implementation\n"
msgstr ""

#: src/types.md:138 src/types.md:265
msgid "// To &PyAny automatically with Deref implementation\n"
msgstr ""

#: src/types.md:141 src/types.md:268
msgid "// To &PyAny explicitly with .as_ref()\n"
msgstr ""

#: src/types.md:144
msgid "// To Py<T> with .into() or Py::from()\n"
msgstr ""

#: src/types.md:147
msgid "// To PyObject with .into() or .to_object(py)\n"
msgstr ""

#: src/types.md:154
msgid "`Py<T>` and `PyObject`"
msgstr ""

#: src/types.md:156
msgid ""
"**Represents:** a GIL-independent reference to a Python object. This can be "
"a Python native type (like `PyTuple`), or a `pyclass` type implemented in "
"Rust. The most commonly-used variant, `Py<PyAny>`, is also known as "
"`PyObject`."
msgstr ""

#: src/types.md:160
msgid ""
"**Used:** Whenever you want to carry around references to a Python object "
"without caring about a GIL lifetime.  For example, storing Python object "
"references in a Rust struct that outlives the Python-Rust FFI boundary, or "
"returning objects from functions implemented in Rust back to Python."
msgstr ""

#: src/types.md:164
msgid "Can be cloned using Python reference counts with `.clone()`."
msgstr ""

#: src/types.md:168
msgid "For a `Py<PyList>`, the conversions are as below:"
msgstr ""

#: src/types.md:175
msgid "// To &PyList with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:179
msgid ""
"// Because `.into_ref()` will consume `list`.\n"
"// To &PyList with Py::into_ref() (moves the pointer into PyO3's object "
"storage)\n"
msgstr ""

#: src/types.md:189
msgid ""
"For a `#[pyclass] struct MyClass`, the conversions for `Py<MyClass>` are "
"below:"
msgstr ""

#: src/types.md:197
msgid "// To &PyCell<MyClass> with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:201
msgid ""
"// Because `.into_ref()` will consume `my_class`.\n"
"// To &PyCell<MyClass> with Py::into_ref() (moves the pointer into PyO3's "
"object storage)\n"
msgstr ""

#: src/types.md:205
msgid "// To Py<PyAny> (aka PyObject) with .into_py(py)\n"
msgstr ""

#: src/types.md:209
msgid "// To PyRef<MyClass> with Py::borrow or Py::try_borrow\n"
msgstr ""

#: src/types.md:212
msgid "// To PyRefMut<MyClass> with Py::borrow_mut or Py::try_borrow_mut\n"
msgstr ""

#: src/types.md:220
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:222
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:226
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:230
msgid ""
"Like pyo3's Python native types, `PyCell<T>` implements `Deref<Target = "
"PyAny>`, so it also exposes all of the methods on `PyAny`."
msgstr ""

#: src/types.md:235
msgid ""
"`PyCell<T>` can be used to access `&T` and `&mut T` via `PyRef<T>` and "
"`PyRefMut<T>` respectively."
msgstr ""

#: src/types.md:242
msgid "// To PyRef<T> with .borrow() or .try_borrow()\n"
msgstr ""

#: src/types.md:247
msgid "// To PyRefMut<T> with .borrow_mut() or .try_borrow_mut()\n"
msgstr ""

#: src/types.md:255
msgid "`PyCell<T>` can also be accessed like a Python-native type."
msgstr ""

#: src/types.md:262
msgid "// Use methods from PyAny on PyCell<T> with Deref implementation\n"
msgstr ""

#: src/types.md:275
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:277
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:280
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:284
msgid "Related traits and types"
msgstr ""

#: src/types.md:286
msgid "`PyClass`"
msgstr ""

#: src/types.md:288
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:291
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:293
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""

#: src/index.md:1
msgid "The PyO3 user guide"
msgstr ""

#: src/index.md:3
msgid ""
"Welcome to the PyO3 user guide! This book is a companion to [PyO3's API docs]"
"(https://docs.rs/pyo3). It contains examples and documentation to explain "
"all of PyO3's use cases in detail."
msgstr ""

#: src/index.md:5
msgid ""
"Please choose from the chapters on the left to jump to individual topics, or "
"continue below to start with PyO3's README."
msgstr ""

#: src/index.md:7
msgid "PyO3"
msgstr ""

#: src/index.md:9
msgid ""
"[![actions status](https://github.com/PyO3/pyo3/workflows/CI/badge.svg)]"
"(https://github.com/PyO3/pyo3/actions) [![benchmark](https://github.com/PyO3/"
"pyo3/actions/workflows/bench.yml/badge.svg)](https://pyo3.rs/dev/bench/) [!"
"[codecov](https://codecov.io/gh/PyO3/pyo3/branch/main/graph/badge.svg)]"
"(https://codecov.io/gh/PyO3/pyo3) [![crates.io](https://img.shields.io/"
"crates/v/pyo3)](https://crates.io/crates/pyo3) [![minimum rustc 1.41]"
"(https://img.shields.io/badge/rustc-1.41+-blue.svg)](https://rust-lang."
"github.io/rfcs/2495-min-rust-version.html) [![dev chat](https://img.shields."
"io/gitter/room/nwjs/nw.js.svg)](https://gitter.im/PyO3/Lobby) [!"
"[contributing notes](https://img.shields.io/badge/contribute-on%20github-"
"Green)](https://github.com/PyO3/pyo3/blob/main/Contributing.md)"
msgstr ""

#: src/index.md:17
msgid ""
"[Rust](https://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/), including tools for creating native Python extension modules. Running "
"and interacting with Python code from a Rust binary is also supported."
msgstr ""

#: src/index.md:19
msgid "User Guide: [stable](https://pyo3.rs) | [main](https://pyo3.rs/main)"
msgstr ""

#: src/index.md:21
msgid ""
"API Documentation: [stable](https://docs.rs/pyo3/) | [main](https://pyo3.rs/"
"main/doc)"
msgstr ""

#: src/index.md:23
msgid "Usage"
msgstr ""

#: src/index.md:25
msgid "PyO3 supports the following software versions:"
msgstr ""

#: src/index.md:26
msgid "Python 3.6 and up (CPython and PyPy)"
msgstr ""

#: src/index.md:27
msgid "Rust 1.41 and up"
msgstr ""

#: src/index.md:29
msgid ""
"You can use PyO3 to write a native Python module in Rust, or to embed Python "
"in a Rust binary. The following sections explain each of these in turn."
msgstr ""

#: src/index.md:31
msgid "Using Rust from Python"
msgstr ""

#: src/index.md:33
msgid ""
"PyO3 can be used to generate a native Python module. The easiest way to try "
"this out for the first time is to use [`maturin`](https://github.com/PyO3/"
"maturin). `maturin` is a tool for building and publishing Rust-based Python "
"packages with minimal configuration. The following steps set up some files "
"for an example Python module, install `maturin`, and then show how build and "
"import the Python module."
msgstr ""

#: src/index.md:35
msgid ""
"First, create a new folder (let's call it `string_sum`) containing the "
"following two files:"
msgstr ""

#: src/index.md:37
msgid "**`Cargo.toml`**"
msgstr ""

#: src/index.md:39
msgid ""
"```toml\n"
"[package]\n"
"name = \"string-sum\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"\n"
"[lib]\n"
"name = \"string_sum\"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"#\n"
"# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) "
"will not be able\n"
"# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also "
"included, e.g.:\n"
"# crate-type = [\"cdylib\", \"rlib\"]\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies.pyo3]\n"
"version = \"0.15.2\"\n"
"features = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/index.md:59
msgid "**`src/lib.rs`**"
msgstr ""

#: src/index.md:63
msgid "/// Formats the sum of two numbers as string.\n"
msgstr ""

#: src/index.md:69
msgid ""
"/// A Python module implemented in Rust. The name of this function must "
"match\n"
"/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able "
"to\n"
"/// import the module.\n"
msgstr ""

#: src/index.md:81
msgid ""
"With those two files in place, now `maturin` needs to be installed. This can "
"be done using Python's package manager `pip`. First, load up a new Python "
"`virtualenv`, and install `maturin` into it:"
msgstr ""

#: src/index.md:90
msgid "Now build and execute the module:"
msgstr ""

#: src/index.md:93
msgid "# lots of progress output as maturin runs the compilation...\n"
msgstr ""

#: src/index.md:97
msgid "'25'"
msgstr ""

#: src/index.md:101
msgid ""
"As well as with `maturin`, it is possible to build using [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) or [manually](https://pyo3.rs/"
"latest/building_and_distribution.html#manual-builds). Both offer more "
"flexibility than `maturin` but require further configuration."
msgstr ""

#: src/index.md:103
msgid "Using Python from Rust"
msgstr ""

#: src/index.md:105
msgid ""
"To embed Python into a Rust binary, you need to ensure that your Python "
"installation contains a shared library. The following steps demonstrate how "
"to ensure this (for Ubuntu), and then give some example code which runs an "
"embedded Python interpreter."
msgstr ""

#: src/index.md:107
msgid "To install the Python shared library on Ubuntu:"
msgstr ""

#: src/index.md:113
msgid ""
"Start a new project with `cargo new` and add  `pyo3` to the `Cargo.toml` "
"like this:"
msgstr ""

#: src/index.md:115
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.15.2\"\n"
"features = [\"auto-initialize\"]\n"
"```"
msgstr ""

#: src/index.md:121
msgid ""
"Example program displaying the value of `sys.version` and the current user "
"name:"
msgstr ""

#: src/index.md:129
msgid "\"sys\""
msgstr ""

#: src/index.md:130
msgid "\"version\""
msgstr ""

#: src/index.md:132
msgid "\"os\""
msgstr ""

#: src/index.md:133
msgid "\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\""
msgstr ""

#: src/index.md:136
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/index.md:142
msgid ""
"The guide has [a section](https://pyo3.rs/latest/python_from_rust.html) with "
"lots of examples about this topic."
msgstr ""

#: src/index.md:145
msgid "Tools and libraries"
msgstr ""

#: src/index.md:147
msgid ""
"[maturin](https://github.com/PyO3/maturin) _Zero configuration build tool "
"for Rust-made Python extensions_."
msgstr ""

#: src/index.md:148
msgid ""
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) _Setuptools "
"plugin for Rust support_."
msgstr ""

#: src/index.md:149
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html)_"
msgstr ""

#: src/index.md:150
msgid ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _Rust binding of NumPy C-"
"API_"
msgstr ""

#: src/index.md:151
msgid ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject to automatically transform Python dicts into Rust structs_"
msgstr ""

#: src/index.md:152
msgid ""
"[pyo3-log](https://github.com/vorner/pyo3-log) _Bridge from Rust to Python "
"logging_"
msgstr ""

#: src/index.md:153
msgid ""
"[pythonize](https://github.com/davidhewitt/pythonize) _Serde serializer for "
"converting Rust objects to JSON-compatible Python objects_"
msgstr ""

#: src/index.md:154
msgid ""
"[pyo3-asyncio](https://github.com/awestlake87/pyo3-asyncio) Utilities for "
"working with Python's Asyncio library and async functions"
msgstr ""

#: src/index.md:156
msgid "Examples"
msgstr ""

#: src/index.md:158
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json_"
msgstr ""

#: src/index.md:159
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/main/examples/"
"html-py-ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""

#: src/index.md:160
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library_"
msgstr ""

#: src/index.md:161
msgid ""
"[autopy](https://github.com/autopilot-rs/autopy) _A simple, cross-platform "
"GUI automation library for Python and Rust._"
msgstr ""

#: src/index.md:162
msgid ""
"Contains an example of building wheels on TravisCI and appveyor using "
"[cibuildwheel](https://github.com/pypa/cibuildwheel)"
msgstr ""

#: src/index.md:163
msgid "[orjson](https://github.com/ijl/orjson) _Fast Python JSON library_"
msgstr ""

#: src/index.md:164
msgid ""
"[inline-python](https://github.com/fusion-engineering/inline-python) _Inline "
"Python code directly in your Rust code_"
msgstr ""

#: src/index.md:165
msgid ""
"[Rogue-Gym](https://github.com/kngwyu/rogue-gym) _Customizable rogue-like "
"game for AI experiments_"
msgstr ""

#: src/index.md:166
msgid "Contains an example of building wheels on Azure Pipelines"
msgstr ""

#: src/index.md:167
msgid ""
"[fastuuid](https://github.com/thedrow/fastuuid/) _Python bindings to Rust's "
"UUID library_"
msgstr ""

#: src/index.md:168
msgid ""
"[wasmer-python](https://github.com/wasmerio/wasmer-python) _Python library "
"to run WebAssembly binaries_"
msgstr ""

#: src/index.md:169
msgid ""
"[mocpy](https://github.com/cds-astro/mocpy) _Astronomical Python library "
"offering data structures for describing any arbitrary coverage regions on "
"the unit sphere_"
msgstr ""

#: src/index.md:170
msgid ""
"[tokenizers](https://github.com/huggingface/tokenizers/tree/master/bindings/"
"python) _Python bindings to the Hugging Face tokenizers (NLP) written in "
"Rust_"
msgstr ""

#: src/index.md:171
msgid ""
"[pyre](https://github.com/Project-Dream-Weaver/pyre-http) _Fast Python HTTP "
"server written in Rust_"
msgstr ""

#: src/index.md:172
msgid ""
"[jsonschema-rs](https://github.com/Stranger6667/jsonschema-rs/tree/master/"
"bindings/python) _Fast JSON Schema validation library_"
msgstr ""

#: src/index.md:173
msgid ""
"[css-inline](https://github.com/Stranger6667/css-inline/tree/master/bindings/"
"python) _CSS inlining for Python implemented in Rust_"
msgstr ""

#: src/index.md:174
msgid ""
"[cryptography](https://github.com/pyca/cryptography/tree/main/src/rust) "
"_Python cryptography library with some functionality in Rust_"
msgstr ""

#: src/index.md:175
msgid ""
"[polaroid](https://github.com/daggy1234/polaroid) _Hyper Fast and safe image "
"manipulation library for Python written in Rust_"
msgstr ""

#: src/index.md:176
msgid ""
"[ormsgpack](https://github.com/aviramha/ormsgpack) _Fast Python msgpack "
"library_"
msgstr ""

#: src/index.md:178
msgid "Articles and other media"
msgstr ""

#: src/index.md:180
msgid ""
"[davidhewitt's 2021 talk at Rust Manchester meetup](https://www.youtube.com/"
"watch?v=-XyWG_klSAw&t=320s) - Aug 19, 2021"
msgstr ""

#: src/index.md:181
msgid ""
"[Incrementally porting a small Python project to Rust](https://blog."
"waleedkhan.name/port-python-to-rust/) - Apr 29, 2021"
msgstr ""

#: src/index.md:182
msgid ""
"[Vortexa - Integrating Rust into Python](https://www.vortexa.com/insight/"
"integrating-rust-into-python) - Apr 12, 2021"
msgstr ""

#: src/index.md:183
msgid ""
"[Writing and publishing a Python module in Rust](https://blog.yossarian."
"net/2020/08/02/Writing-and-publishing-a-python-module-in-rust) - Aug 2, 2020"
msgstr ""

#: src/index.md:185
msgid "Contributing"
msgstr ""

#: src/index.md:187
msgid ""
"Everyone is welcomed to contribute to PyO3! There are many ways to support "
"the project, such as:"
msgstr ""

#: src/index.md:189
msgid "help PyO3 users with issues on GitHub and Gitter"
msgstr ""

#: src/index.md:190
msgid "improve documentation"
msgstr ""

#: src/index.md:191
msgid "write features and bugfixes"
msgstr ""

#: src/index.md:192
msgid "publish blogs and examples of how to use PyO3"
msgstr ""

#: src/index.md:194
msgid ""
"Our [contributing notes](https://github.com/PyO3/pyo3/blob/main/Contributing."
"md) and [architecture guide](https://github.com/PyO3/pyo3/blob/main/"
"Architecture.md) have more resources if you wish to volunteer time for PyO3 "
"and are searching where to start."
msgstr ""

#: src/index.md:196
msgid ""
"If you don't have time to contribute yourself but still wish to support the "
"project's future success, some of our maintainers have GitHub sponsorship "
"pages:"
msgstr ""

#: src/index.md:198
msgid "[davidhewitt](https://github.com/sponsors/davidhewitt)"
msgstr ""

#: src/index.md:200
msgid "License"
msgstr ""

#: src/index.md:202
msgid ""
"PyO3 is licensed under the [Apache-2.0 license](https://opensource.org/"
"licenses/APACHE-2.0). Python is licensed under the [Python License](https://"
"docs.python.org/3/license.html)."
msgstr ""

#: src/memory.md:3
msgid ""
"Rust and Python have very different notions of memory management.  Rust has "
"a strict memory model with concepts of ownership, borrowing, and lifetimes, "
"where memory is freed at predictable points in program execution.  Python "
"has a looser memory model in which variables are reference-counted with "
"shared, mutable state by default. A global interpreter lock (GIL) is needed "
"to prevent race conditions, and a garbage collector is needed to break "
"reference cycles. Memory in Python is freed eventually by the garbage "
"collector, but not usually in a predictable way."
msgstr ""

#: src/memory.md:12
msgid ""
"PyO3 bridges the Rust and Python memory models with two different strategies "
"for accessing memory allocated on Python's heap from inside Rust.  These are "
"GIL-bound, or \"owned\" references, and GIL-independent `Py<Any>` smart "
"pointers."
msgstr ""

#: src/memory.md:16
msgid "GIL-bound Memory"
msgstr ""

#: src/memory.md:18
msgid ""
"PyO3's GIL-bound, \"owned references\" (`&PyAny` etc.) make PyO3 more "
"ergonomic to use by ensuring that their lifetime can never be longer than "
"the duration the Python GIL is held.  This means that most of PyO3's API can "
"assume the GIL is held. (If PyO3 could not assume this, every PyO3 API would "
"need to take a `Python` GIL token to prove that the GIL is held.)  This "
"allows us to write very simple and easy-to-understand programs like this:"
msgstr ""

#: src/memory.md:27 src/memory.md:44 src/memory.md:67 src/memory.md:83
#: src/memory.md:116 src/memory.md:133 src/memory.md:158 src/memory.md:176
msgid "\"\\\"Hello World!\\\"\""
msgstr ""

#: src/memory.md:28 src/memory.md:45 src/memory.md:68 src/memory.md:84
#: src/memory.md:117 src/memory.md:138 src/memory.md:163 src/memory.md:181
msgid "\"Python says: {}\""
msgstr ""

#: src/memory.md:33
msgid ""
"Internally, calling `Python::with_gil()` or `Python::acquire_gil()` creates "
"a `GILPool` which owns the memory pointed to by the reference.  In the "
"example above, the lifetime of the reference `hello` is bound to the "
"`GILPool`.  When the `with_gil()` closure ends or the `GILGuard` from "
"`acquire_gil()` is dropped, the `GILPool` is also dropped and the Python "
"reference counts of the variables it owns are decreased, releasing them to "
"the Python garbage collector.  Most of the time we don't have to think about "
"this, but consider the following:"
msgstr ""

#: src/memory.md:47
msgid "// There are 10 copies of `hello` on Python's heap here.\n"
msgstr ""

#: src/memory.md:52
msgid ""
"We might assume that the `hello` variable's memory is freed at the end of "
"each loop iteration, but in fact we create 10 copies of `hello` on Python's "
"heap. This may seem surprising at first, but it is completely consistent "
"with Rust's memory model.  The `hello` variable is dropped at the end of "
"each loop, but it is only a reference to the memory owned by the `GILPool`, "
"and its lifetime is bound to the `GILPool`, not the for loop.  The `GILPool` "
"isn't dropped until the end of the `with_gil()` closure, at which point the "
"10 copies of `hello` are finally released to the Python garbage collector."
msgstr ""

#: src/memory.md:61
msgid ""
"In general we don't want unbounded memory growth during loops!  One "
"workaround is to acquire and release the GIL with each iteration of the loop."
msgstr ""

#: src/memory.md:70
msgid "// only one copy of `hello` at a time\n"
msgstr ""

#: src/memory.md:74
msgid ""
"It might not be practical or performant to acquire and release the GIL so "
"many times.  Another workaround is to work with the `GILPool` object "
"directly, but this is unsafe."
msgstr ""

#: src/memory.md:90
msgid ""
"The unsafe method `Python::new_pool` allows you to create a nested `GILPool` "
"from which you can retrieve a new `py: Python` GIL token.  Variables created "
"with this new GIL token are bound to the nested `GILPool` and will be "
"released when the nested `GILPool` is dropped.  Here, the nested `GILPool` "
"is dropped at the end of each loop iteration, before the `with_gil()` "
"closure ends."
msgstr ""

#: src/memory.md:96
msgid ""
"When doing this, you must be very careful to ensure that once the `GILPool` "
"is dropped you do not retain access to any owned references created after "
"the `GILPool` was created.  Read the [documentation for `Python::new_pool()`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/struct.Python.html#method.new_pool) "
"for more information on safety."
msgstr ""

#: src/memory.md:102
msgid "GIL-independent Memory"
msgstr ""

#: src/memory.md:104
msgid ""
"Sometimes we need a reference to memory on Python's heap that can outlive "
"the GIL.  Python's `Py<PyAny>` is analogous to `Rc<T>`, but for variables "
"whose memory is allocated on Python's heap.  Cloning a `Py<PyAny>` increases "
"its internal reference count just like cloning `Rc<T>`.  The smart pointer "
"can outlive the GIL from which it was created.  It isn't magic, though.  We "
"need to reacquire the GIL to access the memory pointed to by the `Py<PyAny>`."
msgstr ""

#: src/memory.md:111
msgid ""
"What happens to the memory when the last `Py<PyAny>` is dropped and its "
"reference count reaches zero?  It depends whether or not we are holding the "
"GIL."
msgstr ""

#: src/memory.md:122
msgid ""
"At the end of the `Python::with_gil()` closure `hello` is dropped, and then "
"the GIL is dropped.  Since `hello` is dropped while the GIL is still held by "
"the current thread, its memory is released to the Python garbage collector "
"immediately."
msgstr ""

#: src/memory.md:127
msgid ""
"This example wasn't very interesting.  We could have just used a GIL-bound "
"`&PyString` reference.  What happens when the last `Py<Any>` is dropped "
"while we are _not_ holding the GIL?"
msgstr ""

#: src/memory.md:134
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program we want to access `hello`.\n"
msgstr ""

#: src/memory.md:139
msgid "// Now we're done with `hello`.\n"
msgstr ""

#: src/memory.md:141
msgid ""
"// Memory *not* released here.\n"
"// Sometime later we need the GIL again for something...\n"
msgstr ""

#: src/memory.md:144
msgid "// Memory for `hello` is released here.\n"
msgstr ""

#: src/memory.md:148
msgid ""
"When `hello` is dropped _nothing_ happens to the pointed-to memory on "
"Python's heap because nothing _can_ happen if we're not holding the GIL.  "
"Fortunately, the memory isn't leaked.  PyO3 keeps track of the memory "
"internally and will release it the next time we acquire the GIL."
msgstr ""

#: src/memory.md:153
msgid ""
"We can avoid the delay in releasing memory if we are careful to drop the "
"`Py<Any>` while the GIL is held."
msgstr ""

#: src/memory.md:159 src/memory.md:177
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program:\n"
msgstr ""

#: src/memory.md:164
msgid "// Memory released here.\n"
msgstr ""

#: src/memory.md:168
msgid ""
"We could also have used `Py::into_ref()`, which consumes `self`, instead of "
"`Py::as_ref()`.  But note that in addition to being slower than `as_ref()`, "
"`into_ref()` binds the memory to the lifetime of the `GILPool`, which means "
"that rather than being released immediately, the memory will not be released "
"until the GIL is dropped."
msgstr ""

#: src/memory.md:182
msgid ""
"// Memory not released yet.\n"
"    // Do more stuff...\n"
"    // Memory released here at end of `with_gil()` closure.\n"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"CPython has the infamous [Global Interpreter Lock](https://docs.python.org/3/"
"glossary.html#term-global-interpreter-lock), which prevents several threads "
"from executing Python bytecode in parallel. This makes threading in Python a "
"bad fit for [CPU-bound](https://stackoverflow.com/questions/868568/) tasks "
"and often forces developers to accept the overhead of multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a "
"look at our [word-count](https://github.com/PyO3/pyo3/blob/main/examples/"
"word-count/src/lib.rs) example, where we have a `search` function that "
"utilizes the [rayon](https://github.com/rayon-rs/rayon) crate to count words "
"in parallel."
msgstr ""

#: src/parallelism.md:16
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""

#: src/parallelism.md:23
msgid ""
"To enable parallel execution of this function, the [`Python::allow_threads`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.allow_threads) "
"method can be used to temporarily release the GIL, thus allowing other "
"Python threads to run. We then have a function exposed to the Python runtime "
"which calls `search_sequential` inside a closure passed to [`Python::"
"allow_threads`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method."
"allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:31
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""

#: src/parallelism.md:48
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:50
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr ""

#: src/parallelism.md:52
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr ""

#: src/parallelism.md:54
msgid "Pure Python version"
msgstr ""

#: src/parallelism.md:55
msgid "Rust parallel version"
msgstr ""

#: src/parallelism.md:56
msgid "Rust sequential version"
msgstr ""

#: src/parallelism.md:57
msgid "Rust sequential version executed twice with two Python threads"
msgstr ""

#: src/parallelism.md:59
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `tox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""

#: src/parallelism.md:61
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr ""

#: src/parallelism.md:73
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""

#: src/class.md:1
msgid "Python Classes"
msgstr ""

#: src/class.md:3
msgid ""
"PyO3 exposes a group of attributes powered by Rust's proc macro system for "
"defining Python classes as Rust structs."
msgstr ""

#: src/class.md:5
msgid ""
"The main attribute is `#[pyclass]`, which is placed upon a Rust `struct` to "
"generate a Python type for it. A struct will usually also have _one_ "
"`#[pymethods]`\\-annotated `impl` block for the struct, which is used to "
"define Python methods and constants for the generated Python type. (If the "
"[`multiple-pymethods`](features.md#multiple-pymethods) feature is enabled "
"each `#[pyclass]` is allowed to have multiple `#[pymethods]` blocks.) "
"Finally, there may be multiple `#[pyproto]` trait implementations for the "
"struct, which are used to define certain python magic methods such as "
"`__str__`."
msgstr ""

#: src/class.md:7
msgid ""
"This chapter will discuss the functionality and configuration these "
"attributes offer. Below is a list of links to the relevant section of this "
"chapter for each:"
msgstr ""

#: src/class.md:9
msgid "[`#[pyclass]`](#defining-a-new-class)"
msgstr ""

#: src/class.md:10
msgid "[`#[pyo3(get, set)]`](#object-properties-using-pyo3get-set)"
msgstr ""

#: src/class.md:11
msgid "[`#[pymethods]`](#instance-methods)"
msgstr ""

#: src/class.md:12
msgid "[`#[new]`](#constructor)"
msgstr ""

#: src/class.md:13
msgid "[`#[getter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:14
msgid "[`#[setter]`](#object-properties-using-getter-and-setter)"
msgstr ""

#: src/class.md:15
msgid "[`#[staticmethod]`](#static-methods)"
msgstr ""

#: src/class.md:16
msgid "[`#[classmethod]`](#class-methods)"
msgstr ""

#: src/class.md:17
msgid "[`#[classattr]`](#class-attributes)"
msgstr ""

#: src/class.md:18
msgid "[`#[args]`](#method-arguments)"
msgstr ""

#: src/class.md:19
msgid "[`#[pyproto]`](class/protocols.html)"
msgstr ""

#: src/class.md:21
msgid "Defining a new class"
msgstr ""

#: src/class.md:23
msgid ""
"To define a custom Python class, a Rust struct needs to be annotated with "
"the `#[pyclass]` attribute."
msgstr ""

#: src/class.md:36
msgid ""
"Because Python objects are freely shared between threads by the Python "
"interpreter, all structs annotated with `#[pyclass]` must implement `Send` "
"(unless annotated with [`#[pyclass(unsendable)]`](#customizing-the-class))."
msgstr ""

#: src/class.md:38
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html), [`PyTypeObject`]"
"(https://pyo3.rs/main/doc/pyo3/type_object/trait.PyTypeObject.html), and "
"[`PyClass`](https://pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html) for "
"`MyClass`. To see these generated implementations, refer to the "
"[implementation details](#implementation-details) at the end of this chapter."
msgstr ""

#: src/class.md:40
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:42
msgid ""
"Custom Python classes can then be added to a module using `add_class()`."
msgstr ""

#: src/class.md:58
msgid "PyCell and interior mutability"
msgstr ""

#: src/class.md:60
msgid ""
"You sometimes need to convert your `pyclass` into a Python object and access "
"it from Rust code (e.g., for testing it). [`PyCell`](https://pyo3.rs/main/"
"doc/pyo3/pycell/struct.PyCell.html) is the primary interface for that."
msgstr ""

#: src/class.md:64
msgid ""
"`PyCell<T: PyClass>` is always allocated in the Python heap, so Rust doesn't "
"have ownership of it. In other words, Rust code can only extract a "
"`&PyCell<T>`, not a `PyCell<T>`."
msgstr ""

#: src/class.md:67
msgid ""
"Thus, to mutate data behind `&PyCell` safely, PyO3 employs the [Interior "
"Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-"
"mutability.html) like [`RefCell`](https://doc.rust-lang.org/std/cell/struct."
"RefCell.html)."
msgstr ""

#: src/class.md:71
msgid ""
"Users who are familiar with `RefCell` can use `PyCell` just like `RefCell`."
msgstr ""

#: src/class.md:73
msgid ""
"For users who are not very familiar with `RefCell`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:74
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:75
msgid "References must always be valid."
msgstr ""

#: src/class.md:77
msgid ""
"`PyCell`, like `RefCell`, ensures these borrowing rules by tracking "
"references at runtime."
msgstr ""

#: src/class.md:89
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:91
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:95
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:97
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:102
msgid "// You can convert `&PyCell` to a Python object\n"
msgstr ""

#: src/class.md:103
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:107
msgid ""
"`&PyCell<T>` is bounded by the same lifetime as a [`GILGuard`](https://pyo3."
"rs/main/doc/pyo3/struct.GILGuard.html). To make the object longer lived (for "
"example, to store it in a struct on the Rust side), you can use `Py<T>`, "
"which stores an object longer than the GIL lifetime, and therefore needs a "
"`Python<'_>` token to access."
msgstr ""

#: src/class.md:126
msgid "// Py<MyClass>::as_ref returns &PyCell<MyClass>\n"
msgstr ""

#: src/class.md:127
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:132
msgid "Customizing the class"
msgstr ""

#: src/class.md:134
msgid "The `#[pyclass]` macro accepts the following parameters:"
msgstr ""

#: src/class.md:136
msgid ""
"`name=\"XXX\"` - Set the class name shown in Python code. By default, the "
"struct name is used as the class name."
msgstr ""

#: src/class.md:137
msgid ""
"`freelist=XXX` - The `freelist` parameter adds support of free allocation "
"list to custom class. The performance improvement applies to types that are "
"often created and deleted in a row, so that they can benefit from a "
"freelist. `XXX` is a number of items for the free list."
msgstr ""

#: src/class.md:140
msgid ""
"`gc` - Classes with the `gc` parameter participate in Python garbage "
"collection. If a custom class contains references to other Python objects "
"that can be collected, the [`PyGCProtocol`](https://pyo3.rs/main/doc/pyo3/"
"class/gc/trait.PyGCProtocol.html) trait has to be implemented."
msgstr ""

#: src/class.md:142
msgid "`weakref` - Adds support for Python weak references."
msgstr ""

#: src/class.md:143
msgid ""
"`extends=BaseType` - Use a custom base class. The base `BaseType` must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:144
msgid "`subclass` - Allows Python classes to inherit from this class."
msgstr ""

#: src/class.md:145
msgid ""
"`dict` - Adds `__dict__` support, so that the instances of this type have a "
"dictionary containing arbitrary instance variables."
msgstr ""

#: src/class.md:146
msgid ""
"`unsendable` - Making it safe to expose `!Send` structs to Python, where all "
"object can be accessed by multiple threads. A class marked with `unsendable` "
"panics when accessed by another thread."
msgstr ""

#: src/class.md:148
msgid ""
"`module=\"XXX\"` - Set the name of the module the class will be shown as "
"defined in. If not given, the class will be a virtual member of the "
"`builtins` module."
msgstr ""

#: src/class.md:151
msgid "Constructor"
msgstr ""

#: src/class.md:153
msgid ""
"By default it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:174
msgid ""
"Alternatively, if your `new` method may fail you can return `PyResult<Self>`."
msgstr ""

#: src/class.md:192
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:195
msgid "For arguments, see the `Method arguments` section below."
msgstr ""

#: src/class.md:197
msgid "Return type"
msgstr ""

#: src/class.md:199
msgid ""
"Generally, `#[new]` method have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:202
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:205
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:205
msgid "**May fail**"
msgstr ""

#: src/class.md:207
msgid "**No inheritance**"
msgstr ""

#: src/class.md:207
msgid "`T`"
msgstr ""

#: src/class.md:207
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:208
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:208
msgid "`(T, U)`"
msgstr ""

#: src/class.md:208
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:209
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:209
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/main/doc/pyo3/pyclass_init/struct."
"PyClassInitializer.html)"
msgstr ""

#: src/class.md:209
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:211
msgid "Inheritance"
msgstr ""

#: src/class.md:213
msgid ""
"By default, `PyAny` is used as the base class. To override this default, use "
"the `extends` parameter for `pyclass` with the full path to the base class."
msgstr ""

#: src/class.md:216
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the baseclass of `T`. But for more deeply nested inheritance, you have to "
"return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:221
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/main/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_ref()` as `&Self::BaseClass`, or by `self_.into_super()` as `PyRef<Self::"
"BaseClass>`."
msgstr ""

#: src/class.md:259
msgid "// Get &BaseClass\n"
msgstr ""

#: src/class.md:279
msgid "// Get PyRef<SubClass>\n"
msgstr ""

#: src/class.md:285
msgid "\"assert subsub.method3() == 3000\""
msgstr ""

#: src/class.md:289
msgid ""
"You can also inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/main/doc/pyo3/type_object/trait."
"PySizedLayout.html). However, this is not supported when building for the "
"Python limited API (aka the `abi3` feature of PyO3)."
msgstr ""

#: src/class.md:292
msgid ""
"However, because of some technical problems, we don't currently provide safe "
"upcasting methods for types that inherit native types. Even in such cases, "
"you can unsafely get a base class by raw pointer conversion."
msgstr ""

#: src/class.md:323
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:328
msgid ""
"If `SubClass` does not provide a baseclass initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:351
msgid "Object properties"
msgstr ""

#: src/class.md:353
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:354
msgid ""
"For simple fields with no side effects, a `#[pyo3(get, set)]` attribute can "
"be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:355
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the [`#[pymethods]`](#instance-methods) block."
msgstr ""

#: src/class.md:357
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:359
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:361
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:372
msgid ""
"The above would make the `num` field available for reading and writing as a "
"`self.num` Python property. To expose the property with a different name to "
"the field, specify this alongside the rest of the options, e.g. `#[pyo3(get, "
"set, name = \"custom_name\")]`."
msgstr ""

#: src/class.md:374
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:376
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:377
msgid ""
"For `get` the field type must implement both `IntoPy<PyObject>` and `Clone`."
msgstr ""

#: src/class.md:378
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:380
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:382
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:384
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:402
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:405
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:432
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:434
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:458
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:460
msgid ""
"Attributes defined by `#[setter]` or `#[pyo3(set)]` will always raise "
"`AttributeError` on `del` operations. Support for defining custom `del` "
"behavior is tracked in [\\#1778](https://github.com/PyO3/pyo3/issues/1778)."
msgstr ""

#: src/class.md:464
msgid "Instance methods"
msgstr ""

#: src/class.md:466
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:470
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust. However to have multiple `#[pymethods]`\\-annotated `impl` blocks for "
"the same struct you must enable the [`multiple-pymethods`](features."
"md#multiple-pymethods) feature of PyO3."
msgstr ""

#: src/class.md:493
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:497
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:515
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:517
msgid "Class methods"
msgstr ""

#: src/class.md:519
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:540
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:542
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:544
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:545
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:546
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:548
msgid "Static methods"
msgstr ""

#: src/class.md:550
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:570
msgid "Class attributes"
msgstr ""

#: src/class.md:572
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute. "
"The return type must be `T` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:584
msgid "\"hello\""
msgstr ""

#: src/class.md:590
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:594
msgid ""
"Note that unlike class variables defined in Python code, class attributes "
"defined in Rust cannot be mutated at all:"
msgstr ""

#: src/class.md:597
msgid ""
"// Would raise a `TypeError: can't set attributes of built-in/extension type "
"'MyClass'`\n"
msgstr ""

#: src/class.md:598
msgid "\"my_class.my_attribute = 'foo'\""
msgstr ""

#: src/class.md:601
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:611
msgid "\"foobar\""
msgstr ""

#: src/class.md:615
msgid "Method arguments"
msgstr ""

#: src/class.md:617
msgid ""
"By default, PyO3 uses function signatures to determine which arguments are "
"required. Then it scans the incoming `args` and `kwargs` parameters. If it "
"can not find all required parameters, it raises a `TypeError` exception. It "
"is possible to override the default behavior with the `#[args(...)]` "
"attribute. This attribute accepts a comma separated list of parameters in "
"the form of `attr_name=\"default value\"`. Each parameter has to match the "
"method parameter by name."
msgstr ""

#: src/class.md:623
msgid "Each parameter can be one of the following types:"
msgstr ""

#: src/class.md:625
msgid ""
"`\"/\"`: positional-only arguments separator, each parameter defined before "
"`\"/\"` is a positional-only parameter. Corresponds to python's `def "
"meth(arg1, arg2, ..., /, argN..)`."
msgstr ""

#: src/class.md:628
msgid ""
"`\"*\"`: var arguments separator, each parameter defined after `\"*\"` is a "
"keyword-only parameter. Corresponds to python's `def meth(*, arg1.., "
"arg2=..)`."
msgstr ""

#: src/class.md:630
msgid ""
"`args=\"*\"`: \"args\" is var args, corresponds to Python's `def "
"meth(*args)`. Type of the `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:632
msgid ""
"`kwargs=\"**\"`: \"kwargs\" receives keyword arguments, corresponds to "
"Python's `def meth(**kwargs)`. The type of the `kwargs` parameter has to be "
"`Option<&PyDict>`."
msgstr ""

#: src/class.md:634
msgid ""
"`arg=\"Value\"`: arguments with default value. Corresponds to Python's `def "
"meth(arg=Value)`. If the `arg` argument is defined after var arguments, it "
"is treated as a keyword-only argument. Note that `Value` has to be valid "
"rust code, PyO3 just inserts it into the generated code unmodified."
msgstr ""

#: src/class.md:639
msgid "Example:"
msgstr ""

#: src/class.md:651
msgid "\"-1\""
msgstr ""

#: src/class.md:657
msgid "\"10\""
msgstr ""

#: src/class.md:658
msgid "\"*\""
msgstr ""

#: src/class.md:659
msgid "\"\\\"Hello\\\"\""
msgstr ""

#: src/class.md:660
msgid "\"**\""
msgstr ""

#: src/class.md:671
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={}\""
msgstr ""

#: src/class.md:678
msgid "\"num={}\""
msgstr ""

#: src/class.md:682
msgid ""
"N.B. the position of the `\"/\"` and `\"*\"` arguments (if included) control "
"the system of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/class.md:687 src/class.md:688
msgid "\"World\""
msgstr ""

#: src/class.md:691
msgid "Produces output:"
msgstr ""

#: src/class.md:699
msgid "Making class method signatures available to Python"
msgstr ""

#: src/class.md:701
msgid ""
"The [`#[pyo3(text_signature = \"...\")]`](./function.md#text_signature) "
"option for `#[pyfunction]` also works for classes and methods:"
msgstr ""

#: src/class.md:707
msgid "// it works even if the item is not documented:\n"
msgstr ""

#: src/class.md:710 src/class.md:753
msgid "\"(c, d, /)\""
msgstr ""

#: src/class.md:715
msgid ""
"// the signature for the constructor is attached\n"
"    // to the struct definition instead.\n"
msgstr ""

#: src/class.md:721
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/class.md:722
msgid "\"($self, e, f)\""
msgstr ""

#: src/class.md:727 src/class.md:782
msgid "\"(cls, e, f)\""
msgstr ""

#: src/class.md:732 src/class.md:794
msgid "\"(e, f)\""
msgstr ""

#: src/class.md:740
msgid "\"inspect\""
msgstr ""

#: src/class.md:740
msgid "\"signature\""
msgstr ""

#: src/class.md:741
msgid "\"my_module\""
msgstr ""

#: src/class.md:743 src/class.md:829
msgid "\"MyClass\""
msgstr ""

#: src/class.md:746 src/class.md:755 src/class.md:764 src/class.md:776
#: src/class.md:788
msgid "\"__doc__\""
msgstr ""

#: src/class.md:751 src/class.md:768 src/class.md:780 src/class.md:792
msgid "\"__str__\""
msgstr ""

#: src/class.md:758
msgid ""
"\"`text_signature` on classes is not compatible with compilation in `abi3` "
"mode until Python 3.10 or greater\""
msgstr ""

#: src/class.md:762
msgid "\"my_method\""
msgstr ""

#: src/class.md:770
msgid "\"(self, /, e, f)\""
msgstr ""

#: src/class.md:774
msgid "\"my_class_method\""
msgstr ""

#: src/class.md:786
msgid "\"my_static_method\""
msgstr ""

#: src/class.md:802
msgid ""
"Note that `text_signature` on classes is not compatible with compilation in "
"`abi3` mode until Python 3.10 or greater."
msgstr ""

#: src/class.md:805
msgid "Implementation details"
msgstr ""

#: src/class.md:807
msgid ""
"The `#[pyclass]` macros rely on a lot of conditional code generation: each "
"`#[pyclass]` can optionally have a `#[pymethods]` block as well as several "
"different possible `#[pyproto]` trait implementations."
msgstr ""

#: src/class.md:809
msgid ""
"To support this flexibility the `#[pyclass]` macro expands to a blob of "
"boilerplate code which sets up the structure for [\"dtolnay specialization\"]"
"(https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/"
"README.md). This implementation pattern enables the Rust compiler to use "
"`#[pymethods]` and `#[pyproto]` implementations when they are present, and "
"fall back to default (empty) definitions when they are not."
msgstr ""

#: src/class.md:811
msgid ""
"This simple technique works for the case when there is zero or one "
"implementations. To support multiple `#[pymethods]` for a `#[pyclass]` (in "
"the [`multiple-pymethods`](features.md#multiple-pymethods) feature), a "
"registry mechanism provided by the [`inventory`](https://github.com/dtolnay/"
"inventory) crate is used instead. This collects `impl`s at library load "
"time, but isn't supported on all platforms. See [inventory: how it works]"
"(https://github.com/dtolnay/inventory#how-it-works) for more details."
msgstr ""

#: src/class.md:813
msgid ""
"The `#[pyclass]` macro expands to roughly the code seen below. The "
"`PyClassImplCollector` is the type used internally by PyO3 for dtolnay "
"specialization:"
msgstr ""

#: src/class.md:816
msgid "\"multiple-pymethods\""
msgstr ""

#: src/class.md:817
msgid ""
"// Note: the implementation differs slightly with the `multiple-pymethods` "
"feature enabled.\n"
msgstr ""

#: src/class.md:819
msgid "/// Class for demonstration\n"
msgstr ""

#: src/class.md:853
msgid "\"Class for demonstration\\u{0}\""
msgstr ""

#: src/class.md:889
msgid ""
"// Implementation which uses dtolnay specialization to load all slots.\n"
msgstr ""

#: src/class.md:912
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""

#: src/class/protocols.md:1
msgid "Class customizations"
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. You may be "
"familiar with implementing these protocols in Python classes by \"magic\" "
"methods, such as `__str__` or `__repr__`. Because of the double-underscores "
"surrounding their name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"In the Python C-API which PyO3 is implemented upon, many of these magic "
"methods have to be placed into special \"slots\" on the class type object. "
"as already covered in the previous section. There are two ways in which this "
"can be done:"
msgstr ""

#: src/class/protocols.md:7
msgid ""
"\\[Experimental for PyO3 0.15, may change slightly in PyO3 0.16\\] In "
"`#[pymethods]`, if the name of the method is a recognised magic method, PyO3 "
"will place it in the type object automatically."
msgstr ""

#: src/class/protocols.md:8
msgid ""
"\\[Stable, but expected to be deprecated in PyO3 0.16\\] In special traits "
"combined with the `#[pyproto]` attribute."
msgstr ""

#: src/class/protocols.md:10
msgid ""
"(There are also many magic methods which don't have a special slot, such as "
"`__dir__`. These methods can be implemented as normal in `#[pymethods]`.)"
msgstr ""

#: src/class/protocols.md:12
msgid ""
"This chapter of the guide has a section on each of these solutions in turn:"
msgstr ""

#: src/class/protocols.md:14
msgid "Magic methods in `#[pymethods]`"
msgstr ""

#: src/class/protocols.md:16
msgid ""
"In PyO3 0.15, if a function name in `#[pymethods]` is a recognised magic "
"method, it will be automatically placed into the correct slot in the Python "
"type object. The function name is taken from the usual rules for naming "
"`#[pymethods]`: the `#[pyo3(name = \"...\")]` attribute is used if present, "
"otherwise the Rust function name is used."
msgstr ""

#: src/class/protocols.md:18
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the the subset which "
"have slots as [defined here](https://docs.python.org/3/c-api/typeobj.html). "
"Some of the slots do not have a magic method in Python, which leads to a few "
"additional magic methods defined only in PyO3:"
msgstr ""

#: src/class/protocols.md:19
msgid "Magic methods for garbage collection"
msgstr ""

#: src/class/protocols.md:20
msgid "Magic methods for the buffer protocol"
msgstr ""

#: src/class/protocols.md:21
msgid "Magic methods for the sequence protocol"
msgstr ""

#: src/class/protocols.md:23
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:24
msgid "The `#[pyo3(text_signature = \"...\")]` attribute is not allowed"
msgstr ""

#: src/class/protocols.md:25
msgid "The signature is restricted to match the magic method"
msgstr ""

#: src/class/protocols.md:27
msgid ""
"The following sections list of all magic methods PyO3 currently handles.  "
"The given signatures should be interpreted as follows:"
msgstr ""

#: src/class/protocols.md:29
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `PyCell` reference like `self_: PyRef<Self>` and "
"`self_: PyRefMut<Self>`, as described [here](../class.md#inheritance)."
msgstr ""

#: src/class/protocols.md:32
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:33
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:34
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:36
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:38
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:40
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:45 src/class/protocols.md:257
msgid "Basic object customization"
msgstr ""

#: src/class/protocols.md:47
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:48
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:49
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:53
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to `None`. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/protocols.md:69
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:70
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:71
msgid "`__setattr__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:72
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:73
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:75
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:78
msgid "Example: Callable objects"
msgstr ""

#: src/class/protocols.md:80
msgid ""
"Custom classes can be callable if they have a `#[pymethod]` named `__call__`."
msgstr ""

#: src/class/protocols.md:82
msgid ""
"The following pyclass is a basic decorator - its constructor takes a Python "
"object as argument and calls that object when called."
msgstr ""

#: src/class/protocols.md:89
msgid "\"counter\""
msgstr ""

#: src/class/protocols.md:109
msgid "\"__name__\""
msgstr ""

#: src/class/protocols.md:111
msgid "\"{} has been called {} time(s).\""
msgstr ""

#: src/class/protocols.md:117
msgid "Python code:"
msgstr ""

#: src/class/protocols.md:130
msgid "Output:"
msgstr ""

#: src/class/protocols.md:143
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:145
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:146
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:148
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:150
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:151
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:152
msgid "`__anext__(<self>) -> Option<object> or IterANextOutput`"
msgstr ""

#: src/class/protocols.md:154
msgid "Sequence types"
msgstr ""

#: src/class/protocols.md:156 src/class/protocols.md:243
#: src/class/protocols.md:247
msgid "TODO; see [\\#1884](https://github.com/PyO3/pyo3/issues/1884)"
msgstr ""

#: src/class/protocols.md:158
msgid "Mapping types"
msgstr ""

#: src/class/protocols.md:160
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:161
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:165
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:180
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:181
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:182
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:184
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:186
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:187
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:188
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:190
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:192
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:193
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:194
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:195
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:196
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:197
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:198
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:199
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:200
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:201
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:202
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:203
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:204
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:205
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:206
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:207
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:208
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:209
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:210
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:211
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:212
msgid "`__add__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:213
msgid "`__radd__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:214
msgid "`__sub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:215
msgid "`__rsub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:216
msgid "`__mul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:217
msgid "`__rmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:218
msgid "`__matmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:219
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:220
msgid "`__floordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:221
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:222
msgid "`__truediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:223
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:224
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:225
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:226
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:227
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:228
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:229
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:230
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:231
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:232
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:233
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:234
msgid "`__xor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:235
msgid "`__rxor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:236
msgid "`__or__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:237
msgid "`__ror__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:238
msgid "`__pow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:239
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:241
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:245 src/class/protocols.md:475
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:249
msgid "`#[pyproto]` traits"
msgstr ""

#: src/class/protocols.md:251
msgid ""
"PyO3 can use the `#[pyproto]` attribute in combination with special traits "
"to implement the magic methods which need slots. The special traits are "
"listed below. See also the [documentation for the `pyo3::class` module]"
"(https://pyo3.rs/main/doc/pyo3/class/index.html)."
msgstr ""

#: src/class/protocols.md:253
msgid ""
"Before PyO3 0.15 this was the only supported solution for implementing magic "
"methods. Due to complexity in the implementation and usage, these traits are "
"expected to be deprecated in PyO3 0.16 in favour of the `#[pymethods]` "
"solution."
msgstr ""

#: src/class/protocols.md:255
msgid ""
"All `#[pyproto]` methods can return `T` instead of `PyResult<T>` if the "
"method implementation is infallible. In addition, if the return type is "
"`()`, it can be omitted altogether."
msgstr ""

#: src/class/protocols.md:259
msgid ""
"The [`PyObjectProtocol`](https://pyo3.rs/main/doc/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provides several basic customizations."
msgstr ""

#: src/class/protocols.md:261
msgid "Attribute access"
msgstr ""

#: src/class/protocols.md:263
msgid "To customize object attribute access, define the following methods:"
msgstr ""

#: src/class/protocols.md:265
msgid ""
"`fn __getattr__(&self, name: impl FromPyObject) -> PyResult<impl "
"IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:266
msgid ""
"`fn __setattr__(&mut self, name: impl FromPyObject, value: impl "
"FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:267
msgid "`fn __delattr__(&mut self, name: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:269
msgid ""
"Each method corresponds to Python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class/protocols.md:271
msgid "String Conversions"
msgstr ""

#: src/class/protocols.md:273
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:274
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:276
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`."
msgstr ""

#: src/class/protocols.md:278
msgid "Comparison operators"
msgstr ""

#: src/class/protocols.md:280
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:282
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class/protocols.md:288
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class/protocols.md:290
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class/protocols.md:293
msgid "Other methods"
msgstr ""

#: src/class/protocols.md:295
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:297
msgid "Determines the \"truthyness\" of the object."
msgstr ""

#: src/class/protocols.md:299
msgid "Emulating numeric types"
msgstr ""

#: src/class/protocols.md:301
msgid ""
"The [`PyNumberProtocol`](https://pyo3.rs/main/doc/pyo3/class/number/trait."
"PyNumberProtocol.html) trait can be implemented to emulate [numeric types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types)."
msgstr ""

#: src/class/protocols.md:303
msgid ""
"`fn __add__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:304
msgid ""
"`fn __sub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:305
msgid ""
"`fn __mul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:306
msgid ""
"`fn __matmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:307
msgid ""
"`fn __truediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:308
msgid ""
"`fn __floordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:309
msgid ""
"`fn __mod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:310
msgid ""
"`fn __divmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:311
msgid ""
"`fn __pow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:312
msgid ""
"`fn __lshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:313
msgid ""
"`fn __rshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:314
msgid ""
"`fn __and__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:315
msgid ""
"`fn __or__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:316
msgid ""
"`fn __xor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:318
msgid ""
"These methods are called to implement the binary arithmetic operations (`+`, "
"`-`, `*`, `@`, `/`, `//`, `%`, `divmod()`, `pow()` and `**`, `<<`, `>>`, "
"`&`, `^`, and `|`)."
msgstr ""

#: src/class/protocols.md:321
msgid ""
"If `rhs` is not of the type specified in the signature, the generated code "
"will automatically `return NotImplemented`.  This is not the case for `lhs` "
"which must match signature or else raise a TypeError."
msgstr ""

#: src/class/protocols.md:326
msgid "The reflected operations are also available:"
msgstr ""

#: src/class/protocols.md:328
msgid ""
"`fn __radd__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:329
msgid ""
"`fn __rsub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:330
msgid ""
"`fn __rmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:331
msgid ""
"`fn __rmatmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:332
msgid ""
"`fn __rtruediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:333
msgid ""
"`fn __rfloordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:334
msgid ""
"`fn __rmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:335
msgid ""
"`fn __rdivmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:336
msgid ""
"`fn __rpow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:337
msgid ""
"`fn __rlshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:338
msgid ""
"`fn __rrshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:339
msgid ""
"`fn __rand__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:340
msgid ""
"`fn __ror__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:341
msgid ""
"`fn __rxor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:343
msgid ""
"The code generated for these methods expect that all arguments match the "
"signature, or raise a TypeError."
msgstr ""

#: src/class/protocols.md:346
msgid ""
"This trait also has support the augmented arithmetic assignments (`+=`, `-"
"=`, `*=`, `@=`, `/=`, `//=`, `%=`, `**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:349
msgid "`fn __iadd__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:350
msgid "`fn __isub__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:351
msgid "`fn __imul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:352
msgid ""
"`fn __imatmul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:353
msgid ""
"`fn __itruediv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:354
msgid ""
"`fn __ifloordiv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:355
msgid "`fn __imod__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:356
msgid "`fn __ipow__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:357
msgid ""
"`fn __ilshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:358
msgid ""
"`fn __irshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:359
msgid "`fn __iand__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:360
msgid "`fn __ior__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:361
msgid "`fn __ixor__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:363
msgid ""
"The following methods implement the unary arithmetic operations (`-`, `+`, "
"`abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:365
msgid "`fn __neg__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:366
msgid "`fn __pos__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:367
msgid "`fn __abs__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:368
msgid "`fn __invert__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:370
msgid "Support for coercions:"
msgstr ""

#: src/class/protocols.md:372
msgid "`fn __int__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:373
msgid "`fn __float__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:375
msgid "Other:"
msgstr ""

#: src/class/protocols.md:377
msgid "`fn __index__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:379
msgid "Emulating sequential containers (such as lists or tuples)"
msgstr ""

#: src/class/protocols.md:381
msgid ""
"The [`PySequenceProtocol`](https://pyo3.rs/main/doc/pyo3/class/sequence/"
"trait.PySequenceProtocol.html) trait can be implemented to emulate "
"[sequential container types](https://docs.python.org/3/reference/datamodel."
"html#emulating-container-types)."
msgstr ""

#: src/class/protocols.md:384
msgid ""
"For a sequence, the keys are the integers _k_ for which _0 \\<= k \\< N_, "
"where _N_ is the length of the sequence."
msgstr ""

#: src/class/protocols.md:387 src/class/protocols.md:449
msgid "`fn __len__(&self) -> PyResult<usize>`"
msgstr ""

#: src/class/protocols.md:389
msgid "Implements the built-in function `len()` for the sequence."
msgstr ""

#: src/class/protocols.md:391
msgid "`fn __getitem__(&self, idx: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:393
msgid ""
"Implements evaluation of the `self[idx]` element. If the `idx` value is "
"outside the set of indexes for the sequence, `IndexError` should be raised."
msgstr ""

#: src/class/protocols.md:396
msgid ""
"_Note:_ Negative integer indexes are handled as follows: if `__len__()` is "
"defined, it is called and the sequence length is used to compute a positive "
"index, which is passed to `__getitem__()`. If `__len__()` is not defined, "
"the index is passed as is to the function."
msgstr ""

#: src/class/protocols.md:401
msgid ""
"`fn __setitem__(&mut self, idx: isize, value: impl FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class/protocols.md:403
msgid ""
"Implements assignment to the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"replaced."
msgstr ""

#: src/class/protocols.md:406
msgid "`fn __delitem__(&mut self, idx: isize) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:408
msgid ""
"Implements deletion of the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"deleted."
msgstr ""

#: src/class/protocols.md:411
msgid "`fn __contains__(&self, item: impl FromPyObject) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:413
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that dont define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:418
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:420
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:424
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:426
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:430
msgid ""
"`fn __inplace_concat__(&mut self, other: impl FromPyObject) -> "
"PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:432
msgid ""
"Concatenates two sequences in place. Returns the modified first operand. "
"Used by the `+=` operator, after trying the numeric in place addition via "
"the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:436
msgid "`fn __inplace_repeat__(&mut self, count: isize) -> PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:438
msgid ""
"Repeats the sequence `count` times in place. Returns the modified first "
"operand. Used by the `*=` operator, after trying the numeric in place "
"multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:442
msgid "Emulating mapping containers (such as dictionaries)"
msgstr ""

#: src/class/protocols.md:444
msgid ""
"The [`PyMappingProtocol`](https://pyo3.rs/main/doc/pyo3/class/mapping/trait."
"PyMappingProtocol.html) trait allows to emulate [mapping container types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-container-"
"types)."
msgstr ""

#: src/class/protocols.md:447
msgid "For a mapping, the keys may be Python objects of arbitrary type."
msgstr ""

#: src/class/protocols.md:451
msgid "Implements the built-in function `len()` for the mapping."
msgstr ""

#: src/class/protocols.md:453
msgid ""
"`fn __getitem__(&self, key: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:455
msgid ""
"Implements evaluation of the `self[key]` element. If `key` is of an "
"inappropriate type, `TypeError` may be raised; if `key` is missing (not in "
"the container), `KeyError` should be raised."
msgstr ""

#: src/class/protocols.md:459
msgid ""
"`fn __setitem__(&mut self, key: impl FromPyObject, value: impl FromPyObject) "
"-> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:461
msgid ""
"Implements assignment to the `self[key]` element or insertion of a new `key` "
"mapping to `value`. Should only be implemented if the mapping support "
"changes to the values for keys, or if new keys can be added. The same "
"exceptions should be raised for improper key values as for the "
"`__getitem__()` method."
msgstr ""

#: src/class/protocols.md:468
msgid "`fn __delitem__(&mut self, key: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:470
msgid ""
"Implements deletion of the `self[key]` element. Should only be implemented "
"if the mapping supports removal of keys. The same exceptions should be "
"raised for improper key values as for the `__getitem__()` method."
msgstr ""

#: src/class/protocols.md:477
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement the [`PyGCProtocol`](https://pyo3.rs/main/"
"doc/pyo3/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another Python object. `__clear__` "
"must clear out any mutable references to other Python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class/protocols.md:508
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:514
msgid ""
"Special protocol trait implementations have to be annotated with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class/protocols.md:516
msgid ""
"It is also possible to enable GC for custom classes using the `gc` parameter "
"of the `pyclass` attribute. i.e. `#[pyclass(gc)]`. In that case instances of "
"custom class participate in Python garbage collection, and it is possible to "
"track them with `gc` module methods. When using the `gc` parameter, it is "
"_required_ to implement the `PyGCProtocol` trait, failure to do so will "
"result in an error at compile time:"
msgstr ""

#: src/class/protocols.md:522
msgid ""
"```compile_fail\n"
"#[pyclass(gc)]\n"
"struct GCTracked {} // Fails because it does not implement PyGCProtocol\n"
"```"
msgstr ""

#: src/class/protocols.md:527
msgid "Iterator Types"
msgstr ""

#: src/class/protocols.md:529
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://pyo3.rs/main/"
"doc/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class/protocols.md:532
msgid "`fn __iter__(slf: PyRefMut<Self>) -> PyResult<impl IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:533
msgid ""
"`fn __next__(slf: PyRefMut<Self>) -> PyResult<Option<impl IntoPy<PyObject>>>`"
msgstr ""

#: src/class/protocols.md:535
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items. These two methods can be take either `PyRef<Self>` or "
"`PyRefMut<Self>` as their first argument, so that mutable borrow can be "
"avoided if needed."
msgstr ""

#: src/class/protocols.md:561
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, you should "
"implement `PyIterProtocol` for both the iterable and the iterator, but the "
"iterable only needs to support `__iter__()` while the iterator must support "
"both `__iter__()` and `__next__()`. The default implementations in "
"`PyIterProtocol` will ensure that the objects behave correctly in Python. "
"For example:"
msgstr ""

#: src/class/protocols.md:604
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:605
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:609
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/3/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:612
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:614
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration. In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://pyo3.rs/"
"main/doc/pyo3/class/iter/enum.IterNextOutput.html) enum to both `Yield` "
"values and `Return` a final value - see its docs for further details and an "
"example."
msgstr ""

#: src/exception.md:1
msgid "Python Exceptions"
msgstr ""

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"You can use the [`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"create_exception.html) macro to define a new exception type:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr ""

#: src/exception.md:27 src/exception.md:43
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:28
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:29
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:33
msgid ""
"When using PyO3 to create an extension module, you can add the new exception "
"to the module like this, so that it is importable from Python:"
msgstr ""

#: src/exception.md:42
msgid "// ... other elements added to module ...\n"
msgstr ""

#: src/exception.md:50
msgid "Raising an exception"
msgstr ""

#: src/exception.md:52
msgid ""
"To raise an exception from `pyfunction`s and `pymethods`, you should return "
"an `Err(PyErr)`. If returned to Python code, this [`PyErr`](https://pyo3.rs/"
"main/doc/pyo3/struct.PyErr.html) will then be raised as a Python exception. "
"Many PyO3 APIs also return [`PyResult`](https://pyo3.rs/main/doc/pyo3/type."
"PyResult.html)."
msgstr ""

#: src/exception.md:55
msgid ""
"If a Rust type exists for the exception, then it is possible to use the "
"`new_err` method. For example, each standard exception defined in the `pyo3::"
"exceptions` module has a corresponding Rust type and exceptions defined by "
"[`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro.create_exception."
"html) and [`import_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"import_exception.html) macro have Rust types as well."
msgstr ""

#: src/exception.md:67
msgid "\"division by zero\""
msgstr ""

#: src/exception.md:80
msgid ""
"You can also manually write and fetch errors in the Python interpreter's "
"global state:"
msgstr ""

#: src/exception.md:87
msgid "\"Error\""
msgstr ""

#: src/exception.md:93
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance`](https://pyo3.rs/main/doc/pyo3/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:100
msgid "Checking exception types"
msgstr ""

#: src/exception.md:102
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type. In PyO3 every native type "
"has access to the [`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/"
"struct.PyAny.html#method.is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:116
msgid ""
"[`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyType.html#method.is_instance) "
"method to do the actual work."
msgstr ""

#: src/exception.md:119
msgid "To check the type of an exception, you can similarly do:"
msgstr ""

#: src/exception.md:130
msgid "Handling Rust errors"
msgstr ""

#: src/exception.md:132
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:136
msgid ""
"A [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct.PyErr.html) represents a "
"Python exception. Errors within the PyO3 library are also exposed as Python "
"exceptions."
msgstr ""

#: src/exception.md:139
msgid ""
"If your code has a custom error type, adding an implementation of `std::"
"convert::From<MyError> for PyErr` is usually enough. PyO3 will then "
"automatically convert your error to a Python exception when needed."
msgstr ""

#: src/exception.md:142
msgid ""
"The following code snippet defines a Rust error named `CustomIOError`. In "
"its `From<CustomIOError> for PyErr` implementation it returns a `PyErr` "
"representing Python's `OSError`."
msgstr ""

#: src/exception.md:157
msgid "\"Oh no!\""
msgstr ""

#: src/exception.md:167 src/exception.md:173
msgid "/* ... */"
msgstr ""

#: src/exception.md:170 src/exception.md:186
msgid "\"0.0.0.0\""
msgstr ""

#: src/exception.md:192
msgid ""
"This has been implemented for most of Rust's standard library errors, so "
"that you can use the `?` (\"try\") operator with them. The following code "
"snippet will raise a `ValueError` in Python if `String::parse()` returns an "
"error."
msgstr ""

#: src/exception.md:207
msgid "\"1\""
msgstr ""

#: src/exception.md:208
msgid "\"1337\""
msgstr ""

#: src/exception.md:213
msgid "\"foo\""
msgstr ""

#: src/exception.md:216
msgid "\"13.37\""
msgstr ""

#: src/exception.md:223
msgid ""
"If lazy construction of the Python exception instance is desired, the "
"[`PyErrArguments`](https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html) "
"trait can be implemented. In that case, actual exception argument creation "
"is delayed until the `PyErr` is needed."
msgstr ""

#: src/exception.md:228
msgid "Using exceptions defined in Python code"
msgstr ""

#: src/exception.md:230
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The `import_exception!` macro allows importing a specific exception "
"class and defines a Rust type for that exception."
msgstr ""

#: src/exception.md:243
msgid "\"tell\""
msgstr ""

#: src/exception.md:244
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:251
msgid ""
"[`pyo3::exceptions`](https://pyo3.rs/main/doc/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""

#: src/function.md:1
msgid "Python Functions"
msgstr ""

#: src/function.md:3
msgid ""
"The `#[pyfunction]` attribute is used to define a Python function from a "
"Rust function. Once defined, the function needs to be added to a [module](./"
"module.md) using the `wrap_pyfunction!` macro."
msgstr ""

#: src/function.md:5
msgid ""
"The following example defines a function called `double` in a Python module "
"called `my_extension`:"
msgstr ""

#: src/function.md:22
msgid ""
"This chapter of the guide explains full usage of the `#[pyfunction]` "
"attribute. The following topics are covered:"
msgstr ""

#: src/function.md:24
msgid "[Function options](#function-options)"
msgstr ""

#: src/function.md:25
msgid "[`#[pyo3(name = \"...\")]`](#name)"
msgstr ""

#: src/function.md:26
msgid "[`#[pyo3(text_signature = \"...\")]`](#text_signature)"
msgstr ""

#: src/function.md:27
msgid "[`#[pyo3(pass_module)]`](#pass_module)"
msgstr ""

#: src/function.md:28
msgid "[Argument parsing](#argument-parsing)"
msgstr ""

#: src/function.md:29
msgid "[`#[pyo3(from_py_with = \"...\")]`](#from_py_with)"
msgstr ""

#: src/function.md:30
msgid "[Advanced function patterns](#advanced-function-patterns)"
msgstr ""

#: src/function.md:31
msgid "[`#[pyfn]` shorthand](#pyfn-shorthand)"
msgstr ""

#: src/function.md:33
msgid "Function options"
msgstr ""

#: src/function.md:35
msgid ""
"The `#[pyo3]` attribute can be used to modify properties of the generated "
"Python function. It can take any combination of the following options:"
msgstr ""

#: src/function.md:37
msgid "<a name=\"name\"></a> `#[pyo3(name = \"...\")]`"
msgstr ""

#: src/function.md:39
msgid "Overrides the name exposed to Python."
msgstr ""

#: src/function.md:41
msgid ""
"In the following example, the Rust function `no_args_py` will be added to "
"the Python module `module_with_functions` as the Python function `no_args`:"
msgstr ""

#: src/function.md:48 src/function.md:59
msgid "\"no_args\""
msgstr ""

#: src/function.md:60
msgid "\"no_args_py\""
msgstr ""

#: src/function.md:64
msgid "<a name=\"text_signature\"></a> `#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function.md:66
msgid ""
"Sets the function signature visible in Python tooling (such as via [`inspect."
"signature`](https://docs.python.org/3/library/inspect.html#inspect."
"signature))."
msgstr ""

#: src/function.md:68
msgid ""
"The example below creates a function `add` which has a signature describing "
"two positional-only arguments `a` and `b`."
msgstr ""

#: src/function.md:74
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:76 src/function.md:93
msgid "\"(a, b, /)\""
msgstr ""

#: src/function.md:86
msgid "\"This function adds two unsigned 64-bit integers.\""
msgstr ""

#: src/function.md:100
msgid "<a name=\"pass_module\" ></a> `#[pyo3(pass_module)]`"
msgstr ""

#: src/function.md:102
msgid ""
"Set this option to make PyO3 pass the containing module as the first "
"argument to the function. It is then possible to use the module in the "
"function body. The first argument **must** be of type `&PyModule`."
msgstr ""

#: src/function.md:104
msgid ""
"The following example creates a function `pyfunction_with_module` which "
"returns the containing module's name (i.e. `module_with_fn`):"
msgstr ""

#: src/function.md:121
msgid "Argument parsing"
msgstr ""

#: src/function.md:123
msgid ""
"The `#[pyfunction]` attribute supports specifying details of argument "
"parsing. The details are given in the section [\"Method arguments\" of the "
"Classes chapter](class.md#method-arguments).  Here is an example for a "
"function that accepts arbitrary keyword arguments (`**kwargs` in Python "
"syntax) and returns the number that was passed:"
msgstr ""

#: src/function.md:141
msgid "Per-argument options"
msgstr ""

#: src/function.md:143
msgid ""
"The `#[pyo3]` attribute can be used on individual arguments to modify "
"properties of them in the generated function. It can take any combination of "
"the following options:"
msgstr ""

#: src/function.md:145
msgid "<a name=\"from_py_with\"></a> `#[pyo3(from_py_with = \"...\")]`"
msgstr ""

#: src/function.md:147
msgid ""
"Set this on an option to specify a custom function to convert the function "
"argument from Python to the desired Rust type, instead of using the default "
"`FromPyObject` extraction. The function signature must be `fn(&PyAny) -> "
"PyResult<T>` where `T` is the Rust type of the argument."
msgstr ""

#: src/function.md:149
msgid ""
"The following example uses `from_py_with` to convert the input Python object "
"to its length:"
msgstr ""

#: src/function.md:172
msgid "Advanced function patterns"
msgstr ""

#: src/function.md:174
msgid "Making the function signature available to Python (old method)"
msgstr ""

#: src/function.md:176
msgid ""
"Alternatively, simply make sure the first line of your docstring is "
"formatted like in the following example. Please note that the newline after "
"the `--` is mandatory. The `/` signifies the end of positional-only "
"arguments."
msgstr ""

#: src/function.md:180
msgid ""
"`#[pyo3(text_signature)]` should be preferred, since it will override "
"automatically generated signatures when those are added in a future version "
"of PyO3."
msgstr ""

#: src/function.md:186
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:195
msgid ""
"// a function with a signature but without docs. Both blank lines after the "
"`--` are mandatory.\n"
msgstr ""

#: src/function.md:197
msgid ""
"/// sub(a, b, /)\n"
"/// --\n"
"///\n"
"///\n"
msgstr ""

#: src/function.md:208
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:217
msgid "Closures"
msgstr ""

#: src/function.md:219
msgid ""
"Currently, there are no conversions between `Fn`s in Rust and callables in "
"Python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:223
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:225
msgid ""
"You can pass Python `def`'d functions and built-in functions to Rust "
"functions [`PyFunction`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFunction.html) corresponds to regular Python functions while "
"[`PyCFunction`](https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html) "
"describes built-ins such as `repr()`."
msgstr ""

#: src/function.md:229
msgid ""
"You can also use [`PyAny::is_callable`](https://pyo3.rs/main/doc/pyo3/struct."
"PyAny.html#tymethod.is_callable) to check if you have a callable object. "
"`is_callable` will return `true` for functions (including lambdas), methods "
"and objects with a `__call__` method. You can call the object with [`PyAny::"
"call`](https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call) with "
"the args as first parameter and the kwargs (or `None`) as second parameter. "
"There are also [`PyAny::call0`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#tymethod.call0) with no args and [`PyAny::call1`](https://pyo3.rs/main/"
"doc/pyo3/struct.PyAny.html#tymethod.call1) with only positional args."
msgstr ""

#: src/function.md:235
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:237
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use [`wrap_pyfunction!`](https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction."
"html) to get the corresponding [`PyCFunction`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyCFunction.html). For dynamic functions, e.g. lambdas and "
"functions that were passed as arguments, you must put them in some kind of "
"owned container, e.g. a `Box`. (A long-term solution will be a special "
"container similar to wasm-bindgen's `Closure`). You can then use a "
"`#[pyclass]` struct with that container as a field as a way to pass the "
"function over the FFI barrier. You can even make that class callable with "
"`__call__` so it looks like a function in Python code."
msgstr ""

#: src/function.md:254
msgid "Accessing the FFI functions"
msgstr ""

#: src/function.md:256
msgid ""
"In order to make Rust functions callable from Python, PyO3 generates an "
"`extern \"C\"` function whose exact signature depends on the Rust "
"signature.  (PyO3 chooses the optimal Python argument passing convention.) "
"It then embeds the call to the Rust function inside this FFI-wrapper "
"function. This wrapper handles extraction of the regular arguments and the "
"keyword arguments from the input `PyObject`s."
msgstr ""

#: src/function.md:262
msgid ""
"The `wrap_pyfunction` macro can be used to directly get a `PyCFunction` "
"given a `#[pyfunction]` and a `PyModule`: `wrap_pyfunction!(rust_fun, "
"module)`."
msgstr ""

#: src/function.md:265
msgid "`#[pyfn]` shorthand"
msgstr ""

#: src/function.md:267
msgid ""
"There is a shorthand to `#[pyfunction]` and `wrap_pymodule!`: the function "
"can be placed inside the module definition and annotated with `#[pyfn]`. To "
"simplify PyO3, it is expected that `#[pyfn]` may be removed in a future "
"release (See [\\#694](https://github.com/PyO3/pyo3/issues/694))."
msgstr ""

#: src/function.md:270
msgid "An example of `#[pyfn]` is below:"
msgstr ""

#: src/function.md:287
msgid ""
"`#[pyfn(m)]` is just syntactic sugar for `#[pyfunction]`, and takes all the "
"same options documented in the rest of this chapter. The code above is "
"expanded to the following:"
msgstr ""

#: src/module.md:1
msgid "Python Modules"
msgstr ""

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr ""

#: src/module.md:12
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:21
msgid ""
"The `#[pymodule]` procedural macro takes care of exporting the "
"initialization function of your module to Python."
msgstr ""

#: src/module.md:24
msgid ""
"The module's name defaults to the name of the Rust function. You can "
"override the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:36
msgid "\"custom_name\""
msgstr ""

#: src/module.md:43
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:47
msgid "To import the module, either:"
msgstr ""

#: src/module.md:48
msgid ""
"copy the shared library as described in [Manual builds]"
"(building_and_distribution.html#manual-builds), or"
msgstr ""

#: src/module.md:49
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:52
msgid "Documentation"
msgstr ""

#: src/module.md:54
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the module initialization function will be applied "
"automatically as the Python docstring of your module."
msgstr ""

#: src/module.md:57
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:65
msgid "Organizing your module registration code"
msgstr ""

#: src/module.md:67
msgid ""
"For most projects, it's adequate to centralize all your FFI code into a "
"single Rust module."
msgstr ""

#: src/module.md:69
msgid ""
"However, for larger projects, it can be helpful to split your Rust code into "
"several Rust modules to keep your code readable. Unfortunately, though, some "
"of the macros like `wrap_pyfunction!` do not yet work when used on code "
"defined in other modules ([\\#1709](https://github.com/PyO3/pyo3/"
"issues/1709)). One way to work around this is to pass references to the "
"`PyModule` so that each module registers its own FFI code. For example:"
msgstr ""

#: src/module.md:75 src/module.md:118
msgid "// src/lib.rs\n"
msgstr ""

#: src/module.md:84
msgid "// src/dirutil.rs\n"
msgstr ""

#: src/module.md:97 src/module.md:127
msgid "// src/osutil.rs\n"
msgstr ""

#: src/module.md:109 src/module.md:134
msgid "\"linux\""
msgstr ""

#: src/module.md:114
msgid ""
"Another workaround for splitting FFI code across multiple modules ([\\#1709]"
"(https://github.com/PyO3/pyo3/issues/1709)) is to add `use module::*`, like "
"this:"
msgstr ""

#: src/module.md:139
msgid "Python submodules"
msgstr ""

#: src/module.md:141
msgid ""
"You can create a module hierarchy within a single extension module by using "
"[`PyModule.add_submodule()`](https://pyo3.rs/main/doc/pyo3/prelude/struct."
"PyModule.html#method.add_submodule). For example, you could define the "
"modules `parent_module` and `parent_module.child_module`."
msgstr ""

#: src/module.md:155
msgid "\"child_module\""
msgstr ""

#: src/module.md:163
msgid "\"func\""
msgstr ""

#: src/module.md:170
msgid "\"parent_module\""
msgstr ""

#: src/module.md:172
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:176
msgid ""
"Note that this does not define a package, so this wont allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:181
msgid ""
"It is not necessary to add `#[pymodule]` on nested modules, which is only "
"required on the top-level module."
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:11
msgid "Type Conversions"
msgstr ""

#: src/SUMMARY.md:12
msgid "Mapping of Rust types to Python types\\]"
msgstr ""

#: src/SUMMARY.md:13
msgid "Conversion traits\\]"
msgstr ""

#: src/SUMMARY.md:15
msgid "Calling Python from Rust"
msgstr ""

#: src/SUMMARY.md:16
msgid "GIL, mutability and object types"
msgstr ""

#: src/SUMMARY.md:21
msgid "Advanced Topics"
msgstr ""

#: src/SUMMARY.md:24
msgid "Useful Crates"
msgstr ""

#: src/SUMMARY.md:25
msgid "Logging"
msgstr ""

#: src/SUMMARY.md:26
msgid "Async / Await"
msgstr ""

#: src/SUMMARY.md:27
msgid "FAQ & Troubleshooting"
msgstr ""

#: src/SUMMARY.md:31
msgid ""
"Appendix A: Migration Guide Appendix B: PyO3 and rust-cpython Appendix C: "
"Trait bounds Appendix D: Python typing hints CHANGELOG"
msgstr ""

#: src/conversions.md:3
msgid ""
"In this portion of the guide we'll talk about the mapping of Python types to "
"Rust types offered by PyO3, as well as the traits available to perform "
"conversions between them."
msgstr ""

#: src/conversions/traits.md:1
msgid "Conversion traits"
msgstr ""

#: src/conversions/traits.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions/traits.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr ""

#: src/conversions/traits.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions/traits.md:15
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)."
msgstr ""

#: src/conversions/traits.md:19
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](../class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions/traits.md:26
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"
msgstr ""

#: src/conversions/traits.md:28
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) can be automatically derived for many kinds of structs and enums if "
"the member types themselves implement `FromPyObject`. This even includes "
"members with a generic type `T: FromPyObject`. Derivation for empty enums, "
"enum variants and structs is not supported."
msgstr ""

#: src/conversions/traits.md:33
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for structs"
msgstr ""

#: src/conversions/traits.md:35
msgid ""
"The derivation generates code that will attempt to access the attribute  "
"`my_string` on the Python object, i.e. `obj.getattr(\"my_string\")`, and "
"call `extract()` on the attribute."
msgstr ""

#: src/conversions/traits.md:38
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    my_string: String,\n"
"}\n"
"#\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let module = PyModule::from_code(\n"
"#             py,\n"
"#             \"class Foo:\n"
"#             def __init__(self):\n"
"#                 self.my_string = 'test'\",\n"
"#             \"\",\n"
"#             \"\",\n"
"#         )?;\n"
"# \n"
"#         let class = module.getattr(\"Foo\")?;\n"
"#         let instance = class.call0()?;\n"
"#         let rustystruct: RustyStruct = instance.extract()?;\n"
"#         assert_eq!(rustystruct.my_string, \"test\");\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:66
msgid ""
"By setting the `#[pyo3(item)]` attribute on the field, PyO3 will attempt to "
"extract the value by calling the `get_item` method on the Python object."
msgstr ""

#: src/conversions/traits.md:68
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    #[pyo3(item)]\n"
"    my_string: String,\n"
"}\n"
"#\n"
"# use pyo3::types::PyDict;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let dict = PyDict::new(py);\n"
"#         dict.set_item(\"my_string\", \"test\")?;\n"
"# \n"
"#         let rustystruct: RustyStruct = dict.extract()?;\n"
"#         assert_eq!(rustystruct.my_string, \"test\");\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:91
msgid "The argument passed to `getattr` and `get_item` can also be configured:"
msgstr ""

#: src/conversions/traits.md:93
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    #[pyo3(item(\"key\"))]\n"
"    string_in_mapping: String,\n"
"    #[pyo3(attribute(\"name\"))]\n"
"    string_attr: String,\n"
"}\n"
"# \n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let module = PyModule::from_code(\n"
"#             py,\n"
"#             \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.name = 'test'\n"
"#                 self['key'] = 'test2'\",\n"
"#             \"\",\n"
"#             \"\",\n"
"#         )?;\n"
"# \n"
"#         let class = module.getattr(\"Foo\")?;\n"
"#         let instance = class.call0()?;\n"
"#         let rustystruct: RustyStruct = instance.extract()?;\n"
"# \t\tassert_eq!(rustystruct.string_attr, \"test\");\n"
"#         assert_eq!(rustystruct.string_in_mapping, \"test2\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:127
msgid ""
"This tries to extract `string_attr` from the attribute `name` and "
"`string_in_mapping` from a mapping with the key `\"key\"`. The arguments for "
"`attribute` are restricted to non-empty string literals while `item` can "
"take any valid literal that implements `ToBorrowedObject`."
msgstr ""

#: src/conversions/traits.md:132
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for tuple structs"
msgstr ""

#: src/conversions/traits.md:134
msgid ""
"Tuple structs are also supported but do not allow customizing the "
"extraction. The input is always assumed to be a Python tuple with the same "
"length as the Rust type, the `n`th field is extracted from the `n`th item in "
"the Python tuple."
msgstr ""

#: src/conversions/traits.md:138
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTuple(String, String);\n"
"\n"
"# use pyo3::types::PyTuple;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let tuple = PyTuple::new(py, vec![\"test\", \"test2\"]);\n"
"# \n"
"#         let rustytuple: RustyTuple = tuple.extract()?;\n"
"#         assert_eq!(rustytuple.0, \"test\");\n"
"#         assert_eq!(rustytuple.1, \"test2\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:158
msgid ""
"Tuple structs with a single field are treated as wrapper types which are "
"described in the following section. To override this behaviour and ensure "
"that the input is in fact a tuple, specify the struct as"
msgstr ""

#: src/conversions/traits.md:161
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTuple((String,));\n"
"\n"
"# use pyo3::types::PyTuple;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let tuple = PyTuple::new(py, vec![\"test\"]);\n"
"# \n"
"#         let rustytuple: RustyTuple = tuple.extract()?;\n"
"#         assert_eq!((rustytuple.0).0, \"test\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:180
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for wrapper types"
msgstr ""

#: src/conversions/traits.md:182
msgid ""
"The `pyo3(transparent)` attribute can be used on structs with exactly one "
"field. This results in extracting directly from the input object, i.e. `obj."
"extract()`, rather than trying to access an item or attribute. This "
"behaviour is enabled per default for newtype structs and tuple-variants with "
"a single field."
msgstr ""

#: src/conversions/traits.md:187
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTransparentTupleStruct(String);\n"
"\n"
"#[derive(FromPyObject)]\n"
"#[pyo3(transparent)]\n"
"struct RustyTransparentStruct {\n"
"    inner: String,\n"
"}\n"
"\n"
"# use pyo3::types::PyString;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let s = PyString::new(py, \"test\");\n"
"# \n"
"#         let tup: RustyTransparentTupleStruct = s.extract()?;\n"
"#         assert_eq!(tup.0, \"test\");\n"
"# \n"
"#         let stru: RustyTransparentStruct = s.extract()?;\n"
"#         assert_eq!(stru.inner, \"test\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:215
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for enums"
msgstr ""

#: src/conversions/traits.md:217
msgid ""
"The `FromPyObject` derivation for enums generates code that tries to extract "
"the variants in the order of the fields. As soon as a variant can be "
"extracted succesfully, that variant is returned. This makes it possible to "
"extract Python union types like `str | int`."
msgstr ""

#: src/conversions/traits.md:221
msgid ""
"The same customizations and restrictions described for struct derivations "
"apply to enum variants, i.e. a tuple variant assumes that the input is a "
"Python tuple, and a struct variant defaults to extracting fields as "
"attributes but can be configured in the same manner. The `transparent` "
"attribute can be applied to single-field-variants."
msgstr ""

#: src/conversions/traits.md:226
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"# #[derive(Debug)]\n"
"enum RustyEnum<'a> {\n"
"    Int(usize), // input is a positive int\n"
"    String(String), // input is a string\n"
"    IntTuple(usize, usize), // input is a 2-tuple with positive ints\n"
"    StringIntTuple(String, usize), // input is a 2-tuple with String and "
"int\n"
"    Coordinates3d { // needs to be in front of 2d\n"
"        x: usize,\n"
"        y: usize,\n"
"        z: usize,\n"
"    },\n"
"    Coordinates2d { // only gets checked if the input did not have `z`\n"
"        #[pyo3(attribute(\"x\"))]\n"
"        a: usize,\n"
"        #[pyo3(attribute(\"y\"))]\n"
"        b: usize,\n"
"    },\n"
"    #[pyo3(transparent)]\n"
"    CatchAll(&'a PyAny), // This extraction never fails\n"
"}\n"
"# \n"
"# use pyo3::types::{PyBytes, PyString};\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         {\n"
"#             let thing = 42_u8.to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 42,\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Int(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = PyString::new(py, \"text\");\n"
"#             let rust_thing: RustyEnum = thing.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 \"text\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::String(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = (32_u8, 73_u8).to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (32, 73),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::IntTuple(i, j) => (i, j),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = (\"foo\", 73_u8).to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (String::from(\"foo\"), 73),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::StringIntTuple(i, j) => (i, j),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let module = PyModule::from_code(\n"
"#                 py,\n"
"#                 \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 0\n"
"#                 self.y = 1\n"
"#                 self.z = 2\",\n"
"#                 \"\",\n"
"#                 \"\",\n"
"#             )?;\n"
"# \n"
"#             let class = module.getattr(\"Foo\")?;\n"
"#             let instance = class.call0()?;\n"
"#             let rust_thing: RustyEnum = instance.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (0, 1, 2),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Coordinates3d { x, y, z } => (x, y, z),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let module = PyModule::from_code(\n"
"#                 py,\n"
"#                 \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 3\n"
"#                 self.y = 4\",\n"
"#                 \"\",\n"
"#                 \"\",\n"
"#             )?;\n"
"# \n"
"#             let class = module.getattr(\"Foo\")?;\n"
"#             let instance = class.call0()?;\n"
"#             let rust_thing: RustyEnum = instance.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (3, 4),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Coordinates2d { a, b } => (a, b),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = PyBytes::new(py, b\"text\");\n"
"#             let rust_thing: RustyEnum = thing.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 b\"text\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::CatchAll(i) => i.downcast::<PyBytes>()?."
"as_bytes(),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:368
msgid ""
"If none of the enum variants match, a `PyTypeError` containing the names of "
"the tested variants is returned. The names reported in the error message can "
"be customized through the `#[pyo3(annotation = \"name\")]` attribute, e.g. "
"to use conventional Python type names:"
msgstr ""

#: src/conversions/traits.md:373
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"# #[derive(Debug)]\n"
"enum RustyEnum {\n"
"    #[pyo3(transparent, annotation = \"str\")]\n"
"    String(String),\n"
"    #[pyo3(transparent, annotation = \"int\")]\n"
"    Int(isize),\n"
"}\n"
"#\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         {\n"
"#             let thing = 42_u8.to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 42,\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Int(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = \"foo\".to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 \"foo\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::String(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = b\"foo\".to_object(py);\n"
"#             let error = thing.extract::<RustyEnum>(py).unwrap_err();\n"
"#             assert!(error.is_instance::<pyo3::exceptions::"
"PyTypeError>(py));\n"
"#         }\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:424
msgid ""
"If the input is neither a string nor an integer, the error message will be: "
"`\"'<INPUT_TYPE>' cannot be converted to 'str | int'\"`."
msgstr ""

#: src/conversions/traits.md:427
msgid "`#[derive(FromPyObject)]` Container Attributes"
msgstr ""

#: src/conversions/traits.md:428
msgid "`pyo3(transparent)`"
msgstr ""

#: src/conversions/traits.md:429
msgid ""
"extract the field directly from the object as `obj.extract()` instead of "
"`get_item()` or `getattr()`"
msgstr ""

#: src/conversions/traits.md:431
msgid ""
"Newtype structs and tuple-variants are treated as transparent per default."
msgstr ""

#: src/conversions/traits.md:432
msgid "only supported for single-field structs and enum variants"
msgstr ""

#: src/conversions/traits.md:433
msgid "`pyo3(annotation = \"name\")`"
msgstr ""

#: src/conversions/traits.md:434
msgid ""
"changes the name of the failed variant in the generated error message in "
"case of failure."
msgstr ""

#: src/conversions/traits.md:435
msgid "e.g. `pyo3(\"int\")` reports the variant's type as `int`."
msgstr ""

#: src/conversions/traits.md:436
msgid "only supported for enum variants"
msgstr ""

#: src/conversions/traits.md:438
msgid "`#[derive(FromPyObject)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:439
msgid "`pyo3(attribute)`, `pyo3(attribute(\"name\"))`"
msgstr ""

#: src/conversions/traits.md:440
msgid ""
"retrieve the field from an attribute, possibly with a custom name specified "
"as an argument"
msgstr ""

#: src/conversions/traits.md:441
msgid "argument must be a string-literal."
msgstr ""

#: src/conversions/traits.md:442
msgid "`pyo3(item)`, `pyo3(item(\"key\"))`"
msgstr ""

#: src/conversions/traits.md:443
msgid ""
"retrieve the field from a mapping, possibly with the custom key specified as "
"an argument."
msgstr ""

#: src/conversions/traits.md:444
msgid "can be any literal that implements `ToBorrowedObject`"
msgstr ""

#: src/conversions/traits.md:446
msgid "`IntoPy<T>`"
msgstr ""

#: src/conversions/traits.md:448
msgid ""
"This trait defines the to-python conversion for a Rust type. It is usually "
"implemented as `IntoPy<PyObject>`, which is the trait needed for returning a "
"value from `#[pyfunction]` and `#[pymethods]`."
msgstr ""

#: src/conversions/traits.md:452
msgid ""
"All types in PyO3 implement this trait, as does a `#[pyclass]` which doesn't "
"use `extends`."
msgstr ""

#: src/conversions/traits.md:454
msgid ""
"Occasionally you may choose to implement this for custom types which are "
"mapped to Python types _without_ having a unique python type."
msgstr ""

#: src/conversions/traits.md:469
msgid "The `ToPyObject` trait"
msgstr ""

#: src/conversions/traits.md:471
msgid ""
"[`ToPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.ToPyObject."
"html) is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://pyo3.rs/main/doc/pyo3/type.PyObject.html). "
"`IntoPy<PyObject>` serves the same purpose, except that it consumes `self`."
msgstr ""

#: src/conversions/tables.md:1
msgid "Mapping of Rust types to Python types"
msgstr ""

#: src/conversions/tables.md:3
msgid ""
"When writing functions callable from Python (such as a `#[pyfunction]` or in "
"a `#[pymethods]` block), the trait `FromPyObject` is required for function "
"arguments, and `IntoPy<PyObject>` is required for function return values."
msgstr ""

#: src/conversions/tables.md:5
msgid ""
"Consult the tables in the following section to find the Rust types provided "
"by PyO3 which implement these traits."
msgstr ""

#: src/conversions/tables.md:7
msgid "Argument Types"
msgstr ""

#: src/conversions/tables.md:9
msgid ""
"When accepting a function argument, it is possible to either use Rust "
"library types or PyO3's Python-native types. (See the next section for "
"discussion on when to use each.)"
msgstr ""

#: src/conversions/tables.md:11
msgid ""
"The table below contains the Python type and the corresponding function "
"argument types that will accept them:"
msgstr ""

#: src/conversions/tables.md:13
msgid "Python"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust (Python-native)"
msgstr ""

#: src/conversions/tables.md:15
msgid "`object`"
msgstr ""

#: src/conversions/tables.md:15 src/conversions/tables.md:28
#: src/conversions/tables.md:29 src/conversions/tables.md:30
#: src/conversions/tables.md:31 src/conversions/tables.md:32
#: src/conversions/tables.md:33 src/conversions/tables.md:34
#: src/conversions/tables.md:35 src/conversions/tables.md:36
#: src/conversions/tables.md:39 src/conversions/tables.md:40
msgid "\\-"
msgstr ""

#: src/conversions/tables.md:15
msgid "`&PyAny`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:79
#: src/conversions/tables.md:80
msgid "`str`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`String`, `Cow<str>`, `&str`, `OsString`, `PathBuf`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`&PyUnicode`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`bytes`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`Vec<u8>`, `&[u8]`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`&PyBytes`"
msgstr ""

#: src/conversions/tables.md:18 src/conversions/tables.md:81
msgid "`bool`"
msgstr ""

#: src/conversions/tables.md:18
msgid "`&PyBool`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "`int`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "Any integer type (`i32`, `u32`, `usize`, etc)"
msgstr ""

#: src/conversions/tables.md:19
msgid "`&PyLong`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`float`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`f32`, `f64`"
msgstr ""

#: src/conversions/tables.md:20
msgid "`&PyFloat`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`complex`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`num_complex::Complex`[^1]"
msgstr ""

#: src/conversions/tables.md:21
msgid "`&PyComplex`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`list[T]`"
msgstr ""

#: src/conversions/tables.md:22 src/conversions/tables.md:37
#: src/conversions/tables.md:86
msgid "`Vec<T>`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`&PyList`"
msgstr ""

#: src/conversions/tables.md:23
msgid "`dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:23 src/conversions/tables.md:38
msgid ""
"`HashMap<K, V>`, `BTreeMap<K, V>`, `hashbrown::HashMap<K, V>`[^2], "
"`indexmap::IndexMap<K, V>`[^3]"
msgstr ""

#: src/conversions/tables.md:23
msgid "`&PyDict`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`(T, U)`, `Vec<T>`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`&PyTuple`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`set[T]`"
msgstr ""

#: src/conversions/tables.md:25 src/conversions/tables.md:26
msgid "`HashSet<T>`, `BTreeSet<T>`, `hashbrown::HashSet<T>`[^2]"
msgstr ""

#: src/conversions/tables.md:25
msgid "`&PySet`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`frozenset[T]`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`&PyFrozenSet`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`bytearray`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`Vec<u8>`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`&PyByteArray`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`slice`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`&PySlice`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`type`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`&PyType`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`module`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`&PyModule`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`datetime.datetime`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`&PyDateTime`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`datetime.date`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`&PyDate`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`datetime.time`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`&PyTime`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`datetime.tzinfo`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`&PyTzInfo`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`datetime.timedelta`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`&PyDelta`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`typing.Optional[T]`"
msgstr ""

#: src/conversions/tables.md:36 src/conversions/tables.md:84
msgid "`Option<T>`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`typing.Sequence[T]`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`&PySequence`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`typing.Mapping[K, V]`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`&PyMapping`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`typing.Iterator[Any]`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`&PyIterator`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`typing.Union[...]`"
msgstr ""

#: src/conversions/tables.md:40
msgid ""
"See [`#[derive(FromPyObject)]`](traits.html#deriving-a-"
"hrefhttpsdocsrspyo3latestpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-"
"for-enums)"
msgstr ""

#: src/conversions/tables.md:42
msgid ""
"There are also a few special types related to the GIL and Rust-defined "
"`#[pyclass]`es which may come in useful:"
msgstr ""

#: src/conversions/tables.md:44
msgid "What"
msgstr ""

#: src/conversions/tables.md:44
msgid "Description"
msgstr ""

#: src/conversions/tables.md:46
msgid "`Python`"
msgstr ""

#: src/conversions/tables.md:46
msgid ""
"A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL"
msgstr ""

#: src/conversions/tables.md:47
msgid "`Py<T>`"
msgstr ""

#: src/conversions/tables.md:47
msgid ""
"A Python object isolated from the GIL lifetime. This can be sent to other "
"threads."
msgstr ""

#: src/conversions/tables.md:48
msgid "`PyObject`"
msgstr ""

#: src/conversions/tables.md:48
msgid "An alias for `Py<PyAny>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "`&PyCell<T>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "A `#[pyclass]` value owned by Python."
msgstr ""

#: src/conversions/tables.md:50
msgid "`PyRef<T>`"
msgstr ""

#: src/conversions/tables.md:50
msgid "A `#[pyclass]` borrowed immutably."
msgstr ""

#: src/conversions/tables.md:51
msgid "`PyRefMut<T>`"
msgstr ""

#: src/conversions/tables.md:51
msgid "A `#[pyclass]` borrowed mutably."
msgstr ""

#: src/conversions/tables.md:53
msgid ""
"For more detail on accepting `#[pyclass]` values as function arguments, see "
"[the section of this guide on Python Classes](../class.md)."
msgstr ""

#: src/conversions/tables.md:55
msgid "Using Rust library types vs Python-native types"
msgstr ""

#: src/conversions/tables.md:57
msgid ""
"Using Rust library types as function arguments will incur a conversion cost "
"compared to using the Python-native types. Using the Python-native types is "
"almost zero-cost (they just require a type check similar to the Python "
"builtin function `isinstance()`)."
msgstr ""

#: src/conversions/tables.md:59
msgid ""
"However, once that conversion cost has been paid, the Rust standard library "
"types offer a number of benefits:"
msgstr ""

#: src/conversions/tables.md:60
msgid ""
"You can write functionality in native-speed Rust code (free of Python's "
"runtime costs)."
msgstr ""

#: src/conversions/tables.md:61
msgid "You get better interoperability with the rest of the Rust ecosystem."
msgstr ""

#: src/conversions/tables.md:62
msgid ""
"You can use `Python::allow_threads` to release the Python GIL and let other "
"Python threads make progress while your Rust code is executing."
msgstr ""

#: src/conversions/tables.md:63
msgid ""
"You also benefit from stricter type checking. For example you can specify "
"`Vec<i32>`, which will only accept a Python `list` containing integers. The "
"Python-native equivalent, `&PyList`, would accept a Python `list` containing "
"Python objects of any type."
msgstr ""

#: src/conversions/tables.md:65
msgid ""
"For most PyO3 usage the conversion cost is worth paying to get these "
"benefits. As always, if you're not sure it's worth it in your case, "
"benchmark it!"
msgstr ""

#: src/conversions/tables.md:67
msgid "Returning Rust values to Python"
msgstr ""

#: src/conversions/tables.md:69
msgid ""
"When returning values from functions callable from Python, Python-native "
"types (`&PyAny`, `&PyDict` etc.) can be used with zero cost."
msgstr ""

#: src/conversions/tables.md:71
msgid ""
"Because these types are references, in some situations the Rust compiler may "
"ask for lifetime annotations. If this is the case, you should use "
"`Py<PyAny>`, `Py<PyDict>` etc. instead - which are also zero-cost. For all "
"of these Python-native types `T`, `Py<T>` can be created from `T` with an `."
"into()` conversion."
msgstr ""

#: src/conversions/tables.md:73
msgid ""
"If your function is fallible, it should return `PyResult<T>` or `Result<T, "
"E>` where `E` implements `From<E> for PyErr`. This will raise a `Python` "
"exception if the `Err` variant is returned."
msgstr ""

#: src/conversions/tables.md:75
msgid ""
"Finally, the following Rust types are also able to convert to Python as "
"return values:"
msgstr ""

#: src/conversions/tables.md:77
msgid "Rust type"
msgstr ""

#: src/conversions/tables.md:77
msgid "Resulting Python Type"
msgstr ""

#: src/conversions/tables.md:79
msgid "`String`"
msgstr ""

#: src/conversions/tables.md:80
msgid "`&str`"
msgstr ""

#: src/conversions/tables.md:84
msgid "`Optional[T]`"
msgstr ""

#: src/conversions/tables.md:85
msgid "`Tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:86
msgid "`List[T]`"
msgstr ""

#: src/conversions/tables.md:87
msgid "`HashMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:87 src/conversions/tables.md:88
msgid "`Dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:88
msgid "`BTreeMap<K, V>`"
msgstr ""

#: src/conversions/tables.md:89
msgid "`HashSet<T>`"
msgstr ""

#: src/conversions/tables.md:89 src/conversions/tables.md:90
msgid "`Set[T]`"
msgstr ""

#: src/conversions/tables.md:90
msgid "`BTreeSet<T>`"
msgstr ""

#: src/conversions/tables.md:91
msgid "`&PyCell<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:92
msgid "`PyRef<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:93
msgid "`PyRefMut<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:95
msgid "Requires the `num-complex` optional feature."
msgstr ""

#: src/conversions/tables.md:97
msgid "Requires the `hashbrown` optional feature."
msgstr ""

#: src/conversions/tables.md:99
msgid "Requires the `indexmap` optional feature."
msgstr ""

#: src/ecosystem.md:1
msgid "The PyO3 Ecosystem"
msgstr ""

#: src/ecosystem.md:3
msgid ""
"This portion of the guide is dedicated to crates which are external to the "
"main PyO3 project and provide additional functionality you might find useful."
msgstr ""

#: src/ecosystem.md:5
msgid ""
"Because these projects evolve independently of the PyO3 repository the "
"content of these articles may fall out of date over time; please file issues "
"on the PyO3 Github to alert maintainers when this is the case."
msgstr ""

#: src/ecosystem/async-await.md:3
msgid ""
"If you are working with a Python library that makes use of async functions "
"or wish to provide Python bindings for an async Rust library, [`pyo3-"
"asyncio`](https://github.com/awestlake87/pyo3-asyncio) likely has the tools "
"you need. It provides conversions between async functions in both Python and "
"Rust and was designed with first-class support for popular Rust runtimes "
"such as [`tokio`](https://tokio.rs/) and [`async-std`](https://async.rs/). "
"In addition, all async Python code runs on the default `asyncio` event loop, "
"so `pyo3-asyncio` should work just fine with existing Python libraries."
msgstr ""

#: src/ecosystem/async-await.md:11
msgid ""
"In the following sections, we'll give a general overview of `pyo3-asyncio` "
"explaining how to call async Python functions with PyO3, how to call async "
"Rust functions from Python, and how to configure your codebase to manage the "
"runtimes of both."
msgstr ""

#: src/ecosystem/async-await.md:15
msgid "Quickstart"
msgstr ""

#: src/ecosystem/async-await.md:17
msgid ""
"Here are some examples to get you started right away! A more detailed "
"breakdown of the concepts in these examples can be found in the following "
"sections."
msgstr ""

#: src/ecosystem/async-await.md:20
msgid "Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:21
msgid ""
"Here we initialize the runtime, import Python's `asyncio` library and run "
"the given future to completion using Python's default `EventLoop` and `async-"
"std`. Inside the future, we convert `asyncio` sleep into a Rust future and "
"await it."
msgstr ""

#: src/ecosystem/async-await.md:24
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"async-std-"
"runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:33 src/ecosystem/async-await.md:63
#: src/ecosystem/async-await.md:522
msgid "//! main.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:40 src/ecosystem/async-await.md:70
#: src/ecosystem/async-await.md:383
msgid "\"asyncio\""
msgstr ""

#: src/ecosystem/async-await.md:41 src/ecosystem/async-await.md:71
#: src/ecosystem/async-await.md:385
msgid "// convert asyncio.sleep into a Rust Future\n"
msgstr ""

#: src/ecosystem/async-await.md:42 src/ecosystem/async-await.md:72
#: src/ecosystem/async-await.md:387
msgid "\"sleep\""
msgstr ""

#: src/ecosystem/async-await.md:51
msgid ""
"The same application can be written to use `tokio` instead using the "
"`#[pyo3_asyncio::tokio::main]` attribute."
msgstr ""

#: src/ecosystem/async-await.md:54
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"tokio-"
"runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:81
msgid ""
"More details on the usage of this library can be found in the [API docs]"
"(https://awestlake87.github.io/pyo3-asyncio/master/doc) and the primer below."
msgstr ""

#: src/ecosystem/async-await.md:83
msgid "PyO3 Native Rust Modules"
msgstr ""

#: src/ecosystem/async-await.md:85
msgid ""
"PyO3 Asyncio can also be used to write native modules with async functions."
msgstr ""

#: src/ecosystem/async-await.md:87
msgid ""
"Add the `[lib]` section to `Cargo.toml` to make your library a `cdylib` that "
"Python can import."
msgstr ""

#: src/ecosystem/async-await.md:88
msgid ""
"```toml\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:94
msgid ""
"Make your project depend on `pyo3` with the `extension-module` feature "
"enabled and select your `pyo3-asyncio` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:97
msgid "For `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:98
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:105
msgid "For `tokio`:"
msgstr ""

#: src/ecosystem/async-await.md:106
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:113
msgid "Export an async function that makes use of `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:116 src/ecosystem/async-await.md:140
#: src/ecosystem/async-await.md:464
msgid "//! lib.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:137
msgid ""
"If you want to use `tokio` instead, here's what your module should look like:"
msgstr ""

#: src/ecosystem/async-await.md:159
msgid ""
"You can build your module with maturin (see the [Using Rust in Python]"
"(https://pyo3.rs/main/#using-rust-from-python) section in the PyO3 guide for "
"setup instructions). After that you should be able to run the Python REPL to "
"try it out."
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"help\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"copyright\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"credits\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"license\""
msgstr ""

#: src/ecosystem/async-await.md:181
msgid "Awaiting an Async Python Function in Rust"
msgstr ""

#: src/ecosystem/async-await.md:183
msgid "Let's take a look at a dead simple async Python function:"
msgstr ""

#: src/ecosystem/async-await.md:186
msgid "# Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:191
msgid ""
"**Async functions in Python are simply functions that return a `coroutine` "
"object**. For our purposes, we really don't need to know much about these "
"`coroutine` objects. The key factor here is that calling an `async` function "
"is _just like calling a regular function_, the only difference is that we "
"have to do something special with the object that it returns."
msgstr ""

#: src/ecosystem/async-await.md:196
msgid ""
"Normally in Python, that something special is the `await` keyword, but in "
"order to await this coroutine in Rust, we first need to convert it into "
"Rust's version of a `coroutine`: a `Future`. That's where `pyo3-asyncio` "
"comes in. [`pyo3_asyncio::into_future`](https://docs.rs/pyo3-asyncio/latest/"
"pyo3_asyncio/fn.into_future.html) performs this conversion for us."
msgstr ""

#: src/ecosystem/async-await.md:202
msgid ""
"The following example uses `into_future` to call the `py_sleep` function "
"shown above and then await the coroutine object returned from the call:"
msgstr ""

#: src/ecosystem/async-await.md:211
msgid "// import the module containing the py_sleep function\n"
msgstr ""

#: src/ecosystem/async-await.md:214
msgid ""
"// calling the py_sleep method like a normal function\n"
"        // returns a coroutine\n"
msgstr ""

#: src/ecosystem/async-await.md:216
msgid "\"py_sleep\""
msgstr ""

#: src/ecosystem/async-await.md:218
msgid ""
"// convert the coroutine into a Rust future using the\n"
"        // tokio runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:223 src/ecosystem/async-await.md:241
#: src/ecosystem/async-await.md:272
msgid "// await the future\n"
msgstr ""

#: src/ecosystem/async-await.md:230
msgid ""
"Alternatively, the below example shows how to write a `#[pyfunction]` which "
"uses `into_future` to receive and await a coroutine argument:"
msgstr ""

#: src/ecosystem/async-await.md:236 src/ecosystem/async-await.md:267
msgid ""
"// convert the coroutine into a Rust future using the\n"
"    // async_std runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:248
msgid "This could be called from Python as:"
msgstr ""

#: src/ecosystem/async-await.md:259
msgid ""
"If for you wanted to pass a callable function to the `#[pyfunction]` "
"instead, (i.e. the last line becomes `await_coro(py_sleep))`, then the above "
"example needs to be tweaked to first call the callable to get the coroutine:"
msgstr ""

#: src/ecosystem/async-await.md:264
msgid "// get the coroutine by calling the callable\n"
msgstr ""

#: src/ecosystem/async-await.md:279
msgid ""
"This can be particularly helpful where you need to repeatedly create and "
"await a coroutine. Trying to await the same coroutine multiple times will "
"raise an error:"
msgstr ""

#: src/ecosystem/async-await.md:285
msgid ""
"If you're interested in learning more about `coroutines` and `awaitables` in "
"general, check out the [Python 3 `asyncio` docs](https://docs.python.org/3/"
"library/asyncio-task.html) for more information."
msgstr ""

#: src/ecosystem/async-await.md:288
msgid "Awaiting a Rust Future in Python"
msgstr ""

#: src/ecosystem/async-await.md:290
msgid ""
"Here we have the same async function as before written in Rust using the "
"[`async-std`](https://async.rs/) runtime:"
msgstr ""

#: src/ecosystem/async-await.md:294
msgid "/// Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:300
msgid ""
"Similar to Python, Rust's async functions also return a special object "
"called a `Future`:"
msgstr ""

#: src/ecosystem/async-await.md:307
msgid ""
"We can convert this `Future` object into Python to make it `awaitable`. This "
"tells Python that you can use the `await` keyword with it. In order to do "
"this, we'll call [`pyo3_asyncio::async_std::future_into_py`](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html):"
msgstr ""

#: src/ecosystem/async-await.md:327
msgid ""
"In Python, we can call this pyo3 function just like any other async function:"
msgstr ""

#: src/ecosystem/async-await.md:336
msgid "Managing Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:338
msgid ""
"Python's event loop requires some special treatment, especially regarding "
"the main thread. Some of Python's `asyncio` features, like proper signal "
"handling, require control over the main thread, which doesn't always play "
"well with Rust."
msgstr ""

#: src/ecosystem/async-await.md:342
msgid ""
"Luckily, Rust's event loops are pretty flexible and don't _need_ control "
"over the main thread, so in `pyo3-asyncio`, we decided the best way to "
"handle Rust/Python interop was to just surrender the main thread to Python "
"and run Rust's event loops in the background. Unfortunately, since most "
"event loop implementations _prefer_ control over the main thread, this can "
"still make some things awkward."
msgstr ""

#: src/ecosystem/async-await.md:347
msgid "PyO3 Asyncio Initialization"
msgstr ""

#: src/ecosystem/async-await.md:349
msgid ""
"Because Python needs to control the main thread, we can't use the convenient "
"proc macros from Rust runtimes to handle the `main` function or `#[test]` "
"functions. Instead, the initialization for PyO3 has to be done from the "
"`main` function and the main thread must block on [`pyo3_asyncio::"
"run_forever`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn."
"run_forever.html) or [`pyo3_asyncio::async_std::run_until_complete`](https://"
"docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete."
"html)."
msgstr ""

#: src/ecosystem/async-await.md:353
msgid ""
"Because we have to block on one of those functions, we can't use "
"[`#[async_std::main]`](https://docs.rs/async-std/latest/async_std/attr.main."
"html) or [`#[tokio::main]`](https://docs.rs/tokio/1.1.0/tokio/attr.main."
"html) since it's not a good idea to make long blocking calls during an async "
"function."
msgstr ""

#: src/ecosystem/async-await.md:356
msgid ""
"Internally, these `#[main]` proc macros are expanded to something like this:"
msgstr ""

#: src/ecosystem/async-await.md:359
msgid "// your async main fn\n"
msgstr ""

#: src/ecosystem/async-await.md:364
msgid ""
"Making a long blocking call inside the `Future` that's being driven by "
"`block_on` prevents that thread from doing anything else and can spell "
"trouble for some runtimes (also this will actually deadlock a single-"
"threaded runtime!). Many runtimes have some sort of `spawn_blocking` "
"mechanism that can avoid this problem, but again that's not something we can "
"use here since we need it to block on the _main_ thread."
msgstr ""

#: src/ecosystem/async-await.md:370
msgid ""
"For this reason, `pyo3-asyncio` provides its own set of proc macros to "
"provide you with this initialization. These macros are intended to mirror "
"the initialization of `async-std` and `tokio` while also satisfying the "
"Python runtime's needs."
msgstr ""

#: src/ecosystem/async-await.md:374
msgid ""
"Here's a full example of PyO3 initialization with the `async-std` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:380
msgid "// PyO3 is initialized - Ready to go\n"
msgstr ""

#: src/ecosystem/async-await.md:397
msgid "A Note About `asyncio.run`"
msgstr ""

#: src/ecosystem/async-await.md:399
msgid ""
"In Python 3.7+, the recommended way to run a top-level coroutine with "
"`asyncio` is with `asyncio.run`. In `v0.13` we recommended against using "
"this function due to initialization issues, but in `v0.14` it's perfectly "
"valid to use this function... with a caveat."
msgstr ""

#: src/ecosystem/async-await.md:402
msgid ""
"Since our Rust \\<\\--> Python conversions require a reference to the Python "
"event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that "
"defines a `rust_sleep` function like in previous examples. You might "
"rightfully assume that you can call pass this directly into `asyncio.run` "
"like this:"
msgstr ""

#: src/ecosystem/async-await.md:413
msgid "You might be surprised to find out that this throws an error:"
msgstr ""

#: src/ecosystem/async-await.md:416
msgid "\"example.py\""
msgstr ""

#: src/ecosystem/async-await.md:421
msgid ""
"What's happening here is that we are calling `rust_sleep` _before_ the "
"future is actually running on the event loop created by `asyncio.run`. This "
"is counter-intuitive, but expected behaviour, and unfortunately there "
"doesn't seem to be a good way of solving this problem within PyO3 Asyncio "
"itself."
msgstr ""

#: src/ecosystem/async-await.md:424
msgid "However, we can make this example work with a simple workaround:"
msgstr ""

#: src/ecosystem/async-await.md:430
msgid ""
"# Calling main will just construct the coroutine that later calls "
"rust_sleep.\n"
"# - This ensures that rust_sleep will be called when the event loop is "
"running,\n"
"#   not before.\n"
msgstr ""

#: src/ecosystem/async-await.md:436
msgid "# Run the main() coroutine at the top-level instead\n"
msgstr ""

#: src/ecosystem/async-await.md:441
msgid "Non-standard Python Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:443
msgid ""
"Python allows you to use alternatives to the default `asyncio` event loop. "
"One popular alternative is `uvloop`. In `v0.13` using non-standard event "
"loops was a bit of an ordeal, but in `v0.14` it's trivial."
msgstr ""

#: src/ecosystem/async-await.md:447
msgid "Using `uvloop` in a PyO3 Asyncio Native Extensions"
msgstr ""

#: src/ecosystem/async-await.md:449
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"async-std = \"1.9\"\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:506
msgid "Using `uvloop` in Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:508
msgid ""
"Using `uvloop` in Rust applications is a bit trickier, but it's still "
"possible with relatively few modifications."
msgstr ""

#: src/ecosystem/async-await.md:511
msgid ""
"Unfortunately, we can't make use of the `#[pyo3_asyncio::<runtime>::main]` "
"attribute with non-standard event loops. This is because the "
"`#[pyo3_asyncio::<runtime>::main]` proc macro has to interact with the "
"Python event loop before we can install the `uvloop` policy."
msgstr ""

#: src/ecosystem/async-await.md:514
msgid ""
"```toml\n"
"[dependencies]\n"
"async-std = \"1.9\"\n"
"pyo3 = \"0.14\"\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:530
msgid "\"uvloop\""
msgstr ""

#: src/ecosystem/async-await.md:531
msgid "\"install\""
msgstr ""

#: src/ecosystem/async-await.md:533
msgid "// store a reference for the assertion\n"
msgstr ""

#: src/ecosystem/async-await.md:537
msgid "// verify that we are on a uvloop.Loop\n"
msgstr ""

#: src/ecosystem/async-await.md:541
msgid "\"Loop\""
msgstr ""

#: src/ecosystem/async-await.md:556
msgid "Additional Information"
msgstr ""

#: src/ecosystem/async-await.md:557
msgid ""
"Managing event loop references can be tricky with pyo3-asyncio. See [Event "
"Loop References](https://docs.rs/pyo3-asyncio/#event-loop-references) in the "
"API docs to get a better intuition for how event loop references are managed "
"in this library."
msgstr ""

#: src/ecosystem/async-await.md:558
msgid ""
"Testing pyo3-asyncio libraries and applications requires a custom test "
"harness since Python requires control over the main thread. You can find a "
"testing guide in the [API docs for the `testing` module](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/testing)"
msgstr ""

#: src/ecosystem/logging.md:3
msgid ""
"It is desirable if both the Python and Rust parts of the application end up "
"logging using the same configuration into the same place."
msgstr ""

#: src/ecosystem/logging.md:6
msgid ""
"This section of the guide briefly discusses how to connect the two "
"languages' logging ecosystems together. The recommended way for Python "
"extension modules is to configure Rust's logger to send log messages to "
"Python using the `pyo3-log` crate. For users who want to do the opposite and "
"send Python log messages to Rust, see the note at the end of this guide."
msgstr ""

#: src/ecosystem/logging.md:12
msgid "Using `pyo3-log` to send Rust log messages to Python"
msgstr ""

#: src/ecosystem/logging.md:14
msgid ""
"The [pyo3-log](https://crates.io/crates/pyo3-log) crate allows sending the "
"messages from the Rust side to Python's [logging](https://docs.python.org/3/"
"library/logging.html) system. This is mostly suitable for writing native "
"extensions for Python programs."
msgstr ""

#: src/ecosystem/logging.md:18
msgid ""
"Use [`pyo3_log::init`](https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html) to "
"install the logger in its default configuration. It's also possible to tweak "
"its configuration (mostly to tune its performance)."
msgstr ""

#: src/ecosystem/logging.md:27
msgid ""
"// This will use the logger installed in `my_module` to send the `info`\n"
"    // message to the Python logging facilities.\n"
msgstr ""

#: src/ecosystem/logging.md:29
msgid "\"Something!\""
msgstr ""

#: src/ecosystem/logging.md:34
msgid "// A good place to install the Rust -> Python logger.\n"
msgstr ""

#: src/ecosystem/logging.md:42
msgid ""
"Then it is up to the Python side to actually output the messages somewhere."
msgstr ""

#: src/ecosystem/logging.md:48
msgid ""
"'%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'"
msgstr ""

#: src/ecosystem/logging.md:54
msgid ""
"It is important to initialize the Python loggers first, before calling any "
"Rust functions that may log. This limitation can be worked around if it is "
"not possible to satisfy, read the documentation about [caching](https://docs."
"rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching)."
msgstr ""

#: src/ecosystem/logging.md:58
msgid "The Python to Rust direction"
msgstr ""

#: src/ecosystem/logging.md:60
msgid ""
"To best of our knowledge nobody implemented the reverse direction yet, "
"though it should be possible. If interested, the `pyo3` community would be "
"happy to provide guidance."
msgstr ""
