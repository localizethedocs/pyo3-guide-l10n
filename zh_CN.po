msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:51Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/distribution.md:1
msgid "Distribution"
msgstr ""

#: src/distribution.md:3
msgid "`setuptools-rust` integration"
msgstr ""

#: src/distribution.md:5
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is a setuptools "
"helpers for Rust Python extensions. It supports `PyO3` by default."
msgstr ""

#: src/distribution.md:7
msgid ""
"For detailed usage, please refer to its [README](https://github.com/PyO3/"
"setuptools-rust/blob/master/README.rst)"
msgstr ""

#: src/distribution.md:9
msgid "Source distribution"
msgstr ""

#: src/distribution.md:11
msgid ""
"To build a source code distribution, you need to add the following lines to "
"your `MANIFEST.in` file to ensure it correctly packages Rust extension "
"source code."
msgstr ""

#: src/distribution.md:18
msgid ""
"Then you can build a source code distribution by (assuming you have already "
"written a `setup.py`):"
msgstr ""

#: src/distribution.md:24
msgid "Binary wheel distribution"
msgstr ""

#: src/distribution.md:26
msgid ""
"To build a binary wheel, [manylinux](https://github.com/pypa/manylinux) "
"would be a natural choice for Linux."
msgstr ""

#: src/distribution.md:28
msgid "TODO: an manylinux1 example, macOS wheel"
msgstr ""

#: src/getting_started.md:1
msgid "Getting Started"
msgstr ""

#: src/getting_started.md:3
msgid ""
"In this tutorial, we will walk through the steps of building a simple Python "
"extension called `TODO`."
msgstr ""

#: src/getting_started.md:5
msgid "Install Rust"
msgstr ""

#: src/getting_started.md:7
msgid ""
"Before we begin, we need to install Rust using the [rustup](https://www."
"rustup.rs/) installer:"
msgstr ""

#: src/getting_started.md:13
msgid ""
"If you already have rustup installed, run this command to ensure you have "
"the latest version of Rust:"
msgstr ""

#: src/overview.md:1
msgid "Overview"
msgstr ""

#: src/overview.md:3
msgid ""
"[![Build Status](https://travis-ci.org/PyO3/pyo3.svg?branch=master)](https://"
"travis-ci.org/PyO3/pyo3) [![Latest Version](https://img.shields.io/crates/v/"
"pyo3.svg)](https://crates.io/crates/pyo3) [![Rust Documentation](https://img."
"shields.io/badge/api-rustdoc-blue.svg)](http://pyo3.github.io/pyo3/pyo3/)"
msgstr ""

#: src/overview.md:7
msgid ""
"PyO3 is a [Rust](http://www.rust-lang.org/) bindings for the [Python]"
"(https://www.python.org/) interpreter."
msgstr ""

#: src/overview.md:9
msgid "Supported Python versions:"
msgstr ""

#: src/overview.md:11
msgid "Python2.7, Python 3.5 and up"
msgstr ""

#: src/overview.md:13
msgid "Supported Rust version:"
msgstr ""

#: src/overview.md:15
msgid "Rust 1.20.0-nightly or later"
msgstr ""

#: src/overview.md:16
msgid "On Windows, we require rustc 1.20.0-nightly"
msgstr ""

#: src/overview.md:18
msgid "Usage"
msgstr ""

#: src/overview.md:20
msgid "To use `pyo3`, add this to your `Cargo.toml`:"
msgstr ""

#: src/overview.md:22
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.1\"\n"
"```"
msgstr ""

#: src/overview.md:27
msgid "Example program displaying the value of `sys.version`:"
msgstr ""

#: src/overview.md:40
msgid "\"sys\""
msgstr ""

#: src/overview.md:41
msgid "\"version\""
msgstr ""

#: src/overview.md:44
msgid "\"os\""
msgstr ""

#: src/overview.md:45
msgid "\"os.getenv('USER') or os.getenv('USERNAME')\""
msgstr ""

#: src/overview.md:47
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/overview.md:52
msgid "Example library with python bindings:"
msgstr ""

#: src/overview.md:54
msgid ""
"The following two files will build with `cargo build`, and will generate a "
"python-compatible library. On macOS, you will need to rename the output from "
"\\*.dylib to \\*.so. On Windows, you will need to rename the output from \\*."
"dll to \\*.pyd."
msgstr ""

#: src/overview.md:58
msgid "**`Cargo.toml`:**"
msgstr ""

#: src/overview.md:60
msgid ""
"```toml\n"
"[lib]\n"
"name = \"rust2py\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies.pyo3]\n"
"version = \"0.1\"\n"
"features = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/overview.md:70
msgid "**`src/lib.rs`**"
msgstr ""

#: src/overview.md:77
msgid ""
"// add bindings to the generated python module\n"
"// N.B: names: \"librust2py\" must be the name of the `.so` or `.pyd` file\n"
"/// This module is implemented in Rust.\n"
msgstr ""

#: src/overview.md:84
msgid "\"sum_as_string\""
msgstr ""

#: src/overview.md:85
msgid ""
"// pyo3 aware function. All of our python interface could be declared in a "
"separate module.\n"
"    // Note that the `#[pyfn()]` annotation automatically converts the "
"arguments from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/overview.md:95
msgid "// logic implemented as a normal rust function\n"
msgstr ""

#: src/overview.md:98
msgid "\"{}\""
msgstr ""

#: src/overview.md:104
msgid ""
"For `setup.py` integration, see [setuptools-rust](https://github.com/PyO3/"
"setuptools-rust)"
msgstr ""

#: src/overview.md:106
msgid "Ownership and Lifetimes"
msgstr ""

#: src/overview.md:108
msgid ""
"In Python, all objects are implicitly reference counted. In Rust, we will "
"use the [`PyObject`](https://pyo3.github.io/pyo3/pyo3/struct.PyObject.html) "
"type to represent a reference to a Python object."
msgstr ""

#: src/overview.md:112
msgid ""
"Because all Python objects potentially have multiple owners, the concept of "
"Rust mutability does not apply to Python objects. As a result, this API will "
"**allow mutating Python objects even if they are not stored in a mutable "
"Rust variable**."
msgstr ""

#: src/overview.md:117
msgid ""
"The Python interpreter uses a global interpreter lock (GIL) to ensure thread-"
"safety. This API uses a zero-sized [`struct Python<'p>`](https://pyo3.github."
"io/PyO3/pyo3/struct.Python.html) as a token to indicate that a function can "
"assume that the GIL is held."
msgstr ""

#: src/overview.md:121
msgid ""
"You obtain a [`Python`](https://pyo3.github.io/PyO3/pyo3/struct.Python.html) "
"instance by acquiring the GIL, and have to pass it into some operations that "
"call into the Python runtime."
msgstr ""

#: src/overview.md:124
msgid ""
"PyO3 library provides wrappers for python native objects. Ownership of "
"python objects are disallowed because any access to python runtime has to be "
"protected by GIL. All apis are available through references. Lifetimes of "
"python object's refereces are bound to GIL lifetime."
msgstr ""

#: src/overview.md:129
msgid ""
"There are two types of pointers that could be stored on rust structs. Both "
"implements `Send` and `Sync` traits and maintain python object's reference "
"count."
msgstr ""

#: src/overview.md:132
msgid ""
"[`PyObject`](https://pyo3.github.io/pyo3/pyo3/struct.PyObject.html) is "
"general purpose type. It does not maintain type of the referenced object. It "
"provides helper methods for extracing rust values and casting to specific "
"python object type."
msgstr ""

#: src/overview.md:136
msgid ""
"[`Py<T>`](https://pyo3.github.io/pyo3/pyo3/struct.Py.html) represents a "
"reference to a concrete python object `T`."
msgstr ""

#: src/overview.md:139
msgid ""
"To upgrade to a reference [`AsPyRef`](https://pyo3.github.io/pyo3/pyo3/trait."
"AsPyRef.html) trait can be used."
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid "TODO"
msgstr ""

#: src/class.md:1
msgid "Python Class"
msgstr ""

#: src/class.md:3
msgid ""
"Python class generation is powered by unstable [Procedural Macros](https://"
"doc.rust-lang.org/book/first-edition/procedural-macros.html) and "
"[Specialization](https://github.com/rust-lang/rfcs/blob/master/text/1210-"
"impl-specialization.md) and [Const fn](https://github.com/rust-lang/rfcs/"
"blob/master/text/0911-const-fn.md) features, so you need to turn on "
"`proc_macro` and `specialization` features:"
msgstr ""

#: src/class.md:14
msgid "Define new class"
msgstr ""

#: src/class.md:16
msgid ""
"To define python custom class, rust struct needs to be annotated with `#[py::"
"class]` attribute."
msgstr ""

#: src/class.md:29
msgid ""
"The above example generates the following implementations for `MyClass` "
"struct"
msgstr ""

#: src/class.md:40
msgid ""
"Following implementations `PyObjectWithToken`, `ToPyObject`, `IntoPyObject`, "
"`ToPyPointer` are generated only if struct contains `PyToken` attribute."
msgstr ""

#: src/class.md:43
msgid "`PyToken` instance available only in `py.init` method."
msgstr ""

#: src/class.md:45
msgid "TODO - continue"
msgstr ""

#: src/class.md:47
msgid "Constructor"
msgstr ""

#: src/class.md:49
msgid ""
"By default it is not possible to create instance of custom class from python "
"code. To declare constructor, you need to define class method and annotate "
"it with `#[new]` attribute. Only python `__new__` method can be specified, "
"`__init__` is not available."
msgstr ""

#: src/class.md:70
msgid "Some rules of `new` method"
msgstr ""

#: src/class.md:72
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:74
msgid ""
"The first parameter is the type object of the class to create. This may be "
"the type object of a derived class declared in Python."
msgstr ""

#: src/class.md:76 src/class.md:206
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:77 src/class.md:207
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:78
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`. Usually, `T` will be `MyType`."
msgstr ""

#: src/class.md:82
msgid "Object properties"
msgstr ""

#: src/class.md:84
msgid ""
"Instance's `__dict__` attributes is not supported by pyo3 library. But it is "
"possible to specify instance get/set descriptors. Descriptor methods can be "
"defined in `#[methods]` `impl` block only and has to be annotated with "
"`#[getter]` or `[setter]` attributes. i.e."
msgstr ""

#: src/class.md:100
msgid ""
"Getter or setter function's name is used as property name by default. There "
"are several ways how to override name."
msgstr ""

#: src/class.md:103
msgid ""
"If function name starts with `get_` or `set_` for getter or setter "
"respectively. Descriptor name becomes function name with prefix removed. "
"This is useful in case os rust's special keywords like `type`."
msgstr ""

#: src/class.md:123
msgid ""
"In this case property `num` is defined. And it is available from python code "
"as `self.num`."
msgstr ""

#: src/class.md:125
msgid ""
"Also both `#[getter]` and `#[setter]` attributes accepts one parameter. If "
"parameter is specified, it is used and property name. i.e."
msgstr ""

#: src/class.md:144
msgid ""
"In this case property `number` is defined. And it is available from python "
"code as `self.number`."
msgstr ""

#: src/class.md:146
msgid "Instance methods"
msgstr ""

#: src/class.md:148
msgid ""
"To define python compatible method, `impl` block for struct has to be "
"annotated with `#[py::methods]` attribute. `pyo3` library generates python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:168
msgid ""
"Calls to this methods protected by `GIL`, `&self` or `&mut self` can be "
"used. The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:171
msgid ""
"`Python` parameter can be spefieid as part of method signature, in this case "
"`py` argument get injected by method wrapper. i.e"
msgstr ""

#: src/class.md:184
msgid ""
"From python prespective `method2`, in above example, does not accept any "
"arguments."
msgstr ""

#: src/class.md:186
msgid "Class methods"
msgstr ""

#: src/class.md:188
msgid ""
"To specify class method for custom class, method needs to be annotated "
"with`#[classmethod]` attribute."
msgstr ""

#: src/class.md:202
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:204
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:208
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:210
msgid "Static methods"
msgstr ""

#: src/class.md:212
msgid ""
"To specify class method for custom class, method needs to be annotated with "
"`#[staticmethod]` attribute. The return type must be `PyResult<T>` for some "
"`T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:227
msgid "Callable object"
msgstr ""

#: src/class.md:229
msgid ""
"To specify custom `__call__` method for custom class, call method needs to "
"be annotated with `#[call]` attribute. Arguments of the method are speficied "
"same as for instance method."
msgstr ""

#: src/class.md:237 src/class.md:272
msgid "\"*\""
msgstr ""

#: src/class.md:239
msgid "\"MyCLS has been called\""
msgstr ""

#: src/class.md:245
msgid "Method arguments"
msgstr ""

#: src/class.md:247
msgid ""
"By default pyo3 library uses function signature to determine which arguments "
"are required. Then it scans incoming `args` parameter and then incoming "
"`kwargs` parameter. If it can not find all required parameters, it raises "
"`TypeError` exception. It is possible to override default bahavior with "
"`#[args(...)]` attribute. `args` attribute accept comma separated list of "
"parameters in form `attr_name=\"default value\"`. Each parameter has to "
"match method parameter by name."
msgstr ""

#: src/class.md:254
msgid "Each parameter could one of following type:"
msgstr ""

#: src/class.md:256
msgid ""
"\"\\*\": var arguments separator, each parameter defined after \"\\*\" is "
"keyword only paramters. coresponds to python's `def meth(*, arg1.., arg2=..)`"
msgstr ""

#: src/class.md:258
msgid ""
"args=\"\\*\": \"args\" is var args, coresponds to python's `def "
"meth(*args)`. Type of `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:260
msgid ""
"kwargs=\"\\*\\*\": \"kwargs\" is kwyword arguments, coresponds to python's "
"`def meth(**kwargs)`. Type of `kwargs` parameter has to be `Option<&PyDict>`."
msgstr ""

#: src/class.md:262
msgid ""
"arg=\"Value\": arguments with default value. coresponds to python's `def "
"meth(arg=Value)`. if `arg` argument is defined after var arguments it is "
"treated as keyword argument. Note that `Value` has to be valid rust code, "
"pyo3 just inserts it into generated code unmodified."
msgstr ""

#: src/class.md:267 src/class.md:403
msgid "Example:"
msgstr ""

#: src/class.md:272
msgid "\"**\""
msgstr ""

#: src/class.md:280
msgid "Class customizations"
msgstr ""

#: src/class.md:282
msgid ""
"Python object model defines several protocols for different object behavior, "
"like sequence, mapping or number protocols. pyo3 library defines separate "
"trait for each of them. To provide specific python object behavior you need "
"to implement specific trait for your struct. Important note, each protocol "
"implementation block has to be annotated with `#[py::proto]` attribute."
msgstr ""

#: src/class.md:288
msgid "Basic object customization"
msgstr ""

#: src/class.md:290
msgid ""
"[`PyObjectProtocol`](https://pyo3.github.io/pyo3/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provide several basic customizations."
msgstr ""

#: src/class.md:292
msgid "Attribute access"
msgstr ""

#: src/class.md:294
msgid "To customize object attribute access define following methods:"
msgstr ""

#: src/class.md:296
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:297
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:298
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:300
msgid ""
"Each methods coresponds to python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:302
msgid "String Conversions"
msgstr ""

#: src/class.md:304
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:305
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:307
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`. In Python 2.7, Unicode strings returned by `__str__` "
"and `__repr__` will be converted to byte strings by the Python runtime, "
"which results in an exception if the string contains non-ASCII characters."
msgstr ""

#: src/class.md:311
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:313
msgid ""
"On Python 3.x, provides the conversion to `bytes`. On Python 2.7, "
"`__bytes__` is allowed but has no effect."
msgstr ""

#: src/class.md:316
msgid "`fn __unicode__(&self) -> PyResult<PyUnicode>`"
msgstr ""

#: src/class.md:318
msgid ""
"On Python 2.7, provides the conversion to `unicode`. On Python 3.x, "
"`__unicode__` is allowed but has no effect."
msgstr ""

#: src/class.md:321
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:323
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:326
msgid "Comparison operators"
msgstr ""

#: src/class.md:328
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:330
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:336
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:338
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:341
msgid "Other methods"
msgstr ""

#: src/class.md:343
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:345
msgid ""
"Determines the \"truthyness\" of the object. This method works for both "
"python 3 and python 2, even on Python 2.7 where the Python spelling was "
"`__nonzero__`."
msgstr ""

#: src/class.md:349
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:351
msgid ""
"If your type owns references to other python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement [`PyGCProtocol`](https://pyo3.github.io/"
"pyo3/pyo3/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another python object. `__clear__` "
"must clear out any mutable references to other python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:384
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:391
msgid ""
"Special protocol trait implementation has to be annotated with `#[py::"
"proto]` attribute."
msgstr ""

#: src/class.md:393
msgid "Iterator Types"
msgstr ""

#: src/class.md:395
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://pyo3.github.io/"
"pyo3/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:398
msgid "`fn __iter__(&mut self) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:399
msgid "`fn __next__(&mut self) -> PyResult<Option<impl IntoPyObject>>`"
msgstr ""

#: src/class.md:401
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""

#: src/exception.md:1
msgid "Python Exception"
msgstr ""

#: src/exception.md:3
msgid "Define a new exception"
msgstr ""

#: src/exception.md:5
msgid "You can use the `py_exception!` macro to define a new excetpion type:"
msgstr ""

#: src/exception.md:11
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:12
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:14
msgid "For example:"
msgstr ""

#: src/exception.md:28
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:30
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:31
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:35
msgid "Raise an exception"
msgstr ""

#: src/exception.md:37
msgid ""
"To raise an exception, first you need to obtain an exception type and "
"construct a new [`PyErr`](https://pyo3.github.io/PyO3/pyo3/struct.PyErr."
"html), then call [`PyErr::restore()`](https://pyo3.github.io/PyO3/pyo3/"
"struct.PyErr.html#method.restore) method to write the exception back to the "
"Python interpreter's global state."
msgstr ""

#: src/exception.md:53
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance()`](https://pyo3.github.io/PyO3/pyo3/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:59
msgid "Check exception type"
msgstr ""

#: src/exception.md:61
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check object type, in `PyO3` there is a [`Python::"
"is_instance()`](https://pyo3.github.io/PyO3/pyo3/struct.Python.html#method."
"is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:79
msgid ""
"[`Python::is_instance()`](https://pyo3.github.io/PyO3/pyo3/struct.Python."
"html#method.is_instance) calls the underlaying [`PyType::is_instance`]"
"(https://pyo3.github.io/PyO3/pyo3/struct.PyType.html#method.is_instance) "
"method to do the actual work."
msgstr ""

#: src/exception.md:81
msgid "To check the type of an exception, you can simply do:"
msgstr ""

#: src/exception.md:84
msgid "\"Error calling is_instance\""
msgstr ""

#: src/exception.md:87
msgid "Handle Rust Error"
msgstr ""

#: src/exception.md:89
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://pyo3.github.io/PyO3/pyo3/type.PyResult.html). This is an alias for "
"the type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:92
msgid ""
"A [`PyErr`](https://pyo3.github.io/PyO3/pyo3/struct.PyErr.html) represents a "
"Python exception. Errors within the `PyO3` library are also exposed as "
"Python exceptions."
msgstr ""

#: src/exception.md:95
msgid ""
"The [`ToPyErr`](https://pyo3.github.io/PyO3/pyo3/trait.ToPyErr.html) trait "
"provides a way to convert Rust errors to Python exceptions."
msgstr ""

#: src/exception.md:103
msgid ""
"It's implemented for most of the standard library's error types so that you "
"use [`Result::map_err()`](https://doc.rust-lang.org/std/result/enum.Result."
"html#method.map_err) to transform errors to Python exceptions as well as "
"taking advantage of `try!` macro or `?` operator."
msgstr ""

#: src/exception.md:114
msgid ""
"The code snippet above will raise `ValueError` in Python if `String::"
"parse()` return an error."
msgstr ""

#: src/function.md:1
msgid "Python Function"
msgstr ""

#: src/module.md:1
msgid "Python Module"
msgstr ""

#: src/module.md:3
msgid ""
"Python module generation is powered by unstable [Procedural Macros](https://"
"doc.rust-lang.org/book/first-edition/procedural-macros.html) feature, so you "
"need to turn on `proc_macro` feature:"
msgstr ""

#: src/module.md:12
msgid ""
"You need to change your `crate-type` to `cdylib` to produce a Python "
"compatible library:"
msgstr ""

#: src/module.md:14
msgid ""
"```toml\n"
"[lib]\n"
"name = \"rust2py\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.1\", features = [\"extension-module\"] }\n"
"```"
msgstr ""

#: src/module.md:23
msgid "Now you can write your module, for example"
msgstr ""

#: src/module.md:57
msgid ""
"The `modinit` procedural macro attribute takes care of exporting the "
"initialization function of your module to Python. It takes one argument as "
"the name of your module, it must be the name of the `.so` or `.pyd` file."
msgstr ""

#: src/module.md:59
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/first-edition/"
"comments.html) of the module initialization function will be applied "
"automatically as the Python doc string of your module."
msgstr ""

#: src/module.md:67
msgid ""
"Which means that the above Python code will print `This module is "
"implemented in Rust.`."
msgstr ""

#: src/module.md:69
msgid "On macOS, you will need to rename the output from `*.dylib` to `*.so`."
msgstr ""

#: src/module.md:71
msgid "On Windows, you will need to rename the output from `*.dll` to `*.pyd`."
msgstr ""

#: src/module.md:73
msgid ""
"For `setup.py` integration, You can use [setuptools-rust](https://github.com/"
"PyO3/setuptools-rust), learn more about it in [Distribution](./distribution."
"html)."
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:7
msgid "Type Conversions"
msgstr ""

#: src/conversions.md:3
msgid ""
"`PyO3` provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions.md:5
msgid "`ToPyObject` and `IntoPyObject` trait"
msgstr ""

#: src/conversions.md:7
msgid ""
"[`ToPyObject`](https://pyo3.github.io/PyO3/pyo3/trait.ToPyObject.html) trait "
"is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://pyo3.github.io/PyO3/pyo3/struct.PyObject.html). "
"[`IntoPyObject`](https://pyo3.github.io/PyO3/pyo3/trait.IntoPyObject.html) "
"serves the same purpose except it consumes `self`."
msgstr ""

#: src/conversions.md:9
msgid "`IntoPyTuple` trait"
msgstr ""

#: src/conversions.md:11
msgid ""
"[`IntoPyTuple`](https://pyo3.github.io/PyO3/pyo3/trait.IntoPyTuple.html) "
"trait is a conversion trait that allows various objects to be converted into "
"[`PyTuple`](https://pyo3.github.io/PyO3/pyo3/struct.PyTuple.html) object."
msgstr ""

#: src/conversions.md:13
msgid ""
"For example, [`IntoPyTuple`](https://pyo3.github.io/PyO3/pyo3/trait."
"IntoPyTuple.html) trait is implemented for `()` so that you can convert it "
"into a empty [`PyTuple`](https://pyo3.github.io/PyO3/pyo3/struct.PyTuple."
"html)"
msgstr ""

#: src/conversions.md:27
msgid "`FromPyObject` and `RefFromPyObject` trait"
msgstr ""
