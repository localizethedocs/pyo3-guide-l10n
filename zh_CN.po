msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr ""

#: src/advanced.md:3
msgid "FFI"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of Python's C API through the `ffi` module."
msgstr ""

#: src/advanced.md:7
msgid ""
"The C API is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that API."
msgstr ""

#: src/advanced.md:9
msgid "Testing"
msgstr ""

#: src/advanced.md:11
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For now you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/advanced.md:13
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.8.1\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/rust_cpython.md:1
msgid "Appendix A: PyO3 and rust-cpython"
msgstr ""

#: src/rust_cpython.md:3
msgid ""
"PyO3 began as fork of [rust-cpython](https://github.com/dgrunwald/rust-"
"cpython) when rust-cpython wasn't maintained. Over the time PyO3 has become "
"fundamentally different from rust-cpython."
msgstr ""

#: src/rust_cpython.md:5
msgid ""
"This chapter is based on the discussion in [PyO3/pyo3#55](https://github.com/"
"PyO3/pyo3/issues/55)."
msgstr ""

#: src/rust_cpython.md:7
msgid "Macros"
msgstr ""

#: src/rust_cpython.md:9
msgid ""
"While rust-cpython has a macro based dsl for declaring modules and classes, "
"PyO3 uses proc macros and specialization. PyO3 also doesn't change your "
"struct and functions so you can still use them as normal Rust functions. The "
"disadvantage is that specialization currently only works on nightly."
msgstr ""

#: src/rust_cpython.md:11 src/rust_cpython.md:54
msgid "**rust-cpython**"
msgstr ""

#: src/rust_cpython.md:25 src/rust_cpython.md:65
msgid "**pyo3**"
msgstr ""

#: src/rust_cpython.md:48
msgid "Ownership and lifetimes"
msgstr ""

#: src/rust_cpython.md:50
msgid ""
"All objects are owned by the PyO3 library and all APIs available with "
"references, while in rust-cpython, you own python objects."
msgstr ""

#: src/rust_cpython.md:52
msgid "Here is an example of the PyList API:"
msgstr ""

#: src/rust_cpython.md:76
msgid ""
"Because PyO3 allows only references to Python objects, all references have "
"the GIL lifetime. So the owned Python object is not required, and it is safe "
"to have functions like `fn py<'p>(&'p self) -> Python<'p> {}`."
msgstr ""

#: src/rust_cpython.md:78
msgid "Error handling"
msgstr ""

#: src/rust_cpython.md:80
msgid ""
"rust-cpython requires a `Python` parameter for constructing a `PyErr`, so "
"error handling ergonomics is pretty bad. It is not possible to use `?` with "
"Rust errors."
msgstr ""

#: src/rust_cpython.md:82
msgid ""
"PyO3 on other hand does not require `Python` for constructing a `PyErr`, it "
"is only required if you want to raise an exception in Python with the "
"`PyErr::restore()` method. Due to various `std::convert::From<E> for PyErr` "
"implementations for Rust standard error types `E`, propagating `?` is "
"supported automatically."
msgstr ""

#: src/migration.md:1
msgid "Appendix B: Migrating from older PyO3 versions"
msgstr ""

#: src/migration.md:2
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see [CHANGELOG.md]"
"(https://github.com/PyO3/pyo3/blob/master/CHANGELOG.md)"
msgstr ""

#: src/migration.md:3
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:5
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:6
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:9 src/migration.md:95 src/migration.md:122
#: src/migration.md:157
msgid "Before:"
msgstr ""

#: src/migration.md:23 src/migration.md:105 src/migration.md:129
#: src/migration.md:175
msgid "After:"
msgstr ""

#: src/migration.md:38
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](https://pyo3.rs/master/class.html#constructor) of "
"this guide."
msgstr ""

#: src/migration.md:41
msgid "PyCell"
msgstr ""

#: src/migration.md:42
msgid ""
"PyO3 0.9 introduces [`PyCell`](https://pyo3.rs/master/doc/pyo3/pycell/struct."
"PyCell.html), which is a [`RefCell`](https://doc.rust-lang.org/std/cell/"
"struct.RefCell.html)\\-like object wrapper for ensuring Rust's rules "
"regarding aliasing of references are upheld. For more detail, see the [Rust "
"Book's section on Rust's rules of references](https://doc.rust-lang.org/book/"
"ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:47
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:51
msgid "Here is an example."
msgstr ""

#: src/migration.md:73
msgid ""
"r\"\n"
"# try:\n"
"#    names.merge(names)\n"
"#    assert False, 'Unreachable'\n"
"# except RuntimeError as e:\n"
"#    isinstance(e, borrow_mut_err)\n"
"# \""
msgstr ""

#: src/migration.md:81
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/master/doc/pyo3/"
"pycell/struct.PyBorrowMutError.html) exception, since it requires two "
"mutable borrows of `names`."
msgstr ""

#: src/migration.md:85
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:87
msgid "Object creation"
msgstr ""

#: src/migration.md:88
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use [`PyCell::new`]"
"(https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html#method.new) "
"instead. If you need [`PyRef`](https://pyo3.rs/master/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/master/doc/pyo3/pycell/struct."
"PyRefMut.html), just call `.borrow()` or `.borrow_mut()` on the newly-"
"created `PyCell`."
msgstr ""

#: src/migration.md:116
msgid "Object extraction"
msgstr ""

#: src/migration.md:117
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:138
msgid "\"c\""
msgstr ""

#: src/migration.md:139
msgid "\"c()\""
msgstr ""

#: src/migration.md:142
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:145
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:151
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:152
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://docs.rs/pyo3/latest/pyo3/conversion/trait."
"FromPyObject.html) implementation. So if your protocol methods take `&T` or "
"`&mut T` (where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/master/"
"doc/pyo3/pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/master/"
"doc/pyo3/pycell/struct.PyRefMut.html) instead."
msgstr ""

#: src/building_and_distribution.md:1
msgid "Building and Distribution"
msgstr ""

#: src/building_and_distribution.md:3
msgid "Python version"
msgstr ""

#: src/building_and_distribution.md:5
msgid ""
"PyO3 uses a build script to determine the Python version and set the correct "
"linker arguments. By default it uses the `python3` executable. You can "
"override the Python interpreter by setting `PYTHON_SYS_EXECUTABLE`, e.g., "
"`PYTHON_SYS_EXECUTABLE=python3.6`."
msgstr ""

#: src/building_and_distribution.md:7
msgid "Linking"
msgstr ""

#: src/building_and_distribution.md:9
msgid ""
"Different linker arguments must be set for libraries/extension modules and "
"binaries, which includes both standalone binaries and tests. (More "
"specifically, binaries must be told where to find libpython and libraries "
"must not link to libpython for [manylinux](https://www.python.org/dev/peps/"
"pep-0513/) compliance)."
msgstr ""

#: src/building_and_distribution.md:11
msgid ""
"Since PyO3's build script can't know whether you're building a binary or a "
"library, you have to activate the `extension-module` feature to get the "
"build options for a library, or it'll default to binary."
msgstr ""

#: src/building_and_distribution.md:13
msgid ""
"If you have e.g. a library crate and a profiling crate alongside, you need "
"to use optional features. E.g. you put the following in the library crate:"
msgstr ""

#: src/building_and_distribution.md:15
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.6\"\n"
"\n"
"[lib]\n"
"name = \"hyperjson\"\n"
"crate-type = [\"rlib\", \"cdylib\"]\n"
"\n"
"[features]\n"
"default = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/building_and_distribution.md:27
msgid "And this in the profiling crate:"
msgstr ""

#: src/building_and_distribution.md:29
msgid ""
"```toml\n"
"[dependencies]\n"
"my_main_crate = { path = \"..\", default-features = false }\n"
"pyo3 = \"0.6\"\n"
"```"
msgstr ""

#: src/building_and_distribution.md:35
msgid ""
"On Linux/macOS you might have to change `LD_LIBRARY_PATH` to include "
"libpython, while on windows you might need to set `LIB` to include `pythonxy."
"lib` (where x and y are major and minor version), which is normally either "
"in the `libs` or `Lib` folder of a Python installation."
msgstr ""

#: src/building_and_distribution.md:37
msgid "Distribution"
msgstr ""

#: src/building_and_distribution.md:39
msgid ""
"There are two ways to distribute your module as a Python package: the old, "
"[setuptools-rust](https://github.com/PyO3/setuptools-rust), and the new, "
"[maturin](https://github.com/pyo3/maturin). setuptools-rust needs some "
"configuration files (`setup.py`, `MANIFEST.in`, `build-wheels.sh`, etc.) and "
"external tools (docker, twine). maturin doesn't need any configuration "
"files, however it does not support some functionality of setuptools such as "
"package data ([pyo3/maturin#258](https://github.com/PyO3/maturin/"
"issues/258))."
msgstr ""

#: src/building_and_distribution.md:41
msgid "Cross Compiling"
msgstr ""

#: src/building_and_distribution.md:43
msgid ""
"Cross compiling PyO3 modules is relatively straightforward and requires a "
"few pieces of software:"
msgstr ""

#: src/building_and_distribution.md:45
msgid "A toolchain for your target."
msgstr ""

#: src/building_and_distribution.md:46
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building_and_distribution.md:47
msgid "A Python interpreter that's already been compiled for your target."
msgstr ""

#: src/building_and_distribution.md:48
msgid "The headers that match the above interpreter."
msgstr ""

#: src/building_and_distribution.md:50
msgid ""
"See https://github.com/japaric/rust-cross for a primer on cross compiling "
"Rust in general."
msgstr ""

#: src/building_and_distribution.md:52
msgid ""
"After you've obtained the above, you can build a cross compiled PyO3 module "
"by setting a few extra environment variables:"
msgstr ""

#: src/building_and_distribution.md:54
msgid ""
"`PYO3_CROSS_INCLUDE_DIR`: This variable must be set to the directory "
"containing the headers for the target's Python interpreter."
msgstr ""

#: src/building_and_distribution.md:55
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable must be set to the directory containing "
"the target's libpython DSO."
msgstr ""

#: src/building_and_distribution.md:57
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building_and_distribution.md:60
msgid "\"/home/pyo3/cross/sysroot/usr/include\""
msgstr ""

#: src/building_and_distribution.md:61
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/python_from_rust.md:1
msgid "Calling Python in Rust code"
msgstr ""

#: src/python_from_rust.md:3
msgid ""
"These APIs work from Rust whenever you have a `Python` object handy, whether "
"PyO3 is built for an extension module or not."
msgstr ""

#: src/python_from_rust.md:6
msgid "Want to run just an expression? Then use `eval`."
msgstr ""

#: src/python_from_rust.md:8
msgid ""
"[`Python::eval`](https://pyo3.rs/master/doc/pyo3/struct.Python.html#method."
"eval) is a method to execute a [Python expression](https://docs.python."
"org/3.7/reference/expressions.html) and return the evaluated value as a "
"`&PyAny` object."
msgstr ""

#: src/python_from_rust.md:19
msgid "\"[i * 10 for i in range(5)]\""
msgstr ""

#: src/python_from_rust.md:28
msgid "Want to run statements? Then use `run`."
msgstr ""

#: src/python_from_rust.md:30
msgid ""
"[`Python::run`](https://pyo3.rs/master/doc/pyo3/struct.Python.html#method."
"run) is a method to execute one or more [Python statements](https://docs."
"python.org/3.7/reference/simple_stmts.html). This method returns nothing "
"(like any Python statement), but you can get access to manipulated objects "
"via the `locals` dict."
msgstr ""

#: src/python_from_rust.md:35
msgid ""
"You can also use the [`py_run!`](https://pyo3.rs/master/doc/pyo3/macro."
"py_run.html) macro, which is a shorthand for [`Python::run`](https://pyo3.rs/"
"master/doc/pyo3/struct.Python.html#method.run). Since [`py_run!`](https://"
"pyo3.rs/master/doc/pyo3/macro.py_run.html) panics on exceptions, we "
"recommend you use this macro only for quickly testing your Python extensions."
msgstr ""

#: src/python_from_rust.md:57
msgid "\"User {}(id: {})\""
msgstr ""

#: src/python_from_rust.md:64 src/python_from_rust.md:67
msgid "\"Yu\""
msgstr ""

#: src/python_from_rust.md:68
msgid ""
"r#\"\n"
"assert repr(userdata) == \"User Yu(id: 34)\"\n"
"assert userdata.as_tuple() == userdata_as_tuple\n"
"\"#"
msgstr ""

#: src/python_from_rust.md:75
msgid "You have a Python file or Python function? Then use `PyModule`."
msgstr ""

#: src/python_from_rust.md:77
msgid ""
"[PyModule](https://pyo3.rs/master/doc/pyo3/types/struct.PyModule.html) also "
"can execute Python code by calling its methods."
msgstr ""

#: src/python_from_rust.md:85
msgid ""
"r#\"\n"
"def relu(x):\n"
"    \"\"\"see https://en.wikipedia.org/wiki/"
"Rectifier_(neural_networks)\"\"\"\n"
"    return max(0.0, x)\n"
"\n"
"def leaky_relu(x, slope=0.01):\n"
"    return x if x >= 0 else x * slope\n"
"\"#"
msgstr ""

#: src/python_from_rust.md:92
msgid "\"activators.py\""
msgstr ""

#: src/python_from_rust.md:92
msgid "\"activators\""
msgstr ""

#: src/python_from_rust.md:94
msgid "\"relu\""
msgstr ""

#: src/python_from_rust.md:97
msgid "\"slope\""
msgstr ""

#: src/python_from_rust.md:99
msgid "\"leaky_relu\""
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/debugging.md:5
msgid ""
"PyO3's attributes (`#[pyclass]`, `#[pymodule]`, etc.) are [procedural macros]"
"(https://doc.rust-lang.org/reference/procedural-macros.html), which means "
"that they rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding `-Z trace-macros`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"See [cargo expand](https://github.com/dtolnay/cargo-expand) for a more "
"elaborate version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of Python, otherwise Valgrind won't "
"produce usable results. In Ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on Linux, use `ldd` with the name of your binary and check that you're "
"linking e.g. `libpython3.6dm.so.1.0` instead of `libpython3.6m.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for cpython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run Valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:40
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/get_started.md:1
msgid "PyO3"
msgstr ""

#: src/get_started.md:3
msgid ""
"[Rust](http://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/). This includes running and interacting with Python code from a Rust "
"binary, as well as writing native Python modules."
msgstr ""

#: src/get_started.md:5
msgid ""
"User Guide: [stable](https://pyo3.rs) | [master](https://pyo3.rs/master)"
msgstr ""

#: src/get_started.md:7
msgid "API Documentation: [master](https://pyo3.rs/master/doc)"
msgstr ""

#: src/get_started.md:9
msgid ""
"A comparison with rust-cpython can be found [in the guide](https://pyo3.rs/"
"master/rust_cpython.html)."
msgstr ""

#: src/get_started.md:11
msgid "Usage"
msgstr ""

#: src/get_started.md:13
msgid ""
"PyO3 supports Python 3.5 and up. The minimum required Rust version is 1.42.0-"
"nightly 2019-01-21."
msgstr ""

#: src/get_started.md:15
msgid ""
"If you have never used nightly Rust, the official guide has [a great section]"
"(https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#rustup-and-the-"
"role-of-rust-nightly) about installing it."
msgstr ""

#: src/get_started.md:19
msgid ""
"PyPy is also supported (via cpyext) for Python 3.5 only, targeted PyPy "
"version is 7.0.0. Please refer to the [pypy section](https://pyo3.rs/master/"
"pypy.html)."
msgstr ""

#: src/get_started.md:22
msgid ""
"You can either write a native Python module in Rust, or use Python from a "
"Rust binary."
msgstr ""

#: src/get_started.md:24
msgid ""
"However, on some OSs, you need some additional packages. E.g. if you are on "
"_Ubuntu 18.04_, please run"
msgstr ""

#: src/get_started.md:30
msgid "Using Rust from Python"
msgstr ""

#: src/get_started.md:32
msgid "PyO3 can be used to generate a native Python module."
msgstr ""

#: src/get_started.md:34
msgid "**`Cargo.toml`**"
msgstr ""

#: src/get_started.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"string-sum\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"\n"
"[lib]\n"
"name = \"string_sum\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies.pyo3]\n"
"version = \"0.9.2\"\n"
"features = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/get_started.md:51
msgid "**`src/lib.rs`**"
msgstr ""

#: src/get_started.md:57
msgid "/// Formats the sum of two numbers as string.\n"
msgstr ""

#: src/get_started.md:63
msgid "/// A Python module implemented in Rust.\n"
msgstr ""

#: src/get_started.md:72
msgid ""
"On Windows and Linux, you can build normally with `cargo build --release`. "
"On macOS, you need to set additional linker arguments. One option is to "
"compile with `cargo rustc --release -- -C link-arg=-undefined -C link-"
"arg=dynamic_lookup`, the other is to create a `.cargo/config` with the "
"following content:"
msgstr ""

#: src/get_started.md:74
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/get_started.md:82
msgid ""
"While developing, you can symlink (or copy) and rename the shared library "
"from the target folder: On MacOS, rename `libstring_sum.dylib` to "
"`string_sum.so`, on Windows `libstring_sum.dll` to `string_sum.pyd`, and on "
"Linux `libstring_sum.so` to `string_sum.so`. Then open a Python shell in the "
"same folder and you'll be able to `import string_sum`."
msgstr ""

#: src/get_started.md:84
msgid ""
"To build, test and publish your crate as a Python module, you can use "
"[maturin](https://github.com/PyO3/maturin) or [setuptools-rust](https://"
"github.com/PyO3/setuptools-rust). You can find an example for setuptools-"
"rust in [examples/word-count](https://github.com/PyO3/pyo3/tree/master/"
"examples/word-count), while maturin should work on your crate without any "
"configuration."
msgstr ""

#: src/get_started.md:86
msgid "Using Python from Rust"
msgstr ""

#: src/get_started.md:88
msgid ""
"If you want your Rust application to create a Python interpreter internally "
"and use it to run Python code, add `pyo3` to your `Cargo.toml` like this:"
msgstr ""

#: src/get_started.md:91
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.9.2\"\n"
"```"
msgstr ""

#: src/get_started.md:96
msgid ""
"Example program displaying the value of `sys.version` and the current user "
"name:"
msgstr ""

#: src/get_started.md:106
msgid ""
"// We can't display Python exceptions via std::fmt::Display,\n"
"        // so print the error here manually.\n"
msgstr ""

#: src/get_started.md:113
msgid "\"sys\""
msgstr ""

#: src/get_started.md:114
msgid "\"version\""
msgstr ""

#: src/get_started.md:115
msgid "\"os\""
msgstr ""

#: src/get_started.md:116
msgid "\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\""
msgstr ""

#: src/get_started.md:118
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/get_started.md:123
msgid ""
"Our guide has [a section](https://pyo3.rs/master/python_from_rust.html) with "
"lots of examples about this topic."
msgstr ""

#: src/get_started.md:126
msgid "Examples and tooling"
msgstr ""

#: src/get_started.md:128
msgid ""
"[examples/word-count](https://github.com/PyO3/pyo3/tree/master/examples/word-"
"count) _Counting the occurrences of a word in a text file_"
msgstr ""

#: src/get_started.md:129
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json_"
msgstr ""

#: src/get_started.md:130
msgid ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _Rust binding of NumPy C-"
"API_"
msgstr ""

#: src/get_started.md:131
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/master/html-py-"
"ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""

#: src/get_started.md:132
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://pyo3.github.io/pyo3/pyo3/struct.PyDict.html)_"
msgstr ""

#: src/get_started.md:133
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library_"
msgstr ""

#: src/get_started.md:134
msgid ""
"[autopy](https://github.com/autopilot-rs/autopy) _A simple, cross-platform "
"GUI automation library for Python and Rust._"
msgstr ""

#: src/get_started.md:135
msgid ""
"Contains an example of building wheels on TravisCI and appveyor using "
"[cibuildwheel](https://github.com/joerick/cibuildwheel)"
msgstr ""

#: src/get_started.md:136
msgid "[orjson](https://github.com/ijl/orjson)  _Fast Python JSON library_"
msgstr ""

#: src/get_started.md:137
msgid ""
"[inline-python](https://github.com/dronesforwork/inline-python) _Inline "
"Python code directly in your Rust code_"
msgstr ""

#: src/get_started.md:138
msgid ""
"[Rogue-Gym](https://github.com/kngwyu/rogue-gym) _Customizable rogue-like "
"game for AI experiments_"
msgstr ""

#: src/get_started.md:139
msgid "Contains an example of building wheels on Azure Pipelines"
msgstr ""

#: src/get_started.md:140
msgid ""
"[fastuuid](https://github.com/thedrow/fastuuid/) _Python bindings to Rust's "
"UUID library_"
msgstr ""

#: src/get_started.md:141
msgid ""
"[python-ext-wasm](https://github.com/wasmerio/python-ext-wasm) _Python "
"library to run WebAssembly binaries_"
msgstr ""

#: src/get_started.md:142
msgid ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject to automatically transform Python dicts into Rust structs_"
msgstr ""

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "Mutability and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`PyObject::clone_ref`](https://docs.rs/pyo3/latest/pyo3/struct.PyObject."
"html#method.clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://docs.rs/pyo3/latest/pyo3/"
"types/struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe acces to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:47
msgid "Object types"
msgstr ""

#: src/types.md:49
msgid "`PyObject`"
msgstr ""

#: src/types.md:51
msgid ""
"**Represents:** a GIL independent reference to a Python object of "
"unspecified type."
msgstr ""

#: src/types.md:54
msgid ""
"**Used:** Whenever you want to carry around references to \"some\" Python "
"object, without caring about a GIL lifetime.  For example, storing Python "
"object references in a Rust struct that outlives the Python-Rust FFI "
"boundary, or returning objects from functions implemented in Rust back to "
"Python."
msgstr ""

#: src/types.md:59
msgid "Can be cloned using Python reference counts with `.clone_ref()`."
msgstr ""

#: src/types.md:61 src/types.md:76 src/types.md:97 src/types.md:111
#: src/types.md:127
msgid "**Conversions:**"
msgstr ""

#: src/types.md:63
msgid "To `&PyAny`: `obj.as_ref(py)`"
msgstr ""

#: src/types.md:64
msgid "To `Py<ConcreteType>`: `obj.as_ref(py).extract::<Py<ConcreteType>>`"
msgstr ""

#: src/types.md:65
msgid ""
"To `&ConcreteType` (which must be a Python native type): `obj.cast_as(py)`"
msgstr ""

#: src/types.md:68
msgid "`Py<SomeType>`"
msgstr ""

#: src/types.md:70
msgid ""
"**Represents:** a GIL independent reference to a Python object of known "
"type. This can be a Python native type (like `PyTuple`), or a `pyclass` type "
"implemented in Rust."
msgstr ""

#: src/types.md:74
msgid "**Used:** Like `PyObject`, but with a known inner type."
msgstr ""

#: src/types.md:78 src/types.md:99
msgid "To `PyObject`: `obj.to_object(py)`"
msgstr ""

#: src/types.md:79
msgid ""
"To `&SomeType` or `&PyCell<SomeType>`: `obj.as_ref(py)`.  For `pyclass` "
"types implemented in Rust, you get a `PyCell` (see below).  For Python "
"native types, mutating operations through PyO3's API don't require `&mut` "
"access."
msgstr ""

#: src/types.md:83
msgid ""
"**Note:** `PyObject` is semantically equivalent to `Py<PyAny>` and might be "
"merged with it in the future."
msgstr ""

#: src/types.md:87
msgid "`PyAny`"
msgstr ""

#: src/types.md:89
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, usually "
"`&PyAny`."
msgstr ""

#: src/types.md:93
msgid ""
"**Used:** Whenever you want to refer to some Python object only as long as "
"holding the GIL.  For example, intermediate values and arguments to "
"`pyfunction`s or `pymethod`s implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:102
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:104
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:107
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:113
msgid "To `PyAny`: `obj.as_ref()`"
msgstr ""

#: src/types.md:114
msgid "To `Py<T>`: `Py::from(obj)`"
msgstr ""

#: src/types.md:117
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:119
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:123
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:129
msgid "From `PyAny`: `.downcast()`"
msgstr ""

#: src/types.md:132
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:134
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:137
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:142
msgid "Related traits and types"
msgstr ""

#: src/types.md:144
msgid "`PyClass`"
msgstr ""

#: src/types.md:146
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:149
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:151
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"CPython has the infamous GIL (Global Interpreter Lock), which prevents "
"developers from getting true parallelism when running pure Python code. "
"While PyO3 needs to hold the GIL by default when called from Python, in "
"order to allow manipulation of Python objects, you can release the GIL when "
"executing Rust-only code to achieve true parallelism."
msgstr ""

#: src/parallelism.md:9
msgid ""
"The [`Python::allow_threads`](https://docs.rs/pyo3/latest/pyo3/struct.Python."
"html#method.allow_threads) method temporarily releases the GIL, thus "
"allowing other Python threads to run."
msgstr ""

#: src/parallelism.md:17
msgid ""
"Let's take a look at our [word-count](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/src/lib.rs) example, where we have a "
"`wc_parallel` function that utilizes the [rayon](https://github.com/"
"nikomatsakis/rayon) crate to count words in parallel."
msgstr ""

#: src/parallelism.md:28
msgid ""
"Then in the Python bridge, we have a function `search` exposed to the Python "
"runtime which calls `wc_parallel` inside a closure passed to [`Python::"
"allow_threads`](https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method."
"allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:35
msgid "\"search\""
msgstr ""

#: src/parallelism.md:49
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:51
msgid ""
"Let's benchmark the `word-count` example to verify that we did unlock true "
"parallelism with PyO3. We are using `pytest-benchmark` to benchmark three "
"word count functions:"
msgstr ""

#: src/parallelism.md:54
msgid ""
"[Pure Python version](https://github.com/PyO3/pyo3/blob/master/examples/word-"
"count/word_count/__init__.py#L9)"
msgstr ""

#: src/parallelism.md:55
msgid ""
"[Rust sequential version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L64)"
msgstr ""

#: src/parallelism.md:56
msgid ""
"[Rust parallel version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L54)"
msgstr ""

#: src/parallelism.md:58
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/tests/test_word_count.py), then we can run "
"`pytest tests` to benchmark them."
msgstr ""

#: src/parallelism.md:61
msgid "On MacBook Pro (Retina, 15-inch, Mid 2015) the benchmark gives:"
msgstr ""

#: src/parallelism.md:63
msgid ""
"![Benchmark Result](https://user-images.githubusercontent."
"com/1556054/28604608-81bd6d22-71fe-11e7-8a2c-c3cf3bd0f622.png)"
msgstr ""

#: src/pypy.md:1
msgid "PyPy Support"
msgstr ""

#: src/pypy.md:3
msgid "Using PyPy is supported via cpyext."
msgstr ""

#: src/pypy.md:5
msgid ""
"Support is only provided for building Rust extension for code running under "
"PyPy. This means that PyPy **cannot** be called from rust via cpyext. Note "
"that there some differences in the ffi module between PyPy and CPython."
msgstr ""

#: src/pypy.md:7
msgid ""
"This is a limitation of cpyext and support for embedding cpyext is not "
"planned."
msgstr ""

#: src/pypy.md:9
msgid ""
"Compilation against PyPy is done by exporting the `PYTHON_SYS_EXECUTABLE` to "
"point to a PyPy binary or by compiling in a PyPy virtualenv."
msgstr ""

#: src/pypy.md:11
msgid ""
"For example, `PYTHON_SYS_EXECUTABLE=\"/path/to/pypy3\" /path/to/pypy3 setup."
"py install`"
msgstr ""

#: src/pypy.md:14
msgid "Unsupported features"
msgstr ""

#: src/pypy.md:16
msgid ""
"These are features currently supported by PyO3, but not yet implemented in "
"cpyext."
msgstr ""

#: src/pypy.md:18
msgid "Complex number functions (`_Py_c_sum`, `_Py_c_sum` ..)"
msgstr ""

#: src/pypy.md:19
msgid "Conversion to rust's i128, u128 types."
msgstr ""

#: src/pypy.md:20
msgid "`PySequence_Count` (which is used to count number of element in array)"
msgstr ""

#: src/pypy.md:21
msgid "`PyDict_MergeFromSeq2` (used in `PyDict::from_sequence`)"
msgstr ""

#: src/class.md:1
msgid "Python Classes"
msgstr ""

#: src/class.md:3
msgid "Defining a new class"
msgstr ""

#: src/class.md:5
msgid ""
"To define a custom Python class, a Rust struct needs to be annotated with "
"the `#[pyclass]` attribute."
msgstr ""

#: src/class.md:17
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://docs."
"rs/pyo3/latest/pyo3/type_object/trait.PyTypeInfo.html), [`PyTypeObject`]"
"(https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeObject.html), and "
"[`PyClass`](https://pyo3.rs/master/doc/pyo3/pyclass/trait.PyClass.html) for "
"`MyClass`."
msgstr ""

#: src/class.md:20
msgid "Specifically, the following implementation is generated:"
msgstr ""

#: src/class.md:24
msgid "/// Class for demonstration\n"
msgstr ""

#: src/class.md:41
msgid "\"MyClass\""
msgstr ""

#: src/class.md:43
msgid "\"Class for demonstration\""
msgstr ""

#: src/class.md:88
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""

#: src/class.md:91
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:93
msgid ""
"Custom Python classes can then be added to a module using `add_class()`."
msgstr ""

#: src/class.md:109
msgid "PyCell and interior mutability"
msgstr ""

#: src/class.md:111
msgid ""
"You sometimes need to convert your `pyclass` into a Python object and access "
"it from Rust code (e.g., for testing it). [`PyCell`](https://pyo3.rs/master/"
"doc/pyo3/pycell/struct.PyCell.html) is the primary interface for that."
msgstr ""

#: src/class.md:115
msgid ""
"`PyCell<T: PyClass>` is always allocated in the Python heap, so Rust doesn't "
"have ownership of it. In other words, Rust code can only extract a "
"`&PyCell<T>`, not a `PyCell<T>`."
msgstr ""

#: src/class.md:118
msgid ""
"Thus, to mutate data behind `&PyCell` safely, PyO3 employs the [Interior "
"Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-"
"mutability.html) like [`RefCell`](https://doc.rust-lang.org/std/cell/struct."
"RefCell.html)."
msgstr ""

#: src/class.md:122
msgid ""
"Users who are familiar with `RefCell` can use `PyCell` just like `RefCell`."
msgstr ""

#: src/class.md:124
msgid ""
"For users who are not very familiar with `RefCell`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:125
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:126
msgid "References must always be valid."
msgstr ""

#: src/class.md:128
msgid ""
"`PyCell`, like `RefCell`, ensures these borrowing rules by tracking "
"references at runtime."
msgstr ""

#: src/class.md:143
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:145
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:149
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:151
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:155
msgid "// You can convert `&PyCell` to a Python object\n"
msgstr ""

#: src/class.md:157
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:160
msgid ""
"`&PyCell<T>` is bounded by the same lifetime as a [`GILGuard`](https://docs."
"rs/pyo3/latest/pyo3/struct.GILGuard.html). To make the object longer lived "
"(for example, to store it in a struct on the Rust side), you can use "
"`Py<T>`, which stores an object longer than the GIL lifetime, and therefore "
"needs a `Python<'_>` token to access."
msgstr ""

#: src/class.md:178
msgid "// AsPyRef::as_ref returns &PyCell\n"
msgstr ""

#: src/class.md:179
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:183
msgid "Customizing the class"
msgstr ""

#: src/class.md:185
msgid "The `#[pyclass]` macro accepts the following parameters:"
msgstr ""

#: src/class.md:187
msgid ""
"`name=XXX` - Set the class name shown in Python code. By default, the struct "
"name is used as the class name."
msgstr ""

#: src/class.md:188
msgid ""
"`freelist=XXX` - The `freelist` parameter adds support of free allocation "
"list to custom class. The performance improvement applies to types that are "
"often created and deleted in a row, so that they can benefit from a "
"freelist. `XXX` is a number of items for the free list."
msgstr ""

#: src/class.md:191
msgid ""
"`gc` - Classes with the `gc` parameter participate in Python garbage "
"collection. If a custom class contains references to other Python objects "
"that can be collected, the [`PyGCProtocol`](https://docs.rs/pyo3/latest/pyo3/"
"class/gc/trait.PyGCProtocol.html) trait has to be implemented."
msgstr ""

#: src/class.md:193
msgid "`weakref` - Adds support for Python weak references."
msgstr ""

#: src/class.md:194
msgid ""
"`extends=BaseType` - Use a custom base class. The base `BaseType` must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:195
msgid "`subclass` - Allows Python classes to inherit from this class."
msgstr ""

#: src/class.md:196
msgid ""
"`dict` - Adds `__dict__` support, so that the instances of this type have a "
"dictionary containing arbitrary instance variables."
msgstr ""

#: src/class.md:197
msgid ""
"`module=\"XXX\"` - Set the name of the module the class will be shown as "
"defined in. If not given, the class will be a virtual member of the "
"`builtins` module."
msgstr ""

#: src/class.md:200
msgid "Constructor"
msgstr ""

#: src/class.md:202
msgid ""
"By default it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:222
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:225
msgid "For arguments, see the `Method arguments` section below."
msgstr ""

#: src/class.md:227
msgid "Return type"
msgstr ""

#: src/class.md:229
msgid ""
"Generally, `#[new]` method have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:232
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:235
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:235
msgid "**May fail**"
msgstr ""

#: src/class.md:237
msgid "**No inheritance**"
msgstr ""

#: src/class.md:237
msgid "`T`"
msgstr ""

#: src/class.md:237
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:238
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:238
msgid "`(T, U)`"
msgstr ""

#: src/class.md:238
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:239
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:239
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/master/doc/pyo3/pyclass_init/"
"struct.PyClassInitializer.html)"
msgstr ""

#: src/class.md:239
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:241
msgid "Inheritance"
msgstr ""

#: src/class.md:243
msgid ""
"By default, `PyAny` is used as the base class. To override this default, use "
"the `extends` parameter for `pyclass` with the full path to the base class."
msgstr ""

#: src/class.md:246
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the baseclass of `T`. But for more deeply nested inheritance, you have to "
"return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:251
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/master/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_ref()` as `&Self::BaseClass`, or by `self_.into_super()` as `PyRef<Self::"
"BaseClass>`."
msgstr ""

#: src/class.md:289
msgid "// Get &BaseClass\n"
msgstr ""

#: src/class.md:309
msgid "// Get PyRef<SubClass>\n"
msgstr ""

#: src/class.md:316
msgid "\"assert subsub.method3() == 3000\""
msgstr ""

#: src/class.md:319
msgid ""
"You can also inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/master/doc/pyo3/type_object/trait."
"PySizedLayout.html)."
msgstr ""

#: src/class.md:322
msgid ""
"However, because of some technical problems, we don't currently provide safe "
"upcasting methods for types that inherit native types. Even in such cases, "
"you can unsafely get a base class by raw pointer conversion."
msgstr ""

#: src/class.md:353
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:356
msgid ""
"If `SubClass` does not provide a baseclass initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:379
msgid "Object properties"
msgstr ""

#: src/class.md:381
msgid ""
"Property descriptor methods can be defined in a `#[pymethods]` `impl` block "
"only and have to be annotated with `#[getter]` and `#[setter]` attributes. "
"For example:"
msgstr ""

#: src/class.md:400
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:403
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:430
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:432
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:456
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:458
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can also declare getters and setters in your Rust struct "
"field definition, for example:"
msgstr ""

#: src/class.md:470
msgid "Then it is available from Python code as `self.num`."
msgstr ""

#: src/class.md:472
msgid "Instance methods"
msgstr ""

#: src/class.md:474
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:478
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust."
msgstr ""

#: src/class.md:500
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:504
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:522
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:524
msgid "Class methods"
msgstr ""

#: src/class.md:526
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute."
msgstr ""

#: src/class.md:546
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:548
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:550
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:551
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:552
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:554
msgid "Static methods"
msgstr ""

#: src/class.md:556
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:576
msgid "Callable objects"
msgstr ""

#: src/class.md:578
msgid ""
"To specify a custom `__call__` method for a custom class, the method needs "
"to be annotated with the `#[call]` attribute. Arguments of the method are "
"specified as for instance methods."
msgstr ""

#: src/class.md:592 src/class.md:642
msgid "\"*\""
msgstr ""

#: src/class.md:594
msgid "\"MyClass has been called\""
msgstr ""

#: src/class.md:600
msgid "Method arguments"
msgstr ""

#: src/class.md:602
msgid ""
"By default, PyO3 uses function signatures to determine which arguments are "
"required. Then it scans the incoming `args` and `kwargs` parameters. If it "
"can not find all required parameters, it raises a `TypeError` exception. It "
"is possible to override the default behavior with the `#[args(...)]` "
"attribute. This attribute accepts a comma separated list of parameters in "
"the form of `attr_name=\"default value\"`. Each parameter has to match the "
"method parameter by name."
msgstr ""

#: src/class.md:608
msgid "Each parameter can be one of the following types:"
msgstr ""

#: src/class.md:610
msgid ""
"`\"*\"`: var arguments separator, each parameter defined after `\"*\"` is a "
"keyword-only parameter. Corresponds to python's `def meth(*, arg1.., "
"arg2=..)`."
msgstr ""

#: src/class.md:612
msgid ""
"`args=\"*\"`: \"args\" is var args, corresponds to Python's `def "
"meth(*args)`. Type of the `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:614
msgid ""
"`kwargs=\"**\"`: \"kwargs\" receives keyword arguments, corresponds to "
"Python's `def meth(**kwargs)`. The type of the `kwargs` parameter has to be "
"`Option<&PyDict>`."
msgstr ""

#: src/class.md:616
msgid ""
"`arg=\"Value\"`: arguments with default value. Corresponds to Python's `def "
"meth(arg=Value)`. If the `arg` argument is defined after var arguments, it "
"is treated as a keyword-only argument. Note that `Value` has to be valid "
"rust code, PyO3 just inserts it into the generated code unmodified."
msgstr ""

#: src/class.md:621 src/class.md:813
msgid "Example:"
msgstr ""

#: src/class.md:634
msgid "\"-1\""
msgstr ""

#: src/class.md:634 src/class.md:641
msgid "\"true\""
msgstr ""

#: src/class.md:640
msgid "\"10\""
msgstr ""

#: src/class.md:643
msgid "\"\\\"Hello\\\"\""
msgstr ""

#: src/class.md:644
msgid "\"**\""
msgstr ""

#: src/class.md:657
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={}, debug={}\""
msgstr ""

#: src/class.md:665
msgid "\"num={}, debug={}\""
msgstr ""

#: src/class.md:669
msgid ""
"N.B. the position of the `\"*\"` argument (if included) controls the system "
"of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/class.md:674 src/class.md:675
msgid "\"World\""
msgstr ""

#: src/class.md:679
msgid "Produces output:"
msgstr ""

#: src/class.md:687
msgid "Class customizations"
msgstr ""

#: src/class.md:689
msgid ""
"Python's object model defines several protocols for different object "
"behavior, like sequence, mapping or number protocols. PyO3 defines separate "
"traits for each of them. To provide specific Python object behavior, you "
"need to implement the specific trait for your struct. Important note, each "
"protocol implementation block has to be annotated with the `#[pyproto]` "
"attribute."
msgstr ""

#: src/class.md:694
msgid "Basic object customization"
msgstr ""

#: src/class.md:696
msgid ""
"The [`PyObjectProtocol`](https://docs.rs/pyo3/latest/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provides several basic customizations."
msgstr ""

#: src/class.md:698
msgid "Attribute access"
msgstr ""

#: src/class.md:700
msgid "To customize object attribute access, define the following methods:"
msgstr ""

#: src/class.md:702
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl "
"IntoPy<PyObject>>`"
msgstr ""

#: src/class.md:703
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:704
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:706
msgid ""
"Each method corresponds to Python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:708
msgid "String Conversions"
msgstr ""

#: src/class.md:710
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:711
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:713
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`."
msgstr ""

#: src/class.md:715
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:717
msgid "Provides the conversion to `bytes`."
msgstr ""

#: src/class.md:719
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:721
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:724
msgid "Comparison operators"
msgstr ""

#: src/class.md:726
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:728
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:734
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:736
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:739
msgid "Other methods"
msgstr ""

#: src/class.md:741
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:743
msgid "Determines the \"truthyness\" of the object."
msgstr ""

#: src/class.md:745
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:747
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement the [`PyGCProtocol`](https://docs.rs/pyo3/"
"latest/pyo3/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another Python object. `__clear__` "
"must clear out any mutable references to other Python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:781
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:790
msgid ""
"Special protocol trait implementations have to be annotated with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class.md:792
msgid ""
"It is also possible to enable GC for custom classes using the `gc` parameter "
"of the `pyclass` attribute. i.e. `#[pyclass(gc)]`. In that case instances of "
"custom class participate in Python garbage collection, and it is possible to "
"track them with `gc` module methods. When using the `gc` parameter, it is "
"_required_ to implement the `PyGCProtocol` trait, failure to do so will "
"result in an error at compile time:"
msgstr ""

#: src/class.md:798
msgid ""
"```compile_fail\n"
"#[pyclass(gc)]\n"
"struct GCTracked {} // Fails because it does not implement PyGCProtocol\n"
"```"
msgstr ""

#: src/class.md:803
msgid "Iterator Types"
msgstr ""

#: src/class.md:805
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://docs.rs/pyo3/"
"latest/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:808
msgid "`fn __iter__(slf: PyRefMut<Self>) -> PyResult<impl IntoPy<PyObject>>`"
msgstr ""

#: src/class.md:809
msgid ""
"`fn __next__(slf: PyRefMut<Self>) -> PyResult<Option<impl IntoPy<PyObject>>>`"
msgstr ""

#: src/class.md:811
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""

#: src/class.md:835
msgid "How methods are implemented"
msgstr ""

#: src/class.md:837
msgid ""
"Users should be able to define a `#[pyclass]` with or without "
"`#[pymethods]`, while PyO3 needs a trait with a function that returns all "
"methods. Since it's impossible to make the code generation in pyclass "
"dependent on whether there is an impl block, we'd need to implement the "
"trait on `#[pyclass]` and override the implementation in `#[pymethods]`, "
"which is to the best of my knowledge only possible with the specialization "
"feature, which can't be used on stable."
msgstr ""

#: src/class.md:843
msgid ""
"To escape this we use [inventory](https://github.com/dtolnay/inventory), "
"which allows us to collect `impl`s from arbitrary source code by exploiting "
"some binary trick. See [inventory: how it works](https://github.com/dtolnay/"
"inventory#how-it-works) and `pyo3_derive_backend::py_class::impl_inventory` "
"for more details."
msgstr ""

#: src/exception.md:1
msgid "Python Exceptions"
msgstr ""

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"You can use the [`create_exception!`](https://docs.rs/pyo3/latest/pyo3/macro."
"create_exception.html) macro to define a new exception type:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr ""

#: src/exception.md:29
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:31
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:32
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:36
msgid "Raising an exception"
msgstr ""

#: src/exception.md:38
msgid ""
"To raise an exception, first you need to obtain an exception type and "
"construct a new [`PyErr`](https://docs.rs/pyo3/latest/pyo3/struct.PyErr."
"html), then call the [`PyErr::restore`](https://docs.rs/pyo3/latest/pyo3/"
"struct.PyErr.html#method.restore) method to write the exception back to the "
"Python interpreter's global state."
msgstr ""

#: src/exception.md:47
msgid "\"Error\""
msgstr ""

#: src/exception.md:53
msgid ""
"From `pyfunction`s and `pyclass` methods, returning an `Err(PyErr)` is "
"enough; PyO3 will handle restoring the exception on the Python interpreter "
"side."
msgstr ""

#: src/exception.md:56
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance`](https://docs.rs/pyo3/latest/pyo3/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:62
msgid ""
"If a Rust type exists for the exception, then it is possible to use the "
"`py_err` method. For example, each standard exception defined in the `pyo3::"
"exceptions` module has a corresponding Rust type, exceptions defined by "
"[`create_exception!`](https://docs.rs/pyo3/latest/pyo3/macro."
"create_exception.html) and [`import_exception!`](https://docs.rs/pyo3/latest/"
"pyo3/macro.import_exception.html) macro have Rust types as well."
msgstr ""

#: src/exception.md:73
msgid "\"argument is wrong\""
msgstr ""

#: src/exception.md:80
msgid "Checking exception types"
msgstr ""

#: src/exception.md:82
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type, in PyO3 there is a "
"[`Python::is_instance`](https://docs.rs/pyo3/latest/pyo3/struct.Python."
"html#method.is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:98
msgid ""
"[`Python::is_instance`](https://docs.rs/pyo3/latest/pyo3/struct.Python."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://docs.rs/pyo3/latest/pyo3/types/struct.PyType.html#method."
"is_instance) method to do the actual work."
msgstr ""

#: src/exception.md:101
msgid "To check the type of an exception, you can simply do:"
msgstr ""

#: src/exception.md:114
msgid "Handling Rust errors"
msgstr ""

#: src/exception.md:116
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://docs.rs/pyo3/latest/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:119
msgid ""
"A [`PyErr`](https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html) represents a "
"Python exception. Errors within the PyO3 library are also exposed as Python "
"exceptions."
msgstr ""

#: src/exception.md:122
msgid ""
"The PyO3 library handles Python exceptions in two stages. During the first "
"stage, a [`PyErr`](https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html) "
"instance is created. At this stage, holding Python's GIL is not required. "
"During the second stage, an actual Python exception instance is created and "
"set active in the Python interpreter."
msgstr ""

#: src/exception.md:126
msgid ""
"In simple cases, for custom errors adding an implementation of `std::"
"convert::From<T>` trait for this custom error is enough. `PyErr::new` "
"accepts an argument in the form of `ToPyObject + 'static`. If the `'static` "
"constraint can not be satisfied or more complex arguments are required, the "
"[`PyErrArguments`](https://docs.rs/pyo3/latest/pyo3/trait.PyErrArguments."
"html) trait can be implemented. In that case, actual exception argument "
"creation is delayed until a `Python` object is available."
msgstr ""

#: src/exception.md:146
msgid "\"Oh no!\""
msgstr ""

#: src/exception.md:160
msgid "\"127.0.0.1:80\""
msgstr ""

#: src/exception.md:165
msgid ""
"The code snippet above will raise an `OSError` in Python if `bind()` returns "
"a `CustomIOError`."
msgstr ""

#: src/exception.md:167
msgid ""
"The `std::convert::From<T>` trait is implemented for most of the Rust "
"standard library's error types so the `?` operator can be used."
msgstr ""

#: src/exception.md:178
msgid ""
"The code snippet above will raise a `ValueError` in Python if `String::"
"parse()` returns an error."
msgstr ""

#: src/exception.md:181
msgid "Using exceptions defined in Python code"
msgstr ""

#: src/exception.md:183
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The `import_exception!` macro allows importing a specific exception "
"class and defines a zero-sized Rust type for that exception."
msgstr ""

#: src/exception.md:199
msgid "\"tell\""
msgstr ""

#: src/exception.md:200
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:207
msgid ""
"[`pyo3::exceptions`](https://docs.rs/pyo3/latest/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""

#: src/function.md:1
msgid "Python Functions"
msgstr ""

#: src/function.md:3
msgid ""
"PyO3 supports two ways to define a free function in Python. Both require "
"registering the function to a [module](./module.md)."
msgstr ""

#: src/function.md:6
msgid ""
"One way is defining the function in the module definition, annotated with "
"`#[pyfn]`."
msgstr ""

#: src/function.md:14
msgid "\"sum_as_string\""
msgstr ""

#: src/function.md:16
msgid "\"{}\""
msgstr ""

#: src/function.md:25
msgid ""
"The other is annotating a function with `#[pyfunction]` and then adding it "
"to the module using the `wrap_pyfunction!` macro."
msgstr ""

#: src/function.md:47
msgid "Argument parsing"
msgstr ""

#: src/function.md:49
msgid ""
"Both the `#[pyfunction]` and `#[pyfn]` attributes support specifying details "
"of argument parsing.  The details are given in the section \"Method "
"arguments\" in the [Classes](class.md) chapter.  Here is an example for a "
"function that accepts arbitrary keyword arguments (`**kwargs` in Python "
"syntax) and returns the number that was passed:"
msgstr ""

#: src/function.md:75
msgid "Making the function signature available to Python"
msgstr ""

#: src/function.md:77
msgid ""
"In order to make the function signature available to Python to be retrieved "
"via `inspect.signature`, use the `#[text_signature]` annotation as in the "
"example below. The `/` signifies the end of positional-only arguments. (This "
"is not a feature of this library in particular, but the general format used "
"by CPython for annotating signatures of built-in functions.)"
msgstr ""

#: src/function.md:85
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:88
msgid "\"(a, b, /)\""
msgstr ""

#: src/function.md:94
msgid "This also works for classes and methods:"
msgstr ""

#: src/function.md:99
msgid "// it works even if the item is not documented:\n"
msgstr ""

#: src/function.md:103
msgid "\"(c, d, /)\""
msgstr ""

#: src/function.md:108
msgid ""
"// the signature for the constructor is attached\n"
"    // to the struct definition instead.\n"
msgstr ""

#: src/function.md:114
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/function.md:115
msgid "\"($self, e, f)\""
msgstr ""

#: src/function.md:120
msgid "\"(cls, e, f)\""
msgstr ""

#: src/function.md:125
msgid "\"(e, f)\""
msgstr ""

#: src/function.md:132
msgid "Making the function signature available to Python (old method)"
msgstr ""

#: src/function.md:134
msgid ""
"Alternatively, simply make sure the first line of your docstring is "
"formatted like in the following example. Please note that the newline after "
"the `--` is mandatory. The `/` signifies the end of positional-only "
"arguments."
msgstr ""

#: src/function.md:138
msgid ""
"`#[text_signature]` should be preferred, since it will override "
"automatically generated signatures when those are added in a future version "
"of PyO3."
msgstr ""

#: src/function.md:143
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:152
msgid ""
"// a function with a signature but without docs. Both blank lines after the "
"`--` are mandatory.\n"
msgstr ""

#: src/function.md:154
msgid ""
"/// sub(a, b, /)\n"
"/// --\n"
"///\n"
"///\n"
msgstr ""

#: src/function.md:165
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:174
msgid "Closures"
msgstr ""

#: src/function.md:176
msgid ""
"Currently, there are no conversions between `Fn`s in Rust and callables in "
"Python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:178
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:180
msgid ""
"You can use [`ObjectProtocol::is_callable`](https://docs.rs/pyo3/latest/pyo3/"
"trait.ObjectProtocol.html#tymethod.is_callable) to check if you have a "
"callable object. `is_callable` will return `true` for functions (including "
"lambdas), methods and objects with a `__call__` method. You can call the "
"object with [`ObjectProtocol::call`](https://docs.rs/pyo3/latest/pyo3/trait."
"ObjectProtocol.html#tymethod.call) with the args as first parameter and the "
"kwargs (or `None`) as second parameter. There are also [`ObjectProtocol::"
"call0`](https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html#tymethod."
"call0) with no args and [`ObjectProtocol::call1`](https://docs.rs/pyo3/"
"latest/pyo3/trait.ObjectProtocol.html#tymethod.call1) with only positional "
"args."
msgstr ""

#: src/function.md:182
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:184
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use [`wrap_pyfunction!`](https://docs.rs/pyo3/latest/pyo3/macro."
"wrap_pyfunction.html) to get the corresponding [`PyObject`](https://docs.rs/"
"pyo3/latest/pyo3/struct.PyObject). For dynamic functions, e.g. lambdas and "
"functions that were passed as arguments, you must put them in some kind of "
"owned container, e.g. a `Box`. (A long-term solution will be a special "
"container similar to wasm-bindgen's `Closure`). You can then use a "
"`#[pyclass]` struct with that container as a field as a way to pass the "
"function over the FFI barrier. You can even make that class callable with "
"`__call__` so it looks like a function in Python code."
msgstr ""

#: src/module.md:1
msgid "Python Modules"
msgstr ""

#: src/module.md:3
msgid ""
"As shown in the Getting Started chapter, you can create a module as follows:"
msgstr ""

#: src/module.md:7
msgid ""
"// add bindings to the generated Python module\n"
"// N.B: \"rust2py\" must be the name of the `.so` or `.pyd` file.\n"
msgstr ""

#: src/module.md:10
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:14
msgid ""
"// PyO3 aware function. All of our Python interfaces could be declared in a "
"separate module.\n"
"    // Note that the `#[pyfn()]` annotation automatically converts the "
"arguments from\n"
"    // Python objects to Rust values, and the Rust return value back into a "
"Python object.\n"
"    // The `_py` argument represents that we're holding the GIL.\n"
msgstr ""

#: src/module.md:26
msgid "// logic implemented as a normal Rust function\n"
msgstr ""

#: src/module.md:35
msgid ""
"The `#[pymodule]` procedural macro attribute takes care of exporting the "
"initialization function of your module to Python. It can take as an argument "
"the name of your module, which must be the name of the `.so` or `.pyd` file; "
"the default is the Rust function's name."
msgstr ""

#: src/module.md:37
msgid ""
"To import the module, either copy the shared library as described in [Get "
"Started](./get_started.md) or use a tool, e.g. `maturin develop` with "
"[maturin](https://github.com/PyO3/maturin) or `python setup.py develop` with "
"[setuptools-rust](https://github.com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:39
msgid "Documentation"
msgstr ""

#: src/module.md:41
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/first-edition/"
"comments.html) of the module initialization function will be applied "
"automatically as the Python docstring of your module."
msgstr ""

#: src/module.md:49
msgid ""
"Which means that the above Python code will print `This module is "
"implemented in Rust.`."
msgstr ""

#: src/module.md:51
msgid "Modules as objects"
msgstr ""

#: src/module.md:53
msgid ""
"In Python, modules are first class objects. This means that you can store "
"them as values or add them to dicts or other modules:"
msgstr ""

#: src/module.md:62
msgid "\"Subfunction\""
msgstr ""

#: src/module.md:81
msgid "\"supermodule\""
msgstr ""

#: src/module.md:83
msgid "\"assert supermodule.submodule.subfunction() == 'Subfunction'\""
msgstr ""

#: src/module.md:87
msgid ""
"This way, you can create a module hierarchy within a single extension module."
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:7
msgid "Type Conversions"
msgstr ""

#: src/SUMMARY.md:9
msgid "Calling Python from Rust"
msgstr ""

#: src/SUMMARY.md:10
msgid "GIL, mutability and object types"
msgstr ""

#: src/SUMMARY.md:13
msgid "Advanced Topics"
msgstr ""

#: src/SUMMARY.md:15
msgid "PyPy support"
msgstr ""

#: src/SUMMARY.md:17
msgid "Appendix B: Migration Guide"
msgstr ""

#: src/conversions.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr ""

#: src/conversions.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions.md:15
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://docs.rs/pyo3/latest/pyo3/types/trait."
"FromPyObject.html)."
msgstr ""

#: src/conversions.md:19
msgid ""
"[`FromPyObject`](https://docs.rs/pyo3/latest/pyo3/types/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions.md:27
msgid "The `ToPyObject` trait"
msgstr ""

#: src/conversions.md:29
msgid ""
"[`ToPyObject`](https://docs.rs/pyo3/latest/pyo3/trait.ToPyObject.html) is a "
"conversion trait that allows various objects to be converted into "
"[`PyObject`](https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html). "
"`IntoPy<PyObject>` serves the same purpose, except that it consumes `self`."
msgstr ""

#: src/conversions.md:34
msgid "`*args` and `**kwargs` for Python object calls"
msgstr ""

#: src/conversions.md:36
msgid ""
"There are several ways how to pass positional and keyword arguments to a "
"Python object call. The [`ObjectProtocol`](https://docs.rs/pyo3/latest/pyo3/"
"trait.ObjectProtocol.html) trait provides two methods:"
msgstr ""

#: src/conversions.md:39
msgid "`call` - call any callable Python object."
msgstr ""

#: src/conversions.md:40
msgid ""
"`call_method` - call a specific method on the object, shorthand for "
"`get_attr` then `call`."
msgstr ""

#: src/conversions.md:42
msgid ""
"Both methods need `args` and `kwargs` arguments, but there are variants for "
"less complex calls, such as `call1` for only `args` and `call0` for no "
"arguments at all."
msgstr ""

#: src/conversions.md:57
msgid "\"arg1\""
msgstr ""

#: src/conversions.md:58
msgid "\"arg2\""
msgstr ""

#: src/conversions.md:59
msgid "\"arg3\""
msgstr ""

#: src/conversions.md:66
msgid "// call object without empty arguments\n"
msgstr ""

#: src/conversions.md:69
msgid "// call object with PyTuple\n"
msgstr ""

#: src/conversions.md:73
msgid "// pass arguments as rust tuple\n"
msgstr ""

#: src/conversions.md:79
msgid ""
"`kwargs` can be `None` or `Some(&PyDict)`. You can use the [`IntoPyDict`]"
"(https://docs.rs/pyo3/latest/pyo3/types/trait.IntoPyDict.html) trait to "
"convert other dict-like containers, e.g. `HashMap` or `BTreeMap`, as well as "
"tuples with up to 10 elements and `Vec`s where each element is a two-element "
"tuple."
msgstr ""

#: src/conversions.md:98
msgid "\"key1\""
msgstr ""

#: src/conversions.md:100
msgid "\"key2\""
msgstr ""

#: src/conversions.md:108
msgid "// call object with PyDict\n"
msgstr ""

#: src/conversions.md:112
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/conversions.md:116
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/conversions.md:123
msgid "`FromPy<T>` and `IntoPy<T>`"
msgstr ""

#: src/conversions.md:125
msgid ""
"Many conversions in PyO3 can't use `std::convert::From` because they need a "
"GIL token. The [`FromPy`](https://docs.rs/pyo3/latest/pyo3/trait.FromPy."
"html) trait offers an `from_py` method that works just like `from`, except "
"for taking a `Python<'_>` argument. I.e. `FromPy<T>` could be converting a "
"Rust object into a Python object even though it is called [`FromPy`](https://"
"docs.rs/pyo3/latest/pyo3/trait.FromPy.html) - it doesn't say anything about "
"which side of the conversion is a Python object."
msgstr ""

#: src/conversions.md:129
msgid ""
"Just like `From<T>`, if you implement `FromPy<T>` you gain a blanket "
"implementation of [`IntoPy`](https://docs.rs/pyo3/latest/pyo3/trait.IntoPy."
"html) for free."
msgstr ""

#: src/conversions.md:131
msgid ""
"Eventually, traits such as [`ToPyObject`](https://docs.rs/pyo3/latest/pyo3/"
"trait.ToPyObject.html) will be replaced by this trait and a [`FromPy`]"
"(https://docs.rs/pyo3/latest/pyo3/trait.FromPy.html) trait will be added "
"that will implement [`IntoPy`](https://docs.rs/pyo3/latest/pyo3/trait.IntoPy."
"html), just like with `From` and `Into`."
msgstr ""
