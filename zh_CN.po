msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr ""

#: src/advanced.md:3
msgid "ffi"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of python's C api through the `ffi`."
msgstr ""

#: src/advanced.md:7
msgid ""
"The C api is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that api."
msgstr ""

#: src/advanced.md:9
msgid "Testing"
msgstr ""

#: src/advanced.md:11
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For nnow you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/advanced.md:13
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/rust-cpython.md:1
msgid "Appendix: PyO3 and rust-cpython"
msgstr ""

#: src/rust-cpython.md:3
msgid ""
"PyO3 began as fork of [rust-cpython](https://github.com/dgrunwald/rust-"
"cpython) when rust-cpython wasn't maintained. Over the time pyo3 has become "
"fundamentally different from rust-cpython."
msgstr ""

#: src/rust-cpython.md:5
msgid ""
"This chapter is based on the discussion in [PyO3/pyo3#55](https://github.com/"
"PyO3/pyo3/issues/55)."
msgstr ""

#: src/rust-cpython.md:7
msgid "Macros"
msgstr ""

#: src/rust-cpython.md:9
msgid ""
"While rust-cpython has a macro based dsl for declaring modules and classes, "
"PyO3 use proc macros and specialization. PyO3 also doesn't change your "
"struct and functions so you can still use them as normal rust functions. The "
"disadvantage is that proc macros and specialization currently only work on "
"nightly."
msgstr ""

#: src/rust-cpython.md:11 src/rust-cpython.md:60
msgid "**rust-cpython**"
msgstr ""

#: src/rust-cpython.md:25 src/rust-cpython.md:71
msgid "**pyo3**"
msgstr ""

#: src/rust-cpython.md:54
msgid "Ownership and lifetimes"
msgstr ""

#: src/rust-cpython.md:56
msgid ""
"All objects are owned by PyO3 library and all apis available with "
"references, while in rust-cpython, you own python objects."
msgstr ""

#: src/rust-cpython.md:58
msgid "Here is example of PyList api:"
msgstr ""

#: src/rust-cpython.md:82
msgid ""
"Because PyO3 allows only references to python object, all reference have the "
"Gil lifetime. So the python object is not required, and it is safe to have "
"functions like `fn py<'p>(&'p self) -> Python<'p> {}`."
msgstr ""

#: src/rust-cpython.md:84
msgid "Error handling"
msgstr ""

#: src/rust-cpython.md:86
msgid ""
"rust-cpython requires a `Python` parameter for `PyErr`, so error handling "
"ergonomics is pretty bad. It is not possible to use `?` with rust errors."
msgstr ""

#: src/rust-cpython.md:88
msgid ""
"PyO3 on other hand does not require `Python` for `PyErr`, it is only "
"required if you want to raise an exception in python with the `PyErr::"
"restore()` method. Due to the `std::convert::From<Err> for PyErr` trait `?` "
"is supported automatically."
msgstr ""

#: src/building-and-distribution.md:1
msgid "Building and Distribution"
msgstr ""

#: src/building-and-distribution.md:3
msgid "Python version"
msgstr ""

#: src/building-and-distribution.md:5
msgid ""
"PyO3 uses a build script to determine the python version and set the correct "
"linker arguments. By default it uses the `python3` executable. With the "
"`python2` feature it uses the `python2` executable. You can override the "
"python interpreter by setting `PYTHON_SYS_EXECUTABLE`."
msgstr ""

#: src/building-and-distribution.md:7
msgid "Linking"
msgstr ""

#: src/building-and-distribution.md:9
msgid ""
"Different linker arguments must be set for libraries/extension modules and "
"binaries, which includes both standalone binaries and tests. (More "
"specifically, binaries must be told where to find libpython and libraries "
"must not link to libpython for [manylinux](https://www.python.org/dev/peps/"
"pep-0513/) compliance)."
msgstr ""

#: src/building-and-distribution.md:11
msgid ""
"Since PyO3's build script can't know whether you're building a binary or a "
"library, you have to activate the `extension-module` feature to get the "
"build options for a library, or it'll default to binary."
msgstr ""

#: src/building-and-distribution.md:13
msgid ""
"If you have e.g. a library crate and a profiling crate alongside, you need "
"to use optional features. E.g. you put the following in the library crate:"
msgstr ""

#: src/building-and-distribution.md:15
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.5.2\"\n"
"\n"
"[lib]\n"
"name = \"hyperjson\"\n"
"crate-type = [\"rlib\", \"cdylib\"]\n"
"\n"
"[features]\n"
"default = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/building-and-distribution.md:27
msgid "And this in the profiling crate:"
msgstr ""

#: src/building-and-distribution.md:29
msgid ""
"```toml\n"
"[dependencies]\n"
"my_main_crate = { path = \"..\", default-features = false }\n"
"pyo3 = \"0.5.2\"\n"
"```"
msgstr ""

#: src/building-and-distribution.md:35
msgid ""
"On linux/mac you might have to change `LD_LIBRARY_PATH` to include "
"libpython, while on windows you might need to set `LIB` to include `pythonxy."
"lib` (where x and y are major and minor version), which is normally either "
"in the `libs` or `Lib` folder of a python installation."
msgstr ""

#: src/building-and-distribution.md:37
msgid "Distribution"
msgstr ""

#: src/building-and-distribution.md:39
msgid ""
"There are two ways to distribute your module as python package: The old "
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) and the new [pyo3-"
"pack](https://github.com/pyo3/pyo3-pack). setuptools-rust needs some "
"configuration files (`setup.py`,  `MANIFEST.in`, `build-wheels.sh`, etc.) "
"and external tools (docker, twine). pyo3-pack doesn't need any configuration "
"files. It can not yet build sdist though ([pyo3/pyo3-pack#2](https://github."
"com/PyO3/pyo3-pack/issues/2))."
msgstr ""

#: src/building-and-distribution.md:41
msgid "Cross Compiling"
msgstr ""

#: src/building-and-distribution.md:43
msgid ""
"Cross compiling PyO3 modules is relatively straightforward and requires a "
"few pieces of software:"
msgstr ""

#: src/building-and-distribution.md:45
msgid "A toolchain for your target."
msgstr ""

#: src/building-and-distribution.md:46
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building-and-distribution.md:47
msgid "A Python interpreter that's already been compiled for your target."
msgstr ""

#: src/building-and-distribution.md:48
msgid "The headers that match the above interpreter."
msgstr ""

#: src/building-and-distribution.md:50
msgid ""
"See https://github.com/japaric/rust-cross for a primer on cross compiling "
"Rust in general."
msgstr ""

#: src/building-and-distribution.md:52
msgid ""
"After you've obtained the above, you can build a cross compiled Pyo3 module "
"by setting a few extra environment variables:"
msgstr ""

#: src/building-and-distribution.md:54
msgid ""
"`PYO3_CROSS_INCLUDE_DIR`: This variable must be set to the directory "
"containing the headers for the target's python interpreter."
msgstr ""

#: src/building-and-distribution.md:55
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable must be set to the directory containing "
"the target's libpython DSO."
msgstr ""

#: src/building-and-distribution.md:57
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building-and-distribution.md:60
msgid "\"/home/pyo3/cross/sysroot/usr/include\""
msgstr ""

#: src/building-and-distribution.md:61
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/debugging.md:5
msgid ""
"PyO3's attributes, `#[pyclass]`, `#[pymodule]`, etc. are [procedural macros]"
"(https://doc.rust-lang.org/unstable-book/language-features/proc-macro.html), "
"which means that rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding -Z trace-macros\\`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"See [cargo expand](https://github.com/dtolnay/cargo-expand) for a more "
"elaborate version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of python, otherwise valgrind won't "
"produce usable results. In ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on linux, use `ldd` with the name of you're binary and check that you're "
"linking e.g. `libpython3.6dm.so.1.0` instead of `libpython3.6m.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for cpython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:40
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/get_started.md:1
msgid "PyO3"
msgstr ""

#: src/get_started.md:3
msgid ""
"[Rust](http://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/). This includes running and interacting with python code from a rust "
"binaries as well as writing native python modules."
msgstr ""

#: src/get_started.md:5
msgid ""
"User Guide: [stable](https://pyo3.rs) | [master](https://pyo3.rs/master)"
msgstr ""

#: src/get_started.md:7
msgid "API Documentation: [master](https://pyo3.rs/master/doc)"
msgstr ""

#: src/get_started.md:9
msgid ""
"A comparison with rust-cpython can be found [in the guide](https://pyo3.rs/"
"master/rust-cpython.html)."
msgstr ""

#: src/get_started.md:11
msgid "Usage"
msgstr ""

#: src/get_started.md:13
msgid ""
"PyO3 supports python 2.7 as well as python 3.5 and up. The minimum required "
"rust version is 1.30.0-nightly 2018-08-18."
msgstr ""

#: src/get_started.md:15
msgid ""
"You can either write a native python module in rust or use python from a "
"rust binary."
msgstr ""

#: src/get_started.md:17
msgid "On some OSs, you need some additional packages."
msgstr ""

#: src/get_started.md:19
msgid "E.g. if you are on Ubuntu18.04, please run"
msgstr ""

#: src/get_started.md:25
msgid "Using rust from python"
msgstr ""

#: src/get_started.md:27
msgid "PyO3 can be used to generate a native python module."
msgstr ""

#: src/get_started.md:29
msgid "**`Cargo.toml`:**"
msgstr ""

#: src/get_started.md:31
msgid ""
"```toml\n"
"[package]\n"
"name = \"string-sum\"\n"
"version = \"0.1.0\"\n"
"\n"
"[lib]\n"
"name = \"string_sum\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0-alpha.4\"\n"
"features = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/get_started.md:45
msgid "**`src/lib.rs`**"
msgstr ""

#: src/get_started.md:52
msgid "/// Formats the sum of two numbers as string\n"
msgstr ""

#: src/get_started.md:57
msgid "/// This module is a python module implemented in Rust.\n"
msgstr ""

#: src/get_started.md:67
msgid ""
"On windows and linux, you can build normally with `cargo build --release`. "
"On macOS, you need to set additional linker arguments. One option is to "
"compile with `cargo rustc --release -- -C link-arg=-undefined -C link-"
"arg=dynamic_lookup`, the other is to create a `.cargo/config` with the "
"following content:"
msgstr ""

#: src/get_started.md:69
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/get_started.md:77
msgid ""
"For developing, you can copy and rename the shared library from the target "
"folder: On macOS, rename `libstring_sum.dylib` to `string_sum.so`, on "
"windows `libstring_sum.dll` to `string_sum.pyd` and on linux `libstring_sum."
"so` to `string_sum.so`. Then open a python shell in the same folder and "
"you'll be able to `import string_sum`."
msgstr ""

#: src/get_started.md:79
msgid ""
"To build, test and publish your crate as python module, you can use [pyo3-"
"pack](https://github.com/PyO3/pyo3-pack) or [setuptools-rust](https://github."
"com/PyO3/setuptools-rust). You can find an example for setuptools-rust in "
"[examples/word-count](examples/word-count), while pyo3-pack should work on "
"your crate without any configuration."
msgstr ""

#: src/get_started.md:81
msgid "Using python from rust"
msgstr ""

#: src/get_started.md:83
msgid "Add `pyo3` this to your `Cargo.toml`:"
msgstr ""

#: src/get_started.md:85
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.5\"\n"
"```"
msgstr ""

#: src/get_started.md:90
msgid "Example program displaying the value of `sys.version`:"
msgstr ""

#: src/get_started.md:100
msgid "\"sys\""
msgstr ""

#: src/get_started.md:101
msgid "\"version\""
msgstr ""

#: src/get_started.md:103
msgid "\"os\""
msgstr ""

#: src/get_started.md:104
msgid "\"os.getenv('USER') or os.getenv('USERNAME')\""
msgstr ""

#: src/get_started.md:106
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/get_started.md:111
msgid "Examples and tooling"
msgstr ""

#: src/get_started.md:113
msgid ""
"[examples/word-count](examples/word-count) _Counting the occurrences of a "
"word in a text file_"
msgstr ""

#: src/get_started.md:114
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json_"
msgstr ""

#: src/get_started.md:115
msgid ""
"[rust-numpy](https://github.com/rust-numpy/rust-numpy) _Rust binding of "
"NumPy C-API_"
msgstr ""

#: src/get_started.md:116
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/master/html-py-"
"ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""

#: src/get_started.md:117
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://pyo3.github.io/pyo3/pyo3/struct.PyDict.html)_"
msgstr ""

#: src/get_started.md:118
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library_"
msgstr ""

#: src/get_started.md:119
msgid ""
"[autopy](https://github.com/autopilot-rs/autopy) _A simple, cross-platform "
"GUI automation library for Python and Rust._"
msgstr ""

#: src/get_started.md:120
msgid "[orjson](https://github.com/ijl/orjson)  _Fast Python JSON library_"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr ""

#: src/parallelism.md:3
msgid ""
"CPython has an infamous GIL(Global Interpreter Lock) prevents developers "
"getting true parallelism. With PyO3 you can release GIL when executing Rust "
"code to achieve true parallelism."
msgstr ""

#: src/parallelism.md:7
msgid ""
"The [`Python::allow_threads`](https://docs.rs/pyo3/0.2.7/struct.Python."
"html#method.allow_threads) method temporarily releases the GIL, thus "
"allowing other Python threads to run."
msgstr ""

#: src/parallelism.md:16
msgid ""
"Let's take a look at our [word-count](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/src/lib.rs) example, we have a `wc_parallel` "
"function utilize the [rayon](https://github.com/nikomatsakis/rayon) crate to "
"count words in parallel."
msgstr ""

#: src/parallelism.md:27
msgid ""
"Then in the Python bridge, we have a function `search` exposed to Python "
"runtime which calls `wc_parallel` inside `Python::allow_threads` method to "
"enable true parallelism:"
msgstr ""

#: src/parallelism.md:34
msgid "\"search\""
msgstr ""

#: src/parallelism.md:48
msgid "Benchmark"
msgstr ""

#: src/parallelism.md:50
msgid ""
"Let's benchmark the `word-count` example to verify that we did unlock true "
"parallelism with PyO3. We are using `pytest-benchmark` to benchmark three "
"word count functions:"
msgstr ""

#: src/parallelism.md:53
msgid ""
"[Pure Python version](https://github.com/PyO3/pyo3/blob/master/examples/word-"
"count/word_count/__init__.py#L9)"
msgstr ""

#: src/parallelism.md:54
msgid ""
"[Rust sequential version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L64)"
msgstr ""

#: src/parallelism.md:55
msgid ""
"[Rust parallel version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L54)"
msgstr ""

#: src/parallelism.md:57
msgid ""
"Benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/tests/test_word_count.py), then we can run "
"`pytest tests` to benchmark them."
msgstr ""

#: src/parallelism.md:60
msgid "On MacBook Pro (Retina, 15-inch, Mid 2015) the benchmark gives:"
msgstr ""

#: src/parallelism.md:62
msgid ""
"![Benchmark Result](https://user-images.githubusercontent."
"com/1556054/28604608-81bd6d22-71fe-11e7-8a2c-c3cf3bd0f622.png)"
msgstr ""

#: src/class.md:1
msgid "Python Class"
msgstr ""

#: src/class.md:3
msgid "Define new class"
msgstr ""

#: src/class.md:5
msgid ""
"To define a custom python class, a rust struct needs to be annotated with "
"the `#[pyclass]` attribute."
msgstr ""

#: src/class.md:19
msgid ""
"The above example generates implementations for `PyTypeInfo` and "
"`PyTypeObject` for `MyClass`."
msgstr ""

#: src/class.md:21
msgid "Get Python objects from `pyclass`"
msgstr ""

#: src/class.md:22
msgid "You can use `pyclass`es like normal rust structs."
msgstr ""

#: src/class.md:24
msgid ""
"However, if instantiated normally, you can't treat `pyclass`es as Python "
"objects."
msgstr ""

#: src/class.md:26
msgid ""
"To get a Python object which includes `pyclass`, we have to use some special "
"methods."
msgstr ""

#: src/class.md:28
msgid "`PyRef`"
msgstr ""

#: src/class.md:29
msgid ""
"`PyRef` is a special reference, which ensures that the referred struct is a "
"part of a Python object, and you are also holding the GIL."
msgstr ""

#: src/class.md:32
msgid ""
"You can get an instance of `PyRef` by `PyRef::new`, which does 3 things:"
msgstr ""

#: src/class.md:33
msgid "Allocate a Python object in the Python heap"
msgstr ""

#: src/class.md:34
msgid "Copies the rust struct into the Python object"
msgstr ""

#: src/class.md:35
msgid "Returns a reference of it"
msgstr ""

#: src/class.md:37
msgid ""
"You can use `PyRef` just like `&T`, because it implements `Deref<Target=T>`."
msgstr ""

#: src/class.md:51
msgid "// You can treat a `PyRef` as a Python object\n"
msgstr ""

#: src/class.md:53
msgid "\"obj\""
msgstr ""

#: src/class.md:56
msgid "`PyRefMut`"
msgstr ""

#: src/class.md:57
msgid "`PyRefMut` is a mutable version of `PyRef`."
msgstr ""

#: src/class.md:72
msgid "`Py`"
msgstr ""

#: src/class.md:73
msgid ""
"`Py` is a object wrapper which stores an object longer than the GIL lifetime."
msgstr ""

#: src/class.md:75
msgid "You can use it to avoid lifetime problems."
msgstr ""

#: src/class.md:93
msgid "Customizing the class"
msgstr ""

#: src/class.md:95
msgid "The `#[pyclass]` macro accepts following parameters:"
msgstr ""

#: src/class.md:97
msgid ""
"`name=XXX` - Set the class name shown in python code. By default struct name "
"is used as a class name."
msgstr ""

#: src/class.md:98
msgid ""
"`freelist=XXX` - `freelist` parameter add support of free allocation list to "
"custom class. The performance improvement applies to types that are often "
"created and deleted in a row, so that they can benefit from a freelist. "
"`XXX` is a number of items for free list."
msgstr ""

#: src/class.md:101
msgid ""
"`gc` - Classes with the `gc` parameter participate in python garbage "
"collector. If a custom class contains references to other python object that "
"can be collected, the `PyGCProtocol` trait has to be implemented."
msgstr ""

#: src/class.md:104
msgid "`weakref` - adds support for python weak references"
msgstr ""

#: src/class.md:105
msgid ""
"`extends=BaseType` - use a custom base class. The base BaseType must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:106
msgid "`subclass` - Allows Python classes to inherit from this class"
msgstr ""

#: src/class.md:107
msgid ""
"`dict` - adds `__dict__` support, the instances of this type have a "
"dictionary containing instance variables."
msgstr ""

#: src/class.md:109
msgid "Constructor"
msgstr ""

#: src/class.md:111
msgid ""
"By default it is not possible to create an instance of a custom class from "
"python code. To declare a constructor, you need to define a class method and "
"annotate it with `#[new]` attribute. Only the python `__new__` method can be "
"specified, `__init__` is not available."
msgstr ""

#: src/class.md:138
msgid "Rules for the `new` method:"
msgstr ""

#: src/class.md:140
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:142
msgid ""
"The first parameter is the raw object and the custom `new` method must "
"initialize the object with an instance of the struct using `init` method. "
"The type of the object may be the type object of a derived class declared in "
"Python."
msgstr ""

#: src/class.md:145
msgid "The first parameter implicitly has type `&PyRawObject`."
msgstr ""

#: src/class.md:146 src/class.md:383
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:147
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`. Usually, `T` will be `MyType`."
msgstr ""

#: src/class.md:150
msgid "Inheritance"
msgstr ""

#: src/class.md:152
msgid ""
"By default `PyObject` is used as default base class. To override default "
"base class `base` parameter for `class` needs to be used. Value is full path "
"to base class. `new` method accepts `PyRawObject` object. `obj` instance "
"must be initialized with value of custom class struct. Subclass must call "
"parent's `new` method."
msgstr ""

#: src/class.md:197
msgid ""
"`ObjectProtocol` trait provides `get_base()` method. It returns reference to "
"instance of base class."
msgstr ""

#: src/class.md:201
msgid "Object properties"
msgstr ""

#: src/class.md:203
msgid ""
"Descriptor methods can be defined in `#[pymethods]` `impl` block only and "
"has to be annotated with `#[getter]` or `[setter]` attributes. i.e."
msgstr ""

#: src/class.md:225
msgid ""
"Getter or setter function's name is used as property name by default. There "
"are several ways how to override name."
msgstr ""

#: src/class.md:228
msgid ""
"If function name starts with `get_` or `set_` for getter or setter "
"respectively. Descriptor name becomes function name with prefix removed. "
"This is useful in case of rust's special keywords like `type`."
msgstr ""

#: src/class.md:256
msgid ""
"In this case property `num` is defined. And it is available from python code "
"as `self.num`."
msgstr ""

#: src/class.md:258
msgid ""
"Also both `#[getter]` and `#[setter]` attributes accepts one parameter. If "
"this parameter is specified, it is used as a property name. i.e."
msgstr ""

#: src/class.md:285
msgid ""
"In this case the property `number` is defined and is available from python "
"code as `self.number`."
msgstr ""

#: src/class.md:287
msgid ""
"For simple cases you can also define getters and setters in your Rust struct "
"field definition, for example:"
msgstr ""

#: src/class.md:299
msgid "Then it is available from Python code as `self.num`."
msgstr ""

#: src/class.md:301
msgid "Instance methods"
msgstr ""

#: src/class.md:303
msgid ""
"To define a python compatible method, `impl` block for struct has to be "
"annotated with the `#[pymethods]` attribute. PyO3 generates python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:329
msgid ""
"Calls to this methods protected by `GIL`, `&self` or `&mut self` can be "
"used. The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:332
msgid ""
"`Python` parameter can be specified as part of method signature, in this "
"case `py` argument get injected by method wrapper. i.e"
msgstr ""

#: src/class.md:352
msgid ""
"From python perspective `method2`, in above example, does not accept any "
"arguments."
msgstr ""

#: src/class.md:354
msgid "Class methods"
msgstr ""

#: src/class.md:356
msgid ""
"To specify a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute."
msgstr ""

#: src/class.md:378
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:380
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:382
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:384
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:386
msgid "Static methods"
msgstr ""

#: src/class.md:388
msgid ""
"To specify a static method for a custom class, method needs to be annotated "
"with `#[staticmethod]` attribute. The return type must be `PyResult<T>` for "
"some `T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:410
msgid "Callable object"
msgstr ""

#: src/class.md:412
msgid ""
"To specify a custom `__call__` method for a custom class, call methods need "
"to be annotated with the `#[call]` attribute. Arguments of the method are "
"specified same as for instance method."
msgstr ""

#: src/class.md:428 src/class.md:471
msgid "\"*\""
msgstr ""

#: src/class.md:430
msgid "\"MyClass has been called\""
msgstr ""

#: src/class.md:436
msgid "Method arguments"
msgstr ""

#: src/class.md:438
msgid ""
"By default PyO3 uses function signatures to determine which arguments are "
"required. Then it scans incoming `args` parameter and then incoming `kwargs` "
"parameter. If it can not find all required parameters, it raises a "
"`TypeError` exception. It is possible to override the default behavior with "
"`#[args(...)]` attribute. `args` attribute accepts a comma separated list of "
"parameters in form of `attr_name=\"default value\"`. Each parameter has to "
"match the method parameter by name."
msgstr ""

#: src/class.md:444
msgid "Each parameter could be one of following type:"
msgstr ""

#: src/class.md:446
msgid ""
"\"\\*\": var arguments separator, each parameter defined after \"\\*\" is "
"keyword only parameters. corresponds to python's `def meth(*, arg1.., "
"arg2=..)`"
msgstr ""

#: src/class.md:448
msgid ""
"args=\"\\*\": \"args\" is var args, corresponds to python's `def "
"meth(*args)`. Type of `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:450
msgid ""
"kwargs=\"\\*\\*\": \"kwargs\" is keyword arguments, corresponds to python's "
"`def meth(**kwargs)`. Type of `kwargs` parameter has to be `Option<&PyDict>`."
msgstr ""

#: src/class.md:452
msgid ""
"arg=\"Value\": arguments with default value. corresponds to python's `def "
"meth(arg=Value)`. if `arg` argument is defined after var arguments it is "
"treated as keyword argument. Note that `Value` has to be valid rust code, "
"PyO3 just inserts it into generated code unmodified."
msgstr ""

#: src/class.md:457 src/class.md:608
msgid "Example:"
msgstr ""

#: src/class.md:471
msgid "\"**\""
msgstr ""

#: src/class.md:479
msgid "Class customizations"
msgstr ""

#: src/class.md:481
msgid ""
"Python's object model defines several protocols for different object "
"behavior, like sequence, mapping or number protocols. PyO3 defines separate "
"traits for each of them. To provide specific python object behavior you need "
"to implement the specific trait for your struct. Important note, each "
"protocol implementation block has to be annotated with `#[pyproto]` "
"attribute."
msgstr ""

#: src/class.md:486
msgid "Basic object customization"
msgstr ""

#: src/class.md:488
msgid ""
"[`PyObjectProtocol`](https://docs.rs/pyo3/0.6.0-alpha.4/class/basic/trait."
"PyObjectProtocol.html) trait provide several basic customizations."
msgstr ""

#: src/class.md:490
msgid "Attribute access"
msgstr ""

#: src/class.md:492
msgid "To customize object attribute access define following methods:"
msgstr ""

#: src/class.md:494
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:495
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:496
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:498
msgid ""
"Each methods corresponds to python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:500
msgid "String Conversions"
msgstr ""

#: src/class.md:502
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:503
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:505
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`. In Python 2.7, Unicode strings returned by `__str__` "
"and `__repr__` will be converted to byte strings by the Python runtime, "
"which results in an exception if the string contains non-ASCII characters."
msgstr ""

#: src/class.md:509
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:511
msgid ""
"On Python 3.x, provides the conversion to `bytes`. On Python 2.7, "
"`__bytes__` is allowed but has no effect."
msgstr ""

#: src/class.md:514
msgid "`fn __unicode__(&self) -> PyResult<PyUnicode>`"
msgstr ""

#: src/class.md:516
msgid ""
"On Python 2.7, provides the conversion to `unicode`. On Python 3.x, "
"`__unicode__` is allowed but has no effect."
msgstr ""

#: src/class.md:519
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:521
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:524
msgid "Comparison operators"
msgstr ""

#: src/class.md:526
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:528
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:534
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:536
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:539
msgid "Other methods"
msgstr ""

#: src/class.md:541
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:543
msgid ""
"Determines the \"truthiness\" of the object. This method works for both "
"python 3 and python 2, even on Python 2.7 where the Python spelling was "
"`__nonzero__`."
msgstr ""

#: src/class.md:547
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:549
msgid ""
"If your type owns references to other python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement [`PyGCProtocol`](https://docs.rs/"
"pyo3/0.6.0-alpha.4/class/gc/trait.PyGCProtocol.html) trait for your struct. "
"It includes two methods `__traverse__` and `__clear__`. These correspond to "
"the slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` "
"must call `visit.call()` for each reference to another python object. "
"`__clear__` must clear out any mutable references to other python objects "
"(thus breaking reference cycles). Immutable references do not have to be "
"cleared, as every cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:583
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:592
msgid ""
"Special protocol trait implementations have to be annotated with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class.md:594
msgid ""
"It is also possible to enable GC for custom class using `gc` parameter for "
"`class` annotation. i.e. `#[pyclass(gc)]`. In that case instances of custom "
"class participate in python garbage collector, and it is possible to track "
"them with `gc` module methods."
msgstr ""

#: src/class.md:598
msgid "Iterator Types"
msgstr ""

#: src/class.md:600
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://docs.rs/"
"pyo3/0.6.0-alpha.4/class/iter/trait.PyIterProtocol.html) trait. It includes "
"two methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:603
msgid "`fn __iter__(slf: PyRefMut<Self>) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:604
msgid ""
"`fn __next__(slf: PyRefMut<Self>) -> PyResult<Option<impl IntoPyObject>>`"
msgstr ""

#: src/class.md:606
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""

#: src/class.md:632
msgid "Manually implementing pyclass"
msgstr ""

#: src/class.md:634
msgid ""
"TODO: Which traits to implement (basically `PyTypeCreate: PyObjectAlloc + "
"PyTypeInfo + PyMethodsProtocol + Sized`) and what they mean."
msgstr ""

#: src/class.md:636
msgid "How methods are implemented"
msgstr ""

#: src/class.md:638
msgid ""
"Users should be able to define a `#[pyclass]` with or without "
"`#[pymethods]`, while PyO3 needs a trait with a function that returns all "
"methods. Since it's impossible to make the code generation in pyclass "
"dependent on whether there is an impl block, we'd need to implement the "
"trait on `#[pyclass]` and override the implementation in `#[pymethods]`, "
"which is to the best of my knowledge only possible with the specialization "
"feature, which can't be used on stable."
msgstr ""

#: src/class.md:644
msgid ""
"To escape this we use [inventory](https://github.com/dtolnay/inventory), "
"which allows us to collect `impl`s from arbitrary source code by exploiting "
"some binary trick. See [inventory: how it works](https://github.com/dtolnay/"
"inventory#how-it-works) and `pyo3_derive_backend::py_class::impl_inventory` "
"for more details."
msgstr ""

#: src/exception.md:1
msgid "Python Exception"
msgstr ""

#: src/exception.md:3
msgid "Define a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"You can use the `create_exception!` macro to define a new exception type:"
msgstr ""

#: src/exception.md:14
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:15
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:17
msgid "For example:"
msgstr ""

#: src/exception.md:31
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:33
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:34
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:38
msgid "Raise an exception"
msgstr ""

#: src/exception.md:40
msgid ""
"To raise an exception, first you need to obtain an exception type and "
"construct a new [`PyErr`](https://docs.rs/pyo3/0.2.7/struct.PyErr.html), "
"then call [`PyErr::restore()`](https://docs.rs/pyo3/0.2.7/struct.PyErr."
"html#method.restore) method to write the exception back to the Python "
"interpreter's global state."
msgstr ""

#: src/exception.md:50
msgid "\"Error\""
msgstr ""

#: src/exception.md:56
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance()`](https://docs.rs/pyo3/0.2.7/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:62
msgid ""
"If rust type exists for exception, then it is possible to use `new` method. "
"For example each standard exception defined in `exc` module has "
"corresponding rust type, exceptions defined by `create_exception!` and "
"`import_exception!` macro have rust type as well."
msgstr ""

#: src/exception.md:74
msgid "\"argument is wrong\""
msgstr ""

#: src/exception.md:81
msgid "Check exception type"
msgstr ""

#: src/exception.md:83
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check object type, in `PyO3` there is a [`Python::"
"is_instance()`](https://docs.rs/pyo3/0.2.7/struct.Python.html#method."
"is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:101
msgid ""
"[`Python::is_instance()`](https://docs.rs/pyo3/0.2.7/struct.Python."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://docs.rs/pyo3/0.2.7/struct.PyType.html#method.is_instance) method to "
"do the actual work."
msgstr ""

#: src/exception.md:103
msgid "To check the type of an exception, you can simply do:"
msgstr ""

#: src/exception.md:117
msgid "Handle Rust Error"
msgstr ""

#: src/exception.md:119
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://docs.rs/pyo3/0.2.7/type.PyResult.html). This is an alias for the "
"type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:122
msgid ""
"A [`PyErr`](https://docs.rs/pyo3/0.2.7/struct.PyErr.html) represents a "
"Python exception. Errors within the PyO3 library are also exposed as Python "
"exceptions."
msgstr ""

#: src/exception.md:125
msgid ""
"PyO3 library handles python exception in two stages. During first stage "
"`PyErr` instance get created. At this stage python GIL is not required. "
"During second stage, actual python exception instance get crated and set to "
"python interpreter."
msgstr ""

#: src/exception.md:129
msgid ""
"In simple case, for custom errors support implementation of `std::convert::"
"From<T>` trait for this custom error is enough. `PyErr::new` accepts "
"arguments in form of `ToPyObject + 'static`. In case if `'static` constraint "
"can not be satisfied or more complex arguments are required [`PyErrArgument`]"
"(https://docs.rs/pyo3/0.2.7/trait.PyErrArguments.html) trait can be "
"implemented. In that case actual exception arguments creation get delayed "
"until `Python` object is available."
msgstr ""

#: src/exception.md:147
msgid "\"127.0.0.1:80\""
msgstr ""

#: src/exception.md:152
msgid ""
"The code snippet above will raise `OSError` in Python if `TcpListener::"
"bind()` return an error."
msgstr ""

#: src/exception.md:154
msgid ""
"`std::convert::From<T>` trait is implemented for most of the standard "
"library's error types so `try!` macro or `?` operator can be used."
msgstr ""

#: src/exception.md:166
msgid ""
"The code snippet above will raise `ValueError` in Python if `String::"
"parse()` return an error."
msgstr ""

#: src/exception.md:169
msgid "Using exceptions defined in python code"
msgstr ""

#: src/exception.md:171
msgid ""
"It is possible to use exception defined in python code as native rust types. "
"`import_exception!` macro allows to import specific exception class and "
"defined zst type for that exception."
msgstr ""

#: src/exception.md:188
msgid "\"tell\""
msgstr ""

#: src/exception.md:189
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:196
msgid ""
"[`exc`](https://docs.rs/pyo3/0.2.7/exc/index.html) defines exceptions for "
"several standard library modules."
msgstr ""

#: src/function.md:1
msgid "Python Function"
msgstr ""

#: src/function.md:3
msgid ""
"PyO3 supports two ways to define a function in python. Both require "
"registering the function to a [module](./module.md)"
msgstr ""

#: src/function.md:6
msgid "One way is defining the function in the module definition."
msgstr ""

#: src/function.md:15
msgid ""
"// Note that the `#[pyfn()]` annotation automatically converts the arguments "
"from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/function.md:17
msgid "\"sum_as_string\""
msgstr ""

#: src/function.md:19
msgid "\"{}\""
msgstr ""

#: src/function.md:28
msgid ""
"The other is annotating a function with `#[pyfunction]` and then adding it "
"to the module using the `add_wrapped_to_module!` macro, which takes the "
"module as first parameter, the function name as second and an instance of "
"`Python` as third."
msgstr ""

#: src/function.md:53
msgid "Making the function signature available to Python"
msgstr ""

#: src/function.md:55
msgid ""
"In order to make the function signature available to Python to be retrieved "
"via `inspect.signature`, simply make sure the first line of your doc-string "
"is formatted like in the example below. Please note that the new-line after "
"the `--` is mandatory. The `/` signifies the end of positional only "
"arguments. This is not a feature of this library in particular, but the "
"general format used by CPython for annotating signatures of built-in "
"functions. Function signatures for built-ins are new in Python 3 â€” in Python "
"2, it is simply considered to be part of the doc-string."
msgstr ""

#: src/function.md:67
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:78
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:86
msgid "Closures"
msgstr ""

#: src/function.md:88
msgid ""
"Currently, there are no conversions between `Fn`s in rust and callables in "
"python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:90
msgid "Calling a python function in rust"
msgstr ""

#: src/function.md:92
msgid ""
"You can use `ObjectProtocol::is_callable` to check if you got a callable, "
"which is true for functions (including lambdas), methods and objects with a "
"`__call__` method. You can call the object with `ObjectProtocol::call` with "
"the args as first parameter and the kwargs (or `None`) as second parameter. "
"There are also `ObjectProtocol::call0` with no args and `ObjectProtocol::"
"call1` with only the args."
msgstr ""

#: src/function.md:94
msgid "Calling rust `Fn`s in python"
msgstr ""

#: src/function.md:96
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use `wrap_pyfunction!` to get the corresponding `PyObject`. For dynamic "
"functions, e.g. lambda and functions that were passed as arguments, you must "
"put them in some kind of owned container, e.g. a box. (Long-Term a special "
"container similar to wasm-bindgen's `Closure` should take care of that). You "
"can than use a `#[pyclass]` struct with that container as field as a way to "
"pass the function over the ffi-barrier. You can even make that class "
"callable with `__call__` so it looks like a function in python code."
msgstr ""

#: src/module.md:1
msgid "Python Module"
msgstr ""

#: src/module.md:3
msgid ""
"As shown in the Getting Started chapter, you can create a module as follows:"
msgstr ""

#: src/module.md:8
msgid ""
"// add bindings to the generated python module\n"
"// N.B: names: \"librust2py\" must be the name of the `.so` or `.pyd` file\n"
"/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:15
msgid ""
"// PyO3 aware function. All of our python interface could be declared in a "
"separate module.\n"
"    // Note that the `#[pyfn()]` annotation automatically converts the "
"arguments from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/module.md:26
msgid "// logic implemented as a normal rust function\n"
msgstr ""

#: src/module.md:35
msgid ""
"The `#[pymodule]` procedural macro attribute takes care of exporting the "
"initialization function of your module to Python. It takes one argument as "
"the name of your module, which must be the name of the `.so` or `.pyd` file."
msgstr ""

#: src/module.md:37
msgid ""
"To import the module, either copy the shared library as described in [Get "
"Started](./overview.md) or use a tool, e.g. `pyo3-pack develop` with [pyo3-"
"pack](https://github.com/PyO3/pyo3-pack) or `python setup.py develop` with "
"[setuptools-rust](https://github.com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:39
msgid "Documentation"
msgstr ""

#: src/module.md:41
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/first-edition/"
"comments.html) of the module initialization function will be applied "
"automatically as the Python doc string of your module."
msgstr ""

#: src/module.md:49
msgid ""
"Which means that the above Python code will print `This module is "
"implemented in Rust.`."
msgstr ""

#: src/module.md:51
msgid "Modules as objects"
msgstr ""

#: src/module.md:53
msgid ""
"In python, modules are first class objects. This means can store them as "
"values or add them to dicts or other modules:"
msgstr ""

#: src/module.md:64
msgid "\"Subfunction\""
msgstr ""

#: src/module.md:86
msgid "\"supermodule\""
msgstr ""

#: src/module.md:88
msgid "\"assert supermodule.submodule.subfuntion() == 'Subfunction'\""
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Get Started"
msgstr ""

#: src/SUMMARY.md:4
msgid "Type Conversions"
msgstr ""

#: src/SUMMARY.md:11
msgid "Advanced Topics"
msgstr ""

#: src/SUMMARY.md:13
msgid "Appendix: Pyo3 and rust-cpython"
msgstr ""

#: src/conversions.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions.md:5
msgid "`.extract()`"
msgstr ""

#: src/conversions.md:7
msgid ""
"The easiest way to convert a python object to a rust value is using `."
"extract()?`."
msgstr ""

#: src/conversions.md:9
msgid "`ToPyObject` and `IntoPyObject` trait"
msgstr ""

#: src/conversions.md:11
msgid ""
"[`ToPyObject`](https://docs.rs/pyo3/0.6.0-alpha.4/trait.ToPyObject.html) "
"trait is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://docs.rs/pyo3/0.6.0-alpha.4/struct.PyObject.html). "
"[`IntoPyObject`](https://docs.rs/pyo3/0.6.0-alpha.4/trait.IntoPyObject.html) "
"serves the same purpose except it consumes `self`."
msgstr ""

#: src/conversions.md:13
msgid "`FromPyObject` and `RefFromPyObject` trait"
msgstr ""

#: src/conversions.md:15
msgid "`*args` and `**kwargs` for python object call"
msgstr ""

#: src/conversions.md:17
msgid ""
"There are several way how to pass positional and keyword arguments to python "
"object call. [`ObjectProtocol`](https://docs.rs/pyo3/0.6.0-alpha.4/trait."
"ObjectProtocol.html) trait provides two methods:"
msgstr ""

#: src/conversions.md:21
msgid "`call` - call callable python object."
msgstr ""

#: src/conversions.md:22
msgid "`call_method` - call specific method on the object."
msgstr ""

#: src/conversions.md:24
msgid "Both methods accept `args` and `kwargs` arguments."
msgstr ""

#: src/conversions.md:39
msgid "\"arg1\""
msgstr ""

#: src/conversions.md:40
msgid "\"arg2\""
msgstr ""

#: src/conversions.md:41
msgid "\"arg3\""
msgstr ""

#: src/conversions.md:48
msgid "// call object without empty arguments\n"
msgstr ""

#: src/conversions.md:51
msgid "// call object with PyTuple\n"
msgstr ""

#: src/conversions.md:55
msgid "// pass arguments as rust tuple\n"
msgstr ""

#: src/conversions.md:61
msgid ""
"`kwargs` can by `None` or `Some(&PyDict)`. You can use the [`IntoPyDict`]"
"(https://docs.rs/pyo3/0.6.0-alpha.4/trait.IntoPyDict.html) trait to convert "
"other dict-like containers, e.g. `HashMap`, `BTreeMap` as well as tuples "
"with up to 10 elements and `Vec`s where each element is a two element tuple."
msgstr ""

#: src/conversions.md:79
msgid "\"key1\""
msgstr ""

#: src/conversions.md:81
msgid "\"key2\""
msgstr ""

#: src/conversions.md:89
msgid "// call object with PyDict\n"
msgstr ""

#: src/conversions.md:93
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/conversions.md:97
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/conversions.md:104
msgid "`IntoPy<T>`"
msgstr ""

#: src/conversions.md:106
msgid ""
"Many conversions in PyO3 can't use `std::convert::Into` because they need a "
"gil token. That's why the `IntoPy<T>` trait offers an `into_py` methods that "
"works just like `into` except for taking a `Python<'_>` as argument."
msgstr ""

#: src/conversions.md:108
msgid ""
"Eventually, traits such as `IntoPyObject` will be replaces by this trait and "
"a `FromPy` trait will be added that will implement `IntoPy`, just like with "
"`From` and `Into`."
msgstr ""
