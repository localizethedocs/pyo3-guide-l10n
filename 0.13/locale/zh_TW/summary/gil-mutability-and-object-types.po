msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:08Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "Mutability and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`Py::clone_ref`](https://docs.rs/pyo3/latest/pyo3/struct.Py.html#method."
"clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://docs.rs/pyo3/latest/pyo3/"
"types/struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe acces to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:47
msgid "Object types"
msgstr ""

#: src/types.md:49
msgid "[`PyAny`](https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/types.md:51
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, `&PyAny`."
msgstr ""

#: src/types.md:54
msgid ""
"**Used:** Whenever you want to refer to some Python object and will have the "
"GIL for the whole duration you need to access that object. For example, "
"intermediate values and arguments to `pyfunction`s or `pymethod`s "
"implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:59
msgid ""
"Many general methods for interacting with Python objects are on the `PyAny` "
"struct, such as `getattr`, `setattr`, and `.call`."
msgstr ""

#: src/types.md:62 src/types.md:128 src/types.md:166 src/types.md:233
msgid "**Conversions:**"
msgstr ""

#: src/types.md:64
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"Python-native type such as a list:"
msgstr ""

#: src/types.md:72
msgid "// To &PyList with PyAny::downcast\n"
msgstr ""

#: src/types.md:75 src/types.md:96 src/types.md:184
msgid "// To Py<PyAny> (aka PyObject) with .into()\n"
msgstr ""

#: src/types.md:78
msgid "// To Py<PyList> with PyAny::extract\n"
msgstr ""

#: src/types.md:85
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"`#[pyclass]`:"
msgstr ""

#: src/types.md:93
msgid "// To &PyCell<MyClass> with PyAny::downcast\n"
msgstr ""

#: src/types.md:99
msgid "// To Py<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:102
msgid "// To MyClass with PyAny::extract, if MyClass: Clone\n"
msgstr ""

#: src/types.md:105
msgid "// To PyRef<MyClass> or PyRefMut<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:113
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:115
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:118
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:122
msgid ""
"These types all implement `Deref<Target = PyAny>`, so they all expose the "
"same methods which can be found on `PyAny`."
msgstr ""

#: src/types.md:125
msgid ""
"To see all Python types exposed by `PyO3` you should consult the [`pyo3::"
"types`](https://docs.rs/pyo3/latest/pyo3/types/index.html) module."
msgstr ""

#: src/types.md:135
msgid ""
"// Use methods from PyAny on all Python types with Deref implementation\n"
msgstr ""

#: src/types.md:138 src/types.md:267
msgid "// To &PyAny automatically with Deref implementation\n"
msgstr ""

#: src/types.md:141 src/types.md:270
msgid "// To &PyAny explicitly with .as_ref()\n"
msgstr ""

#: src/types.md:144
msgid "// To Py<T> with .into() or Py::from()\n"
msgstr ""

#: src/types.md:147
msgid "// To PyObject with .into() or .to_object(py)\n"
msgstr ""

#: src/types.md:154
msgid "`Py<T>` and `PyObject`"
msgstr ""

#: src/types.md:156
msgid ""
"**Represents:** a GIL-independent reference to a Python object. This can be "
"a Python native type (like `PyTuple`), or a `pyclass` type implemented in "
"Rust. The most commonly-used variant, `Py<PyAny>`, is also known as "
"`PyObject`."
msgstr ""

#: src/types.md:160
msgid ""
"**Used:** Whenever you want to carry around references to a Python object "
"without caring about a GIL lifetime.  For example, storing Python object "
"references in a Rust struct that outlives the Python-Rust FFI boundary, or "
"returning objects from functions implemented in Rust back to Python."
msgstr ""

#: src/types.md:164
msgid "Can be cloned using Python reference counts with `.clone()`."
msgstr ""

#: src/types.md:168
msgid "For a `Py<PyList>`, the conversions are as below:"
msgstr ""

#: src/types.md:176
msgid "// To &PyList with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:180
msgid ""
"// Because `.into_ref()` will consume `list`.\n"
"// To &PyList with Py::into_ref() (moves the pointer into PyO3's object "
"storage)\n"
msgstr ""

#: src/types.md:189
msgid ""
"For a `#[pyclass] struct MyClass`, the conversions for `Py<MyClass>` are "
"below:"
msgstr ""

#: src/types.md:198
msgid "// To &PyCell<MyClass> with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:202
msgid ""
"// Because `.into_ref()` will consume `my_class`.\n"
"// To &PyCell<MyClass> with Py::into_ref() (moves the pointer into PyO3's "
"object storage)\n"
msgstr ""

#: src/types.md:206
msgid "// To Py<PyAny> (aka PyObject) with .into_py(py)\n"
msgstr ""

#: src/types.md:210
msgid "// To PyRef<MyClass> with Py::borrow or Py::try_borrow\n"
msgstr ""

#: src/types.md:213
msgid "// To PyRefMut<MyClass> with Py::borrow_mut or Py::try_borrow_mut\n"
msgstr ""

#: src/types.md:220
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:222
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:226
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:230
msgid ""
"Like pyo3's Python native types, `PyCell<T>` implements `Deref<Target = "
"PyAny>`, so it also exposes all of the methods on `PyAny`."
msgstr ""

#: src/types.md:235
msgid ""
"`PyCell<T>` can be used to access `&T` and `&mut T` via `PyRef<T>` and "
"`PyRefMut<T>` respectively."
msgstr ""

#: src/types.md:243
msgid "// To PyRef<T> with .borrow() or .try_borrow()\n"
msgstr ""

#: src/types.md:248
msgid "// To PyRefMut<T> with .borrow_mut() or .try_borrow_mut()\n"
msgstr ""

#: src/types.md:256
msgid "`PyCell<T>` can also be accessed like a Python-native type."
msgstr ""

#: src/types.md:264
msgid "// Use methods from PyAny on PyCell<T> with Deref implementation\n"
msgstr ""

#: src/types.md:277
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:279
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:282
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:286
msgid "Related traits and types"
msgstr ""

#: src/types.md:288
msgid "`PyClass`"
msgstr ""

#: src/types.md:290
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:293
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:295
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""
