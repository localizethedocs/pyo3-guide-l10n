msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:54Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class.md:1
msgid "Python Classes"
msgstr ""

#: src/class.md:3
msgid "Defining a new class"
msgstr "定義新類別"

#: src/class.md:5
msgid ""
"To define a custom Python class, a Rust struct needs to be annotated with "
"the `#[pyclass]` attribute."
msgstr ""

#: src/class.md:17
msgid ""
"Because Python objects are freely shared between threads by the Python "
"interpreter, all structs annotated with `#[pyclass]` must implement `Send`."
msgstr ""

#: src/class.md:19
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://docs."
"rs/pyo3/latest/pyo3/type_object/trait.PyTypeInfo.html), [`PyTypeObject`]"
"(https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeObject.html), and "
"[`PyClass`](https://pyo3.rs/master/doc/pyo3/pyclass/trait.PyClass.html) for "
"`MyClass`. To see these generated implementations, refer to the section [How "
"methods are implemented](#how-methods-are-implemented) at the end of this "
"chapter."
msgstr ""

#: src/class.md:21
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:23
msgid ""
"Custom Python classes can then be added to a module using `add_class()`."
msgstr ""

#: src/class.md:39
msgid "PyCell and interior mutability"
msgstr ""

#: src/class.md:41
msgid ""
"You sometimes need to convert your `pyclass` into a Python object and access "
"it from Rust code (e.g., for testing it). [`PyCell`](https://pyo3.rs/master/"
"doc/pyo3/pycell/struct.PyCell.html) is the primary interface for that."
msgstr ""

#: src/class.md:45
msgid ""
"`PyCell<T: PyClass>` is always allocated in the Python heap, so Rust doesn't "
"have ownership of it. In other words, Rust code can only extract a "
"`&PyCell<T>`, not a `PyCell<T>`."
msgstr ""

#: src/class.md:48
msgid ""
"Thus, to mutate data behind `&PyCell` safely, PyO3 employs the [Interior "
"Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-"
"mutability.html) like [`RefCell`](https://doc.rust-lang.org/std/cell/struct."
"RefCell.html)."
msgstr ""

#: src/class.md:52
msgid ""
"Users who are familiar with `RefCell` can use `PyCell` just like `RefCell`."
msgstr ""

#: src/class.md:54
msgid ""
"For users who are not very familiar with `RefCell`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:55
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:56
msgid "References must always be valid."
msgstr ""

#: src/class.md:58
msgid ""
"`PyCell`, like `RefCell`, ensures these borrowing rules by tracking "
"references at runtime."
msgstr ""

#: src/class.md:73
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:75
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:79
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:81
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:85
msgid "// You can convert `&PyCell` to a Python object\n"
msgstr ""

#: src/class.md:87
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:90
msgid ""
"`&PyCell<T>` is bounded by the same lifetime as a [`GILGuard`](https://docs."
"rs/pyo3/latest/pyo3/struct.GILGuard.html). To make the object longer lived "
"(for example, to store it in a struct on the Rust side), you can use "
"`Py<T>`, which stores an object longer than the GIL lifetime, and therefore "
"needs a `Python<'_>` token to access."
msgstr ""

#: src/class.md:108
msgid "// AsPyRef::as_ref returns &PyCell\n"
msgstr ""

#: src/class.md:109
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:113
msgid "Customizing the class"
msgstr ""

#: src/class.md:115
msgid "The `#[pyclass]` macro accepts the following parameters:"
msgstr ""

#: src/class.md:117
msgid ""
"`name=XXX` - Set the class name shown in Python code. By default, the struct "
"name is used as the class name."
msgstr ""

#: src/class.md:118
msgid ""
"`freelist=XXX` - The `freelist` parameter adds support of free allocation "
"list to custom class. The performance improvement applies to types that are "
"often created and deleted in a row, so that they can benefit from a "
"freelist. `XXX` is a number of items for the free list."
msgstr ""

#: src/class.md:121
msgid ""
"`gc` - Classes with the `gc` parameter participate in Python garbage "
"collection. If a custom class contains references to other Python objects "
"that can be collected, the [`PyGCProtocol`](https://docs.rs/pyo3/latest/pyo3/"
"class/gc/trait.PyGCProtocol.html) trait has to be implemented."
msgstr ""

#: src/class.md:123
msgid "`weakref` - Adds support for Python weak references."
msgstr ""

#: src/class.md:124
msgid ""
"`extends=BaseType` - Use a custom base class. The base `BaseType` must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:125
msgid "`subclass` - Allows Python classes to inherit from this class."
msgstr ""

#: src/class.md:126
msgid ""
"`dict` - Adds `__dict__` support, so that the instances of this type have a "
"dictionary containing arbitrary instance variables."
msgstr ""

#: src/class.md:127
msgid ""
"`unsendable` - Making it safe to expose `!Send` structs to Python, where all "
"object can be accessed by multiple threads. A class marked with `unsendable` "
"panics when accessed by another thread."
msgstr ""

#: src/class.md:129
msgid ""
"`module=\"XXX\"` - Set the name of the module the class will be shown as "
"defined in. If not given, the class will be a virtual member of the "
"`builtins` module."
msgstr ""

#: src/class.md:132
msgid "Constructor"
msgstr ""

#: src/class.md:134
msgid ""
"By default it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:154
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:157
msgid "For arguments, see the `Method arguments` section below."
msgstr ""

#: src/class.md:159
msgid "Return type"
msgstr ""

#: src/class.md:161
msgid ""
"Generally, `#[new]` method have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:164
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:167
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:167
msgid "**May fail**"
msgstr ""

#: src/class.md:169
msgid "**No inheritance**"
msgstr ""

#: src/class.md:169
msgid "`T`"
msgstr "`T`"

#: src/class.md:169
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:170
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:170
msgid "`(T, U)`"
msgstr "`(T, U)`"

#: src/class.md:170
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:171
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:171
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/master/doc/pyo3/pyclass_init/"
"struct.PyClassInitializer.html)"
msgstr ""

#: src/class.md:171
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:173
msgid "Inheritance"
msgstr ""

#: src/class.md:175
msgid ""
"By default, `PyAny` is used as the base class. To override this default, use "
"the `extends` parameter for `pyclass` with the full path to the base class."
msgstr ""

#: src/class.md:178
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the baseclass of `T`. But for more deeply nested inheritance, you have to "
"return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:183
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/master/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_ref()` as `&Self::BaseClass`, or by `self_.into_super()` as `PyRef<Self::"
"BaseClass>`."
msgstr ""

#: src/class.md:221
msgid "// Get &BaseClass\n"
msgstr ""

#: src/class.md:241
msgid "// Get PyRef<SubClass>\n"
msgstr ""

#: src/class.md:248
msgid "\"assert subsub.method3() == 3000\""
msgstr ""

#: src/class.md:251
msgid ""
"You can also inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/master/doc/pyo3/type_object/trait."
"PySizedLayout.html)."
msgstr ""

#: src/class.md:254
msgid ""
"However, because of some technical problems, we don't currently provide safe "
"upcasting methods for types that inherit native types. Even in such cases, "
"you can unsafely get a base class by raw pointer conversion."
msgstr ""

#: src/class.md:285
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:288
msgid ""
"If `SubClass` does not provide a baseclass initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:311
msgid "Object properties"
msgstr ""

#: src/class.md:313
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:314
msgid ""
"For simple fields with no side effects, a `#[pyo3(get, set)]` attribute can "
"be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:315
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the `#[pymethods]` block."
msgstr ""

#: src/class.md:317
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:319
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:321
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:332
msgid ""
"The above would make the `num` property available for reading and writing "
"from Python code as `self.num`."
msgstr ""

#: src/class.md:334
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:336
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:337
msgid ""
"For `get` the field type must implement both `IntoPy<PyObject>` and `Clone`."
msgstr ""

#: src/class.md:338
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:340
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:342
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:344
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:362
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:365
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:392
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:394
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:418
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:420
msgid "Instance methods"
msgstr ""

#: src/class.md:422
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:426
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust."
msgstr ""

#: src/class.md:448
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:452
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:470
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:472
msgid "Class methods"
msgstr ""

#: src/class.md:474
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:495
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:497
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:499
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:500
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:501
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:503
msgid "Static methods"
msgstr ""

#: src/class.md:505
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:525
msgid "Class attributes"
msgstr ""

#: src/class.md:527
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute. "
"The return type must be `T` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:539
msgid "\"hello\""
msgstr ""

#: src/class.md:546
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:549
msgid ""
"Note that unlike class variables defined in Python code, class attributes "
"defined in Rust cannot be mutated at all:"
msgstr ""

#: src/class.md:552
msgid ""
"// Would raise a `TypeError: can't set attributes of built-in/extension type "
"'MyClass'`\n"
msgstr ""

#: src/class.md:553
msgid "\"my_class.my_attribute = 'foo'\""
msgstr ""

#: src/class.md:556
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:566
msgid "\"foobar\""
msgstr ""

#: src/class.md:570
msgid "Callable objects"
msgstr ""

#: src/class.md:572
msgid ""
"To specify a custom `__call__` method for a custom class, the method needs "
"to be annotated with the `#[call]` attribute. Arguments of the method are "
"specified as for instance methods."
msgstr ""

#: src/class.md:586 src/class.md:636
msgid "\"*\""
msgstr ""

#: src/class.md:588
msgid "\"MyClass has been called\""
msgstr ""

#: src/class.md:594
msgid "Method arguments"
msgstr ""

#: src/class.md:596
msgid ""
"By default, PyO3 uses function signatures to determine which arguments are "
"required. Then it scans the incoming `args` and `kwargs` parameters. If it "
"can not find all required parameters, it raises a `TypeError` exception. It "
"is possible to override the default behavior with the `#[args(...)]` "
"attribute. This attribute accepts a comma separated list of parameters in "
"the form of `attr_name=\"default value\"`. Each parameter has to match the "
"method parameter by name."
msgstr ""

#: src/class.md:602
msgid "Each parameter can be one of the following types:"
msgstr ""

#: src/class.md:604
msgid ""
"`\"*\"`: var arguments separator, each parameter defined after `\"*\"` is a "
"keyword-only parameter. Corresponds to python's `def meth(*, arg1.., "
"arg2=..)`."
msgstr ""

#: src/class.md:606
msgid ""
"`args=\"*\"`: \"args\" is var args, corresponds to Python's `def "
"meth(*args)`. Type of the `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:608
msgid ""
"`kwargs=\"**\"`: \"kwargs\" receives keyword arguments, corresponds to "
"Python's `def meth(**kwargs)`. The type of the `kwargs` parameter has to be "
"`Option<&PyDict>`."
msgstr ""

#: src/class.md:610
msgid ""
"`arg=\"Value\"`: arguments with default value. Corresponds to Python's `def "
"meth(arg=Value)`. If the `arg` argument is defined after var arguments, it "
"is treated as a keyword-only argument. Note that `Value` has to be valid "
"rust code, PyO3 just inserts it into the generated code unmodified."
msgstr ""

#: src/class.md:615 src/class.md:812
msgid "Example:"
msgstr ""

#: src/class.md:628
msgid "\"-1\""
msgstr ""

#: src/class.md:628 src/class.md:635
msgid "\"true\""
msgstr ""

#: src/class.md:634
msgid "\"10\""
msgstr ""

#: src/class.md:637
msgid "\"\\\"Hello\\\"\""
msgstr ""

#: src/class.md:638
msgid "\"**\""
msgstr ""

#: src/class.md:651
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={}, debug={}\""
msgstr ""

#: src/class.md:659
msgid "\"num={}, debug={}\""
msgstr ""

#: src/class.md:663
msgid ""
"N.B. the position of the `\"*\"` argument (if included) controls the system "
"of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/class.md:668 src/class.md:669
msgid "\"World\""
msgstr ""

#: src/class.md:673
msgid "Produces output:"
msgstr ""

#: src/class.md:681
msgid "Class customizations"
msgstr ""

#: src/class.md:683
msgid ""
"Python's object model defines several protocols for different object "
"behavior, like sequence, mapping or number protocols. PyO3 defines separate "
"traits for each of them. To provide specific Python object behavior, you "
"need to implement the specific trait for your struct. Important note, each "
"protocol implementation block has to be annotated with the `#[pyproto]` "
"attribute."
msgstr ""

#: src/class.md:688
msgid ""
"All `#[pyproto]` methods which can be defined below can return `T` instead "
"of `PyResult<T>` if the method implementation is infallible. In addition, if "
"the return type is `()`, it can be omitted altogether."
msgstr ""

#: src/class.md:691
msgid "Basic object customization"
msgstr ""

#: src/class.md:693
msgid ""
"The [`PyObjectProtocol`](https://docs.rs/pyo3/latest/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provides several basic customizations."
msgstr ""

#: src/class.md:695
msgid "Attribute access"
msgstr ""

#: src/class.md:697
msgid "To customize object attribute access, define the following methods:"
msgstr ""

#: src/class.md:699
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl "
"IntoPy<PyObject>>`"
msgstr ""

#: src/class.md:700
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:701
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:703
msgid ""
"Each method corresponds to Python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:705
msgid "String Conversions"
msgstr ""

#: src/class.md:707
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:708
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:710
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`."
msgstr ""

#: src/class.md:712
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:714
msgid "Provides the conversion to `bytes`."
msgstr ""

#: src/class.md:716
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:718
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:721
msgid "Comparison operators"
msgstr ""

#: src/class.md:723
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:725
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:731
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:733
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:736
msgid "Other methods"
msgstr ""

#: src/class.md:738
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:740
msgid "Determines the \"truthyness\" of the object."
msgstr ""

#: src/class.md:742
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:744
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement the [`PyGCProtocol`](https://docs.rs/pyo3/"
"latest/pyo3/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another Python object. `__clear__` "
"must clear out any mutable references to other Python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:778
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:787
msgid ""
"Special protocol trait implementations have to be annotated with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class.md:789
msgid ""
"It is also possible to enable GC for custom classes using the `gc` parameter "
"of the `pyclass` attribute. i.e. `#[pyclass(gc)]`. In that case instances of "
"custom class participate in Python garbage collection, and it is possible to "
"track them with `gc` module methods. When using the `gc` parameter, it is "
"_required_ to implement the `PyGCProtocol` trait, failure to do so will "
"result in an error at compile time:"
msgstr ""

#: src/class.md:795
msgid ""
"```compile_fail\n"
"#[pyclass(gc)]\n"
"struct GCTracked {} // Fails because it does not implement PyGCProtocol\n"
"```"
msgstr ""

#: src/class.md:800
msgid "Iterator Types"
msgstr ""

#: src/class.md:802
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://docs.rs/pyo3/"
"latest/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:805
msgid "`fn __iter__(slf: PyRefMut<Self>) -> PyResult<impl IntoPy<PyObject>>`"
msgstr ""

#: src/class.md:806
msgid ""
"`fn __next__(slf: PyRefMut<Self>) -> PyResult<Option<impl IntoPy<PyObject>>>`"
msgstr ""

#: src/class.md:808
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items. These two methods can be take either `PyRef<Self>` or "
"`PyRefMut<Self>` as their first argument, so that mutable borrow can be "
"avoided if needed."
msgstr ""

#: src/class.md:834
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, you should "
"implement `PyIterProtocol` for both the iterable and the iterator, but the "
"iterable only needs to support `__iter__()` while the iterator must support "
"both `__iter__()` and `__next__()`. The default implementations in "
"`PyIterProtocol` will ensure that the objects behave correctly in Python. "
"For example:"
msgstr ""

#: src/class.md:883
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class.md:884
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class.md:887
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/3/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class.md:890
msgid "Returning a value from iteration"
msgstr ""

#: src/class.md:892
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration. In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://docs.rs/"
"pyo3/latest/pyo3/class/iter/enum.IterNextOutput.html) enum to both `Yield` "
"values and `Return` a final value - see its docs for further details and an "
"example."
msgstr ""

#: src/class.md:898
msgid "How methods are implemented"
msgstr ""

#: src/class.md:900
msgid ""
"Users should be able to define a `#[pyclass]` with or without "
"`#[pymethods]`, while PyO3 needs a trait with a function that returns all "
"methods. Since it's impossible to make the code generation in pyclass "
"dependent on whether there is an impl block, we'd need to implement the "
"trait on `#[pyclass]` and override the implementation in `#[pymethods]`. To "
"enable this, we use a static registry type provided by [inventory](https://"
"github.com/dtolnay/inventory), which allows us to collect `impl`s from "
"arbitrary source code by exploiting some binary trick. See [inventory: how "
"it works](https://github.com/dtolnay/inventory#how-it-works) and "
"`pyo3_derive_backend::py_class` for more details. Also for `#[pyproto]`, we "
"use a similar, but more task-specific registry and initialize it using the "
"[ctor](https://github.com/mmastrac/rust-ctor) crate."
msgstr ""

#: src/class.md:910
msgid "Specifically, the following implementation is generated:"
msgstr ""

#: src/class.md:914
msgid "/// Class for demonstration\n"
msgstr ""

#: src/class.md:931
msgid "\"MyClass\""
msgstr ""

#: src/class.md:933
msgid "\"Class for demonstration\""
msgstr ""

#: src/class.md:986
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""
