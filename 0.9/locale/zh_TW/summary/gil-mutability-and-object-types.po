msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "Mutability and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`PyObject::clone_ref`](https://docs.rs/pyo3/latest/pyo3/struct.PyObject."
"html#method.clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://docs.rs/pyo3/latest/pyo3/"
"types/struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe acces to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:47
msgid "Object types"
msgstr ""

#: src/types.md:49
msgid "`PyObject`"
msgstr ""

#: src/types.md:51
msgid ""
"**Represents:** a GIL independent reference to a Python object of "
"unspecified type."
msgstr ""

#: src/types.md:54
msgid ""
"**Used:** Whenever you want to carry around references to \"some\" Python "
"object, without caring about a GIL lifetime.  For example, storing Python "
"object references in a Rust struct that outlives the Python-Rust FFI "
"boundary, or returning objects from functions implemented in Rust back to "
"Python."
msgstr ""

#: src/types.md:59
msgid "Can be cloned using Python reference counts with `.clone_ref()`."
msgstr ""

#: src/types.md:61 src/types.md:76 src/types.md:97 src/types.md:111
#: src/types.md:127
msgid "**Conversions:**"
msgstr ""

#: src/types.md:63
msgid "To `&PyAny`: `obj.as_ref(py)`"
msgstr ""

#: src/types.md:64
msgid "To `Py<ConcreteType>`: `obj.as_ref(py).extract::<Py<ConcreteType>>`"
msgstr ""

#: src/types.md:65
msgid ""
"To `&ConcreteType` (which must be a Python native type): `obj.cast_as(py)`"
msgstr ""

#: src/types.md:68
msgid "`Py<SomeType>`"
msgstr ""

#: src/types.md:70
msgid ""
"**Represents:** a GIL independent reference to a Python object of known "
"type. This can be a Python native type (like `PyTuple`), or a `pyclass` type "
"implemented in Rust."
msgstr ""

#: src/types.md:74
msgid "**Used:** Like `PyObject`, but with a known inner type."
msgstr ""

#: src/types.md:78 src/types.md:99
msgid "To `PyObject`: `obj.to_object(py)`"
msgstr ""

#: src/types.md:79
msgid ""
"To `&SomeType` or `&PyCell<SomeType>`: `obj.as_ref(py)`.  For `pyclass` "
"types implemented in Rust, you get a `PyCell` (see below).  For Python "
"native types, mutating operations through PyO3's API don't require `&mut` "
"access."
msgstr ""

#: src/types.md:83
msgid ""
"**Note:** `PyObject` is semantically equivalent to `Py<PyAny>` and might be "
"merged with it in the future."
msgstr ""

#: src/types.md:87
msgid "`PyAny`"
msgstr ""

#: src/types.md:89
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, usually "
"`&PyAny`."
msgstr ""

#: src/types.md:93
msgid ""
"**Used:** Whenever you want to refer to some Python object only as long as "
"holding the GIL.  For example, intermediate values and arguments to "
"`pyfunction`s or `pymethod`s implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:102
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:104
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:107
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:113
msgid "To `PyAny`: `obj.as_ref()`"
msgstr ""

#: src/types.md:114
msgid "To `Py<T>`: `Py::from(obj)`"
msgstr ""

#: src/types.md:117
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:119
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:123
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:129
msgid "From `PyAny`: `.downcast()`"
msgstr ""

#: src/types.md:132
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:134
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:137
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:142
msgid "Related traits and types"
msgstr ""

#: src/types.md:144
msgid "`PyClass`"
msgstr ""

#: src/types.md:146
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:149
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:151
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""
