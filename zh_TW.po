msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:56Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/rust-cpython.md:1
msgid "Appendix: pyo3 and rust-cpython"
msgstr ""

#: src/rust-cpython.md:3
msgid ""
"Pyo3 began as fork of [rust-cpython](https://github.com/dgrunwald/rust-"
"cpython) when rust-cpython wasn't maintained. Over the time pyo3 has become "
"fundamentally different from rust-cpython."
msgstr ""

#: src/rust-cpython.md:5
msgid ""
"This chapter is based on the discussion in [PyO3/pyo3#55](https://github.com/"
"PyO3/pyo3/issues/55)."
msgstr ""

#: src/rust-cpython.md:7
msgid "Macros"
msgstr ""

#: src/rust-cpython.md:9
msgid ""
"While rust-cpython has a macro based dsl for declaring modules and classes, "
"pyo3 use proc macros and spezialization. Pyo3 also doesn't change your "
"struct and functions so you can still use them as normal rust functions. The "
"disadvantage is that proc macros and spezialization currently only work on "
"nightly."
msgstr ""

#: src/rust-cpython.md:11 src/rust-cpython.md:63
msgid "**rust-cpython**"
msgstr ""

#: src/rust-cpython.md:25 src/rust-cpython.md:74
msgid "**pyo3**"
msgstr ""

#: src/rust-cpython.md:57
msgid "Ownership and lifetimes"
msgstr ""

#: src/rust-cpython.md:59
msgid ""
"All objects are owned by pyo3 library and all apis available with "
"references, while in rust-cpython, you own python objects."
msgstr ""

#: src/rust-cpython.md:61
msgid "Here is example of PyList api:"
msgstr ""

#: src/rust-cpython.md:85
msgid ""
"Because pyo3 allows only references to python object, all reference have the "
"Gil lifetime. So the python object is not required, and it is safe to have "
"functions like `fn py<'p>(&'p self) -> Python<'p> {}`."
msgstr ""

#: src/rust-cpython.md:87
msgid "Error handling"
msgstr "錯誤處理"

#: src/rust-cpython.md:89
msgid ""
"rust-cpython requires a `Python` parameter for `PyErr`, so error handling "
"ergonomics is pretty bad. It is not possible to use `?` with rust errors."
msgstr ""

#: src/rust-cpython.md:91
msgid ""
"`pyo3` on other hand does not require `Python` for `PyErr`, it is only "
"required if you want to raise an exception in python with the `PyErr::"
"restore()` method. Due to the `std::convert::From<Err> for PyErr` trait `?` "
"is supported automatically."
msgstr ""

#: src/debugging.md:1
msgid "Debugging"
msgstr "除錯"

#: src/debugging.md:3
msgid ""
"Pyo3's attributes, `#[pyclass]`, `#[pymodinit]`, etc. are [procedural macros]"
"(https://doc.rust-lang.org/unstable-book/language-features/proc-macro.html), "
"which means that rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:9
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:11
msgid "You can also debug classic `!`\\-macros by adding -Z trace-macros\\`:"
msgstr ""

#: src/debugging.md:17
msgid ""
"See [cargo expand](https://github.com/dtolnay/cargo-expand) for a more "
"elaborate version of those commands."
msgstr ""

#: src/distribution.md:1
msgid "Distribution"
msgstr ""

#: src/distribution.md:3
msgid "`setuptools-rust` integration"
msgstr ""

#: src/distribution.md:5
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is a setuptools "
"helpers for Rust Python extensions. It supports `PyO3` by default."
msgstr ""

#: src/distribution.md:7
msgid ""
"For detailed usage, please refer to its [README](https://github.com/PyO3/"
"setuptools-rust/blob/master/README.rst)"
msgstr ""

#: src/distribution.md:9
msgid "Source distribution"
msgstr ""

#: src/distribution.md:11
msgid ""
"To build a source code distribution, you need to add the following lines to "
"your `MANIFEST.in` file to ensure it correctly packages Rust extension "
"source code."
msgstr ""

#: src/distribution.md:18
msgid ""
"Then you can build a source code distribution by (assuming you have already "
"written a `setup.py`):"
msgstr ""

#: src/distribution.md:24
msgid "Binary wheel distribution"
msgstr ""

#: src/distribution.md:26
msgid ""
"To build a binary wheel, [manylinux](https://github.com/pypa/manylinux) "
"would be a natural choice for Linux."
msgstr ""

#: src/distribution.md:28
msgid ""
"Take the [example](https://github.com/PyO3/setuptools-rust/tree/master/"
"example) project in [`setuptools-rust`](https://github.com/PyO3/setuptools-"
"rust) repository for example, we have a [`build-wheels.sh`](https://github."
"com/PyO3/setuptools-rust/blob/master/example/build-wheels.sh) to be used "
"with Docker to build manylinux1 wheels. First you need to pull the "
"`manylinux1` Docker image:"
msgstr ""

#: src/distribution.md:36
msgid ""
"Then use the following command to build wheels for supported Python versions:"
msgstr ""

#: src/distribution.md:42
msgid "You will find all the wheels in `dist` directory:"
msgstr ""

#: src/distribution.md:52
msgid ""
"The `*-manylinux1_x86_64.whl` files are the `manylinux1` wheels that you can "
"upload to PyPI."
msgstr ""

#: src/overview.md:1
msgid "PyO3"
msgstr ""

#: src/overview.md:3
msgid ""
"[Rust](http://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/). This includes running and interacting with python code from a rust "
"binaries as well as writing native python modules."
msgstr ""

#: src/overview.md:5
msgid "Usage"
msgstr "使用方式"

#: src/overview.md:7
msgid ""
"Pyo3 supports python 2.7 as well as python 3.5 and up. The minimum required "
"rust version is 1.29.0-nightly 2018-07-16."
msgstr ""

#: src/overview.md:9
msgid ""
"You can either write a native python module in rust or use python from a "
"rust binary."
msgstr ""

#: src/overview.md:11
msgid "Using rust from python"
msgstr ""

#: src/overview.md:13
msgid "Pyo3 can be used to generate a native python module."
msgstr ""

#: src/overview.md:15
msgid "**`Cargo.toml`:**"
msgstr ""

#: src/overview.md:17
msgid ""
"```toml\n"
"[package]\n"
"name = \"rust-py\"\n"
"version = \"0.1.0\"\n"
"\n"
"[lib]\n"
"name = \"rust_py\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies.pyo3]\n"
"version = \"0.3\"\n"
"features = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/overview.md:31
msgid "**`src/lib.rs`**"
msgstr ""

#: src/overview.md:41
msgid "/// Formats the sum of two numbers as string\n"
msgstr ""

#: src/overview.md:46
msgid "/// This module is a python moudle implemented in Rust.\n"
msgstr ""

#: src/overview.md:56
msgid ""
"On windows and linux, you can build normally with `cargo build --release`. "
"On Mac Os, you need to set additional linker arguments. One option is to "
"compile with `cargo rustc --release -- -C link-arg=-undefined -C link-"
"arg=dynamic_lookup`, the other is to create a `.cargo/config` with the "
"following content:"
msgstr ""

#: src/overview.md:58
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""

#: src/overview.md:66
msgid ""
"Also on macOS, you will need to rename the output from \\*.dylib to \\*.so. "
"On Windows, you will need to rename the output from \\*.dll to \\*.pyd."
msgstr ""

#: src/overview.md:68
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) can be used to "
"generate a python package and includes the commands above by default. See "
"[examples/word-count](examples/https://github.com/PyO3/pyo3/tree/master/"
"examples/word-count) and the associated setup.py."
msgstr ""

#: src/overview.md:70
msgid "Using python from rust"
msgstr ""

#: src/overview.md:72
msgid "Add `pyo3` this to your `Cargo.toml`:"
msgstr ""

#: src/overview.md:74
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = \"0.3\"\n"
"```"
msgstr ""

#: src/overview.md:79
msgid "Example program displaying the value of `sys.version`:"
msgstr ""

#: src/overview.md:91
msgid "\"sys\""
msgstr ""

#: src/overview.md:92
msgid "\"version\""
msgstr ""

#: src/overview.md:95
msgid "\"os\""
msgstr ""

#: src/overview.md:96
msgid "\"os.getenv('USER') or os.getenv('USERNAME')\""
msgstr ""

#: src/overview.md:98
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/overview.md:103
msgid "Examples and tooling"
msgstr ""

#: src/overview.md:105
msgid ""
"[examples/word-count](https://github.com/PyO3/pyo3/tree/master/examples/word-"
"count) _Counting the occurences of a word in a text file_"
msgstr ""

#: src/overview.md:106
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json_"
msgstr ""

#: src/overview.md:107
msgid ""
"[rust-numpy](https://github.com/rust-numpy/rust-numpy) _Rust binding of "
"NumPy C-API_"
msgstr ""

#: src/overview.md:108
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://pyo3.github.io/pyo3/pyo3/struct.PyDict.html)_"
msgstr ""

#: src/overview.md:109
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library_"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr "平行化"

#: src/parallelism.md:3
msgid ""
"CPython has an infamous GIL(Global Interpreter Lock) prevents developers "
"getting true parallelism. With `pyo3` you can release GIL when executing "
"Rust code to achieve true parallelism."
msgstr ""

#: src/parallelism.md:7
msgid ""
"The [`Python::allow_threads`](https://docs.rs/pyo3/0.2.7/struct.Python."
"html#method.allow_threads) method temporarily releases the GIL, thus "
"allowing other Python threads to run."
msgstr ""

#: src/parallelism.md:16
msgid ""
"Let's take a look at our [word-count](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/src/lib.rs) example, we have a `wc_parallel` "
"function utilize the [rayon](https://github.com/nikomatsakis/rayon) crate to "
"count words in parallel."
msgstr ""

#: src/parallelism.md:27
msgid ""
"Then in the Python bridge, we have a function `search` exposed to Python "
"runtime which calls `wc_parallel` inside `Python::allow_threads` method to "
"enable true parallelism:"
msgstr ""

#: src/parallelism.md:34
msgid "\"search\""
msgstr ""

#: src/parallelism.md:48
msgid "Benchmark"
msgstr "基準測試"

#: src/parallelism.md:50
msgid ""
"Let's benchmark the `word-count` example to verify that we did unlock true "
"parallelism with `pyo3`. We are using `pytest-benchmark` to benchmark three "
"word count functions:"
msgstr ""

#: src/parallelism.md:53
msgid ""
"[Pure Python version](https://github.com/PyO3/pyo3/blob/master/examples/word-"
"count/word_count/__init__.py#L9)"
msgstr ""

#: src/parallelism.md:54
msgid ""
"[Rust sequential version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L64)"
msgstr ""

#: src/parallelism.md:55
msgid ""
"[Rust parallel version](https://github.com/PyO3/pyo3/blob/master/examples/"
"word-count/src/lib.rs#L54)"
msgstr ""

#: src/parallelism.md:57
msgid ""
"Benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"master/examples/word-count/tests/test_word_count.py), then we can run "
"`pytest tests` to benchmark them."
msgstr ""

#: src/parallelism.md:60
msgid "On MacBook Pro (Retina, 15-inch, Mid 2015) the benchmark gives:"
msgstr ""

#: src/parallelism.md:62
msgid ""
"![Benchmark Result](https://user-images.githubusercontent."
"com/1556054/28604608-81bd6d22-71fe-11e7-8a2c-c3cf3bd0f622.png)"
msgstr ""

#: src/class.md:1
msgid "Python Class"
msgstr ""

#: src/class.md:3
msgid "Define new class"
msgstr ""

#: src/class.md:5
msgid ""
"To define python custom class, rust struct needs to be annotated with "
"`#[pyclass]` attribute."
msgstr ""

#: src/class.md:20
msgid ""
"The above example generates implementations for `PyTypeInfo` and "
"`PyTypeObject` for `MyClass`."
msgstr ""

#: src/class.md:22
msgid ""
"If the class has a `PyToken` attribute, implementations for "
"`PyObjectWithToken`, `ToPyObject`, `IntoPyObject` and `ToPyPointer` are also "
"generated. You can only get a `PyToken` instance through the  `__new__` "
"method."
msgstr ""

#: src/class.md:24
msgid "Customizing the class"
msgstr ""

#: src/class.md:26
msgid "The `#[pyclass]` macro accepts following parameters:"
msgstr ""

#: src/class.md:28
msgid ""
"`name=XXX` - Set the class name shown in python code. By default struct name "
"is used as a class name."
msgstr ""

#: src/class.md:29
msgid ""
"`freelist=XXX` - `freelist` parameter add support of free allocation list to "
"custom class. The performance improvement applies to types that are often "
"created and deleted in a row, so that they can benefit from a freelist. "
"`XXX` is a number of items for free list."
msgstr ""

#: src/class.md:32
msgid ""
"`gc` - Classes with the `gc` parameter participate in python garbage "
"collector. If a custom class contains references to other python object that "
"can be collected, the `PyGCProtocol` trait has to be implemented."
msgstr ""

#: src/class.md:35
msgid "`weakref` - adds support for python weak references"
msgstr ""

#: src/class.md:36
msgid ""
"`extends=BaseType` - use a custom base class. The base BaseType must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:37
msgid "`subclass` - Allows Python classes to inherit from this class"
msgstr ""

#: src/class.md:38
msgid ""
"`dict` - adds `__dict__` support, the instances of this type have a "
"dictionary containing instance variables. (Incomplete, see [\\#123](https://"
"github.com/PyO3/pyo3/issues/123))"
msgstr ""

#: src/class.md:41
msgid "Constructor"
msgstr ""

#: src/class.md:43
msgid ""
"By default it is not possible to create an instance of a custom class from "
"python code. To declare a constructor, you need to define a class method and "
"annotate it with `#[new]` attribute. Only the python `__new__` method can be "
"specified, `__init__` is not available."
msgstr ""

#: src/class.md:75
msgid "Rules for the `new` method:"
msgstr ""

#: src/class.md:77
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:79
msgid ""
"The first parameter is the raw object and the custom `new` method must "
"initialize the object with an instance of the struct using `init` method. "
"The type of the object may be the type object of a derived class declared in "
"Python."
msgstr ""

#: src/class.md:82
msgid "The first parameter implicitly has type `&PyRawObject`."
msgstr ""

#: src/class.md:83 src/class.md:336
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:84
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`. Usually, `T` will be `MyType`."
msgstr ""

#: src/class.md:87
msgid "Inheritance"
msgstr ""

#: src/class.md:89
msgid ""
"By default `PyObject` is used as default base class. To override default "
"base class `base` parameter for `class` needs to be used. Value is full path "
"to base class. `__new__` method accepts `PyRawObject` object. `obj` instance "
"must be initialized with value of custom class struct. Subclass must call "
"parent's `__new__` method."
msgstr ""

#: src/class.md:137
msgid ""
"`ObjectProtocol` trait provides `get_base()` method. It returns reference to "
"instance of base class."
msgstr ""

#: src/class.md:141
msgid "Object properties"
msgstr ""

#: src/class.md:143
msgid ""
"Descriptor methods can be defined in `#[pymethods]` `impl` block only and "
"has to be annotated with `#[getter]` or `[setter]` attributes. i.e."
msgstr ""

#: src/class.md:167
msgid ""
"Getter or setter function's name is used as property name by default. There "
"are several ways how to override name."
msgstr ""

#: src/class.md:170
msgid ""
"If function name starts with `get_` or `set_` for getter or setter "
"respectively. Descriptor name becomes function name with prefix removed. "
"This is useful in case os rust's special keywords like `type`."
msgstr ""

#: src/class.md:200
msgid ""
"In this case property `num` is defined. And it is available from python code "
"as `self.num`."
msgstr ""

#: src/class.md:202
msgid ""
"Also both `#[getter]` and `#[setter]` attributes accepts one parameter. If "
"parameter is specified, it is used and property name. i.e."
msgstr ""

#: src/class.md:231
msgid ""
"In this case property `number` is defined. And it is available from python "
"code as `self.number`."
msgstr ""

#: src/class.md:233
msgid ""
"For simple cases you can also define getters and setters in your Rust struct "
"field definition, for example:"
msgstr ""

#: src/class.md:246
msgid "Then it is available from Python code as `self.num`."
msgstr ""

#: src/class.md:248
msgid "Instance methods"
msgstr ""

#: src/class.md:250
msgid ""
"To define python compatible method, `impl` block for struct has to be "
"annotated with `#[pymethods]` attribute. `pyo3` library generates python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:279
msgid ""
"Calls to this methods protected by `GIL`, `&self` or `&mut self` can be "
"used. The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:282
msgid ""
"`Python` parameter can be specified as part of method signature, in this "
"case `py` argument get injected by method wrapper. i.e"
msgstr ""

#: src/class.md:304
msgid ""
"From python perspective `method2`, in above example, does not accept any "
"arguments."
msgstr ""

#: src/class.md:306
msgid "Class methods"
msgstr ""

#: src/class.md:308
msgid ""
"To specify class method for custom class, method needs to be annotated "
"with`#[classmethod]` attribute."
msgstr ""

#: src/class.md:331
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:333
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:335
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:337
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:339
msgid "Static methods"
msgstr ""

#: src/class.md:341
msgid ""
"To specify class method for custom class, method needs to be annotated with "
"`#[staticmethod]` attribute. The return type must be `PyResult<T>` for some "
"`T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:365
msgid "Callable object"
msgstr ""

#: src/class.md:367
msgid ""
"To specify custom `__call__` method for custom class, call method needs to "
"be annotated with `#[call]` attribute. Arguments of the method are specified "
"same as for instance method."
msgstr ""

#: src/class.md:384 src/class.md:429
msgid "\"*\""
msgstr ""

#: src/class.md:386
msgid "\"MyCLS has been called\""
msgstr ""

#: src/class.md:392
msgid "Method arguments"
msgstr ""

#: src/class.md:394
msgid ""
"By default pyo3 library uses function signature to determine which arguments "
"are required. Then it scans incoming `args` parameter and then incoming "
"`kwargs` parameter. If it can not find all required parameters, it raises "
"`TypeError` exception. It is possible to override default behavior with "
"`#[args(...)]` attribute. `args` attribute accept comma separated list of "
"parameters in form `attr_name=\"default value\"`. Each parameter has to "
"match method parameter by name."
msgstr ""

#: src/class.md:401
msgid "Each parameter could one of following type:"
msgstr ""

#: src/class.md:403
msgid ""
"\"\\*\": var arguments separator, each parameter defined after \"\\*\" is "
"keyword only parameters. corresponds to python's `def meth(*, arg1.., "
"arg2=..)`"
msgstr ""

#: src/class.md:405
msgid ""
"args=\"\\*\": \"args\" is var args, corresponds to python's `def "
"meth(*args)`. Type of `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:407
msgid ""
"kwargs=\"\\*\\*\": \"kwargs\" is keyword arguments, corresponds to python's "
"`def meth(**kwargs)`. Type of `kwargs` parameter has to be `Option<&PyDict>`."
msgstr ""

#: src/class.md:409
msgid ""
"arg=\"Value\": arguments with default value. corresponds to python's `def "
"meth(arg=Value)`. if `arg` argument is defined after var arguments it is "
"treated as keyword argument. Note that `Value` has to be valid rust code, "
"pyo3 just inserts it into generated code unmodified."
msgstr ""

#: src/class.md:414 src/class.md:566
msgid "Example:"
msgstr ""

#: src/class.md:429
msgid "\"**\""
msgstr ""

#: src/class.md:437
msgid "Class customizations"
msgstr "類別自訂"

#: src/class.md:439
msgid ""
"Python object model defines several protocols for different object behavior, "
"like sequence, mapping or number protocols. pyo3 library defines separate "
"trait for each of them. To provide specific python object behavior you need "
"to implement specific trait for your struct. Important note, each protocol "
"implementation block has to be annotated with `#[pyproto]` attribute."
msgstr ""

#: src/class.md:445
msgid "Basic object customization"
msgstr "基本物件自訂"

#: src/class.md:447
msgid ""
"[`PyObjectProtocol`](https://docs.rs/pyo3/0.2.7/class/basic/trait."
"PyObjectProtocol.html) trait provide several basic customizations."
msgstr ""

#: src/class.md:449
msgid "Attribute access"
msgstr ""

#: src/class.md:451
msgid "To customize object attribute access define following methods:"
msgstr ""

#: src/class.md:453
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:454
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:455
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:457
msgid ""
"Each methods corresponds to python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:459
msgid "String Conversions"
msgstr ""

#: src/class.md:461
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:462
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:464
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`. In Python 2.7, Unicode strings returned by `__str__` "
"and `__repr__` will be converted to byte strings by the Python runtime, "
"which results in an exception if the string contains non-ASCII characters."
msgstr ""

#: src/class.md:468
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:470
msgid ""
"On Python 3.x, provides the conversion to `bytes`. On Python 2.7, "
"`__bytes__` is allowed but has no effect."
msgstr ""

#: src/class.md:473
msgid "`fn __unicode__(&self) -> PyResult<PyUnicode>`"
msgstr ""

#: src/class.md:475
msgid ""
"On Python 2.7, provides the conversion to `unicode`. On Python 3.x, "
"`__unicode__` is allowed but has no effect."
msgstr ""

#: src/class.md:478
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:480
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:483
msgid "Comparison operators"
msgstr ""

#: src/class.md:485
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:487
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:493
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:495
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:498
msgid "Other methods"
msgstr ""

#: src/class.md:500
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:502
msgid ""
"Determines the \"truthyness\" of the object. This method works for both "
"python 3 and python 2, even on Python 2.7 where the Python spelling was "
"`__nonzero__`."
msgstr ""

#: src/class.md:506
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:508
msgid ""
"If your type owns references to other python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement [`PyGCProtocol`](https://docs.rs/"
"pyo3/0.2.7/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another python object. `__clear__` "
"must clear out any mutable references to other python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:543
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:550
msgid ""
"Special protocol trait implementation has to be annotated with `#[pyproto]` "
"attribute."
msgstr ""

#: src/class.md:552
msgid ""
"It is also possible to enable gc for custom class using `gc` parameter for "
"`class` annotation. i.e. `#[pyclass(gc)]`. In that case instances of custom "
"class participate in python garbage collector, and it is possible to track "
"them with `gc` module methods."
msgstr ""

#: src/class.md:556
msgid "Iterator Types"
msgstr ""

#: src/class.md:558
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://docs.rs/"
"pyo3/0.2.7/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:561
msgid "`fn __iter__(&mut self) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:562
msgid "`fn __next__(&mut self) -> PyResult<Option<impl IntoPyObject>>`"
msgstr ""

#: src/class.md:564
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""

#: src/exception.md:1
msgid "Python Exception"
msgstr ""

#: src/exception.md:3
msgid "Define a new exception"
msgstr ""

#: src/exception.md:5
msgid "You can use the `py_exception!` macro to define a new exception type:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr "例如："

#: src/exception.md:30
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:32
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:33
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:37
msgid "Raise an exception"
msgstr ""

#: src/exception.md:39
msgid ""
"To raise an exception, first you need to obtain an exception type and "
"construct a new [`PyErr`](https://docs.rs/pyo3/0.2.7/struct.PyErr.html), "
"then call [`PyErr::restore()`](https://docs.rs/pyo3/0.2.7/struct.PyErr."
"html#method.restore) method to write the exception back to the Python "
"interpreter's global state."
msgstr ""

#: src/exception.md:49
msgid "\"Error\""
msgstr ""

#: src/exception.md:55
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance()`](https://docs.rs/pyo3/0.2.7/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:61
msgid ""
"If rust type exists for exception, then it is possible to use `new` method. "
"For example each standard exception defined in `exc` module has "
"corresponding rust type, exceptions defined by `py_exception!` and "
"`import_exception!` macro have rust type as well."
msgstr ""

#: src/exception.md:72
msgid "\"argument is wrong\""
msgstr ""

#: src/exception.md:79
msgid "Check exception type"
msgstr ""

#: src/exception.md:81
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check object type, in `PyO3` there is a [`Python::"
"is_instance()`](https://docs.rs/pyo3/0.2.7/struct.Python.html#method."
"is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:99
msgid ""
"[`Python::is_instance()`](https://docs.rs/pyo3/0.2.7/struct.Python."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://docs.rs/pyo3/0.2.7/struct.PyType.html#method.is_instance) method to "
"do the actual work."
msgstr ""

#: src/exception.md:101
msgid "To check the type of an exception, you can simply do:"
msgstr ""

#: src/exception.md:114
msgid "Handle Rust Error"
msgstr ""

#: src/exception.md:116
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://docs.rs/pyo3/0.2.7/type.PyResult.html). This is an alias for the "
"type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:119
msgid ""
"A [`PyErr`](https://docs.rs/pyo3/0.2.7/struct.PyErr.html) represents a "
"Python exception. Errors within the `PyO3` library are also exposed as "
"Python exceptions."
msgstr ""

#: src/exception.md:122
msgid ""
"PyO3 library handles python exception in two stages. During first stage "
"`PyErr` instance get created. At this stage python GIL is not required. "
"During second stage, actual python exception instance get crated and set to "
"python interpreter."
msgstr ""

#: src/exception.md:126
msgid ""
"In simple case, for custom errors support implementation of `std::convert::"
"From<T>` trait for this custom error is enough. `PyErr::new` accepts "
"arguments in form of `ToPyObject + 'static`. In case if `'static` constraint "
"can not be satisfied or more complex arguments are required [`PyErrArgument`]"
"(https://docs.rs/pyo3/0.2.7/trait.PyErrArguments.html) trait can be "
"implemented. In that case actual exception arguments creation get delayed "
"until `Python` object is available."
msgstr ""

#: src/exception.md:147
msgid "\"127.0.0.1:80\""
msgstr ""

#: src/exception.md:152
msgid ""
"The code snippet above will raise `OSError` in Python if `TcpListener::"
"bind()` return an error."
msgstr ""

#: src/exception.md:154
msgid ""
"`std::convert::From<T>` trait is implemented for most of the standard "
"library's error types so `try!` macro or `?` operator can be used."
msgstr ""

#: src/exception.md:166
msgid ""
"The code snippet above will raise `ValueError` in Python if `String::"
"parse()` return an error."
msgstr ""

#: src/exception.md:169
msgid "Using exceptions defined in python code"
msgstr ""

#: src/exception.md:171
msgid ""
"It is possible to use exception defined in python code as native rust types. "
"`import_exception!` macro allows to import specific exception class and "
"defined zst type for that exception."
msgstr ""

#: src/exception.md:187
msgid "\"tell\""
msgstr ""

#: src/exception.md:188
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:195
msgid ""
"[`exc`](https://docs.rs/pyo3/0.2.7/exc/index.html) defines exceptions for "
"several standard library modules."
msgstr ""

#: src/function.md:1
msgid "Python Function"
msgstr ""

#: src/function.md:3
msgid ""
"Pyo3 supports two ways to define a function in python. Both require "
"registering the function to a [module](./module.md)"
msgstr ""

#: src/function.md:6
msgid "One way is defining the function in the module definition."
msgstr ""

#: src/function.md:18
msgid ""
"// Note that the `#[pyfn()]` annotation automatically converts the arguments "
"from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/function.md:20
msgid "\"sum_as_string\""
msgstr ""

#: src/function.md:22
msgid "\"{}\""
msgstr ""

#: src/function.md:31
msgid ""
"The other is annotating a function with `#[py::function]` and then adding it "
"to the module using the `add_function_to_module!` macro, which takes the "
"module as first parameter, the function name as second and an instance of "
"`Python` as third."
msgstr ""

#: src/function.md:58
msgid "Closures"
msgstr ""

#: src/function.md:60
msgid ""
"Currently, there are no conversions between `Fn`s in rust and callables in "
"python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:62
msgid "Calling a python function in rust"
msgstr ""

#: src/function.md:64
msgid ""
"You can use `ObjectProtocol::is_callable` to check if you got a callable, "
"which is true for functions (including lambdas), methods and objects with a "
"`__call__` method. You can call the object with `ObjectProtocol::call` with "
"the args as first parameter and the kwargs (or `NoArgs`) as second paramter. "
"There are also `ObjectProtocol::call0` with no args and `ObjectProtocol::"
"call1` with only the args."
msgstr ""

#: src/function.md:66
msgid "Calling rust `Fn`s in python"
msgstr ""

#: src/function.md:68
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use `wrap_function!` to get the corresponding `PyObject`. For dynamic "
"functions, e.g. lambda and functions that were passed as arguments, you must "
"put them in some kind of owned container, e.g. a box. (Long-Term a special "
"container similar to wasm-bindgen's `Closure` should take care of that). You "
"can than use a `#[pyclass]` struct with that container as field as a way to "
"pass the function over the ffi-barrier. You can even make that class "
"callable with `__call__` so it looks like a function in python code."
msgstr ""

#: src/module.md:1
msgid "Python Module"
msgstr ""

#: src/module.md:3
msgid ""
"As shown in the Getting Started chapter, you can create a module as follows:"
msgstr ""

#: src/module.md:12
msgid ""
"// add bindings to the generated python module\n"
"// N.B: names: \"librust2py\" must be the name of the `.so` or `.pyd` file\n"
"/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:19
msgid ""
"// pyo3 aware function. All of our python interface could be declared in a "
"separate module.\n"
"    // Note that the `#[pyfn()]` annotation automatically converts the "
"arguments from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/module.md:30
msgid "// logic implemented as a normal rust function\n"
msgstr ""

#: src/module.md:39
msgid ""
"The `#[pymodinit}` procedural macro attribute takes care of exporting the "
"initialization function of your module to Python. It takes one argument as "
"the name of your module, it must be the name of the `.so` or `.pyd` file."
msgstr ""

#: src/module.md:41
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/first-edition/"
"comments.html) of the module initialization function will be applied "
"automatically as the Python doc string of your module."
msgstr ""

#: src/module.md:49
msgid ""
"Which means that the above Python code will print `This module is "
"implemented in Rust.`."
msgstr ""

#: src/module.md:51
msgid "On macOS, you will need to rename the output from `*.dylib` to `*.so`."
msgstr ""

#: src/module.md:53
msgid "On Windows, you will need to rename the output from `*.dll` to `*.pyd`."
msgstr ""

#: src/module.md:55
msgid ""
"For `setup.py` integration, You can use [setuptools-rust](https://github.com/"
"PyO3/setuptools-rust), learn more about it in [Distribution](./distribution."
"html)."
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "摘要"

#: src/SUMMARY.md:3
msgid "Get Started"
msgstr ""

#: src/SUMMARY.md:4
msgid "Type Conversions"
msgstr ""

#: src/SUMMARY.md:12
msgid "Appendix: Pyo3 and rust-cpython"
msgstr ""

#: src/conversions.md:3
msgid ""
"`PyO3` provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions.md:5
msgid "`.extract()?`"
msgstr ""

#: src/conversions.md:7
msgid ""
"The easiest way to convert a python object to a rust value is using `."
"extract()`."
msgstr ""

#: src/conversions.md:9
msgid "`ToPyObject` and `IntoPyObject` trait"
msgstr ""

#: src/conversions.md:11
msgid ""
"[`ToPyObject`](https://docs.rs/pyo3/0.2.7/trait.ToPyObject.html) trait is a "
"conversion trait that allows various objects to be converted into "
"[`PyObject`](https://docs.rs/pyo3/0.2.7/struct.PyObject.html). "
"[`IntoPyObject`](https://docs.rs/pyo3/0.2.7/trait.IntoPyObject.html) serves "
"the same purpose except it consumes `self`."
msgstr ""

#: src/conversions.md:13
msgid "`IntoPyTuple` trait"
msgstr ""

#: src/conversions.md:15
msgid ""
"[`IntoPyTuple`](https://docs.rs/pyo3/0.2.7/trait.IntoPyTuple.html) trait is "
"a conversion trait that allows various objects to be converted into "
"[`PyTuple`](https://docs.rs/pyo3/0.2.7/struct.PyTuple.html) object."
msgstr ""

#: src/conversions.md:17
msgid ""
"For example, [`IntoPyTuple`](https://docs.rs/pyo3/0.2.7/trait.IntoPyTuple."
"html) trait is implemented for `()` so that you can convert it into a empty "
"[`PyTuple`](https://docs.rs/pyo3/0.2.7/struct.PyTuple.html)"
msgstr ""

#: src/conversions.md:30
msgid "`FromPyObject` and `RefFromPyObject` trait"
msgstr ""

#: src/conversions.md:32
msgid "`*args` and `**kwargs` for python object call"
msgstr ""

#: src/conversions.md:34
msgid ""
"There are several way how to pass positional and keyword arguments to python "
"object call. [`ObjectProtocol`](https://docs.rs/pyo3/0.2.7/trait."
"ObjectProtocol.html) trait provides two methods:"
msgstr ""

#: src/conversions.md:38
msgid "`call` - call callable python object."
msgstr ""

#: src/conversions.md:39
msgid "`call_method` - call specific method on the object."
msgstr ""

#: src/conversions.md:41
msgid ""
"Both methods accept `args` and `kwargs` arguments. `args` argument is "
"generate over [`IntoPyTuple`](https://docs.rs/pyo3/0.2.7/trait.IntoPyTuple."
"html) trait. So args could be `PyTuple` instance or rust tuple with up to 10 "
"elements. Or `NoArgs` object which represents empty tuple object."
msgstr ""

#: src/conversions.md:57
msgid "\"arg1\""
msgstr ""

#: src/conversions.md:58
msgid "\"arg2\""
msgstr ""

#: src/conversions.md:59
msgid "\"arg3\""
msgstr ""

#: src/conversions.md:66
msgid "// call object without empty arguments\n"
msgstr ""

#: src/conversions.md:69
msgid "// call object with PyTuple\n"
msgstr ""

#: src/conversions.md:73 src/conversions.md:113
msgid "// pass arguments as rust tuple\n"
msgstr ""

#: src/conversions.md:79
msgid ""
"`kwargs` argument is generate over [`IntoPyDictPointer`](https://docs.rs/"
"pyo3/0.2.7/trait.IntoPyDictPointer.html) trait. `HashMap` or `BTreeMap` "
"could be used as keyword arguments. rust tuple with up to 10 elements where "
"each element is tuple with size 2 could be used as kwargs as well. Or "
"`NoArgs` object can be used to indicate that no keywords arguments are "
"provided."
msgstr ""

#: src/conversions.md:98
msgid "\"key1\""
msgstr ""

#: src/conversions.md:100
msgid "\"key2\""
msgstr ""

#: src/conversions.md:108
msgid "// call object with PyDict\n"
msgstr ""

#: src/conversions.md:117
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/conversions.md:125
msgid "TODO"
msgstr ""
