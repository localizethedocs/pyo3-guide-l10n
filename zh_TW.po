msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:47Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/advanced.md:1
msgid "Advanced topics"
msgstr "進階話題"

#: src/advanced.md:3
msgid "FFI"
msgstr ""

#: src/advanced.md:5
msgid "PyO3 exposes much of Python's C API through the `ffi` module."
msgstr "PyO3 透過 `ffi` 模組公開了 Python C API 的大部分內容。"

#: src/advanced.md:7
msgid ""
"The C API is naturally unsafe and requires you to manage reference counts, "
"errors and specific invariants yourself. Please refer to the [C API "
"Reference Manual](https://docs.python.org/3/c-api/) and [The Rustonomicon]"
"(https://doc.rust-lang.org/nightly/nomicon/ffi.html) before using any "
"function from that API."
msgstr ""
"C API 天生不安全，必須由你自行管理引用計數、錯誤與特定不變式。在使用該 API 中"
"的任何函式之前，請參考 [C API 參考手冊](https://docs.python.org/3/c-api/) 以"
"及 [The Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/ffi.html)。"

#: src/advanced.md:9
msgid "Memory management"
msgstr ""

#: src/advanced.md:11
msgid ""
"PyO3's `&PyAny` \"owned references\" and `Py<PyAny>` smart pointers are used "
"to access memory stored in Python's heap.  This memory sometimes lives for "
"longer than expected because of differences in Rust and Python's memory "
"models.  See the chapter on [memory management](./memory.md) for more "
"information."
msgstr ""

#: src/migration.md:1
msgid "Migrating from older PyO3 versions"
msgstr "從舊版 PyO3 遷移"

#: src/migration.md:3
msgid ""
"This guide can help you upgrade code through breaking changes from one PyO3 "
"version to the next. For a detailed list of all changes, see the [CHANGELOG]"
"(changelog.md)."
msgstr ""
"本指南可協助你跨越 PyO3 版本間的破壞性變更來升級程式碼。完整變更清單請見 "
"[CHANGELOG](changelog.md)。"

#: src/migration.md:6
msgid "from 0.16.\\* to 0.17"
msgstr ""

#: src/migration.md:8
msgid "Type checks have been changed for `PyMapping` and `PySequence` types"
msgstr ""

#: src/migration.md:10
msgid ""
"Previously the type checks for `PyMapping` and `PySequence` (implemented in "
"`PyTryFrom`) used the Python C-API functions `PyMapping_Check` and "
"`PySequence_Check`. Unfortunately these functions are not sufficient for "
"distinguishing such types, leading to inconsistent behavior (see [pyo3/"
"pyo3#2072](https://github.com/PyO3/pyo3/issues/2072))."
msgstr ""

#: src/migration.md:16
msgid ""
"PyO3 0.17 changes these downcast checks to explicityly test if the type is a "
"subclass of the corresponding abstract base class `collections.abc.Mapping` "
"or `collections.abc.Sequence`. Note this requires calling into Python, which "
"may incur a performance penalty over the previous method. If this "
"performance penatly is a problem, you may be able to perform your own checks "
"and use `try_from_unchecked` (unsafe)."
msgstr ""

#: src/migration.md:23
msgid ""
"Another side-effect is that a pyclass defined in Rust with PyO3 will need to "
"be _registered_ with the corresponding Python abstract base class for "
"downcasting to succeed. `PySequence::register` and `PyMapping:register` have "
"been added to make it easy to do this from Rust code. These are equivalent "
"to calling `collections.abc.Mapping.register(MappingPyClass)` or "
"`collections.abc.Sequence.register(SequencePyClass)` from Python."
msgstr ""

#: src/migration.md:30
msgid "For example, for a mapping class defined in Rust:"
msgstr ""

#: src/migration.md:44
msgid ""
"// ...\n"
"    // truncated implementation of this mapping pyclass - basically a "
"wrapper around a HashMap\n"
msgstr ""

#: src/migration.md:50
msgid ""
"You must register the class with `collections.abc.Mapping` before the "
"downcast will work:"
msgstr ""

#: src/migration.md:58
msgid ""
"Note that this requirement may go away in the future when a pyclass is able "
"to inherit from the abstract base class directly (see [pyo3/pyo3#991]"
"(https://github.com/PyO3/pyo3/issues/991))."
msgstr ""

#: src/migration.md:60
msgid "\\### The `multiple-pymethods` feature now requires Rust 1.62"
msgstr ""

#: src/migration.md:62
msgid ""
"Due to limitations in the `inventory` crate which the `multiple-pymethods` "
"feature depends on, this feature now requires Rust 1.62. For more "
"information see [dtolnay/inventory#32](https://github.com/dtolnay/inventory/"
"issues/32)."
msgstr ""

#: src/migration.md:65
msgid "Added `impl IntoPy<Py<PyString>> for &str`"
msgstr ""

#: src/migration.md:67
msgid "This may cause inference errors."
msgstr ""

#: src/migration.md:69 src/migration.md:103 src/migration.md:150
#: src/migration.md:339 src/migration.md:424 src/migration.md:473
#: src/migration.md:499 src/migration.md:527 src/migration.md:562
#: src/migration.md:597 src/migration.md:623 src/migration.md:645
#: src/migration.md:675 src/migration.md:761 src/migration.md:788
#: src/migration.md:823
msgid "Before:"
msgstr "之前："

#: src/migration.md:75
msgid "// Cannot infer either `Py<PyAny>` or `Py<PyString>`\n"
msgstr ""

#: src/migration.md:76 src/migration.md:88
msgid "\"test\""
msgstr ""

#: src/migration.md:81
msgid "After, some type annotations may be necessary:"
msgstr ""

#: src/migration.md:93
msgid "The `pyproto` feature is now disabled by default"
msgstr ""

#: src/migration.md:95
msgid ""
"In preparation for removing the deprecated `#[pyproto]` attribute macro in a "
"future PyO3 version, it is now gated behind an opt-in feature flag. This "
"also gives a slight saving to compile times for code which does not use the "
"deprecated macro."
msgstr ""

#: src/migration.md:97
msgid "`PyTypeObject` trait has been deprecated"
msgstr ""

#: src/migration.md:99
msgid ""
"The `PyTypeObject` trait already was near-useless; almost all functionality "
"was already on the `PyTypeInfo` trait, which `PyTypeObject` had a blanket "
"implementation based upon. In PyO3 0.17 the final method, `PyTypeObject::"
"type_object` was moved to `PyTypeInfo::type_object`."
msgstr ""

#: src/migration.md:101
msgid ""
"To migrate, update trait bounds and imports from `PyTypeObject` to "
"`PyTypeInfo`."
msgstr ""

#: src/migration.md:115 src/migration.md:175 src/migration.md:485
msgid "After"
msgstr ""

#: src/migration.md:128
msgid ""
"`impl<T, const N: usize> IntoPy<PyObject> for [T; N]` now requires `T: "
"IntoPy` rather than `T: ToPyObject`"
msgstr ""

#: src/migration.md:130
msgid ""
"If this leads to errors, simply implement `IntoPy`. Because pyclasses "
"already implement `IntoPy`, you probably don't need to worry about this."
msgstr ""

#: src/migration.md:132
msgid "Each `#[pymodule]` can now only be initialized once per process"
msgstr ""

#: src/migration.md:134
msgid ""
"To make PyO3 modules sound in the presence of Python sub-interpreters, for "
"now it has been necessary to explicitly disable the ability to initialize a "
"`#[pymodule]` more than once in the same process. Attempting to do this will "
"now raise an `ImportError`."
msgstr ""

#: src/migration.md:136
msgid "from 0.15.\\* to 0.16"
msgstr ""

#: src/migration.md:138
msgid "Drop support for older technologies"
msgstr ""

#: src/migration.md:140
msgid ""
"PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python "
"version to 3.7. This enables use of newer language features (enabling some "
"of the other additions in 0.16) and simplifies maintenance of the project."
msgstr ""

#: src/migration.md:142
msgid "`#[pyproto]` has been deprecated"
msgstr ""

#: src/migration.md:144
msgid ""
"In PyO3 0.15, the `#[pymethods]` attribute macro gained support for "
"implementing \"magic methods\" such as `__str__` (aka \"dunder\" methods). "
"This implementation was not quite finalized at the time, with a few edge "
"cases to be decided upon. The existing `#[pyproto]` attribute macro was left "
"untouched, because it covered these edge cases."
msgstr ""

#: src/migration.md:146
msgid ""
"In PyO3 0.16, the `#[pymethods]` implementation has been completed and is "
"now the preferred way to implement magic methods. To allow the PyO3 project "
"to move forward, `#[pyproto]` has been deprecated (with expected removal in "
"PyO3 0.18)."
msgstr ""

#: src/migration.md:148
msgid ""
"Migration from `#[pyproto]` to `#[pymethods]` is straightforward; copying "
"the existing methods directly from the `#[pyproto]` trait implementation is "
"all that is needed in most cases."
msgstr ""

#: src/migration.md:163 src/migration.md:187 src/migration.md:351
#: src/migration.md:367
msgid "b\"hello, world\""
msgstr ""

#: src/migration.md:170 src/migration.md:191
msgid "\"hello, world\""
msgstr ""

#: src/migration.md:196
msgid "Removed `PartialEq` for object wrappers"
msgstr ""

#: src/migration.md:198
msgid ""
"The Python object wrappers `Py` and `PyAny` had implementations of "
"`PartialEq` so that `object_a == object_b` would compare the Python objects "
"for pointer equality, which corresponds to the `is` operator, not the `==` "
"operator in Python.  This has been removed in favor of a new method: use "
"`object_a.is(object_b)`.  This also has the advantage of not requiring the "
"same wrapper type for `object_a` and `object_b`; you can now directly "
"compare a `Py<T>` with a `&PyAny` without having to convert."
msgstr ""

#: src/migration.md:206
msgid ""
"To check for Python object equality (the Python `==` operator), use the new "
"method `eq()`."
msgstr ""

#: src/migration.md:209
msgid "Container magic methods now match Python behavior"
msgstr ""

#: src/migration.md:211
msgid ""
"In PyO3 0.15, `__getitem__`, `__setitem__` and `__delitem__` in "
"`#[pymethods]` would generate only the _mapping_ implementation for a "
"`#[pyclass]`. To match the Python behavior, these methods now generate both "
"the _mapping_ **and** _sequence_ implementations."
msgstr ""

#: src/migration.md:213
msgid ""
"This means that classes implementing these `#[pymethods]` will now also be "
"treated as sequences, same as a Python `class` would be. Small differences "
"in behavior may result:"
msgstr ""

#: src/migration.md:214
msgid ""
"PyO3 will allow instances of these classes to be cast to `PySequence` as "
"well as `PyMapping`."
msgstr ""

#: src/migration.md:215
msgid ""
"Python will provide a default implementation of `__iter__` (if the class did "
"not have one) which repeatedly calls `__getitem__` with integers (starting "
"at 0) until an `IndexError` is raised."
msgstr ""

#: src/migration.md:217
msgid "To explain this in detail, consider the following Python class:"
msgstr ""

#: src/migration.md:231
msgid ""
"This class implements a Python [sequence](https://docs.python.org/3/glossary."
"html#term-sequence)."
msgstr ""

#: src/migration.md:233
msgid ""
"The `__len__` and `__getitem__` methods are also used to implement a Python "
"[mapping](https://docs.python.org/3/glossary.html#term-mapping). In the "
"Python C-API, these methods are not shared: the sequence `__len__` and "
"`__getitem__` are defined by the `sq_length` and `sq_item` slots, and the "
"mapping equivalents are `mp_length` and `mp_subscript`. There are similar "
"distinctions for `__setitem__` and `__delitem__`."
msgstr ""

#: src/migration.md:235
msgid ""
"Because there is no such distinction from Python, implementing these methods "
"will fill the mapping and sequence slots simultaneously. A Python class with "
"`__len__` implemented, for example, will have both the `sq_length` and "
"`mp_length` slots filled."
msgstr ""

#: src/migration.md:237
msgid ""
"The PyO3 behavior in 0.16 has been changed to be closer to this Python "
"behavior by default."
msgstr ""

#: src/migration.md:239
msgid "`wrap_pymodule!` and `wrap_pyfunction!` now respect privacy correctly"
msgstr ""

#: src/migration.md:241
msgid ""
"Prior to PyO3 0.16 the `wrap_pymodule!` and `wrap_pyfunction!` macros could "
"use modules and functions whose defining `fn` was not reachable according "
"Rust privacy rules."
msgstr ""

#: src/migration.md:243
msgid ""
"For example, the following code was legal before 0.16, but in 0.16 is "
"rejected because the `wrap_pymodule!` macro cannot access the "
"`private_submodule` function:"
msgstr ""

#: src/migration.md:265
msgid ""
"To fix it, make the private submodule visible, e.g. with `pub` or "
"`pub(crate)`."
msgstr ""

#: src/migration.md:288
msgid "from 0.14.\\* to 0.15"
msgstr ""

#: src/migration.md:290
msgid "Changes in sequence indexing"
msgstr ""

#: src/migration.md:292
msgid ""
"For all types that take sequence indices (`PyList`, `PyTuple` and "
"`PySequence`), the API has been made consistent to only take `usize` "
"indices, for consistency with Rust's indexing conventions.  Negative "
"indices, which were only sporadically supported even in APIs that took "
"`isize`, now aren't supported anywhere."
msgstr ""

#: src/migration.md:298
msgid ""
"Further, the `get_item` methods now always return a `PyResult` instead of "
"panicking on invalid indices.  The `Index` trait has been implemented "
"instead, and provides the same panic behavior as on Rust vectors."
msgstr ""

#: src/migration.md:302
msgid ""
"Note that _slice_ indices (accepted by `PySequence::get_slice` and other) "
"still inherit the Python behavior of clamping the indices to the actual "
"length, and not panicking/returning an error on out of range indices."
msgstr ""

#: src/migration.md:306
msgid ""
"An additional advantage of using Rust's indexing conventions for these types "
"is that these types can now also support Rust's indexing operators as part "
"of a consistent API:"
msgstr ""

#: src/migration.md:315
msgid "\"[1, 2]\""
msgstr ""

#: src/migration.md:319
msgid "from 0.13.\\* to 0.14"
msgstr ""

#: src/migration.md:321
msgid "`auto-initialize` feature is now opt-in"
msgstr ""

#: src/migration.md:323
msgid ""
"For projects embedding Python in Rust, PyO3 no longer automatically "
"initializes a Python interpreter on the first call to `Python::with_gil` (or "
"`Python::acquire_gil`) unless the [`auto-initialize` feature](features."
"md#auto-initialize) is enabled."
msgstr ""

#: src/migration.md:325
msgid "New `multiple-pymethods` feature"
msgstr ""

#: src/migration.md:327
msgid ""
"`#[pymethods]` have been reworked with a simpler default implementation "
"which removes the dependency on the `inventory` crate. This reduces "
"dependencies and compile times for the majority of users."
msgstr ""

#: src/migration.md:329
msgid ""
"The limitation of the new default implementation is that it cannot support "
"multiple `#[pymethods]` blocks for the same `#[pyclass]`. If you need this "
"functionality, you must enable the `multiple-pymethods` feature which will "
"switch `#[pymethods]` to the inventory-based implementation."
msgstr ""

#: src/migration.md:331
msgid "Deprecated `#[pyproto]` methods"
msgstr ""

#: src/migration.md:333
msgid ""
"Some protocol (aka `__dunder__`) methods such as `__bytes__` and "
"`__format__` have been possible to implement two ways in PyO3 for some time: "
"via a `#[pyproto]` (e.g. `PyBasicProtocol` for the methods listed here), or "
"by writing them directly in `#[pymethods]`. This is only true for a handful "
"of the `#[pyproto]` methods (for technical reasons to do with the way PyO3 "
"currently interacts with the Python C-API)."
msgstr ""

#: src/migration.md:335
msgid ""
"In the interest of having onle one way to do things, the `#[pyproto]` forms "
"of these methods have been deprecated."
msgstr ""

#: src/migration.md:337
msgid ""
"To migrate just move the affected methods from a `#[pyproto]` to a "
"`#[pymethods]` block."
msgstr ""

#: src/migration.md:356 src/migration.md:447 src/migration.md:507
#: src/migration.md:536 src/migration.md:575 src/migration.md:607
#: src/migration.md:630 src/migration.md:656 src/migration.md:689
#: src/migration.md:771 src/migration.md:795 src/migration.md:841
msgid "After:"
msgstr ""

#: src/migration.md:372
msgid "from 0.12.\\* to 0.13"
msgstr ""

#: src/migration.md:374
msgid "Minimum Rust version increased to Rust 1.45"
msgstr ""

#: src/migration.md:376
msgid ""
"PyO3 `0.13` makes use of new Rust language features stabilised between Rust "
"1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, "
"you will need to update your toolchain to be able to continue using PyO3."
msgstr ""

#: src/migration.md:378
msgid "Runtime changes to support the CPython limited API"
msgstr ""

#: src/migration.md:380
msgid ""
"In PyO3 `0.13` support was added for compiling against the CPython limited "
"API. This had a number of implications for _all_ PyO3 users, described here."
msgstr ""

#: src/migration.md:382
msgid ""
"The largest of these is that all types created from PyO3 are what CPython "
"calls \"heap\" types. The specific implications of this are:"
msgstr ""

#: src/migration.md:384
msgid ""
"If you wish to subclass one of these types _from Rust_ you must mark it "
"`#[pyclass(subclass)]`, as you would if you wished to allow subclassing it "
"from Python code."
msgstr ""

#: src/migration.md:385
msgid "Type objects are now mutable - Python code can set attributes on them."
msgstr ""

#: src/migration.md:386
msgid ""
"`__module__` on types without `#[pyclass(module=\"mymodule\")]` no longer "
"returns `builtins`, it now raises `AttributeError`."
msgstr ""

#: src/migration.md:388
msgid "from 0.11.\\* to 0.12"
msgstr ""

#: src/migration.md:390
msgid "`PyErr` has been reworked"
msgstr ""

#: src/migration.md:392
msgid ""
"In PyO3 `0.12` the `PyErr` type has been re-implemented to be significantly "
"more compatible with the standard Rust error handling ecosystem. "
"Specifically `PyErr` now implements `Error + Send + Sync`, which are the "
"standard traits used for error types."
msgstr ""

#: src/migration.md:396
msgid ""
"While this has necessitated the removal of a number of APIs, the resulting "
"`PyErr` type should now be much more easier to work with. The following "
"sections list the changes in detail and how to migrate to the new APIs."
msgstr ""

#: src/migration.md:400
msgid ""
"`PyErr::new` and `PyErr::from_type` now require `Send + Sync` for their "
"argument"
msgstr ""

#: src/migration.md:402
msgid ""
"For most uses no change will be needed. If you are trying to construct "
"`PyErr` from a value that is not `Send + Sync`, you will need to first "
"create the Python object and then use `PyErr::from_instance`."
msgstr ""

#: src/migration.md:406
msgid ""
"Similarly, any types which implemented `PyErrArguments` will now need to be "
"`Send + Sync`."
msgstr ""

#: src/migration.md:408
msgid "`PyErr`'s contents are now private"
msgstr ""

#: src/migration.md:410
msgid ""
"It is no longer possible to access the fields `.ptype`, `.pvalue` and `."
"ptraceback` of a `PyErr`. You should instead now use the new methods `PyErr::"
"ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/migration.md:413
msgid "`PyErrValue` and `PyErr::from_value` have been removed"
msgstr ""

#: src/migration.md:415
msgid ""
"As these were part the internals of `PyErr` which have been reworked, these "
"APIs no longer exist."
msgstr ""

#: src/migration.md:417
msgid ""
"If you used this API, it is recommended to use `PyException::new_err` (see "
"[the section on Exception types](#exception-types-have-been-reworked))."
msgstr ""

#: src/migration.md:420
msgid "`Into<PyResult<T>>` for `PyErr` has been removed"
msgstr ""

#: src/migration.md:422
msgid ""
"This implementation was redundant. Just construct the `Result::Err` variant "
"directly."
msgstr ""

#: src/migration.md:426 src/migration.md:432 src/migration.md:444
#: src/migration.md:453
msgid "\"error message\""
msgstr ""

#: src/migration.md:429
msgid ""
"After (also using the new reworked exception types; see the following "
"section):"
msgstr ""

#: src/migration.md:435
msgid "Exception types have been reworked"
msgstr ""

#: src/migration.md:437
msgid ""
"Previously exception types were zero-sized marker types purely used to "
"construct `PyErr`. In PyO3 0.12, these types have been replaced with full "
"definitions and are usable in the same way as `PyAny`, `PyDict` etc. This "
"makes it possible to interact with Python exception objects."
msgstr ""

#: src/migration.md:441
msgid ""
"The new types also have names starting with the \"Py\" prefix. For example, "
"before:"
msgstr ""

#: src/migration.md:454
msgid "// Uses Display for PyErr, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:456
msgid "\"TypeError: error message\""
msgstr ""

#: src/migration.md:457
msgid ""
"// Now possible to interact with exception instances, new for PyO3 0.12\n"
msgstr ""

#: src/migration.md:460
msgid "\"__class__\""
msgstr ""

#: src/migration.md:465
msgid "`FromPy` has been removed"
msgstr ""

#: src/migration.md:466
msgid ""
"To simplify the PyO3 conversion traits, the `FromPy` trait has been removed. "
"Previously there were two ways to define the to-Python conversion for a "
"type: `FromPy<T> for PyObject` and `IntoPy<PyObject> for T`."
msgstr ""

#: src/migration.md:470
msgid ""
"Now there is only one way to define the conversion, `IntoPy`, so downstream "
"crates may need to adjust accordingly."
msgstr ""

#: src/migration.md:497
msgid ""
"Similarly, code which was using the `FromPy` trait can be trivially "
"rewritten to use `IntoPy`."
msgstr ""

#: src/migration.md:515
msgid "`PyObject` is now a type alias of `Py<PyAny>`"
msgstr ""

#: src/migration.md:516
msgid ""
"This should change very little from a usage perspective. If you implemented "
"traits for both `PyObject` and `Py<T>`, you may find you can just remove the "
"`PyObject` implementation."
msgstr ""

#: src/migration.md:519
msgid "`AsPyRef` has been removed"
msgstr ""

#: src/migration.md:520
msgid ""
"As `PyObject` has been changed to be just a type alias, the only remaining "
"implementor of `AsPyRef` was `Py<T>`. This removed the need for a trait, so "
"the `AsPyRef::as_ref` method has been moved to `Py::as_ref`."
msgstr ""

#: src/migration.md:524
msgid ""
"This should require no code changes except removing `use pyo3::AsPyRef` for "
"code which did not use `pyo3::prelude::*`."
msgstr ""

#: src/migration.md:545
msgid "from 0.10.\\* to 0.11"
msgstr ""

#: src/migration.md:547
msgid "Stable Rust"
msgstr ""

#: src/migration.md:548
msgid ""
"PyO3 now supports the stable Rust toolchain. The minimum required version is "
"1.39.0."
msgstr ""

#: src/migration.md:550
msgid "`#[pyclass]` structs must now be `Send` or `unsendable`"
msgstr ""

#: src/migration.md:551
msgid ""
"Because `#[pyclass]` structs can be sent between threads by the Python "
"interpreter, they must implement `Send` or declared as `unsendable` (by "
"`#[pyclass(unsendable)]`). Note that `unsendable` is added in PyO3 `0.11.1` "
"and `Send` is always required in PyO3 `0.11.0`."
msgstr ""

#: src/migration.md:555
msgid ""
"This may \"break\" some code which previously was accepted, even though it "
"could be unsound. There can be two fixes:"
msgstr ""

#: src/migration.md:558
msgid ""
"If you think that your `#[pyclass]` actually must be `Send`able, then let's "
"implement `Send`. A common, safer way is using thread-safe types. E.g., "
"`Arc` instead of `Rc`, `Mutex` instead of `RefCell`, and `Box<dyn Send + T>` "
"instead of `Box<dyn T>`."
msgstr ""

#: src/migration.md:588
msgid ""
"In situations where you cannot change your `#[pyclass]` to automatically "
"implement `Send` (e.g., when it contains a raw pointer), you can use `unsafe "
"impl Send`. In such cases, care should be taken to ensure the struct is "
"actually thread safe. See [the Rustnomicon](https://doc.rust-lang.org/"
"nomicon/send-and-sync.html) for more."
msgstr ""

#: src/migration.md:593
msgid ""
"If you think that your `#[pyclass]` should not be accessed by another "
"thread, you can use `unsendable` flag. A class marked with `unsendable` "
"panics when accessed by another thread, making it thread-safe to expose an "
"unsendable object to the Python interpreter."
msgstr ""

#: src/migration.md:618
msgid "All `PyObject` and `Py<T>` methods now take `Python` as an argument"
msgstr ""

#: src/migration.md:619
msgid ""
"Previously, a few methods such as `Object::get_refcnt` did not take `Python` "
"as an argument (to ensure that the Python GIL was held by the current "
"thread). Technically, this was not sound. To migrate, just pass a `py` "
"argument to any calls to these methods."
msgstr ""

#: src/migration.md:637
msgid "from 0.9.\\* to 0.10"
msgstr ""

#: src/migration.md:639
msgid "`ObjectProtocol` is removed"
msgstr ""

#: src/migration.md:640
msgid ""
"All methods are moved to [`PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html). And since now all native types (e.g., `PyList`) "
"implements `Deref<Target=PyAny>`, all you need to do is remove "
"`ObjectProtocol` from your code. Or if you use `ObjectProtocol` by `use "
"pyo3::prelude::*`, you have to do nothing."
msgstr ""

#: src/migration.md:650 src/migration.md:659
msgid "\"lambda: 'Hi :)'\""
msgstr ""

#: src/migration.md:665
msgid "No `#![feature(specialization)]` in user code"
msgstr ""

#: src/migration.md:666
msgid ""
"While PyO3 itself still requires specialization and nightly Rust, now you "
"don't have to use `#![feature(specialization)]` in your crate."
msgstr ""

#: src/migration.md:669
msgid "from 0.8.\\* to 0.9"
msgstr ""

#: src/migration.md:671
msgid "`#[new]` interface"
msgstr ""

#: src/migration.md:672
msgid ""
"[`PyRawObject`](https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct."
"PyRawObject.html) is now removed and our syntax for constructors has changed."
msgstr ""

#: src/migration.md:704
msgid ""
"Basically you can return `Self` or `Result<Self>` directly. For more, see "
"[the constructor section](class.html#constructor) of this guide."
msgstr ""

#: src/migration.md:707
msgid "PyCell"
msgstr ""

#: src/migration.md:708
msgid ""
"PyO3 0.9 introduces [`PyCell`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyCell.html), which is a [`RefCell`](https://doc.rust-lang.org/std/cell/"
"struct.RefCell.html)\\-like object wrapper for ensuring Rust's rules "
"regarding aliasing of references are upheld. For more detail, see the [Rust "
"Book's section on Rust's rules of references](https://doc.rust-lang.org/book/"
"ch04-02-references-and-borrowing.html#the-rules-of-references)"
msgstr ""

#: src/migration.md:713
msgid ""
"For `#[pymethods]` or `#[pyfunction]`s, your existing code should continue "
"to work without any change. Python exceptions will automatically be raised "
"when your functions are used in a way which breaks Rust's rules of "
"references."
msgstr ""

#: src/migration.md:717
msgid "Here is an example."
msgstr ""

#: src/migration.md:738
msgid ""
"r\"\n"
"#     try:\n"
"#        names.merge(names)\n"
"#        assert False, 'Unreachable'\n"
"#     except RuntimeError as e:\n"
"#        assert str(e) == 'Already borrowed'\n"
"#     \""
msgstr ""

#: src/migration.md:747
msgid ""
"`Names` has a `merge` method, which takes `&mut self` and another argument "
"of type `&mut Self`. Given this `#[pyclass]`, calling `names.merge(names)` "
"in Python raises a [`PyBorrowMutError`](https://pyo3.rs/main/doc/pyo3/pycell/"
"struct.PyBorrowMutError.html) exception, since it requires two mutable "
"borrows of `names`."
msgstr ""

#: src/migration.md:751
msgid ""
"However, for `#[pyproto]` and some functions, you need to manually fix the "
"code."
msgstr ""

#: src/migration.md:753
msgid "Object creation"
msgstr ""

#: src/migration.md:754
msgid ""
"In 0.8 object creation was done with `PyRef::new` and `PyRefMut::new`. In "
"0.9 these have both been removed. To upgrade code, please use [`PyCell::new`]"
"(https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html#method.new) "
"instead. If you need [`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct."
"PyRef.html), just call `.borrow()` or `.borrow_mut()` on the newly-created "
"`PyCell`."
msgstr ""

#: src/migration.md:782
msgid "Object extraction"
msgstr ""

#: src/migration.md:783
msgid ""
"For `PyClass` types `T`, `&T` and `&mut T` no longer have [`FromPyObject`]"
"(https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html) "
"implementations. Instead you should extract `PyRef<T>` or `PyRefMut<T>`, "
"respectively. If `T` implements `Clone`, you can extract `T` itself. In "
"addition, you can also extract `&PyCell<T>`, though you rarely need it."
msgstr ""

#: src/migration.md:803
msgid "\"c\""
msgstr ""

#: src/migration.md:804
msgid "\"c()\""
msgstr ""

#: src/migration.md:807
msgid "// extracted by cloning the object\n"
msgstr ""

#: src/migration.md:810
msgid ""
"// we need to drop obj_ref before we can extract a PyRefMut due to Rust's "
"rules of references\n"
msgstr ""

#: src/migration.md:817
msgid "`#[pyproto]`"
msgstr ""

#: src/migration.md:818
msgid ""
"Most of the arguments to methods in `#[pyproto]` impls require a "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) implementation. So if your protocol methods take `&T` or `&mut T` "
"(where `T: PyClass`), please use [`PyRef`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) or [`PyRefMut`](https://pyo3.rs/main/doc/pyo3/"
"pycell/struct.PyRef.html) instead."
msgstr ""

#: src/migration.md:844
msgid "\"pyproto\""
msgstr ""

#: src/rust_cpython.md:1
msgid "PyO3 and rust-cpython"
msgstr ""

#: src/rust_cpython.md:3
msgid ""
"PyO3 began as fork of [rust-cpython](https://github.com/dgrunwald/rust-"
"cpython) when rust-cpython wasn't maintained. Over time PyO3 has become "
"fundamentally different from rust-cpython."
msgstr ""

#: src/rust_cpython.md:5
msgid "Macros"
msgstr ""

#: src/rust_cpython.md:7
msgid ""
"While rust-cpython has a `macro_rules!` based dsl for declaring modules and "
"classes, PyO3 uses proc macros. PyO3 also doesn't change your struct and "
"functions so you can still use them as normal Rust functions."
msgstr ""

#: src/rust_cpython.md:9 src/rust_cpython.md:53
msgid "**rust-cpython**"
msgstr ""

#: src/rust_cpython.md:23 src/rust_cpython.md:64
msgid "**pyo3**"
msgstr ""

#: src/rust_cpython.md:46
msgid "Ownership and lifetimes"
msgstr ""

#: src/rust_cpython.md:48
msgid ""
"While in rust-cpython you always own python objects, PyO3 allows efficient "
"_borrowed objects_ and most APIs are available with references."
msgstr ""

#: src/rust_cpython.md:51
msgid "Here is an example of the PyList API:"
msgstr ""

#: src/rust_cpython.md:75
msgid ""
"In PyO3, all object references are bounded by the GIL lifetime. So the owned "
"Python object is not required, and it is safe to have functions like `fn "
"py<'p>(&'p self) -> Python<'p> {}`."
msgstr ""

#: src/rust_cpython.md:78
msgid "Error handling"
msgstr "錯誤處理"

#: src/rust_cpython.md:80
msgid ""
"rust-cpython requires a `Python` parameter for constructing a `PyErr`, so "
"error handling ergonomics is pretty bad. It is not possible to use `?` with "
"Rust errors."
msgstr ""

#: src/rust_cpython.md:82
msgid ""
"PyO3 on other hand does not require `Python` for constructing a `PyErr`, it "
"is only required if you want to raise an exception in Python with the "
"`PyErr::restore()` method. Due to various `std::convert::From<E> for PyErr` "
"implementations for Rust standard error types `E`, propagating `?` is "
"supported automatically."
msgstr ""

#: src/trait_bounds.md:1
msgid "Using in Python a Rust function with trait bounds"
msgstr "在 Python 中使用帶有 trait bounds 的 Rust 函式"

#: src/trait_bounds.md:3
msgid ""
"PyO3 allows for easy conversion from Rust to Python for certain functions "
"and classes (see the [conversion table](conversions/tables.html). However, "
"it is not always straightforward to convert Rust code that requires a given "
"trait implementation as an argument."
msgstr ""

#: src/trait_bounds.md:6
msgid ""
"This tutorial explains how to convert a Rust function that takes a trait as "
"argument for use in Python with classes implementing the same methods as the "
"trait."
msgstr ""
"本教學說明如何將以 trait 作為參數的 Rust 函式轉換成可在 Python 中使用，並讓具"
"備相同方法的 Python 類別能夠配合使用。"

#: src/trait_bounds.md:8
msgid "Why is this useful?"
msgstr "為什麼這很有用？"

#: src/trait_bounds.md:10
msgid "Pros"
msgstr "優點"

#: src/trait_bounds.md:11
msgid "Make your Rust code available to Python users"
msgstr "讓你的 Rust 程式碼可供 Python 使用者使用"

#: src/trait_bounds.md:12
msgid "Code complex algorithms in Rust with the help of the borrow checker"
msgstr "在 Rust 中編寫複雜演算法並受惠於借用檢查器"

#: src/trait_bounds.md:14
msgid "Cons"
msgstr "缺點"

#: src/trait_bounds.md:15
msgid ""
"Not as fast as native Rust (type conversion has to be performed and one part "
"of the code runs in Python)"
msgstr "不如原生 Rust 快（需要進行型別轉換，且部分程式碼在 Python 端執行）"

#: src/trait_bounds.md:16
msgid "You need to adapt your code to expose it"
msgstr "你需要調整程式碼以便對外暴露"

#: src/trait_bounds.md:18
msgid "Example"
msgstr "範例"

#: src/trait_bounds.md:20
msgid ""
"Let's work with the following basic example of an implementation of a "
"optimization solver operating on a given model."
msgstr "讓我們以一個基本範例開始：一個在給定模型上運作的最佳化求解器實作。"

#: src/trait_bounds.md:22
msgid ""
"Let's say we have a function `solve` that operates on a model and mutates "
"its state. The argument of the function can be any model that implements the "
"`Model` trait :"
msgstr ""
"假設我們有一個 `solve` 函式，會在模型上運作並改變其狀態。該函式的參數可以是任"
"何實作 `Model` trait 的模型："

#: src/trait_bounds.md:34 src/trait_bounds.md:475
msgid "\"Magic solver that mutates the model into a resolved state\""
msgstr ""

#: src/trait_bounds.md:37
msgid "Let's assume we have the following constraints:"
msgstr "假設我們有以下限制："

#: src/trait_bounds.md:38
msgid "We cannot change that code as it runs on many Rust models."
msgstr "我們不能修改該程式碼，因為它已用在許多 Rust 模型上。"

#: src/trait_bounds.md:39
msgid ""
"We also have many Python models that cannot be solved as this solver is not "
"available in that language. Rewriting it in Python would be cumbersome and "
"error-prone, as everything is already available in Rust."
msgstr ""

#: src/trait_bounds.md:42
msgid "How could we expose this solver to Python thanks to PyO3 ?"
msgstr "那我們該如何透過 PyO3 將此求解器提供給 Python 使用？"

#: src/trait_bounds.md:44
msgid "Implementation of the trait bounds for the Python class"
msgstr "為 Python 類別實作 trait bounds"

#: src/trait_bounds.md:46
msgid ""
"If a Python class implements the same three methods as the `Model` trait, it "
"seems logical it could be adapted to use the solver. However, it is not "
"possible to pass a `PyObject` to it as it does not implement the Rust trait "
"(even if the Python model has the required methods)."
msgstr ""

#: src/trait_bounds.md:49
msgid ""
"In order to implement the trait, we must write a wrapper around the calls in "
"Rust to the Python model. The method signatures must be the same as the "
"trait, keeping in mind that the Rust trait cannot be changed for the purpose "
"of making the code available in Python."
msgstr ""
"為了實作該 trait，我們必須在 Rust 端撰寫一個包裝器來呼叫 Python 模型。方法簽"
"章必須與 trait 相同，因為 Rust trait 不能為了讓程式碼可在 Python 使用而被修"
"改。"

#: src/trait_bounds.md:52
msgid ""
"The Python model we want to expose is the following one, which already "
"contains all the required methods:"
msgstr "以下是我們想要對外暴露的 Python 模型，已包含所有必要方法："

#: src/trait_bounds.md:64
msgid ""
"The following wrapper will call the Python model from Rust, using a struct "
"to hold the model as a `PyAny` object:"
msgstr ""
"以下包裝器會從 Rust 呼叫 Python 模型，使用結構來持有該模型的 `PyAny` 物件："

#: src/trait_bounds.md:82 src/trait_bounds.md:183 src/trait_bounds.md:363
#: src/trait_bounds.md:421 src/trait_bounds.md:520
msgid "\"Rust calling Python to set the variables\""
msgstr ""

#: src/trait_bounds.md:88 src/trait_bounds.md:189 src/trait_bounds.md:369
#: src/trait_bounds.md:427 src/trait_bounds.md:526
msgid "\"set_variables\""
msgstr ""

#: src/trait_bounds.md:94 src/trait_bounds.md:195 src/trait_bounds.md:352
msgid "\"Rust calling Python to get the results\""
msgstr ""

#: src/trait_bounds.md:98 src/trait_bounds.md:199 src/trait_bounds.md:356
#: src/trait_bounds.md:410 src/trait_bounds.md:537
msgid "\"get_results\""
msgstr ""

#: src/trait_bounds.md:106 src/trait_bounds.md:207 src/trait_bounds.md:375
#: src/trait_bounds.md:433 src/trait_bounds.md:549
msgid "\"Rust calling Python to perform the computation\""
msgstr ""

#: src/trait_bounds.md:110 src/trait_bounds.md:211 src/trait_bounds.md:379
#: src/trait_bounds.md:437 src/trait_bounds.md:553
msgid "\"compute\""
msgstr ""

#: src/trait_bounds.md:117
msgid ""
"Now that this bit is implemented, let's expose the model wrapper to Python. "
"Let's add the PyO3 annotations and add a constructor:"
msgstr ""
"上述部分完成後，讓我們將模型包裝器對外暴露給 Python。加上 PyO3 標註並新增建構"
"子："

#: src/trait_bounds.md:150
msgid "Now we add the PyO3 annotations to the trait implementation:"
msgstr "接著在 trait 實作上加入 PyO3 標註："

#: src/trait_bounds.md:155
msgid "// the previous trait implementation\n"
msgstr "// 前述的 trait 實作\n"

#: src/trait_bounds.md:159
msgid ""
"However, the previous code will not compile. The compilation error is the "
"following one: `error: #[pymethods] cannot be used on trait impl blocks`"
msgstr ""
"然而，前述程式碼無法編譯。錯誤訊息如下：`error: #[pymethods] cannot be used "
"on trait impl blocks`"

#: src/trait_bounds.md:162
msgid ""
"That's a bummer! However, we can write a second wrapper around these "
"functions to call them directly. This wrapper will also perform the type "
"conversions between Python and Rust."
msgstr ""
"這很可惜！不過，我們可以再寫一個包裝器來直接呼叫這些函式。該包裝器也會負責在 "
"Python 與 Rust 之間進行型別轉換。"

#: src/trait_bounds.md:221 src/trait_bounds.md:504
msgid "\"Set variables from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 來設定變數\""

#: src/trait_bounds.md:226 src/trait_bounds.md:509
msgid "\"Get results from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 取得結果\""

#: src/trait_bounds.md:231
msgid "\"Compute from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 執行計算\""

#: src/trait_bounds.md:236
msgid ""
"This wrapper handles the type conversion between the PyO3 requirements and "
"the trait. In order to meet PyO3 requirements, this wrapper must:"
msgstr ""
"這個包裝器會處理 PyO3 要求與 trait 之間的型別轉換。為了符合 PyO3 的要求，此包"
"裝器必須："

#: src/trait_bounds.md:238
msgid "return an object of type `PyResult`"
msgstr "回傳 `PyResult` 型別的物件"

#: src/trait_bounds.md:239
msgid "use only values, not references in the method signatures"
msgstr "在方法簽章中僅使用值，而非參照"

#: src/trait_bounds.md:241
msgid "Let's run the file python file:"
msgstr "讓我們執行這個 Python 檔案："

#: src/trait_bounds.md:252
msgid "\"__main__\""
msgstr ""

#: src/trait_bounds.md:258
msgid "\"Print value from Python: \""
msgstr ""

#: src/trait_bounds.md:260
msgid "\"Print value from Python through Rust: \""
msgstr ""

#: src/trait_bounds.md:261
msgid "\"Print value directly from Python: \""
msgstr ""

#: src/trait_bounds.md:264
msgid "This outputs:"
msgstr ""

#: src/trait_bounds.md:278
msgid ""
"We have now successfully exposed a Rust model that implements the `Model` "
"trait to Python!"
msgstr ""

#: src/trait_bounds.md:280
msgid ""
"We will now expose the `solve` function, but before, let's talk about types "
"errors."
msgstr ""

#: src/trait_bounds.md:282
msgid "Type errors in Python"
msgstr ""

#: src/trait_bounds.md:284
msgid ""
"What happens if you have type errors when using Python and how can you "
"improve the error messages?"
msgstr ""

#: src/trait_bounds.md:287
msgid "Wrong types in Python function arguments"
msgstr ""

#: src/trait_bounds.md:289
msgid ""
"Let's assume in the first case that you will use in your Python file "
"`my_rust_model.set_variables(2.0)` instead of `my_rust_model."
"set_variables([2.0])`."
msgstr ""

#: src/trait_bounds.md:291
msgid ""
"The Rust signature expects a vector, which corresponds to a list in Python. "
"What happens if instead of a vector, we pass a single value ?"
msgstr ""

#: src/trait_bounds.md:294
msgid "At the execution of Python, we get :"
msgstr ""

#: src/trait_bounds.md:296
msgid ""
"```block\n"
"File \"main.py\", line 15, in <module>\n"
"   my_rust_model.set_variables(2)\n"
"TypeError\n"
"```"
msgstr ""

#: src/trait_bounds.md:302
msgid ""
"It is a type error and Python points to it, so it's easy to identify and "
"solve."
msgstr ""

#: src/trait_bounds.md:304
msgid "Wrong types in Python method signatures"
msgstr ""

#: src/trait_bounds.md:306
msgid ""
"Let's assume now that the return type of one of the methods of our Model "
"class is wrong, for example the `get_results` method that is expected to "
"return a `Vec<f64>` in Rust, a list in Python."
msgstr ""

#: src/trait_bounds.md:316
msgid "#return self.results <-- this is the expected output\n"
msgstr ""

#: src/trait_bounds.md:319
msgid "This call results in the following panic:"
msgstr ""

#: src/trait_bounds.md:325
msgid ""
"This error code is not helpful for a Python user that does not know anything "
"about Rust, or someone that does not know PyO3 was used to interface the "
"Rust code."
msgstr ""

#: src/trait_bounds.md:327
msgid ""
"However, as we are responsible for making the Rust code available to Python, "
"we can do something about it."
msgstr ""

#: src/trait_bounds.md:329
msgid ""
"The issue is that we called `unwrap` anywhere we could, and therefore any "
"panic from PyO3 will be directly forwarded to the end user."
msgstr ""

#: src/trait_bounds.md:331
msgid ""
"Let's modify the code performing the type conversion to give a helpful error "
"message to the Python user:"
msgstr ""

#: src/trait_bounds.md:333
msgid ""
"We used in our `get_results` method the following call that performs the "
"type conversion:"
msgstr ""

#: src/trait_bounds.md:386
msgid "Let's break it down in order to perform better error handling:"
msgstr ""

#: src/trait_bounds.md:405 src/trait_bounds.md:532
msgid "\"Get results from Rust calling Python\""
msgstr ""

#: src/trait_bounds.md:413 src/trait_bounds.md:540
msgid "\"list\""
msgstr ""

#: src/trait_bounds.md:414 src/trait_bounds.md:541
msgid "\"Expected a list for the get_results() method signature, got {}\""
msgstr ""

#: src/trait_bounds.md:444
msgid ""
"By doing so, you catch the result of the Python computation and check its "
"type in order to be able to deliver a better error message before performing "
"the unwrapping."
msgstr ""

#: src/trait_bounds.md:446
msgid ""
"Of course, it does not cover all the possible wrong outputs: the user could "
"return a list of strings instead of a list of floats. In this case, a "
"runtime panic would still occur due to PyO3, but with an error message much "
"more difficult to decipher for non-rust user."
msgstr ""

#: src/trait_bounds.md:450
msgid ""
"It is up to the developer exposing the rust code to decide how much effort "
"to invest into Python type error handling and improved error messages."
msgstr ""

#: src/trait_bounds.md:452
msgid "The final code"
msgstr ""

#: src/trait_bounds.md:454
msgid ""
"Now let's expose the `solve()` function to make it available from Python."
msgstr ""

#: src/trait_bounds.md:456
msgid ""
"It is not possible to directly expose the `solve` function to Python, as the "
"type conversion cannot be performed. It requires an object implementing the "
"`Model` trait as input."
msgstr ""

#: src/trait_bounds.md:459
msgid ""
"However, the `UserModel` already implements this trait. Because of this, we "
"can write a function wrapper that takes the `UserModel`\\--which has already "
"been exposed to Python--as an argument in order to call the core function "
"`solve`."
msgstr ""

#: src/trait_bounds.md:462
msgid "It is also required to make the struct public."
msgstr ""

#: src/trait_bounds.md:479
msgid "\"solve\""
msgstr ""

#: src/python_typing_hints.md:1
msgid "Typing and IDE hints for you Python package"
msgstr ""

#: src/python_typing_hints.md:3
msgid ""
"PyO3 provides an easy to use interface to code native Python libraries in "
"Rust. The accompanying Maturin allows you to build and publish them as a "
"package. Yet, for the better user experience, Python libraries should "
"provide typing hints and documentation for all public entities, so that IDEs "
"can show them during development and type analyzing tools such as `mypy` can "
"use them to properly verify the code."
msgstr ""

#: src/python_typing_hints.md:5
msgid ""
"Currently the best solution for the problem is to maintain manually the `*."
"pyi` files and ship them along with the package."
msgstr ""

#: src/python_typing_hints.md:7
msgid "The `pyi` files introduction"
msgstr ""

#: src/python_typing_hints.md:9
msgid ""
"`pyi` (an abbreviation for `Python Interface`) is called a `Stub File` in "
"most of the documentations related to them. Very good definition of what it "
"is can be found in [old MyPy documentation](https://github.com/python/mypy/"
"wiki/Creating-Stubs-For-Python-Modules):"
msgstr ""

#: src/python_typing_hints.md:11
msgid ""
"A stubs file only contains a description of the public interface of the "
"module without any implementations."
msgstr "Stub 檔案只包含模組公開介面的描述，不包含任何實作。"

#: src/python_typing_hints.md:13
msgid ""
"Probably most Python developers encountered them already when trying to use "
"the IDE \"Go to Definition\" function on any builtin type. For example the "
"definitions of few standard exceptions look like this:"
msgstr ""

#: src/python_typing_hints.md:36
msgid ""
"As we can see those are not full definitions containing implementation, but "
"just a description of interface. It is usually all that is needed by the "
"user of the library."
msgstr ""

#: src/python_typing_hints.md:38
msgid "What does the PEPs say?"
msgstr ""

#: src/python_typing_hints.md:40
msgid ""
"As of the time of writing this documentation the `pyi` files are referenced "
"in three PEPs."
msgstr ""

#: src/python_typing_hints.md:42
msgid ""
"[PEP8 - Style Guide for Python Code - #Function Annotations](https://www."
"python.org/dev/peps/pep-0008/#function-annotations) (last point) recommends "
"all third party library creators to provide stub files as the source of "
"knowledge about the package for type checker tools."
msgstr ""
"[PEP8 - Python 程式碼風格指南 - #Function Annotations](https://www.python."
"org/dev/peps/pep-0008/#function-annotations)（最後一點）建議所有第三方函式庫"
"作者提供 stub 檔案，作為型別檢查工具對套件的知識來源。"

#: src/python_typing_hints.md:44
msgid ""
"(...) it is expected that users of third party library packages may want to "
"run type checkers over those packages. For this purpose [PEP 484](https://"
"www.python.org/dev/peps/pep-0484) recommends the use of stub files: .pyi "
"files that are read by the type checker in preference of the corresponding ."
"py files. (...)"
msgstr ""
"（……）預期第三方函式庫的使用者可能會對這些套件執行型別檢查。為此，[PEP 484]"
"(https://www.python.org/dev/peps/pep-0484) 建議使用 stub 檔案：型別檢查器會優"
"先讀取 .pyi 檔案而不是對應的 .py 檔案。（……）"

#: src/python_typing_hints.md:46
msgid ""
"[PEP484 - Type Hints - #Stub Files](https://www.python.org/dev/peps/pep-0484/"
"#stub-files) defines stub files as follows."
msgstr ""
"[PEP484 - Type Hints - #Stub Files](https://www.python.org/dev/peps/pep-0484/"
"#stub-files) 對 stub 檔案的定義如下。"

#: src/python_typing_hints.md:48
msgid ""
"Stub files are files containing type hints that are only for use by the type "
"checker, not at runtime."
msgstr "Stub 檔案是只提供給型別檢查器使用、而非執行階段使用的型別提示檔案。"

#: src/python_typing_hints.md:50
msgid ""
"It contains a specification for them (highly recommended reading, since it "
"contains at least one thing that is not used in normal Python code) and also "
"some general information about where to store the stub files."
msgstr ""
"其中包含對 stub 檔案的規範（強烈建議閱讀，因為至少有一項是一般 Python 程式碼"
"不會用到的）以及關於存放位置的一般資訊。"

#: src/python_typing_hints.md:52
msgid ""
"[PEP561 - Distributing and Packaging Type Information](https://www.python."
"org/dev/peps/pep-0561/) describes in detail how to build packages that will "
"enable type checking. In particular it contains information about how the "
"stub files must be distributed in order for type checkers to use them."
msgstr ""
"[PEP561 - Distributing and Packaging Type Information](https://www.python."
"org/dev/peps/pep-0561/) 詳細描述如何建置能啟用型別檢查的套件，特別是如何散布 "
"stub 檔案以供型別檢查器使用。"

#: src/python_typing_hints.md:54
msgid "How to do it?"
msgstr "該怎麼做？"

#: src/python_typing_hints.md:56
msgid ""
"[PEP561](https://www.python.org/dev/peps/pep-0561/) recognizes three ways of "
"distributing type information:"
msgstr ""
"[PEP561](https://www.python.org/dev/peps/pep-0561/) 提出三種散布型別資訊的方"
"式："

#: src/python_typing_hints.md:58
msgid "`inline` - the typing is placed directly in source (`py`) files;"
msgstr "`inline` - 型別直接放在原始碼（`py`）檔案中；"

#: src/python_typing_hints.md:59
msgid ""
"`separate package with stub files` - the typing is placed in `pyi` files "
"distributed in their own, separate package;"
msgstr ""
"`separate package with stub files` - 型別放在 `pyi` 檔案中，並以獨立套件發"
"布；"

#: src/python_typing_hints.md:60
msgid ""
"`in-package stub files` - the typing is placed in `pyi` files distributed in "
"the same package as source files."
msgstr ""
"`in-package stub files` - 型別放在 `pyi` 檔案中，並與原始碼同套件發布。"

#: src/python_typing_hints.md:62
msgid ""
"The first way is tricky with PyO3 since we do not have `py` files. When it "
"will be investigated and necessary changes are implemented, this document "
"will be updated."
msgstr ""

#: src/python_typing_hints.md:64
msgid ""
"The second way is easy to do, and the whole work can be fully separated from "
"the main library code. The example repo for the package with stub files can "
"be found in [PEP561 references section](https://www.python.org/dev/peps/"
"pep-0561/#references): [Stub package repository](https://github.com/ethanhs/"
"stub-package)"
msgstr ""
"第二種方式很容易完成，而且可與主函式庫程式碼完全分離。帶有 stub 檔案的套件範"
"例可在 [PEP561 參考資料](https://www.python.org/dev/peps/pep-0561/"
"#references)中找到：[Stub package repository](https://github.com/ethanhs/"
"stub-package)"

#: src/python_typing_hints.md:66
msgid "The third way is described below."
msgstr "第三種方式如下所述。"

#: src/python_typing_hints.md:68
msgid "Including `pyi` files in your PyO3/Maturin build package"
msgstr "在 PyO3/Maturin 建置套件中包含 `pyi` 檔案"

#: src/python_typing_hints.md:70
msgid ""
"When source files are in the same package as stub files, they should be "
"placed next to each other. We need a way to do that with Maturin. Also, in "
"order to mark our package as typing-enabled we need to add an empty file "
"named `py.typed` to the package."
msgstr ""
"當原始碼與 stub 檔案位於同一套件時，應該把它們放在彼此相鄰的位置。我們需要能"
"用 Maturin 達成這點的方法。此外，為了標示套件具有型別資訊，我們需要在套件中新"
"增一個名為 `py.typed` 的空檔案。"

#: src/python_typing_hints.md:72
msgid "If you do not have other Python files"
msgstr "若你沒有其他 Python 檔案"

#: src/python_typing_hints.md:74
msgid ""
"If you do not need to add any other Python files apart from `pyi` to the "
"package, the Maturin provides a way to do most of the work for you. As "
"documented in [Maturin Guide](https://github.com/PyO3/maturin/"
"blob/084cfaced651b28616aeea1f818bdc933a536bfe/guide/src/project_layout."
"md#adding-python-type-information) the only thing you need to do is create a "
"stub file for your module named `<module_name>.pyi` in your project root and "
"Maturin will do the rest."
msgstr ""

#: src/python_typing_hints.md:85
msgid ""
"For example of `pyi` file see [`my_project.pyi` content](#my_projectpyi-"
"content) section."
msgstr ""

#: src/python_typing_hints.md:87
msgid "If you need other Python files"
msgstr ""

#: src/python_typing_hints.md:89
msgid ""
"If you need to add other Python files apart from `pyi` to the package, you "
"can do it also, but that requires some more work. Maturin provides easy way "
"to add files to package ([documentation](https://github.com/PyO3/maturin/"
"blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-rustpython-"
"projects)). You just need to create a folder with the name of your module "
"next to the `Cargo.toml` file (for customization see documentation linked "
"above)."
msgstr ""

#: src/python_typing_hints.md:91
msgid "The folder structure would be:"
msgstr ""

#: src/python_typing_hints.md:107
msgid ""
"Let's go a little bit more into details on the files inside the package "
"folder."
msgstr ""

#: src/python_typing_hints.md:109
msgid "`__init__.py` content"
msgstr ""

#: src/python_typing_hints.md:111
msgid ""
"As we now specify our own package content, we have to provide the `__init__."
"py` file, so the folder is treated as a package and we can import things "
"from it. We can always use the same content that the Maturin creates for us "
"if we do not specify a python source folder. For PyO3 bindings it would be:"
msgstr ""

#: src/python_typing_hints.md:117
msgid ""
"That way everything that is exposed by our native module can be imported "
"directly from the package."
msgstr ""

#: src/python_typing_hints.md:119
msgid "`py.typed` requirement"
msgstr ""

#: src/python_typing_hints.md:121
msgid "As stated in [PEP561](https://www.python.org/dev/peps/pep-0561/):"
msgstr ""

#: src/python_typing_hints.md:122
msgid ""
"Package maintainers who wish to support type checking of their code MUST add "
"a marker file named py.typed to their package supporting typing. This marker "
"applies recursively: if a top-level package includes it, all its sub-"
"packages MUST support type checking as well."
msgstr ""

#: src/python_typing_hints.md:124
msgid ""
"If we do not include that file, some IDEs might still use our `pyi` files to "
"show hints, but the type checkers might not. MyPy will raise an error in "
"this situation:"
msgstr ""

#: src/python_typing_hints.md:126
msgid ""
"```text\n"
"error: Skipping analyzing \"my_project\": found module but no type hints or "
"library stubs\n"
"```"
msgstr ""

#: src/python_typing_hints.md:130
msgid "The file is just a marker file, so it should be empty."
msgstr ""

#: src/python_typing_hints.md:132
msgid "`my_project.pyi` content"
msgstr ""

#: src/python_typing_hints.md:134
msgid ""
"Our module stub file. This document does not aim at describing how to write "
"them, since you can find a lot of documentation on it, starting from already "
"quoted [PEP484](https://www.python.org/dev/peps/pep-0484/#stub-files)."
msgstr ""

#: src/python_typing_hints.md:136
msgid "The example can look like this:"
msgstr ""

#: src/python_typing_hints.md:140
msgid ""
"\"\"\"\n"
"    A class representing a car.\n"
"\n"
"    :param body_type: the name of body type, e.g. hatchback, sedan\n"
"    :param horsepower: power of the engine in horsepower\n"
"    \"\"\""
msgstr ""

#: src/python_typing_hints.md:149
msgid "'Car'"
msgstr ""

#: src/python_typing_hints.md:150
msgid ""
"\"\"\"\n"
"        Creates a Car based on unique name\n"
"\n"
"        :param name: model name of a car to be created\n"
"        :return: a Car instance with default data\n"
"        \"\"\""
msgstr ""

#: src/python_typing_hints.md:158
msgid ""
"\"\"\"\n"
"        Gets the best color for the car.\n"
"\n"
"        :return: the name of the color our great algorithm thinks is the "
"best for this car\n"
"        \"\"\""
msgstr ""

#: src/building_and_distribution.md:1
msgid "Building and distribution"
msgstr "建置與散布"

#: src/building_and_distribution.md:3
msgid ""
"This chapter of the guide goes into detail on how to build and distribute "
"projects using PyO3. The way to achieve this is very different depending on "
"whether the project is a Python module implemented in Rust, or a Rust binary "
"embedding Python. For both types of project there are also common problems "
"such as the Python version to build for and the [linker](https://en."
"wikipedia.org/wiki/Linker_(computing)) arguments to use."
msgstr ""
"本章將詳細說明如何使用 PyO3 建置與散布專案。具體做法會依專案是以 Rust 實作的 "
"Python 模組，或是嵌入 Python 的 Rust 可執行檔而有很大差異。兩者也有共同問題，"
"例如要建置的 Python 版本，以及要使用的[連結器](https://en.wikipedia.org/wiki/"
"Linker_(computing))參數。"

#: src/building_and_distribution.md:5
msgid ""
"The material in this chapter is intended for users who have already read the "
"PyO3 [README](#index.md). It covers in turn the choices that can be made for "
"Python modules and for Rust binaries. There is also a section at the end "
"about cross-compiling projects using PyO3."
msgstr ""

#: src/building_and_distribution.md:7
msgid ""
"There is an additional sub-chapter dedicated to [supporting multiple Python "
"versions](./building_and_distribution/multiple_python_versions.html)."
msgstr ""

#: src/building_and_distribution.md:9
msgid "Configuring the Python version"
msgstr "設定 Python 版本"

#: src/building_and_distribution.md:11
msgid ""
"PyO3 uses a build script (backed by the [`pyo3-build-config`](https://github."
"com/PyO3/pyo3/tree/main/pyo3-build-config) crate) to determine the Python "
"version and set the correct linker arguments. By default it will attempt to "
"use the following in order:"
msgstr ""
"PyO3 使用建置腳本（由 [`pyo3-build-config`](https://github.com/PyO3/pyo3/"
"tree/main/pyo3-build-config) crate 支援）來判斷 Python 版本並設定正確的連結器"
"參數。預設會依序嘗試使用："

#: src/building_and_distribution.md:12
msgid "Any active Python virtualenv."
msgstr "任何已啟用的 Python 虛擬環境。"

#: src/building_and_distribution.md:13
msgid "The `python` executable (if it's a Python 3 interpreter)."
msgstr "`python` 執行檔（若它是 Python 3 直譯器）。"

#: src/building_and_distribution.md:14
msgid "The `python3` executable."
msgstr "`python3` 執行檔。"

#: src/building_and_distribution.md:16
msgid ""
"You can override the Python interpreter by setting the `PYO3_PYTHON` "
"environment variable, e.g. `PYO3_PYTHON=python3.7`, `PYO3_PYTHON=/usr/bin/"
"python3.9`, or even a PyPy interpreter `PYO3_PYTHON=pypy3`."
msgstr ""
"你可以設定 `PYO3_PYTHON` 環境變數來覆寫 Python 直譯器，例如 "
"`PYO3_PYTHON=python3.7`、`PYO3_PYTHON=/usr/bin/python3.9`，甚至是 PyPy 直譯"
"器 `PYO3_PYTHON=pypy3`。"

#: src/building_and_distribution.md:18
msgid ""
"Once the Python interpreter is located, `pyo3-build-config` executes it to "
"query the information in the `sysconfig` module which is needed to configure "
"the rest of the compilation."
msgstr ""
"找到 Python 直譯器後，`pyo3-build-config` 會執行它，以查詢 `sysconfig` 模組中"
"的資訊，供後續編譯設定使用。"

#: src/building_and_distribution.md:20
msgid ""
"To validate the configuration which PyO3 will use, you can run a compilation "
"with the environment variable `PYO3_PRINT_CONFIG=1` set. An example output "
"of doing this is shown below:"
msgstr ""
"要驗證 PyO3 將採用的設定，你可以在編譯時設定 `PYO3_PRINT_CONFIG=1` 環境變數。"
"其輸出範例如下："

#: src/building_and_distribution.md:48
msgid "Advanced: config files"
msgstr "進階：設定檔"

#: src/building_and_distribution.md:50
msgid ""
"If you save the above output config from `PYO3_PRINT_CONFIG` to a file, it "
"is possible to manually override the contents and feed it back into PyO3 "
"using the `PYO3_CONFIG_FILE` env var."
msgstr ""
"若將 `PYO3_PRINT_CONFIG` 的輸出設定儲存成檔案，你就能手動覆寫內容，並透過 "
"`PYO3_CONFIG_FILE` 環境變數回饋給 PyO3。"

#: src/building_and_distribution.md:52
msgid ""
"If your build environment is unusual enough that PyO3's regular "
"configuration detection doesn't work, using a config file like this will "
"give you the flexibility to make PyO3 work for you. To see the full set of "
"options supported, see the documentation for the [`InterpreterConfig` struct]"
"(https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct."
"InterpreterConfig.html)."
msgstr ""
"若你的建置環境較為特殊，導致 PyO3 的一般設定偵測無法運作，使用這種設定檔可提"
"供彈性以讓 PyO3 正常運作。要查看完整可用選項，請參考 [`InterpreterConfig` "
"struct](https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct."
"InterpreterConfig.html) 文件。"

#: src/building_and_distribution.md:54
msgid "Building Python extension modules"
msgstr "建置 Python 擴充模組"

#: src/building_and_distribution.md:56
msgid ""
"Python extension modules need to be compiled differently depending on the OS "
"(and architecture) that they are being compiled for. As well as multiple "
"OSes (and architectures), there are also many different Python versions "
"which are actively supported. Packages uploaded to [PyPI](https://pypi.org/) "
"usually want to upload prebuilt \"wheels\" covering many OS/arch/version "
"combinations so that users on all these different platforms don't have to "
"compile the package themselves. Package vendors can opt-in to the \"abi3\" "
"limited Python API which allows their wheels to be used on multiple Python "
"versions, reducing the number of wheels they need to compile, but restricts "
"the functionality they can use."
msgstr ""
"Python 擴充模組的編譯方式會依目標作業系統（與架構）而不同。除了多種作業系統"
"（與架構），也有許多仍在支援的 Python 版本。上傳到 [PyPI](https://pypi.org/) "
"的套件通常會提供涵蓋多種 OS/架構/版本組合的預建「wheels」，讓不同平台的使用者"
"不必自行編譯。套件提供者也可選擇使用受限的 Python API「abi3」，讓單一 wheel "
"支援多個 Python 版本，以減少需要編譯的 wheel 數量，但功能也會受限。"

#: src/building_and_distribution.md:58
msgid ""
"There are many ways to go about this: it is possible to use `cargo` to build "
"the extension module (along with some manual work, which varies with OS). "
"The PyO3 ecosystem has two packaging tools, [`maturin`](https://github.com/"
"PyO3/maturin) and [`setuptools-rust`](https://github.com/PyO3/setuptools-"
"rust), which abstract over the OS difference and also support building "
"wheels for PyPI upload."
msgstr ""
"實作方式有很多種：可以用 `cargo` 來建置擴充模組（並搭配一些手動步驟，會因 OS "
"而異）。PyO3 生態系提供兩個打包工具 [`maturin`](https://github.com/PyO3/"
"maturin) 和 [`setuptools-rust`](https://github.com/PyO3/setuptools-rust)，可"
"抽象化 OS 差異並支援建置可上傳 PyPI 的 wheels。"

#: src/building_and_distribution.md:60
msgid ""
"PyO3 has some Cargo features to configure projects for building Python "
"extension modules:"
msgstr ""

#: src/building_and_distribution.md:61
msgid ""
"The `extension-module` feature, which must be enabled when building Python "
"extension modules."
msgstr ""

#: src/building_and_distribution.md:62
msgid ""
"The `abi3` feature and its version-specific `abi3-pyXY` companions, which "
"are used to opt-in to the limited Python API in order to support multiple "
"Python versions in a single wheel."
msgstr ""

#: src/building_and_distribution.md:64
msgid ""
"This section describes each of these packaging tools before describiing how "
"to build manually without them. It then proceeds with an explanation of the "
"`extension-module` feature. Finally, there is a section describing PyO3's "
"`abi3` features."
msgstr ""

#: src/building_and_distribution.md:66
msgid "Packaging tools"
msgstr "打包工具"

#: src/building_and_distribution.md:68
msgid ""
"The PyO3 ecosystem has two main choices to abstract the process of "
"developing Python extension modules:"
msgstr "PyO3 生態系提供兩個主要選項來抽象化 Python 擴充模組的開發流程："

#: src/building_and_distribution.md:69
msgid ""
"[`maturin`](https://github.com/PyO3/maturin) is a command-line tool to "
"build, package and upload Python modules. It makes opinionated choices about "
"project layout meaning it needs very little configuration. This makes it a "
"great choice for users who are building a Python extension from scratch and "
"don't need flexibility."
msgstr ""

#: src/building_and_distribution.md:70
msgid ""
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) is an add-on "
"for `setuptools` which adds extra keyword arguments to the `setup.py` "
"configuration file. It requires more configuration than `maturin`, however "
"this gives additional flexibility for users adding Rust to an existing "
"Python package that can't satisfy `maturin`'s constraints."
msgstr ""

#: src/building_and_distribution.md:72
msgid ""
"Consult each project's documentation for full details on how to get started "
"using them and how to upload wheels to PyPI."
msgstr ""

#: src/building_and_distribution.md:74
msgid ""
"There are also [`maturin-starter`](https://github.com/PyO3/pyo3/tree/main/"
"examples/maturin-starter) and [`setuptools-rust-starter`](https://github.com/"
"PyO3/pyo3/tree/main/examples/setuptools-rust-starter) examples in the PyO3 "
"repository."
msgstr ""

#: src/building_and_distribution.md:76
msgid "Manual builds"
msgstr "手動建置"

#: src/building_and_distribution.md:78
msgid ""
"To build a PyO3-based Python extension manually, start by running `cargo "
"build` as normal in a library project which uses PyO3's `extension-module` "
"feature and has the [`cdylib` crate type](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#the-crate-type-field)."
msgstr ""

#: src/building_and_distribution.md:80
msgid ""
"Once built, symlink (or copy) and rename the shared library from Cargo's "
"`target/` directory to your desired output directory:"
msgstr ""

#: src/building_and_distribution.md:81
msgid "on macOS, rename `libyour_module.dylib` to `your_module.so`."
msgstr ""

#: src/building_and_distribution.md:82
msgid "on Windows, rename  `libyour_module.dll` to `your_module.pyd`."
msgstr ""

#: src/building_and_distribution.md:83
msgid "on Linux, rename `libyour_module.so` to `your_module.so`."
msgstr ""

#: src/building_and_distribution.md:85
msgid ""
"You can then open a Python shell in the output directory and you'll be able "
"to run `import your_module`."
msgstr ""

#: src/building_and_distribution.md:87
msgid ""
"If you're packaging your library for redistribution, you should indicated "
"the Python interpreter your library is compiled for by including the "
"[platform tag](#platform-tags) in its name. This prevents incompatible "
"interpreters from trying to import your library. If you're compiling for "
"PyPy you _must_ include the platform tag, or PyPy will ignore the module."
msgstr ""

#: src/building_and_distribution.md:89
msgid ""
"See, as an example, Bazel rules to build PyO3 on Linux at https://github.com/"
"TheButlah/rules_pyo3."
msgstr ""

#: src/building_and_distribution.md:91
msgid "Platform tags"
msgstr "平臺標記"

#: src/building_and_distribution.md:93
msgid ""
"Rather than using just the `.so` or `.pyd` extension suggested above "
"(depending on OS), uou can prefix the shared library extension with a "
"platform tag to indicate the interpreter it is compatible with. You can "
"query your interpreter's platform tag from the `sysconfig` module. Some "
"example outputs of this are seen below:"
msgstr ""

#: src/building_and_distribution.md:96
msgid "# CPython 3.10 on macOS\n"
msgstr ""

#: src/building_and_distribution.md:98
msgid "# PyPy 7.3 (Python 3.8) on Linux\n"
msgstr ""

#: src/building_and_distribution.md:100
msgid "'import sysconfig; print(sysconfig.get_config_var(\"EXT_SUFFIX\"))'"
msgstr ""

#: src/building_and_distribution.md:104
msgid ""
"So, for example, a valid module library name on CPython 3.10 for macOS is "
"`your_module.cpython-310-darwin.so`, and its equivalent when compiled for "
"PyPy 7.3 on Linux would be `your_module.pypy38-pp73-x86_64-linux-gnu.so`."
msgstr ""

#: src/building_and_distribution.md:106
msgid ""
"See [PEP 3149](https://peps.python.org/pep-3149/) for more background on "
"platform tags."
msgstr ""

#: src/building_and_distribution.md:108
msgid "macOS"
msgstr ""

#: src/building_and_distribution.md:110
msgid ""
"On macOS, because the `extension-module` feature disables linking to "
"`libpython` ([see the next section](#the-extension-module-feature)), some "
"additional linker arguments need to be set. `maturin` and `setuptools-rust` "
"both pass these arguments for PyO3 automatically, but projects using manual "
"builds will need to set these directly in order to support macOS."
msgstr ""

#: src/building_and_distribution.md:112
msgid ""
"The easiest way to set the correct linker arguments is to add a [`build.rs`]"
"(https://doc.rust-lang.org/cargo/reference/build-scripts.html) with the "
"following content:"
msgstr ""

#: src/building_and_distribution.md:120
msgid ""
"Remember to also add `pyo3-build-config` to the `build-dependencies` section "
"in `Cargo.toml`."
msgstr ""

#: src/building_and_distribution.md:122
msgid ""
"An alternative to using `pyo3-build-config` is add the following to a cargo "
"configuration file (e.g. `.cargo/config.toml`):"
msgstr ""

#: src/building_and_distribution.md:124
msgid ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"\n"
"[target.aarch64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"
msgstr ""
"```toml\n"
"[target.x86_64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"\n"
"[target.aarch64-apple-darwin]\n"
"rustflags = [\n"
"  \"-C\", \"link-arg=-undefined\",\n"
"  \"-C\", \"link-arg=dynamic_lookup\",\n"
"]\n"
"```"

#: src/building_and_distribution.md:138
msgid ""
"Using the MacOS system python3 (`/usr/bin/python3`, as opposed to python "
"installed via homebrew, pyenv, nix, etc.) may result in runtime errors such "
"as `Library not loaded: @rpath/Python3.framework/Versions/3.8/Python3`. "
"These can be resolved with another addition to `.cargo/config.toml`:"
msgstr ""

#: src/building_and_distribution.md:140
msgid ""
"```toml\n"
"[build]\n"
"rustflags = [\n"
"  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/"
"Frameworks\",\n"
"]\n"
"```"
msgstr ""
"```toml\n"
"[build]\n"
"rustflags = [\n"
"  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/"
"Frameworks\",\n"
"]\n"
"```"

#: src/building_and_distribution.md:147
msgid "Alternatively, on rust >= 1.56, one can include in `build.rs`:"
msgstr ""

#: src/building_and_distribution.md:152
msgid ""
"\"cargo:rustc-link-arg=-Wl,-rpath,/Library/Developer/CommandLineTools/"
"Library/Frameworks\""
msgstr ""

#: src/building_and_distribution.md:157
msgid ""
"For more discussion on and workarounds for MacOS linking problems [see this "
"issue](https://github.com/PyO3/pyo3/issues/1800#issuecomment-906786649)."
msgstr ""

#: src/building_and_distribution.md:159
msgid ""
"Finally, don't forget that on MacOS the `extension-module` feature will "
"cause `cargo test` to fail without the `--no-default-features` flag (see "
"[the FAQ](https://pyo3.rs/main/faq.html#i-cant-run-cargo-test-im-having-"
"linker-issues-like-symbol-not-found-or-undefined-reference-to-"
"_pyexc_systemerror))."
msgstr ""

#: src/building_and_distribution.md:161
msgid "The `extension-module` feature"
msgstr ""

#: src/building_and_distribution.md:163
msgid ""
"PyO3's `extension-module` feature is used to disable [linking](https://en."
"wikipedia.org/wiki/Linker_(computing)) to `libpython` on unix targets."
msgstr ""

#: src/building_and_distribution.md:165
msgid ""
"This is necessary because by default PyO3 links to `libpython`. This makes "
"binaries, tests, and examples \"just work\". However, Python extensions on "
"unix must not link to libpython for [manylinux](https://www.python.org/dev/"
"peps/pep-0513/) compliance."
msgstr ""

#: src/building_and_distribution.md:167
msgid ""
"The downside of not linking to `libpython` is that binaries, tests, and "
"examples (which usually embed Python) will fail to build. If you have an "
"extension module as well as other outputs in a single project, you need to "
"use optional Cargo features to disable the `extension-module` when you're "
"not building the extension module. See [the FAQ](faq.md#i-cant-run-cargo-"
"test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-"
"symbol-not-found-or-undefined-reference-to-_pyexc_systemerror) for an "
"example workaround."
msgstr ""

#: src/building_and_distribution.md:169
msgid "`Py_LIMITED_API`/`abi3`"
msgstr ""

#: src/building_and_distribution.md:171
msgid ""
"By default, Python extension modules can only be used with the same Python "
"version they were compiled against. For example, an extension module built "
"for Python 3.5 can't be imported in Python 3.8. [PEP 384](https://www.python."
"org/dev/peps/pep-0384/) introduced the idea of the limited Python API, which "
"would have a stable ABI enabling extension modules built with it to be used "
"against multiple Python versions. This is also known as `abi3`."
msgstr ""

#: src/building_and_distribution.md:173
msgid ""
"The advantage of building extension modules using the limited Python API is "
"that package vendors only need to build and distribute a single copy (for "
"each OS / architecture), and users can install it on all Python versions "
"from the [minimum version](#minimum-python-version-for-abi3) and up. The "
"downside of this is that PyO3 can't use optimizations which rely on being "
"compiled against a known exact Python version. It's up to you to decide "
"whether this matters for your extension module. It's also possible to design "
"your extension module such that you can distribute `abi3` wheels but allow "
"users compiling from source to benefit from additional optimizations - see "
"the [support for multiple python versions](./building_and_distribution/"
"multiple_python_versions.html) section of this guide, in particular the "
"`#[cfg(Py_LIMITED_API)]` flag."
msgstr ""

#: src/building_and_distribution.md:175
msgid ""
"There are three steps involved in making use of `abi3` when building Python "
"packages as wheels:"
msgstr ""

#: src/building_and_distribution.md:177
msgid ""
"Enable the `abi3` feature in `pyo3`. This ensures `pyo3` only calls Python C-"
"API functions which are part of the stable API, and on Windows also ensures "
"that the project links against the correct shared object (no special "
"behavior is required on other platforms):"
msgstr ""

#: src/building_and_distribution.md:179
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"abi3\"] }\n"
"```"
msgstr ""

#: src/building_and_distribution.md:184
msgid ""
"Ensure that the built shared objects are correctly marked as `abi3`. This is "
"accomplished by telling your build system that you're using the limited API. "
"[`maturin`](https://github.com/PyO3/maturin) >= 0.9.0 and [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) >= 0.11.4 support `abi3` wheels. "
"See the [corresponding](https://github.com/PyO3/maturin/pull/353) [PRs]"
"(https://github.com/PyO3/setuptools-rust/pull/82) for more."
msgstr ""

#: src/building_and_distribution.md:187
msgid ""
"Ensure that the `.whl` is correctly marked as `abi3`. For projects using "
"`setuptools`, this is accomplished by passing `--py-limited-api=cp3x` (where "
"`x` is the minimum Python version supported by the wheel, e.g. `--py-limited-"
"api=cp35` for Python 3.5) to `setup.py bdist_wheel`."
msgstr ""

#: src/building_and_distribution.md:189
msgid "Minimum Python version for `abi3`"
msgstr ""

#: src/building_and_distribution.md:191
msgid ""
"Because a single `abi3` wheel can be used with many different Python "
"versions, PyO3 has feature flags `abi3-py37`, `abi3-py38`, `abi3-py39` etc. "
"to set the minimum required Python version for your `abi3` wheel. For "
"example, if you set the `abi3-py37` feature, your extension wheel can be "
"used on all Python 3 versions from Python 3.7 and up. `maturin` and "
"`setuptools-rust` will give the wheel a name like `my-extension-1.0-cp37-"
"abi3-manylinux2020_x86_64.whl`."
msgstr ""

#: src/building_and_distribution.md:194
msgid ""
"As your extension module may be run with multiple different Python versions "
"you may occasionally find you need to check the Python version at runtime to "
"customize behavior. See [the relevant section of this guide](./"
"building_and_distribution/multiple_python_versions.html#checking-the-python-"
"version-at-runtime) on supporting multiple Python versions at runtime."
msgstr ""

#: src/building_and_distribution.md:196
msgid ""
"PyO3 is only able to link your extension module to api3 version up to and "
"including your host Python version. E.g., if you set `abi3-py38` and try to "
"compile the crate with a host of Python 3.7, the build will fail."
msgstr ""

#: src/building_and_distribution.md:198
msgid ""
"Note: If you set more that one of these api version feature flags the lowest "
"version always wins. For example, with both `abi3-py37` and `abi3-py38` set, "
"PyO3 would build a wheel which supports Python 3.7 and up."
msgstr ""

#: src/building_and_distribution.md:200
msgid "Building `abi3` extensions without a Python interpreter"
msgstr ""

#: src/building_and_distribution.md:202
msgid ""
"As an advanced feature, you can build PyO3 wheel without calling Python "
"interpreter with the environment variable `PYO3_NO_PYTHON` set. Also, if the "
"build host Python interpreter is not found or is too old or otherwise "
"unusable, PyO3 will still attempt to compile `abi3` extension modules after "
"displaying a warning message. On Unix-like systems this works "
"unconditionally; on Windows you must also set the `RUSTFLAGS` environment "
"variable to contain `-L native=/path/to/python/libs` so that the linker can "
"find `python3.lib`."
msgstr ""

#: src/building_and_distribution.md:208
msgid ""
"If the `python3.dll` import library is not available, an experimental "
"`generate-import-lib` crate feature may be enabled, and the required library "
"will be created and used by PyO3 automatically."
msgstr ""

#: src/building_and_distribution.md:211
msgid ""
"_Note_: MSVC targets require LLVM binutils (`llvm-dlltool`) to be available "
"in `PATH` for the automatic import library generation feature to work."
msgstr ""

#: src/building_and_distribution.md:214
msgid "Missing features"
msgstr ""

#: src/building_and_distribution.md:216
msgid ""
"Due to limitations in the Python API, there are a few `pyo3` features that "
"do not work when compiling for `abi3`. These are:"
msgstr ""

#: src/building_and_distribution.md:219
msgid ""
"`#[pyo3(text_signature = \"...\")]` does not work on classes until Python "
"3.10 or greater."
msgstr ""

#: src/building_and_distribution.md:220
msgid ""
"The `dict` and `weakref` options on classes are not supported until Python "
"3.9 or greater."
msgstr ""

#: src/building_and_distribution.md:221
msgid "The buffer API is not supported until Python 3.11 or greater."
msgstr ""

#: src/building_and_distribution.md:222
msgid ""
"Optimizations which rely on knowledge of the exact Python version compiled "
"against."
msgstr ""

#: src/building_and_distribution.md:224
msgid "Embedding Python in Rust"
msgstr ""

#: src/building_and_distribution.md:226
msgid ""
"If you want to embed the Python interpreter inside a Rust program, there are "
"two modes in which this can be done: dynamically and statically. We'll cover "
"each of these modes in the following sections. Each of them affect how you "
"must distribute your program. Instead of learning how to do this yourself, "
"you might want to consider using a project like [PyOxidizer](https://github."
"com/indygreg/PyOxidizer) to ship your application and all of its "
"dependencies in a single file."
msgstr ""

#: src/building_and_distribution.md:228
msgid ""
"PyO3 automatically switches between the two linking modes depending on "
"whether the Python distribution you have configured PyO3 to use ([see above]"
"(#python-version)) contains a shared library or a static library. The static "
"library is most often seen in Python distributions compiled from source "
"without the `--enable-shared` configuration option. For example, this is the "
"default for `pyenv` on macOS."
msgstr ""

#: src/building_and_distribution.md:230
msgid "Dynamically embedding the Python interpreter"
msgstr ""

#: src/building_and_distribution.md:232
msgid ""
"Embedding the Python interpreter dynamically is much easier than doing so "
"statically. This is done by linking your program against a Python shared "
"library (such as `libpython.3.9.so` on UNIX, or `python39.dll` on Windows). "
"The implementation of the Python interpreter resides inside the shared "
"library. This means that when the OS runs your Rust program it also needs to "
"be able to find the Python shared library."
msgstr ""

#: src/building_and_distribution.md:234
msgid ""
"This mode of embedding works well for Rust tests which need access to the "
"Python interpreter. It is also great for Rust software which is installed "
"inside a Python virtualenv, because the virtualenv sets up appropriate "
"environment variables to locate the correct Python shared library."
msgstr ""

#: src/building_and_distribution.md:236
msgid ""
"For distributing your program to non-technical users, you will have to "
"consider including the Python shared library in your distribution as well as "
"setting up wrapper scripts to set the right environment variables (such as "
"`LD_LIBRARY_PATH` on UNIX, or `PATH` on Windows)."
msgstr ""

#: src/building_and_distribution.md:238
msgid ""
"Note that PyPy cannot be embedded in Rust (or any other software). Support "
"for this is tracked on the [PyPy issue tracker](https://foss.heptapod.net/"
"pypy/pypy/-/issues/3286)."
msgstr ""

#: src/building_and_distribution.md:240
msgid "Statically embedding the Python interpreter"
msgstr ""

#: src/building_and_distribution.md:242
msgid ""
"Embedding the Python interpreter statically means including the contents of "
"a Python static library directly inside your Rust binary. This means that to "
"distribute your program you only need to ship your binary file: it contains "
"the Python interpreter inside the binary!"
msgstr ""

#: src/building_and_distribution.md:244
msgid ""
"On Windows static linking is almost never done, so Python distributions "
"don't usually include a static library. The information below applies only "
"to UNIX."
msgstr ""

#: src/building_and_distribution.md:246
msgid "The Python static library is usually called `libpython.a`."
msgstr ""

#: src/building_and_distribution.md:248
msgid ""
"Static linking has a lot of complications, listed below. For these reasons "
"PyO3 does not yet have first-class support for this embedding mode. See "
"[issue 416 on PyO3's Github](https://github.com/PyO3/pyo3/issues/416) for "
"more information and to discuss any issues you encounter."
msgstr ""

#: src/building_and_distribution.md:250
msgid ""
"The [`auto-initialize`](features.md#auto-initialize) feature is deliberately "
"disabled when embedding the interpreter statically because this is often "
"unintentionally done by new users to PyO3 running test programs. Trying out "
"PyO3 is much easier using dynamic embedding."
msgstr ""

#: src/building_and_distribution.md:252
msgid "The known complications are:"
msgstr ""

#: src/building_and_distribution.md:253
msgid ""
"To import compiled extension modules (such as other Rust extension modules, "
"or those written in C), your binary must have the correct linker flags set "
"during compilation to export the original contents of `libpython.a` so that "
"extensions can use them (e.g. `-Wl,--export-dynamic`)."
msgstr ""

#: src/building_and_distribution.md:254
msgid ""
"The C compiler and flags which were used to create `libpython.a` must be "
"compatible with your Rust compiler and flags, else you will experience "
"compilation failures."
msgstr ""

#: src/building_and_distribution.md:256
msgid "Significantly different compiler versions may see errors like this:"
msgstr ""

#: src/building_and_distribution.md:262
msgid "Mismatching flags may lead to errors like this:"
msgstr ""

#: src/building_and_distribution.md:268
msgid ""
"If you encounter these or other complications when linking the interpreter "
"statically, discuss them on [issue 416 on PyO3's Github](https://github.com/"
"PyO3/pyo3/issues/416). It is hoped that eventually that discussion will "
"contain enough information and solutions that PyO3 can offer first-class "
"support for static embedding."
msgstr ""

#: src/building_and_distribution.md:270
msgid "Import your module when embedding the Python interpreter"
msgstr ""

#: src/building_and_distribution.md:272
msgid ""
"When you run your Rust binary with an embedded interpreter, any "
"`#[pymodule]` created modules won't be accessible to import unless added to "
"a table called `PyImport_Inittab` before the embedded interpreter is "
"initialized. This will cause Python statements in your embedded interpreter "
"such as `import your_new_module` to fail. You can call the macro "
"[`append_to_inittab`](https://pyo3.rs/main/doc/pyo3/macro.append_to_inittab."
"html) with your module before initializing the Python interpreter to add the "
"module function into that table. (The Python interpreter will be initialized "
"by calling `prepare_freethreaded_python`, `with_embedded_interpreter`, or "
"`Python::with_gil` with the [`auto-initialize`](features.md#auto-initialize) "
"feature enabled.)"
msgstr ""

#: src/building_and_distribution.md:274
msgid "Cross Compiling"
msgstr ""

#: src/building_and_distribution.md:276
msgid ""
"Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 "
"is relatively straightforward. To get started, you'll need a few pieces of "
"software:"
msgstr ""

#: src/building_and_distribution.md:278
msgid "A toolchain for your target."
msgstr ""

#: src/building_and_distribution.md:279
msgid ""
"The appropriate options in your Cargo `.config` for the platform you're "
"targeting and the toolchain you are using."
msgstr ""

#: src/building_and_distribution.md:280
msgid ""
"A Python interpreter that's already been compiled for your target (optional "
"when building \"abi3\" extension modules)."
msgstr ""

#: src/building_and_distribution.md:281
msgid ""
"A Python interpreter that is built for your host and available through the "
"`PATH` or setting the [`PYO3_PYTHON`](#python-version) variable (optional "
"when building \"abi3\" extension modules)."
msgstr ""

#: src/building_and_distribution.md:283
msgid ""
"After you've obtained the above, you can build a cross-compiled PyO3 module "
"by using Cargo's `--target` flag. PyO3's build script will detect that you "
"are attempting a cross-compile based on your host machine and the desired "
"target."
msgstr ""

#: src/building_and_distribution.md:285
msgid ""
"When cross-compiling, PyO3's build script cannot execute the target Python "
"interpreter to query the configuration, so there are a few additional "
"environment variables you may need to set:"
msgstr ""

#: src/building_and_distribution.md:287
msgid ""
"`PYO3_CROSS`: If present this variable forces PyO3 to configure as a cross-"
"compilation."
msgstr ""

#: src/building_and_distribution.md:288
msgid ""
"`PYO3_CROSS_LIB_DIR`: This variable can be set to the directory containing "
"the target's libpython DSO and the associated `_sysconfigdata*.py` file for "
"Unix-like targets, or the Python DLL import libraries for the Windows "
"target. This variable is only needed when the output binary must link to "
"libpython explicitly (e.g. when targeting Windows and Android or embedding a "
"Python interpreter), or when it is absolutely required to get the "
"interpreter configuration from `_sysconfigdata*.py`."
msgstr ""

#: src/building_and_distribution.md:289
msgid ""
"`PYO3_CROSS_PYTHON_VERSION`: Major and minor version (e.g. 3.9) of the "
"target Python installation. This variable is only needed if PyO3 cannot "
"determine the version to target from `abi3-py3*` features, or if "
"`PYO3_CROSS_LIB_DIR` is not set, or if there are multiple versions of Python "
"present in `PYO3_CROSS_LIB_DIR`."
msgstr ""

#: src/building_and_distribution.md:290
msgid ""
"`PYO3_CROSS_PYTHON_IMPLEMENTATION`: Python implementation name (\"CPython\" "
"or \"PyPy\") of the target Python installation. CPython is assumed by "
"default when this variable is not set, unless `PYO3_CROSS_LIB_DIR` is set "
"for a Unix-like target and PyO3 can get the interpreter configuration from "
"`_sysconfigdata*.py`."
msgstr ""

#: src/building_and_distribution.md:292
msgid ""
"An experimental `pyo3` crate feature `generate-import-lib` enables the user "
"to cross-compile extension modules for Windows targets without setting the "
"`PYO3_CROSS_LIB_DIR` environment variable or providing any Windows Python "
"library files. It uses an external [`python3-dll-a`](https://docs.rs/python3-"
"dll-a/latest/python3_dll_a/) crate to generate import libraries for the "
"Python DLL for MinGW-w64 and MSVC compile targets. `python3-dll-a` uses the "
"binutils `dlltool` program to generate DLL import libraries for MinGW-w64 "
"targets. It is possible to override the default `dlltool` command name for "
"the cross target by setting `PYO3_MINGW_DLLTOOL` environment variable. "
"_Note_: MSVC targets require LLVM binutils or MSVC build tools to be "
"available on the host system. More specifically, `python3-dll-a` requires "
"`llvm-dlltool` or `lib.exe` executable to be present in `PATH` when "
"targeting `*-pc-windows-msvc`. Zig compiler executable can be used in place "
"of `llvm-dlltool` when `ZIG_COMMAND` environment variable is set to the "
"installed Zig program name (`\"zig\"` or `\"python -m ziglang\"`)."
msgstr ""

#: src/building_and_distribution.md:304
msgid ""
"An example might look like the following (assuming your target's sysroot is "
"at `/home/pyo3/cross/sysroot` and that your target is `armv7`):"
msgstr ""

#: src/building_and_distribution.md:307 src/building_and_distribution.md:315
#: src/building_and_distribution.md:323
msgid "\"/home/pyo3/cross/sysroot/usr/lib\""
msgstr ""

#: src/building_and_distribution.md:312
msgid ""
"If there are multiple python versions at the cross lib directory and you "
"cannot set a more precise location to include both the `libpython` DSO and "
"`_sysconfigdata*.py` files, you can set the required version:"
msgstr ""

#: src/building_and_distribution.md:314
msgid "3.8"
msgstr ""

#: src/building_and_distribution.md:320
msgid "Or another example with the same sys root but building for Windows:"
msgstr ""

#: src/building_and_distribution.md:322
msgid "3.9"
msgstr ""

#: src/building_and_distribution.md:328
msgid ""
"Any of the `abi3-py3*` features can be enabled instead of setting "
"`PYO3_CROSS_PYTHON_VERSION` in the above examples."
msgstr ""

#: src/building_and_distribution.md:330
msgid ""
"`PYO3_CROSS_LIB_DIR` can often be omitted when cross compiling extension "
"modules for Unix and macOS targets, or when cross compiling extension "
"modules for Windows and the experimental `generate-import-lib` crate feature "
"is enabled."
msgstr ""

#: src/building_and_distribution.md:334
msgid "The following resources may also be useful for cross-compiling:"
msgstr ""

#: src/building_and_distribution.md:335
msgid ""
"[github.com/japaric/rust-cross](https://github.com/japaric/rust-cross) is a "
"primer on cross compiling Rust."
msgstr ""

#: src/building_and_distribution.md:336
msgid ""
"[github.com/rust-embedded/cross](https://github.com/rust-embedded/cross) "
"uses Docker to make Rust cross-compilation easier."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:1
msgid "Supporting multiple Python versions"
msgstr "支援多種 Python 版本"

#: src/building_and_distribution/multiple_python_versions.md:3
msgid ""
"PyO3 supports all actively-supported Python 3 and PyPy versions. As much as "
"possible, this is done internally to PyO3 so that your crate's code does not "
"need to adapt to the differences between each version. However, as Python "
"features grow and change between versions, PyO3 cannot a completely "
"identical API for every Python version. This may require you to add "
"conditional compilation to your crate or runtime checks for the Python "
"version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:5
msgid ""
"This section of the guide first introduces the `pyo3-build-config` crate, "
"which you can use as a `build-dependency` to add additional `#[cfg]` flags "
"which allow you to support multiple Python versions at compile-time."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:7
msgid ""
"Second, we'll show how to check the Python version at runtime. This can be "
"useful when building for multiple versions with the `abi3` feature, where "
"the Python API compiled against is not always the same as the one in use."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:9
msgid "Conditional compilation for different Python versions"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:11
msgid ""
"The `pyo3-build-config` exposes multiple [`#[cfg]` flags](https://doc.rust-"
"lang.org/rust-by-example/attribute/cfg.html) which can be used to "
"conditionally compile code for a given Python version. PyO3 itself depends "
"on this crate, so by using it you can be sure that you are configured "
"correctly for the Python version PyO3 is building against."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:13
msgid "This allows us to write code like the following"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:26
msgid ""
"The following sections first show how to add these `#[cfg]` flags to your "
"build process, and then cover some common patterns flags in a little more "
"detail."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:28
msgid ""
"To see a full reference of all the `#[cfg]` flags provided, see the [`pyo3-"
"build-cfg` docs](https://docs.rs/pyo3-build-config)."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:30
msgid "Using `pyo3-build-config`"
msgstr "使用 `pyo3-build-config`"

#: src/building_and_distribution/multiple_python_versions.md:32
msgid "You can use the `#[cfg]` flags in just two steps:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:34
msgid ""
"Add `pyo3-build-config` with the [`resolve-config`](../features.md#resolve-"
"config) feature enabled to your crate's build dependencies in `Cargo.toml`:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:36
msgid ""
"```toml\n"
"[build-dependencies]\n"
"pyo3-build-config = { git = \"https://github.com/pyo3/pyo3\", features = "
"[\"resolve-config\"] }\n"
"```"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:41
msgid ""
"Add a [`build.rs`](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html) file to your crate with the following contents:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:45
msgid "// If you have an existing build.rs file, just add this line to it.\n"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:50
msgid "After these steps you are ready to annotate your code!"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:52
msgid "Common usages of `pyo3-build-cfg` flags"
msgstr "`pyo3-build-cfg` 旗標的常見用法"

#: src/building_and_distribution/multiple_python_versions.md:54
msgid ""
"The `#[cfg]` flags added by `pyo3-build-cfg` can be combined with all of "
"Rust's logic in the `#[cfg]` attribute to create very precise conditional "
"code generation. The following are some common patterns implemented using "
"these flags:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:60
msgid ""
"This `#[cfg]` marks code that will only be present on Python 3.7 and "
"upwards. There are similar options `Py_3_8`, `Py_3_9`, `Py_3_10` and so on "
"for each minor version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:66
msgid ""
"This `#[cfg]` marks code that will only be present on Python versions before "
"(but not including) Python 3.7."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:72
msgid ""
"This `#[cfg]` marks code that is only available when building for the "
"unlimited Python API (i.e. PyO3's `abi3` feature is not enabled). This might "
"be useful if you want to ship your extension module as an `abi3` wheel and "
"also allow users to compile it from source to make use of optimizations only "
"possible with the unlimited API."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:78
msgid ""
"This `#[cfg]` marks code which is available when running Python 3.9 or "
"newer, or when using the unlimited API with an older Python version. "
"Patterns like this are commonly seen on Python APIs which were added to the "
"limited Python API in a specific minor version."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:84
msgid "This `#[cfg]` marks code which is running on PyPy."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:86
msgid "Checking the Python version at runtime"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:88
msgid ""
"When building with PyO3's `abi3` feature, your extension module will be "
"compiled against a specific [minimum version](../building_and_distribution."
"html#minimum-python-version-for-abi3) of Python, but may be running on newer "
"Python versions."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:90
msgid ""
"For example with PyO3's `abi3-py38` feature, your extension will be compiled "
"as if it were for Python 3.8. If you were using `pyo3-build-config`, "
"`#[cfg(Py_3_8)]` would be present. Your user could freely install and run "
"your abi3 extension on Python 3.9."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:92
msgid ""
"There's no way to detect your user doing that at compile time, so instead "
"you need to fall back to runtime checks."
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:94
msgid ""
"PyO3 provides the APIs [`Python::version()`](https://pyo3.rs/main/doc/pyo3/"
"struct.Python.html#method.version) and [`Python::version_info()`](https://"
"pyo3.rs/main/doc/pyo3/struct.Python.html#method.version_info) to query the "
"running Python version. This allows you to do the following, for example:"
msgstr ""

#: src/building_and_distribution/multiple_python_versions.md:101
msgid "// PyO3 supports Python 3.7 and up.\n"
msgstr ""

#: src/python_from_rust.md:1
msgid "Calling Python in Rust code"
msgstr "在 Rust 程式碼中呼叫 Python"

#: src/python_from_rust.md:3
msgid ""
"This chapter of the guide documents some ways to interact with Python code "
"from Rust:"
msgstr ""

#: src/python_from_rust.md:4
msgid "How to call Python functions"
msgstr "如何呼叫 Python 函式"

#: src/python_from_rust.md:5
msgid "How to execute existing Python code"
msgstr "如何執行既有的 Python 程式碼"

#: src/python_from_rust.md:7
msgid "Calling Python functions"
msgstr ""

#: src/python_from_rust.md:9
msgid ""
"Any Python-native object reference (such as `&PyAny`, `&PyList`, or "
"`&PyCell<MyClass>`) can be used to call Python functions."
msgstr ""

#: src/python_from_rust.md:11
msgid "PyO3 offers two APIs to make function calls:"
msgstr ""

#: src/python_from_rust.md:13
msgid ""
"[`call`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call) - "
"call any callable Python object."
msgstr ""

#: src/python_from_rust.md:14
msgid ""
"[`call_method`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method."
"call_method) - call a method on the Python object."
msgstr ""

#: src/python_from_rust.md:16
msgid ""
"Both of these APIs take `args` and `kwargs` arguments (for positional and "
"keyword arguments respectively). There are variants for less complex calls:"
msgstr ""

#: src/python_from_rust.md:18
msgid ""
"[`call1`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call1) "
"and [`call_method1`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny."
"html#method.call_method1) to call only with positional `args`."
msgstr ""

#: src/python_from_rust.md:19
msgid ""
"[`call0`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call0) "
"and [`call_method0`](https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny."
"html#method.call_method0) to call with no arguments."
msgstr ""

#: src/python_from_rust.md:21
msgid ""
"For convenience the [`Py<T>`](types.html#pyt-and-pyobject) smart pointer "
"also exposes these same six API methods, but needs a `Python` token as an "
"additional first argument to prove the GIL is held."
msgstr ""

#: src/python_from_rust.md:23
msgid ""
"The example below calls a Python function behind a `PyObject` (aka "
"`Py<PyAny>`) reference:"
msgstr ""

#: src/python_from_rust.md:30
msgid "\"arg1\""
msgstr ""

#: src/python_from_rust.md:31
msgid "\"arg2\""
msgstr ""

#: src/python_from_rust.md:32
msgid "\"arg3\""
msgstr ""

#: src/python_from_rust.md:37 src/python_from_rust.md:81
msgid ""
"\"def example(*args, **kwargs):\n"
"                if args != ():\n"
"                    print('called with args', args)\n"
"                if kwargs != {}:\n"
"                    print('called with kwargs', kwargs)\n"
"                if args == () and kwargs == {}:\n"
"                    print('called with no arguments')\""
msgstr ""

#: src/python_from_rust.md:44 src/python_from_rust.md:45
#: src/python_from_rust.md:88 src/python_from_rust.md:89
#: src/python_from_rust.md:292 src/python_from_rust.md:326
msgid "\"\""
msgstr ""

#: src/python_from_rust.md:46 src/python_from_rust.md:90
msgid "\"example\""
msgstr ""

#: src/python_from_rust.md:48
msgid "// call object without any arguments\n"
msgstr ""

#: src/python_from_rust.md:51
msgid "// call object with PyTuple\n"
msgstr ""

#: src/python_from_rust.md:55
msgid "// pass arguments as rust tuple\n"
msgstr ""

#: src/python_from_rust.md:63
msgid "Creating keyword arguments"
msgstr ""

#: src/python_from_rust.md:65
msgid ""
"For the `call` and `call_method` APIs, `kwargs` can be `None` or "
"`Some(&PyDict)`. You can use the [`IntoPyDict`](https://pyo3.rs/main/doc/"
"pyo3/types/trait.IntoPyDict.html) trait to convert other dict-like "
"containers, e.g. `HashMap` or `BTreeMap`, as well as tuples with up to 10 "
"elements and `Vec`s where each element is a two-element tuple."
msgstr ""

#: src/python_from_rust.md:73
msgid "\"key1\""
msgstr ""

#: src/python_from_rust.md:75
msgid "\"key2\""
msgstr ""

#: src/python_from_rust.md:93
msgid "// call object with PyDict\n"
msgstr ""

#: src/python_from_rust.md:97
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/python_from_rust.md:101
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/python_from_rust.md:111
msgid "Executing existing Python code"
msgstr ""

#: src/python_from_rust.md:113
msgid ""
"If you already have some existing Python code that you need to execute from "
"Rust, the following FAQs can help you select the right PyO3 functionality "
"for your situation:"
msgstr ""

#: src/python_from_rust.md:115
msgid "Want to access Python APIs? Then use `PyModule::import`."
msgstr ""

#: src/python_from_rust.md:117
msgid ""
"[`Pymodule::import`](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.import) can be used to get handle to a Python module from Rust. "
"You can use this to import and use any Python module available in your "
"environment."
msgstr ""

#: src/python_from_rust.md:126
msgid "\"builtins\""
msgstr ""

#: src/python_from_rust.md:127
msgid "\"sum\""
msgstr ""

#: src/python_from_rust.md:134
msgid "Want to run just an expression? Then use `eval`."
msgstr ""

#: src/python_from_rust.md:136
msgid ""
"[`Python::eval`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method."
"eval) is a method to execute a [Python expression](https://docs.python."
"org/3.7/reference/expressions.html) and return the evaluated value as a "
"`&PyAny` object."
msgstr ""

#: src/python_from_rust.md:145
msgid "\"[i * 10 for i in range(5)]\""
msgstr ""

#: src/python_from_rust.md:155
msgid "Want to run statements? Then use `run`."
msgstr ""

#: src/python_from_rust.md:157
msgid ""
"[`Python::run`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.run) "
"is a method to execute one or more [Python statements](https://docs.python."
"org/3.7/reference/simple_stmts.html). This method returns nothing (like any "
"Python statement), but you can get access to manipulated objects via the "
"`locals` dict."
msgstr ""

#: src/python_from_rust.md:162
msgid ""
"You can also use the [`py_run!`](https://pyo3.rs/main/doc/pyo3/macro.py_run."
"html) macro, which is a shorthand for [`Python::run`](https://pyo3.rs/main/"
"doc/pyo3/struct.Python.html#method.run). Since [`py_run!`](https://pyo3.rs/"
"main/doc/pyo3/macro.py_run.html) panics on exceptions, we recommend you use "
"this macro only for quickly testing your Python extensions."
msgstr ""

#: src/python_from_rust.md:184
msgid "\"User {}(id: {})\""
msgstr ""

#: src/python_from_rust.md:191 src/python_from_rust.md:194
msgid "\"Yu\""
msgstr ""

#: src/python_from_rust.md:195
msgid ""
"r#\"\n"
"assert repr(userdata) == \"User Yu(id: 34)\"\n"
"assert userdata.as_tuple() == userdata_as_tuple\n"
"    \"#"
msgstr ""

#: src/python_from_rust.md:203
msgid "You have a Python file or code snippet? Then use `PyModule::from_code`."
msgstr ""

#: src/python_from_rust.md:205
msgid ""
"[PyModule::from_code](https://pyo3.rs/main/doc/pyo3/types/struct.PyModule."
"html#method.from_code) can be used to generate a Python module which can "
"then be used just as if it was imported with `PyModule::import`."
msgstr ""

#: src/python_from_rust.md:209
msgid ""
"**Warning**: This will compile and execute code. **Never** pass untrusted "
"code to this function!"
msgstr ""

#: src/python_from_rust.md:217
msgid ""
"r#\"\n"
"def relu(x):\n"
"    \"\"\"see https://en.wikipedia.org/wiki/"
"Rectifier_(neural_networks)\"\"\"\n"
"    return max(0.0, x)\n"
"\n"
"def leaky_relu(x, slope=0.01):\n"
"    return x if x >= 0 else x * slope\n"
"    \"#"
msgstr ""

#: src/python_from_rust.md:224
msgid "\"activators.py\""
msgstr ""

#: src/python_from_rust.md:224
msgid "\"activators\""
msgstr ""

#: src/python_from_rust.md:226
msgid "\"relu\""
msgstr ""

#: src/python_from_rust.md:229
msgid "\"slope\""
msgstr ""

#: src/python_from_rust.md:231
msgid "\"leaky_relu\""
msgstr ""

#: src/python_from_rust.md:239
msgid "Include multiple Python files"
msgstr ""

#: src/python_from_rust.md:241
msgid ""
"You can include a file at compile time by using [`std::include_str`](https://"
"doc.rust-lang.org/std/macro.include_str.html) macro."
msgstr ""

#: src/python_from_rust.md:244
msgid ""
"Or you can load a file at runtime by using [`std::fs::read_to_string`]"
"(https://doc.rust-lang.org/std/fs/fn.read_to_string.html) function."
msgstr ""

#: src/python_from_rust.md:247
msgid ""
"Many Python files can be included and loaded as modules. If one file depends "
"on another you must preserve correct order while declaring `PyModule`."
msgstr ""

#: src/python_from_rust.md:250
msgid "Example directory structure:"
msgstr ""

#: src/python_from_rust.md:263
msgid "`python_app/app.py`:"
msgstr ""

#: src/python_from_rust.md:272
msgid "`python_app/utils/foo.py`:"
msgstr ""

#: src/python_from_rust.md:275
msgid "\"baz\""
msgstr ""

#: src/python_from_rust.md:278 src/python_from_rust.md:303
msgid "The example below shows:"
msgstr ""

#: src/python_from_rust.md:279
msgid ""
"how to include content of `app.py` and `utils/foo.py` into your rust binary"
msgstr ""

#: src/python_from_rust.md:280 src/python_from_rust.md:306
msgid ""
"how to call function `run()` (declared in `app.py`) that needs function "
"imported from `utils/foo.py`"
msgstr ""

#: src/python_from_rust.md:283 src/python_from_rust.md:313
msgid "`src/main.rs`:"
msgstr ""

#: src/python_from_rust.md:288 src/python_from_rust.md:289
msgid "\"CARGO_MANIFEST_DIR\""
msgstr ""

#: src/python_from_rust.md:288
msgid "\"/python_app/utils/foo.py\""
msgstr ""

#: src/python_from_rust.md:289
msgid "\"/python_app/app.py\""
msgstr ""

#: src/python_from_rust.md:291
msgid "\"utils.foo\""
msgstr ""

#: src/python_from_rust.md:293 src/python_from_rust.md:327
msgid "\"run\""
msgstr ""

#: src/python_from_rust.md:298 src/python_from_rust.md:332
msgid "\"py: {}\""
msgstr ""

#: src/python_from_rust.md:304
msgid ""
"how to load content of `app.py` at runtime so that it sees its dependencies "
"automatically"
msgstr ""

#: src/python_from_rust.md:309
msgid ""
"It is recommended to use absolute paths because then your binary can be run "
"from anywhere as long as your `app.py` is in the expected directory (in this "
"example that directory is `/usr/share/python_app`)."
msgstr ""

#: src/python_from_rust.md:321
msgid "\"/usr/share/python_app\""
msgstr ""

#: src/python_from_rust.md:322
msgid "\"app.py\""
msgstr ""

#: src/python_from_rust.md:324
msgid "\"sys\""
msgstr ""

#: src/python_from_rust.md:324
msgid "\"path\""
msgstr ""

#: src/python_from_rust.md:341
msgid "Need to use a context manager from Rust?"
msgstr ""

#: src/python_from_rust.md:343
msgid "Use context managers by directly invoking `__enter__` and `__exit__`."
msgstr ""

#: src/python_from_rust.md:351
msgid ""
"r#\"\n"
"class House(object):\n"
"    def __init__(self, address):\n"
"        self.address = address\n"
"    def __enter__(self):\n"
"        print(f\"Welcome to {self.address}!\")\n"
"    def __exit__(self, type, value, traceback):\n"
"        if type:\n"
"            print(f\"Sorry you had {type} trouble at {self.address}\")\n"
"        else:\n"
"            print(f\"Thank you for visiting {self.address}, come again soon!"
"\")\n"
"\n"
"        \"#"
msgstr ""

#: src/python_from_rust.md:363
msgid "\"house.py\""
msgstr ""

#: src/python_from_rust.md:363
msgid "\"house\""
msgstr ""

#: src/python_from_rust.md:365
msgid "\"House\""
msgstr ""

#: src/python_from_rust.md:366
msgid "\"123 Main Street\""
msgstr ""

#: src/python_from_rust.md:368
msgid "\"__enter__\""
msgstr ""

#: src/python_from_rust.md:370
msgid "\"undefined_variable + 1\""
msgstr ""

#: src/python_from_rust.md:372
msgid ""
"// If the eval threw an exception we'll pass it through to the context "
"manager.\n"
"        // Otherwise, __exit__  is called with empty arguments (Python "
"\"None\").\n"
msgstr ""

#: src/python_from_rust.md:377 src/python_from_rust.md:381
msgid "\"__exit__\""
msgstr ""

#: src/changelog.md:1
msgid "Changelog"
msgstr "變更日誌"

#: src/changelog.md:3
msgid ""
"All notable changes to this project will be documented in this file. For "
"help with updating to new PyO3 versions, please see the [migration guide]"
"(https://pyo3.rs/latest/migration.html)."
msgstr ""

#: src/changelog.md:6
msgid ""
"The format is based on [Keep a Changelog](https://keepachangelog.com/"
"en/1.0.0/) and this project adheres to [Semantic Versioning](https://semver."
"org/spec/v2.0.0.html)."
msgstr ""

#: src/changelog.md:9
msgid ""
"To see unreleased changes, please see the [CHANGELOG on the main branch "
"guide](https://pyo3.rs/main/changelog.html)."
msgstr ""

#: src/changelog.md:13
msgid ""
"[0.17.3](https://github.com/pyo3/pyo3/compare/v0.17.2...v0.17.3) - 2022-11-01"
msgstr ""

#: src/changelog.md:15 src/changelog.md:31 src/changelog.md:55
#: src/changelog.md:187 src/changelog.md:218 src/changelog.md:225
#: src/changelog.md:236 src/changelog.md:329 src/changelog.md:354
#: src/changelog.md:475 src/changelog.md:571 src/changelog.md:632
msgid "Packaging"
msgstr ""

#: src/changelog.md:17
msgid ""
"Support Python 3.11. (Previous versions of PyO3 0.17 have been tested "
"against Python 3.11 release candidates and are expected to be compatible, "
"this is the first version tested against Python 3.11.0.) [\\#2708](https://"
"github.com/PyO3/pyo3/pull/2708)"
msgstr ""

#: src/changelog.md:19 src/changelog.md:35 src/changelog.md:59
#: src/changelog.md:151 src/changelog.md:167 src/changelog.md:191
#: src/changelog.md:247 src/changelog.md:335 src/changelog.md:362
#: src/changelog.md:409 src/changelog.md:426 src/changelog.md:442
#: src/changelog.md:465 src/changelog.md:482 src/changelog.md:575
#: src/changelog.md:600 src/changelog.md:640 src/changelog.md:700
#: src/changelog.md:720 src/changelog.md:787 src/changelog.md:797
#: src/changelog.md:843 src/changelog.md:885 src/changelog.md:902
#: src/changelog.md:950 src/changelog.md:957 src/changelog.md:974
#: src/changelog.md:990 src/changelog.md:1002 src/changelog.md:1028
#: src/changelog.md:1071 src/changelog.md:1133 src/changelog.md:1212
#: src/changelog.md:1241 src/changelog.md:1254 src/changelog.md:1293
#: src/changelog.md:1310
msgid "Added"
msgstr ""

#: src/changelog.md:21
msgid ""
"Implemented `ExactSizeIterator` for `PyListIterator`, `PyDictIterator`, "
"`PySetIterator` and `PyFrozenSetIterator`. [\\#2676](https://github.com/PyO3/"
"pyo3/pull/2676)"
msgstr ""

#: src/changelog.md:23 src/changelog.md:39 src/changelog.md:47
#: src/changelog.md:111 src/changelog.md:160 src/changelog.md:179
#: src/changelog.md:209 src/changelog.md:229 src/changelog.md:311
#: src/changelog.md:344 src/changelog.md:396 src/changelog.md:414
#: src/changelog.md:430 src/changelog.md:453 src/changelog.md:469
#: src/changelog.md:549 src/changelog.md:588 src/changelog.md:622
#: src/changelog.md:676 src/changelog.md:688 src/changelog.md:694
#: src/changelog.md:705 src/changelog.md:713 src/changelog.md:771
#: src/changelog.md:828 src/changelog.md:837 src/changelog.md:872
#: src/changelog.md:889 src/changelog.md:895 src/changelog.md:937
#: src/changelog.md:967 src/changelog.md:978 src/changelog.md:994
#: src/changelog.md:1022 src/changelog.md:1042 src/changelog.md:1109
#: src/changelog.md:1117 src/changelog.md:1123 src/changelog.md:1164
#: src/changelog.md:1178 src/changelog.md:1206 src/changelog.md:1229
#: src/changelog.md:1235 src/changelog.md:1245 src/changelog.md:1260
#: src/changelog.md:1271 src/changelog.md:1287
msgid "Fixed"
msgstr ""

#: src/changelog.md:25
msgid ""
"Fix regression of `impl FromPyObject for [T; N]` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since version 0.17.0. This "
"the same fix that was applied `impl FromPyObject for Vec<T>` in version "
"0.17.1 extended to fixed-size arrays. [\\#2675](https://github.com/PyO3/pyo3/"
"pull/2675)"
msgstr ""

#: src/changelog.md:26
msgid ""
"Fix UB in `FunctionDescription::extract_arguments_fastcall` due to creating "
"slices from a null pointer. [\\#2687](https://github.com/PyO3/pyo3/pull/2687)"
msgstr ""

#: src/changelog.md:29
msgid ""
"[0.17.2](https://github.com/pyo3/pyo3/compare/v0.17.1...v0.17.2) - 2022-10-04"
msgstr ""

#: src/changelog.md:33
msgid ""
"Added optional `chrono` feature to convert `chrono` types into types in the "
"`datetime` module. [\\#2612](https://github.com/PyO3/pyo3/pull/2612)"
msgstr ""

#: src/changelog.md:37
msgid ""
"Add support for `num-bigint` feature on `PyPy`. [\\#2626](https://github.com/"
"PyO3/pyo3/pull/2626)"
msgstr ""

#: src/changelog.md:41
msgid ""
"Correctly implement `__richcmp__` for enums, fixing `__ne__` returning "
"always returning `True`. [\\#2622](https://github.com/PyO3/pyo3/pull/2622)"
msgstr ""

#: src/changelog.md:42
msgid ""
"Fix compile error since 0.17.0 with `Option<&SomePyClass>` argument with a "
"default. [\\#2630](https://github.com/PyO3/pyo3/pull/2630)"
msgstr ""

#: src/changelog.md:43
msgid ""
"Fix regression of `impl FromPyObject for Vec<T>` no longer accepting types "
"passing `PySequence_Check`, e.g. NumPy arrays, since 0.17.0. [\\#2631]"
"(https://github.com/PyO3/pyo3/pull/2631)"
msgstr ""

#: src/changelog.md:45
msgid ""
"[0.17.1](https://github.com/pyo3/pyo3/compare/v0.17.0...v0.17.1) - 2022-08-28"
msgstr ""

#: src/changelog.md:49
msgid ""
"Fix visibility of `PyDictItems`, `PyDictKeys`, and `PyDictValues` types "
"added in PyO3 0.17.0."
msgstr ""

#: src/changelog.md:50
msgid ""
"Fix compile failure when using `#[pyo3(from_py_with = \"...\")]` attribute "
"on an argument of type `Option<T>`. [\\#2592](https://github.com/PyO3/pyo3/"
"pull/2592)"
msgstr ""

#: src/changelog.md:51
msgid ""
"Fix clippy `redundant-closure` lint on `**kwargs` arguments for "
"`#[pyfunction]` and `#[pymethods]`. [\\#2595](https://github.com/PyO3/pyo3/"
"pull/2595)"
msgstr ""

#: src/changelog.md:53
msgid ""
"[0.17.0](https://github.com/pyo3/pyo3/compare/v0.16.6...v0.17.0) - 2022-08-23"
msgstr ""

#: src/changelog.md:57
msgid ""
"Update inventory dependency to `0.3` (the `multiple-pymethods` feature now "
"requires Rust 1.62 for correctness). [\\#2492](https://github.com/PyO3/pyo3/"
"pull/2492)"
msgstr ""

#: src/changelog.md:61
msgid "Add `timezone_utc`. [\\#1588](https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:62
msgid ""
"Implement `ToPyObject` for `[T; N]`. [\\#2313](https://github.com/PyO3/pyo3/"
"pull/2313)"
msgstr ""

#: src/changelog.md:63
msgid ""
"Add `PyDictKeys`, `PyDictValues` and `PyDictItems` Rust types. [\\#2358]"
"(https://github.com/PyO3/pyo3/pull/2358)"
msgstr ""

#: src/changelog.md:64
msgid ""
"Add `append_to_inittab`. [\\#2377](https://github.com/PyO3/pyo3/pull/2377)"
msgstr ""

#: src/changelog.md:65
msgid ""
"Add FFI definition `PyFrame_GetCode`. [\\#2406](https://github.com/PyO3/pyo3/"
"pull/2406)"
msgstr ""

#: src/changelog.md:66
msgid ""
"Add `PyCode` and `PyFrame` high level objects. [\\#2408](https://github.com/"
"PyO3/pyo3/pull/2408)"
msgstr ""

#: src/changelog.md:67
msgid ""
"Add FFI definitions `Py_fstring_input`, `sendfunc`, and `_PyErr_StackItem`. "
"[\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:68
msgid ""
"Add `PyDateTime::new_with_fold`, `PyTime::new_with_fold`, `PyTime::"
"get_fold`, and `PyDateTime::get_fold` for PyPy. [\\#2428](https://github.com/"
"PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:69
msgid ""
"Accept `#[pyo3(name)]` on enum variants. [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:70
msgid ""
"Add `CompareOp::matches` to implement `__richcmp__` as the result of a Rust "
"`std::cmp::Ordering` comparison. [\\#2460](https://github.com/PyO3/pyo3/"
"pull/2460)"
msgstr ""

#: src/changelog.md:71
msgid "Add `PySuper` type. [\\#2486](https://github.com/PyO3/pyo3/pull/2486)"
msgstr ""

#: src/changelog.md:72
msgid ""
"Support PyPy on Windows with the `generate-import-lib` feature. [\\#2506]"
"(https://github.com/PyO3/pyo3/pull/2506)"
msgstr ""

#: src/changelog.md:73
msgid ""
"Add FFI definitions `Py_EnterRecursiveCall` and `Py_LeaveRecursiveCall`. "
"[\\#2511](https://github.com/PyO3/pyo3/pull/2511)"
msgstr ""

#: src/changelog.md:74
msgid ""
"Add `PyDict::get_item_with_error`. [\\#2536](https://github.com/PyO3/pyo3/"
"pull/2536)"
msgstr ""

#: src/changelog.md:75
msgid ""
"Add `#[pyclass(sequence)]` option. [\\#2567](https://github.com/PyO3/pyo3/"
"pull/2567)"
msgstr ""

#: src/changelog.md:77 src/changelog.md:156 src/changelog.md:173
#: src/changelog.md:202 src/changelog.md:266 src/changelog.md:340
#: src/changelog.md:378 src/changelog.md:420 src/changelog.md:448
#: src/changelog.md:502 src/changelog.md:583 src/changelog.md:655
#: src/changelog.md:736 src/changelog.md:791 src/changelog.md:806
#: src/changelog.md:855 src/changelog.md:916 src/changelog.md:1010
#: src/changelog.md:1036 src/changelog.md:1079 src/changelog.md:1142
#: src/changelog.md:1174 src/changelog.md:1188 src/changelog.md:1200
#: src/changelog.md:1217 src/changelog.md:1267 src/changelog.md:1281
#: src/changelog.md:1303
msgid "Changed"
msgstr ""

#: src/changelog.md:79
msgid ""
"Change datetime constructors taking a `tzinfo` to take `Option<&PyTzInfo>` "
"instead of `Option<&PyObject>`: `PyDateTime::new`, `PyDateTime::"
"new_with_fold`, `PyTime::new`, and `PyTime::new_with_fold`. [\\#1588]"
"(https://github.com/PyO3/pyo3/pull/1588)"
msgstr ""

#: src/changelog.md:80
msgid ""
"Move `PyTypeObject::type_object` method to the `PyTypeInfo` trait, and "
"deprecate the `PyTypeObject` trait. [\\#2287](https://github.com/PyO3/pyo3/"
"pull/2287)"
msgstr ""

#: src/changelog.md:81
msgid ""
"Methods of `Py` and `PyAny` now accept `impl IntoPy<Py<PyString>>` rather "
"than just `&str` to allow use of the `intern!` macro. [\\#2312](https://"
"github.com/PyO3/pyo3/pull/2312)"
msgstr ""

#: src/changelog.md:82
msgid ""
"Change the deprecated `pyproto` feature to be opt-in instead of opt-out. "
"[\\#2322](https://github.com/PyO3/pyo3/pull/2322)"
msgstr ""

#: src/changelog.md:83
msgid ""
"Emit better error messages when `#[pyfunction]` return types do not "
"implement `IntoPy`. [\\#2326](https://github.com/PyO3/pyo3/pull/2326)"
msgstr ""

#: src/changelog.md:84
msgid ""
"Require `T: IntoPy` for `impl<T, const N: usize> IntoPy<PyObject> for [T; "
"N]` instead of `T: ToPyObject`. [\\#2326](https://github.com/PyO3/pyo3/"
"pull/2326)"
msgstr ""

#: src/changelog.md:85
msgid ""
"Deprecate the `ToBorrowedObject` trait. [\\#2333](https://github.com/PyO3/"
"pyo3/pull/2333)"
msgstr ""

#: src/changelog.md:86 src/changelog.md:87
msgid ""
"Iterators over `PySet` and `PyDict` will now panic if the underlying "
"collection is mutated during the iteration. [\\#2380](https://github.com/"
"PyO3/pyo3/pull/2380)"
msgstr ""

#: src/changelog.md:88
msgid ""
"Allow `#[classattr]` methods to be fallible. [\\#2385](https://github.com/"
"PyO3/pyo3/pull/2385)"
msgstr ""

#: src/changelog.md:89
msgid ""
"Prevent multiple `#[pymethods]` with the same name for a single "
"`#[pyclass]`. [\\#2399](https://github.com/PyO3/pyo3/pull/2399)"
msgstr ""

#: src/changelog.md:90
msgid ""
"Fixup `lib_name` when using `PYO3_CONFIG_FILE`. [\\#2404](https://github.com/"
"PyO3/pyo3/pull/2404)"
msgstr ""

#: src/changelog.md:91
msgid ""
"Add a message to the `ValueError` raised by the `#[derive(FromPyObject)]` "
"implementation for a tuple struct. [\\#2414](https://github.com/PyO3/pyo3/"
"pull/2414)"
msgstr ""

#: src/changelog.md:92
msgid ""
"Allow `#[classattr]` methods to take `Python` argument. [\\#2456](https://"
"github.com/PyO3/pyo3/pull/2456)"
msgstr ""

#: src/changelog.md:93
msgid ""
"Rework `PyCapsule` type to resolve soundness issues: [\\#2485](https://"
"github.com/PyO3/pyo3/pull/2485)"
msgstr ""

#: src/changelog.md:94
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take `name: "
"Option<CString>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:95
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` must now be `Send`."
msgstr ""

#: src/changelog.md:96
msgid ""
"`PyCapsule::get_context` deprecated in favour of `PyCapsule::context` which "
"doesn't take a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:97
msgid "`PyCapsule::set_context` no longer takes a `py: Python<'_>` argument."
msgstr ""

#: src/changelog.md:98
msgid ""
"`PyCapsule::name` now returns `PyResult<Option<&CStr>>` instead of `&CStr`."
msgstr ""

#: src/changelog.md:99
msgid ""
"`FromPyObject::extract` for `Vec<T>` no longer accepts Python `str` inputs. "
"[\\#2500](https://github.com/PyO3/pyo3/pull/2500)"
msgstr ""

#: src/changelog.md:100
msgid ""
"Ensure each `#[pymodule]` is only initialized once. [\\#2523](https://github."
"com/PyO3/pyo3/pull/2523)"
msgstr ""

#: src/changelog.md:101
msgid ""
"`pyo3_build_config::add_extension_module_link_args` now also emits linker "
"arguments for `wasm32-unknown-emscripten`. [\\#2538](https://github.com/PyO3/"
"pyo3/pull/2538)"
msgstr ""

#: src/changelog.md:102
msgid ""
"Type checks for `PySequence` and `PyMapping` now require inputs to inherit "
"from (or register with) `collections.abc.Sequence` and `collections.abc."
"Mapping` respectively. [\\#2477](https://github.com/PyO3/pyo3/pull/2477)"
msgstr ""

#: src/changelog.md:103
msgid ""
"Disable `PyFunction` on when building for abi3 or PyPy. [\\#2542](https://"
"github.com/PyO3/pyo3/pull/2542)"
msgstr ""

#: src/changelog.md:104
msgid ""
"Deprecate `Python::acquire_gil`. [\\#2549](https://github.com/PyO3/pyo3/"
"pull/2549)"
msgstr ""

#: src/changelog.md:106 src/changelog.md:305 src/changelog.md:531
#: src/changelog.md:616 src/changelog.md:671 src/changelog.md:761
#: src/changelog.md:824 src/changelog.md:864 src/changelog.md:927
#: src/changelog.md:963 src/changelog.md:1017 src/changelog.md:1102
#: src/changelog.md:1156 src/changelog.md:1182 src/changelog.md:1194
#: src/changelog.md:1275
msgid "Removed"
msgstr ""

#: src/changelog.md:108
msgid ""
"Remove all functionality deprecated in PyO3 0.15. [\\#2283](https://github."
"com/PyO3/pyo3/pull/2283)"
msgstr ""

#: src/changelog.md:109
msgid ""
"Make the `Dict`, `WeakRef` and `BaseNativeType` members of the `PyClass` "
"private implementation details. [\\#2572](https://github.com/PyO3/pyo3/"
"pull/2572)"
msgstr ""

#: src/changelog.md:113
msgid ""
"Enable incorrectly disabled FFI definition `PyThreadState_DeleteCurrent`. "
"[\\#2357](https://github.com/PyO3/pyo3/pull/2357)"
msgstr ""

#: src/changelog.md:114
msgid ""
"Fix `wrap_pymodule` interactions with name resolution rules: it no longer "
"\"sees through\" glob imports of `use submodule::*` when `submodule::"
"submodule` is a `#[pymodule]`. [\\#2363](https://github.com/PyO3/pyo3/"
"pull/2363)"
msgstr ""

#: src/changelog.md:115
msgid ""
"Correct FFI definition `PyEval_EvalCodeEx` to take `*const *mut PyObject` "
"array arguments instead of `*mut *mut PyObject`. [\\#2368](https://github."
"com/PyO3/pyo3/pull/2368)"
msgstr ""

#: src/changelog.md:116
msgid ""
"Fix \"raw-ident\" structs (e.g. `#[pyclass] struct r#RawName`) incorrectly "
"having `r#` at the start of the class name created in Python. [\\#2395]"
"(https://github.com/PyO3/pyo3/pull/2395)"
msgstr ""

#: src/changelog.md:117
msgid ""
"Correct FFI definition `Py_tracefunc` to be `unsafe extern \"C\" fn` (was "
"previously safe). [\\#2407](https://github.com/PyO3/pyo3/pull/2407)"
msgstr ""

#: src/changelog.md:118
msgid ""
"Fix compile failure with `#[pyo3(from_py_with = \"...\")]` annotations on a "
"field in a `#[derive(FromPyObject)]` struct. [\\#2414](https://github.com/"
"PyO3/pyo3/pull/2414)"
msgstr ""

#: src/changelog.md:119
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"lacking leading underscores in their names. [\\#2421](https://github.com/"
"PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:120
msgid ""
"Remove FFI definition `PyArena` on Python 3.10 and up. [\\#2421](https://"
"github.com/PyO3/pyo3/pull/2421)"
msgstr ""

#: src/changelog.md:121
msgid ""
"Fix FFI definition `PyCompilerFlags` missing member `cf_feature_version` on "
"Python 3.8 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:122
msgid ""
"Fix FFI definition `PyAsyncMethods` missing member `am_send` on Python 3.10 "
"and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:123
msgid ""
"Fix FFI definition `PyGenObject` having multiple incorrect members on "
"various Python versions. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:124
msgid ""
"Fix FFI definition `PySyntaxErrorObject` missing members `end_lineno` and "
"`end_offset` on Python 3.10 and up. [\\#2423](https://github.com/PyO3/pyo3/"
"pull/2423)"
msgstr ""

#: src/changelog.md:125
msgid ""
"Fix FFI definition `PyHeapTypeObject` missing member `ht_module` on Python "
"3.9 and up. [\\#2423](https://github.com/PyO3/pyo3/pull/2423)"
msgstr ""

#: src/changelog.md:126
msgid ""
"Fix FFI definition `PyFrameObject` having multiple incorrect members on "
"various Python versions. [\\#2424](https://github.com/PyO3/pyo3/pull/2424) "
"[\\#2434](https://github.com/PyO3/pyo3/pull/2434)"
msgstr ""

#: src/changelog.md:127
msgid ""
"Fix FFI definition `PyTypeObject` missing deprecated field `tp_print` on "
"Python 3.8. [\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:128
msgid ""
"Fix FFI definitions `PyDateTime_CAPI`. `PyDateTime_Date`, `PyASCIIObject`, "
"`PyBaseExceptionObject`, `PyListObject`, and `PyTypeObject` on PyPy. "
"[\\#2428](https://github.com/PyO3/pyo3/pull/2428)"
msgstr ""

#: src/changelog.md:129
msgid ""
"Fix FFI definition `_inittab` field `initfunc` typo'd as `initfun`. [\\#2431]"
"(https://github.com/PyO3/pyo3/pull/2431)"
msgstr ""

#: src/changelog.md:130
msgid ""
"Fix FFI definitions `_PyDateTime_BaseTime` and `_PyDateTime_BaseDateTime` "
"incorrectly having `fold` member. [\\#2432](https://github.com/PyO3/pyo3/"
"pull/2432)"
msgstr ""

#: src/changelog.md:131
msgid ""
"Fix FFI definitions `PyTypeObject`. `PyHeapTypeObject`, and "
"`PyCFunctionObject` having incorrect members on PyPy 3.9. [\\#2433](https://"
"github.com/PyO3/pyo3/pull/2433)"
msgstr ""

#: src/changelog.md:132
msgid ""
"Fix FFI definition `PyGetSetDef` to have `*const c_char` for `doc` member "
"(not `*mut c_char`). [\\#2439](https://github.com/PyO3/pyo3/pull/2439)"
msgstr ""

#: src/changelog.md:133
msgid ""
"Fix `#[pyo3(from_py_with = \"...\")]` being ignored for 1-element tuple "
"structs and transparent structs. [\\#2440](https://github.com/PyO3/pyo3/"
"pull/2440)"
msgstr ""

#: src/changelog.md:134
msgid ""
"Use `memoffset` to avoid UB when computing `PyCell` layout. [\\#2450]"
"(https://github.com/PyO3/pyo3/pull/2450)"
msgstr ""

#: src/changelog.md:135
msgid ""
"Fix incorrect enum names being returned by the generated `repr` for enums "
"renamed by `#[pyclass(name = \"...\")]` [\\#2457](https://github.com/PyO3/"
"pyo3/pull/2457)"
msgstr ""

#: src/changelog.md:136
msgid ""
"Fix `PyObject_CallNoArgs` incorrectly being available when building for abi3 "
"on Python 3.9. [\\#2476](https://github.com/PyO3/pyo3/pull/2476)"
msgstr ""

#: src/changelog.md:137
msgid ""
"Fix several clippy warnings generated by `#[pyfunction]` arguments. [\\#2503]"
"(https://github.com/PyO3/pyo3/pull/2503)"
msgstr ""

#: src/changelog.md:139
msgid ""
"[0.16.6](https://github.com/pyo3/pyo3/compare/v0.16.5...v0.16.6) - 2022-08-23"
msgstr ""

#: src/changelog.md:141
msgid "\\### Changed"
msgstr ""

#: src/changelog.md:143
msgid ""
"Fix soundness issues with `PyCapsule` type with select workarounds. Users "
"are encourage to upgrade to PyO3 0.17 at their earliest convenience which "
"contains API breakages which fix the issues in a long-term fashion. [\\#2522]"
"(https://github.com/PyO3/pyo3/pull/2522)"
msgstr ""

#: src/changelog.md:144
msgid ""
"`PyCapsule::new` and `PyCapsule::new_with_destructor` now take ownership of "
"a copy of the `name` to resolve a possible use-after-free."
msgstr ""

#: src/changelog.md:145
msgid ""
"`PyCapsule::name` now returns an empty `CStr` instead of dereferencing a "
"null pointer if the capsule has no name."
msgstr ""

#: src/changelog.md:146
msgid ""
"The destructor `F` in `PyCapsule::new_with_destructor` will never be called "
"if the capsule is deleted from a thread other than the one which the capsule "
"was created in (a warning will be emitted)."
msgstr ""

#: src/changelog.md:147
msgid ""
"Panics during drop of panic payload caught by PyO3 will now abort. [\\#2544]"
"(https://github.com/PyO3/pyo3/pull/2544)"
msgstr ""

#: src/changelog.md:149
msgid ""
"[0.16.5](https://github.com/pyo3/pyo3/compare/v0.16.4...v0.16.5) - 2022-05-15"
msgstr ""

#: src/changelog.md:153
msgid ""
"Add an experimental `generate-import-lib` feature to support auto-generating "
"non-abi3 python import libraries for Windows targets. [\\#2364](https://"
"github.com/PyO3/pyo3/pull/2364)"
msgstr ""

#: src/changelog.md:154
msgid ""
"Add FFI definition `Py_ExitStatusException`. [\\#2374](https://github.com/"
"PyO3/pyo3/pull/2374)"
msgstr ""

#: src/changelog.md:158
msgid ""
"Deprecate experimental `generate-abi3-import-lib` feature in favor of the "
"new `generate-import-lib` feature. [\\#2364](https://github.com/PyO3/pyo3/"
"pull/2364)"
msgstr ""

#: src/changelog.md:162
msgid ""
"Added missing `warn_default_encoding` field to `PyConfig` on 3.10+. The "
"previously missing field could result in incorrect behavior or crashes. "
"[\\#2370](https://github.com/PyO3/pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:163
msgid ""
"Fixed order of `pathconfig_warnings` and `program_name` fields of `PyConfig` "
"on 3.10+. Previously, the order of the fields was swapped and this could "
"lead to incorrect behavior or crashes. [\\#2370](https://github.com/PyO3/"
"pyo3/pull/2370)"
msgstr ""

#: src/changelog.md:165
msgid ""
"[0.16.4](https://github.com/pyo3/pyo3/compare/v0.16.3...v0.16.4) - 2022-04-14"
msgstr ""

#: src/changelog.md:169
msgid ""
"Add `PyTzInfoAccess` trait for safe access to time zone information. "
"[\\#2263](https://github.com/PyO3/pyo3/pull/2263)"
msgstr ""

#: src/changelog.md:170
msgid ""
"Add an experimental `generate-abi3-import-lib` feature to auto-generate "
"`python3.dll` import libraries for Windows. [\\#2282](https://github.com/"
"PyO3/pyo3/pull/2282)"
msgstr ""

#: src/changelog.md:171
msgid ""
"Add FFI definitions for `PyDateTime_BaseTime` and `PyDateTime_BaseDateTime`. "
"[\\#2294](https://github.com/PyO3/pyo3/pull/2294)"
msgstr ""

#: src/changelog.md:175
msgid ""
"Improved performance of failing calls to `FromPyObject::extract` which is "
"common when functions accept multiple distinct types. [\\#2279](https://"
"github.com/PyO3/pyo3/pull/2279)"
msgstr ""

#: src/changelog.md:176
msgid ""
"Default to \"m\" ABI tag when choosing `libpython` link name for CPython 3.7 "
"on Unix. [\\#2288](https://github.com/PyO3/pyo3/pull/2288)"
msgstr ""

#: src/changelog.md:177
msgid ""
"Allow to compile \"abi3\" extensions without a working build host Python "
"interpreter. [\\#2293](https://github.com/PyO3/pyo3/pull/2293)"
msgstr ""

#: src/changelog.md:181
msgid ""
"Crates depending on PyO3 can collect code coverage via LLVM instrumentation "
"using stable Rust. [\\#2286](https://github.com/PyO3/pyo3/pull/2286)"
msgstr ""

#: src/changelog.md:182
msgid ""
"Fix segfault when calling FFI methods `PyDateTime_DATE_GET_TZINFO` or "
"`PyDateTime_TIME_GET_TZINFO` on `datetime` or `time` without a tzinfo. "
"[\\#2289](https://github.com/PyO3/pyo3/pull/2289)"
msgstr ""

#: src/changelog.md:183
msgid ""
"Fix directory names starting with the letter `n` breaking serialization of "
"the interpreter configuration on Windows since PyO3 0.16.3. [\\#2299]"
"(https://github.com/PyO3/pyo3/pull/2299)"
msgstr ""

#: src/changelog.md:185
msgid ""
"[0.16.3](https://github.com/pyo3/pyo3/compare/v0.16.2...v0.16.3) - 2022-04-05"
msgstr ""

#: src/changelog.md:189
msgid ""
"Extend `parking_lot` dependency supported versions to include 0.12. [\\#2239]"
"(https://github.com/PyO3/pyo3/pull/2239)"
msgstr ""

#: src/changelog.md:193
msgid ""
"Add methods to `pyo3_build_config::InterpreterConfig` to run Python scripts "
"using the configured executable. [\\#2092](https://github.com/PyO3/pyo3/"
"pull/2092)"
msgstr ""

#: src/changelog.md:194
msgid ""
"Add `as_bytes` method to `Py<PyBytes>`. [\\#2235](https://github.com/PyO3/"
"pyo3/pull/2235)"
msgstr ""

#: src/changelog.md:195
msgid ""
"Add FFI definitions for `PyType_FromModuleAndSpec`, `PyType_GetModule`, "
"`PyType_GetModuleState` and `PyModule_AddType`. [\\#2250](https://github.com/"
"PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:196
msgid ""
"Add `pyo3_build_config::cross_compiling_from_to` as a helper to detect when "
"PyO3 is cross-compiling. [\\#2253](https://github.com/PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:197
msgid ""
"Add `#[pyclass(mapping)]` option to leave sequence slots empty in container "
"implementations. [\\#2265](https://github.com/PyO3/pyo3/pull/2265)"
msgstr ""

#: src/changelog.md:198
msgid ""
"Add `PyString::intern` to enable usage of the Python's built-in string "
"interning. [\\#2268](https://github.com/PyO3/pyo3/pull/2268)"
msgstr ""

#: src/changelog.md:199
msgid ""
"Add `intern!` macro which can be used to amortize the cost of creating "
"Python strings by storing them inside a `GILOnceCell`. [\\#2269](https://"
"github.com/PyO3/pyo3/pull/2269)"
msgstr ""

#: src/changelog.md:200
msgid ""
"Add `PYO3_CROSS_PYTHON_IMPLEMENTATION` environment variable for selecting "
"the default cross Python implementation. [\\#2272](https://github.com/PyO3/"
"pyo3/pull/2272)"
msgstr ""

#: src/changelog.md:204
msgid ""
"Allow `#[pyo3(crate = \"...\", text_signature = \"...\")]` options to be "
"used directly in `#[pyclass(crate = \"...\", text_signature = \"...\")]`. "
"[\\#2234](https://github.com/PyO3/pyo3/pull/2234)"
msgstr ""

#: src/changelog.md:205
msgid ""
"Make `PYO3_CROSS_LIB_DIR` environment variable optional when cross "
"compiling. [\\#2241](https://github.com/PyO3/pyo3/pull/2241)"
msgstr ""

#: src/changelog.md:206
msgid ""
"Mark `METH_FASTCALL` calling convention as limited API on Python 3.10. "
"[\\#2250](https://github.com/PyO3/pyo3/pull/2250)"
msgstr ""

#: src/changelog.md:207
msgid ""
"Deprecate `pyo3_build_config::cross_compiling` in favour of "
"`pyo3_build_config::cross_compiling_from_to`. [\\#2253](https://github.com/"
"PyO3/pyo3/pull/2253)"
msgstr ""

#: src/changelog.md:211
msgid ""
"Fix `abi3-py310` feature: use Python 3.10 ABI when available instead of "
"silently falling back to the 3.9 ABI. [\\#2242](https://github.com/PyO3/pyo3/"
"pull/2242)"
msgstr ""

#: src/changelog.md:212
msgid ""
"Use shared linking mode when cross compiling against a [Framework bundle]"
"(https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/"
"BPFrameworks/Concepts/FrameworkAnatomy.html) for macOS. [\\#2233](https://"
"github.com/PyO3/pyo3/pull/2233)"
msgstr ""

#: src/changelog.md:213
msgid ""
"Fix panic during compilation when `PYO3_CROSS_LIB_DIR` is set for some host/"
"target combinations. [\\#2232](https://github.com/PyO3/pyo3/pull/2232)"
msgstr ""

#: src/changelog.md:214
msgid ""
"Correct dependency version for `syn` to require minimal patch version "
"1.0.56. [\\#2240](https://github.com/PyO3/pyo3/pull/2240)"
msgstr ""

#: src/changelog.md:216
msgid ""
"[0.16.2](https://github.com/pyo3/pyo3/compare/v0.16.1...v0.16.2) - 2022-03-15"
msgstr ""

#: src/changelog.md:220
msgid ""
"Warn when modules are imported on PyPy 3.7 versions older than PyPy 7.3.8, "
"as they are known to have binary compatibility issues. [\\#2217](https://"
"github.com/PyO3/pyo3/pull/2217)"
msgstr ""

#: src/changelog.md:221
msgid ""
"Ensure build script of `pyo3-ffi` runs before that of `pyo3` to fix cross "
"compilation. [\\#2224](https://github.com/PyO3/pyo3/pull/2224)"
msgstr ""

#: src/changelog.md:223
msgid ""
"[0.16.1](https://github.com/pyo3/pyo3/compare/v0.16.0...v0.16.1) - 2022-03-05"
msgstr ""

#: src/changelog.md:227
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.12. "
"[\\#2197](https://github.com/PyO3/pyo3/pull/2197)"
msgstr ""

#: src/changelog.md:231
msgid ""
"Fix incorrect platform detection for Windows in `pyo3-build-config`. "
"[\\#2198](https://github.com/PyO3/pyo3/pull/2198)"
msgstr ""

#: src/changelog.md:232
msgid ""
"Fix regression from 0.16 preventing cross compiling to aarch64 macOS. "
"[\\#2201](https://github.com/PyO3/pyo3/pull/2201)"
msgstr ""

#: src/changelog.md:234
msgid ""
"[0.16.0](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.16.0) - 2022-02-27"
msgstr ""

#: src/changelog.md:238
msgid ""
"Update MSRV to Rust 1.48. [\\#2004](https://github.com/PyO3/pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:239
msgid ""
"Update `indoc` optional dependency to 1.0. [\\#2004](https://github.com/PyO3/"
"pyo3/pull/2004)"
msgstr ""

#: src/changelog.md:240
msgid ""
"Drop support for Python 3.6, remove `abi3-py36` feature. [\\#2006](https://"
"github.com/PyO3/pyo3/pull/2006)"
msgstr ""

#: src/changelog.md:241
msgid ""
"`pyo3-build-config` no longer enables the `resolve-config` feature by "
"default. [\\#2008](https://github.com/PyO3/pyo3/pull/2008)"
msgstr ""

#: src/changelog.md:242
msgid ""
"Update `inventory` optional dependency to 0.2. [\\#2019](https://github.com/"
"PyO3/pyo3/pull/2019)"
msgstr ""

#: src/changelog.md:243
msgid ""
"Drop `paste` dependency. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:244
msgid ""
"The bindings found in `pyo3::ffi` are now a re-export of a separate `pyo3-"
"ffi` crate. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:245
msgid "Support PyPy 3.9. [\\#2143](https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:249
msgid ""
"Add `PyCapsule` type exposing the [Capsule API](https://docs.python.org/3/c-"
"api/capsule.html#capsules). [\\#1980](https://github.com/PyO3/pyo3/pull/1980)"
msgstr ""

#: src/changelog.md:250
msgid ""
"Add `pyo3_build_config::Sysconfigdata` and supporting APIs. [\\#1996]"
"(https://github.com/PyO3/pyo3/pull/1996)"
msgstr ""

#: src/changelog.md:251
msgid ""
"Add `Py::setattr` method. [\\#2009](https://github.com/PyO3/pyo3/pull/2009)"
msgstr ""

#: src/changelog.md:252
msgid ""
"Add `#[pyo3(crate = \"some::path\")]` option to all attribute macros (except "
"the deprecated `#[pyproto]`). [\\#2022](https://github.com/PyO3/pyo3/"
"pull/2022)"
msgstr ""

#: src/changelog.md:253
msgid ""
"Enable `create_exception!` macro to take an optional docstring. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:254
msgid ""
"Enable `#[pyclass]` for fieldless (aka C-like) enums. [\\#2034](https://"
"github.com/PyO3/pyo3/pull/2034)"
msgstr ""

#: src/changelog.md:255
msgid ""
"Add buffer magic methods `__getbuffer__` and `__releasebuffer__` to "
"`#[pymethods]`. [\\#2067](https://github.com/PyO3/pyo3/pull/2067)"
msgstr ""

#: src/changelog.md:256
msgid ""
"Add support for paths in `wrap_pyfunction` and `wrap_pymodule`. [\\#2081]"
"(https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:257
msgid ""
"Enable `wrap_pyfunction!` to wrap a `#[pyfunction]` implemented in a "
"different Rust module or crate. [\\#2091](https://github.com/PyO3/pyo3/"
"pull/2091)"
msgstr ""

#: src/changelog.md:258
msgid ""
"Add `PyAny::contains` method (`in` operator for `PyAny`). [\\#2115](https://"
"github.com/PyO3/pyo3/pull/2115)"
msgstr ""

#: src/changelog.md:259
msgid ""
"Add `PyMapping::contains` method (`in` operator for `PyMapping`). [\\#2133]"
"(https://github.com/PyO3/pyo3/pull/2133)"
msgstr ""

#: src/changelog.md:260
msgid ""
"Add garbage collection magic magic methods `__traverse__` and `__clear__` to "
"`#[pymethods]`. [\\#2159](https://github.com/PyO3/pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:261
msgid ""
"Add support for `from_py_with` on struct tuples and enums to override the "
"default from-Python conversion. [\\#2181](https://github.com/PyO3/pyo3/"
"pull/2181)"
msgstr ""

#: src/changelog.md:262
msgid ""
"Add `eq`, `ne`, `lt`, `le`, `gt`, `ge` methods to `PyAny` that wrap "
"`rich_compare`. [\\#2175](https://github.com/PyO3/pyo3/pull/2175)"
msgstr ""

#: src/changelog.md:263
msgid ""
"Add `Py::is` and `PyAny::is` methods to check for object identity. [\\#2183]"
"(https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:264
msgid ""
"Add support for the `__getattribute__` magic method. [\\#2187](https://"
"github.com/PyO3/pyo3/pull/2187)"
msgstr ""

#: src/changelog.md:268
msgid ""
"`PyType::is_subclass`, `PyErr::is_instance` and `PyAny::is_instance` now "
"operate run-time type object instead of a type known at compile-time. The "
"old behavior is still available as `PyType::is_subclass_of`, `PyErr::"
"is_instance_of` and `PyAny::is_instance_of`.  [\\#1985](https://github.com/"
"PyO3/pyo3/pull/1985)"
msgstr ""

#: src/changelog.md:269
msgid ""
"Rename some methods on `PyErr` (the old names are just marked deprecated for "
"now): [\\#2026](https://github.com/PyO3/pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:270
msgid "`pytype` -> `get_type`"
msgstr ""

#: src/changelog.md:271
msgid "`pvalue` -> `value` (and deprecate equivalent `instance`)"
msgstr ""

#: src/changelog.md:272
msgid "`ptraceback` -> `traceback`"
msgstr ""

#: src/changelog.md:273
msgid "`from_instance` -> `from_value`"
msgstr ""

#: src/changelog.md:274
msgid "`into_instance` -> `into_value`"
msgstr ""

#: src/changelog.md:275
msgid ""
"`PyErr::new_type` now takes an optional docstring and now returns "
"`PyResult<Py<PyType>>` rather than a `ffi::PyTypeObject` pointer. [\\#2027]"
"(https://github.com/PyO3/pyo3/pull/2027)"
msgstr ""

#: src/changelog.md:276
msgid ""
"Deprecate `PyType::is_instance`; it is inconsistent with other `is_instance` "
"methods in PyO3. Instead of `typ.is_instance(obj)`, use `obj."
"is_instance(typ)`. [\\#2031](https://github.com/PyO3/pyo3/pull/2031)"
msgstr ""

#: src/changelog.md:277
msgid ""
"`__getitem__`, `__setitem__` and `__delitem__` in `#[pymethods]` now "
"implement both a Python mapping and sequence by default. [\\#2065](https://"
"github.com/PyO3/pyo3/pull/2065)"
msgstr ""

#: src/changelog.md:278
msgid ""
"Improve performance and error messages for `#[derive(FromPyObject)]` for "
"enums. [\\#2068](https://github.com/PyO3/pyo3/pull/2068)"
msgstr ""

#: src/changelog.md:279
msgid "Reduce generated LLVM code size (to improve compile times) for:"
msgstr ""

#: src/changelog.md:280
msgid ""
"internal `handle_panic` helper [\\#2074](https://github.com/PyO3/pyo3/"
"pull/2074) [\\#2158](https://github.com/PyO3/pyo3/pull/2158)"
msgstr ""

#: src/changelog.md:281
msgid ""
"`#[pyfunction]` and `#[pymethods]` argument extraction [\\#2075](https://"
"github.com/PyO3/pyo3/pull/2075) [\\#2085](https://github.com/PyO3/pyo3/"
"pull/2085)"
msgstr ""

#: src/changelog.md:282
msgid ""
"`#[pyclass]` type object creation [\\#2076](https://github.com/PyO3/pyo3/"
"pull/2076) [\\#2081](https://github.com/PyO3/pyo3/pull/2081) [\\#2157]"
"(https://github.com/PyO3/pyo3/pull/2157)"
msgstr ""

#: src/changelog.md:283
msgid ""
"Respect Rust privacy rules for items wrapped with `wrap_pyfunction` and "
"`wrap_pymodule`. [\\#2081](https://github.com/PyO3/pyo3/pull/2081)"
msgstr ""

#: src/changelog.md:284
msgid ""
"Add modulo argument to `__ipow__` magic method. [\\#2083](https://github.com/"
"PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:285
msgid ""
"Fix FFI definition for `_PyCFunctionFast`. [\\#2126](https://github.com/PyO3/"
"pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:286
msgid ""
"`PyDateTimeAPI` and `PyDateTime_TimeZone_UTC` are are now unsafe functions "
"instead of statics. [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:287
msgid ""
"`PyDateTimeAPI` does not implicitly call `PyDateTime_IMPORT` anymore to "
"reflect the original Python API more closely. Before the first call to "
"`PyDateTime_IMPORT` a null pointer is returned. Therefore before calling any "
"of the following FFI functions `PyDateTime_IMPORT` must be called to avoid "
"undefined behaviour: [\\#2126](https://github.com/PyO3/pyo3/pull/2126)"
msgstr ""

#: src/changelog.md:288
msgid "`PyDateTime_TimeZone_UTC`"
msgstr ""

#: src/changelog.md:289
msgid "`PyDate_Check`"
msgstr ""

#: src/changelog.md:290
msgid "`PyDate_CheckExact`"
msgstr ""

#: src/changelog.md:291
msgid "`PyDateTime_Check`"
msgstr ""

#: src/changelog.md:292
msgid "`PyDateTime_CheckExact`"
msgstr ""

#: src/changelog.md:293
msgid "`PyTime_Check`"
msgstr ""

#: src/changelog.md:294
msgid "`PyTime_CheckExact`"
msgstr ""

#: src/changelog.md:295
msgid "`PyDelta_Check`"
msgstr ""

#: src/changelog.md:296
msgid "`PyDelta_CheckExact`"
msgstr ""

#: src/changelog.md:297
msgid "`PyTZInfo_Check`"
msgstr ""

#: src/changelog.md:298
msgid "`PyTZInfo_CheckExact`"
msgstr ""

#: src/changelog.md:299
msgid "`PyDateTime_FromTimestamp`"
msgstr ""

#: src/changelog.md:300
msgid "`PyDate_FromTimestamp`"
msgstr ""

#: src/changelog.md:301
msgid ""
"Deprecate the `gc` option for `pyclass` (e.g. `#[pyclass(gc)]`). Just "
"implement a `__traverse__` `#[pymethod]`. [\\#2159](https://github.com/PyO3/"
"pyo3/pull/2159)"
msgstr ""

#: src/changelog.md:302
msgid ""
"The `ml_meth` field of `PyMethodDef` is now represented by the "
"`PyMethodDefPointer` union. [2166](https://github.com/PyO3/pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:303
msgid ""
"Deprecate the `#[pyproto]` traits. [\\#2173](https://github.com/PyO3/pyo3/"
"pull/2173)"
msgstr ""

#: src/changelog.md:307
msgid ""
"Remove all functionality deprecated in PyO3 0.14. [\\#2007](https://github."
"com/PyO3/pyo3/pull/2007)"
msgstr ""

#: src/changelog.md:308
msgid ""
"Remove `Default` impl for `PyMethodDef`. [\\#2166](https://github.com/PyO3/"
"pyo3/pull/2166)"
msgstr ""

#: src/changelog.md:309
msgid ""
"Remove `PartialEq` impl for `Py` and `PyAny` (use the new `is` instead). "
"[\\#2183](https://github.com/PyO3/pyo3/pull/2183)"
msgstr ""

#: src/changelog.md:313
msgid ""
"Fix undefined symbol for `PyObject_HasAttr` on PyPy. [\\#2025](https://"
"github.com/PyO3/pyo3/pull/2025)"
msgstr ""

#: src/changelog.md:314
msgid ""
"Fix memory leak in `PyErr::into_value`. [\\#2026](https://github.com/PyO3/"
"pyo3/pull/2026)"
msgstr ""

#: src/changelog.md:315
msgid ""
"Fix clippy warning `needless-option-as-deref` in code generated by "
"`#[pyfunction]` and `#[pymethods]`. [\\#2040](https://github.com/PyO3/pyo3/"
"pull/2040)"
msgstr ""

#: src/changelog.md:316
msgid ""
"Fix undefined behavior in `PySlice::indices`. [\\#2061](https://github.com/"
"PyO3/pyo3/pull/2061)"
msgstr ""

#: src/changelog.md:317
msgid ""
"Fix the `wrap_pymodule!` macro using the wrong name for a `#[pymodule]` with "
"a `#[pyo3(name = \"..\")]` attribute. [\\#2081](https://github.com/PyO3/pyo3/"
"pull/2081)"
msgstr ""

#: src/changelog.md:318
msgid ""
"Fix magic methods in `#[pymethods]` accepting implementations with the wrong "
"number of arguments. [\\#2083](https://github.com/PyO3/pyo3/pull/2083)"
msgstr ""

#: src/changelog.md:319
msgid ""
"Fix panic in `#[pyfunction]` generated code when a required argument "
"following an `Option` was not provided.  [\\#2093](https://github.com/PyO3/"
"pyo3/pull/2093)"
msgstr ""

#: src/changelog.md:320
msgid ""
"Fixed undefined behaviour caused by incorrect `ExactSizeIterator` "
"implementations. [\\#2124](https://github.com/PyO3/pyo3/pull/2124)"
msgstr ""

#: src/changelog.md:321
msgid ""
"Fix missing FFI definition `PyCMethod_New` on Python 3.9 and up. [\\#2143]"
"(https://github.com/PyO3/pyo3/pull/2143)"
msgstr ""

#: src/changelog.md:322
msgid ""
"Add missing FFI definitions `_PyLong_NumBits` and `_PyLong_AsByteArray` on "
"PyPy. [\\#2146](https://github.com/PyO3/pyo3/pull/2146)"
msgstr ""

#: src/changelog.md:323
msgid ""
"Fix memory leak in implementation of `AsPyPointer` for `Option<T>`. [\\#2160]"
"(https://github.com/PyO3/pyo3/pull/2160)"
msgstr ""

#: src/changelog.md:324
msgid ""
"Fix FFI definition of `_PyLong_NumBits` to return `size_t` instead of "
"`c_int`. [\\#2161](https://github.com/PyO3/pyo3/pull/2161)"
msgstr ""

#: src/changelog.md:325
msgid ""
"Fix `TypeError` thrown when argument parsing failed missing the originating "
"causes. [2177](https://github.com/PyO3/pyo3/pull/2178)"
msgstr ""

#: src/changelog.md:327
msgid ""
"[0.15.2](https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2) - 2022-04-14"
msgstr ""

#: src/changelog.md:331
msgid ""
"Backport of PyPy 3.9 support from PyO3 0.16. [\\#2262](https://github.com/"
"PyO3/pyo3/pull/2262)"
msgstr ""

#: src/changelog.md:333
msgid ""
"[0.15.1](https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1) - 2021-11-19"
msgstr ""

#: src/changelog.md:337
msgid ""
"Add implementations for `Py::as_ref` and `Py::into_ref` for "
"`Py<PySequence>`, `Py<PyIterator>` and `Py<PyMapping>`. [\\#1682](https://"
"github.com/PyO3/pyo3/pull/1682)"
msgstr ""

#: src/changelog.md:338
msgid ""
"Add `PyTraceback` type to represent and format Python tracebacks. [\\#1977]"
"(https://github.com/PyO3/pyo3/pull/1977)"
msgstr ""

#: src/changelog.md:342
msgid ""
"`#[classattr]` constants with a known magic method name (which is lowercase) "
"no longer trigger lint warnings expecting constants to be uppercase. "
"[\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:346
msgid ""
"Fix creating `#[classattr]` by functions with the name of a known magic "
"method. [\\#1969](https://github.com/PyO3/pyo3/pull/1969)"
msgstr ""

#: src/changelog.md:347
msgid ""
"Fix use of `catch_unwind` in `allow_threads` which can cause fatal crashes. "
"[\\#1989](https://github.com/PyO3/pyo3/pull/1989)"
msgstr ""

#: src/changelog.md:348
msgid ""
"Fix build failure on PyPy when abi3 features are activated. [\\#1991]"
"(https://github.com/PyO3/pyo3/pull/1991)"
msgstr ""

#: src/changelog.md:349
msgid ""
"Fix mingw platform detection. [\\#1993](https://github.com/PyO3/pyo3/"
"pull/1993)"
msgstr ""

#: src/changelog.md:350
msgid ""
"Fix panic in `__get__` implementation when accessing descriptor on type "
"object. [\\#1997](https://github.com/PyO3/pyo3/pull/1997)"
msgstr ""

#: src/changelog.md:352
msgid ""
"[0.15.0](https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0) - 2021-11-03"
msgstr ""

#: src/changelog.md:356
msgid ""
"`pyo3`'s `Cargo.toml` now advertises `links = \"python\"` to inform Cargo "
"that it links against _libpython_. [\\#1819](https://github.com/PyO3/pyo3/"
"pull/1819)"
msgstr ""

#: src/changelog.md:357
msgid ""
"Added optional `anyhow` feature to convert `anyhow::Error` into `PyErr`. "
"[\\#1822](https://github.com/PyO3/pyo3/pull/1822)"
msgstr ""

#: src/changelog.md:358
msgid "Support Python 3.10. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:359
msgid ""
"Added optional `eyre` feature to convert `eyre::Report` into `PyErr`. "
"[\\#1893](https://github.com/PyO3/pyo3/pull/1893)"
msgstr ""

#: src/changelog.md:360
msgid "Support PyPy 3.8. [\\#1948](https://github.com/PyO3/pyo3/pull/1948)"
msgstr ""

#: src/changelog.md:364
msgid ""
"Add `PyList::get_item_unchecked` and `PyTuple::get_item_unchecked` to get "
"items without bounds checks. [\\#1733](https://github.com/PyO3/pyo3/"
"pull/1733)"
msgstr ""

#: src/changelog.md:365
msgid ""
"Support `#[doc = include_str!(...)]` attributes on Rust 1.54 and up. "
"[\\#1746](https://github.com/PyO3/pyo3/issues/1746)"
msgstr ""

#: src/changelog.md:366
msgid ""
"Add `PyAny::py` as a convenience for `PyNativeType::py`. [\\#1751](https://"
"github.com/PyO3/pyo3/pull/1751)"
msgstr ""

#: src/changelog.md:367
msgid ""
"Add implementation of `std::ops::Index<usize>` for `PyList`, `PyTuple` and "
"`PySequence`. [\\#1825](https://github.com/PyO3/pyo3/pull/1825)"
msgstr ""

#: src/changelog.md:368
msgid ""
"Add range indexing implementations of `std::ops::Index` for `PyList`, "
"`PyTuple` and `PySequence`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:369
msgid ""
"Add `PyMapping` type to represent the Python mapping protocol. [\\#1844]"
"(https://github.com/PyO3/pyo3/pull/1844)"
msgstr ""

#: src/changelog.md:370
msgid ""
"Add commonly-used sequence methods to `PyList` and `PyTuple`. [\\#1849]"
"(https://github.com/PyO3/pyo3/pull/1849)"
msgstr ""

#: src/changelog.md:371
msgid ""
"Add `as_sequence` methods to `PyList` and `PyTuple`. [\\#1860](https://"
"github.com/PyO3/pyo3/pull/1860)"
msgstr ""

#: src/changelog.md:372
msgid ""
"Add support for magic methods in `#[pymethods]`, intended as a replacement "
"for `#[pyproto]`. [\\#1864](https://github.com/PyO3/pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:373
msgid ""
"Add `abi3-py310` feature. [\\#1889](https://github.com/PyO3/pyo3/pull/1889)"
msgstr ""

#: src/changelog.md:374
msgid ""
"Add `PyCFunction::new_closure` to create a Python function from a Rust "
"closure. [\\#1901](https://github.com/PyO3/pyo3/pull/1901)"
msgstr ""

#: src/changelog.md:375
msgid ""
"Add support for positional-only arguments in `#[pyfunction]`. [\\#1925]"
"(https://github.com/PyO3/pyo3/pull/1925)"
msgstr ""

#: src/changelog.md:376
msgid ""
"Add `PyErr::take` to attempt to fetch a Python exception if present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:380
msgid ""
"`PyList`, `PyTuple` and `PySequence`'s APIs now accepts only `usize` indices "
"instead of `isize`. [\\#1733](https://github.com/PyO3/pyo3/pull/1733), "
"[\\#1802](https://github.com/PyO3/pyo3/pull/1802), [\\#1803](https://github."
"com/PyO3/pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:383
msgid ""
"`PyList::get_item` and `PyTuple::get_item` now return `PyResult<&PyAny>` "
"instead of panicking. [\\#1733](https://github.com/PyO3/pyo3/pull/1733)"
msgstr ""

#: src/changelog.md:384
msgid ""
"`PySequence::in_place_repeat` and `PySequence::in_place_concat` now return "
"`PyResult<&PySequence>` instead of `PyResult<()>`, which is needed in case "
"of immutable sequences such as tuples. [\\#1803](https://github.com/PyO3/"
"pyo3/pull/1803)"
msgstr ""

#: src/changelog.md:385
msgid ""
"`PySequence::get_slice` now returns `PyResult<&PySequence>` instead of "
"`PyResult<&PyAny>`. [\\#1829](https://github.com/PyO3/pyo3/pull/1829)"
msgstr ""

#: src/changelog.md:386
msgid ""
"Deprecate `PyTuple::split_from`. [\\#1804](https://github.com/PyO3/pyo3/"
"pull/1804)"
msgstr ""

#: src/changelog.md:387
msgid ""
"Deprecate `PyTuple::slice`, new method `PyTuple::get_slice` added with "
"`usize` indices. [\\#1828](https://github.com/PyO3/pyo3/pull/1828)"
msgstr ""

#: src/changelog.md:388
msgid ""
"Deprecate FFI definitions `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags` "
"when building for Python 3.9. [\\#1830](https://github.com/PyO3/pyo3/"
"pull/1830)"
msgstr ""

#: src/changelog.md:389
msgid ""
"Mark FFI definitions removed in Python 3.10 `PyParser_ASTFromString`, "
"`PyParser_ASTFromStringObject`, `PyParser_ASTFromFile`, "
"`PyParser_ASTFromFileObject`, `PyParser_SimpleParseStringFlags`, "
"`PyParser_SimpleParseStringFlagsFilename`, `PyParser_SimpleParseFileFlags`, "
"`PyParser_SimpleParseString`, `PyParser_SimpleParseFile`, "
"`Py_SymtableString`, and `Py_SymtableStringObject`. [\\#1830](https://github."
"com/PyO3/pyo3/pull/1830)"
msgstr ""

#: src/changelog.md:390
msgid ""
"`#[pymethods]` now handles magic methods similarly to `#[pyproto]`. In the "
"future, `#[pyproto]` may be deprecated. [\\#1864](https://github.com/PyO3/"
"pyo3/pull/1864)"
msgstr ""

#: src/changelog.md:391
msgid ""
"Deprecate FFI definitions `PySys_AddWarnOption`, "
"`PySys_AddWarnOptionUnicode` and `PySys_HasWarnOptions`. [\\#1887](https://"
"github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:392
msgid ""
"Deprecate `#[call]` attribute in favor of using `fn __call__`. [\\#1929]"
"(https://github.com/PyO3/pyo3/pull/1929)"
msgstr ""

#: src/changelog.md:393 src/changelog.md:405
msgid ""
"Fix missing FFI definition `_PyImport_FindExtensionObject` on Python 3.10. "
"[\\#1942](https://github.com/PyO3/pyo3/pull/1942)"
msgstr ""

#: src/changelog.md:394
msgid ""
"Change `PyErr::fetch` to panic in debug mode if no exception is present. "
"[\\#1957](https://github.com/PyO3/pyo3/pull/1957)"
msgstr ""

#: src/changelog.md:398
msgid ""
"Fix building with a conda environment on Windows. [\\#1873](https://github."
"com/PyO3/pyo3/pull/1873)"
msgstr ""

#: src/changelog.md:399
msgid ""
"Fix panic on Python 3.6 when calling `Python::with_gil` with Python "
"initialized but threading not initialized. [\\#1874](https://github.com/PyO3/"
"pyo3/pull/1874)"
msgstr ""

#: src/changelog.md:400
msgid ""
"Fix incorrect linking to version-specific DLL instead of `python3.dll` when "
"cross-compiling to Windows with `abi3`. [\\#1880](https://github.com/PyO3/"
"pyo3/pull/1880)"
msgstr ""

#: src/changelog.md:401
msgid ""
"Fix FFI definition for `PyTuple_ClearFreeList` incorrectly being present for "
"Python 3.9 and up. [\\#1887](https://github.com/PyO3/pyo3/pull/1887)"
msgstr ""

#: src/changelog.md:402
msgid ""
"Fix panic in generated `#[derive(FromPyObject)]` for enums. [\\#1888]"
"(https://github.com/PyO3/pyo3/pull/1888)"
msgstr ""

#: src/changelog.md:403
msgid ""
"Fix cross-compiling to Python 3.7 builds with the \"m\" abi flag. [\\#1908]"
"(https://github.com/PyO3/pyo3/pull/1908)"
msgstr ""

#: src/changelog.md:404
msgid ""
"Fix `__mod__` magic method fallback to `__rmod__`. [\\#1934](https://github."
"com/PyO3/pyo3/pull/1934)."
msgstr ""

#: src/changelog.md:407
msgid ""
"[0.14.5](https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5) - 2021-09-05"
msgstr ""

#: src/changelog.md:411
msgid ""
"Make `pyo3_build_config::InterpreterConfig` and subfields public. [\\#1848]"
"(https://github.com/PyO3/pyo3/pull/1848)"
msgstr ""

#: src/changelog.md:412
msgid ""
"Add `resolve-config` feature to the `pyo3-build-config` to control whether "
"its build script does anything. [\\#1856](https://github.com/PyO3/pyo3/"
"pull/1856)"
msgstr ""

#: src/changelog.md:416
msgid ""
"Fix 0.14.4 compile regression on `s390x-unknown-linux-gnu` target. [\\#1850]"
"(https://github.com/PyO3/pyo3/pull/1850)"
msgstr ""

#: src/changelog.md:418
msgid ""
"[0.14.4](https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4) - 2021-08-29"
msgstr ""

#: src/changelog.md:422
msgid ""
"Mark `PyString::data` as `unsafe` and disable it and some supporting "
"PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. "
"[\\#1834](https://github.com/PyO3/pyo3/pull/1834)"
msgstr ""

#: src/changelog.md:424
msgid ""
"[0.14.3](https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3) - 2021-08-22"
msgstr ""

#: src/changelog.md:428
msgid ""
"Add `PyString::data` to access the raw bytes stored in a Python string. "
"[\\#1794](https://github.com/PyO3/pyo3/pull/1794)"
msgstr ""

#: src/changelog.md:432
msgid ""
"Raise `AttributeError` to avoid panic when calling `del` on a `#[setter]` "
"defined class property. [\\#1779](https://github.com/PyO3/pyo3/pull/1779)"
msgstr ""

#: src/changelog.md:433
msgid ""
"Restrict FFI definitions `PyGILState_Check` and `Py_tracefunc` to the "
"unlimited API. [\\#1787](https://github.com/PyO3/pyo3/pull/1787)"
msgstr ""

#: src/changelog.md:434
msgid ""
"Add missing `_type` field to `PyStatus` struct definition. [\\#1791](https://"
"github.com/PyO3/pyo3/pull/1791)"
msgstr ""

#: src/changelog.md:435
msgid ""
"Reduce lower bound `num-complex` optional dependency to support interop with "
"`rust-numpy` and `ndarray` when building with the MSRV of 1.41 [\\#1799]"
"(https://github.com/PyO3/pyo3/pull/1799)"
msgstr ""

#: src/changelog.md:436
msgid ""
"Fix memory leak in `Python::run_code`. [\\#1806](https://github.com/PyO3/"
"pyo3/pull/1806)"
msgstr ""

#: src/changelog.md:437
msgid ""
"Fix memory leak in `PyModule::from_code`. [\\#1810](https://github.com/PyO3/"
"pyo3/pull/1810)"
msgstr ""

#: src/changelog.md:438
msgid ""
"Remove use of `pyo3::` in `pyo3::types::datetime` which broke builds using `-"
"Z avoid-dev-deps` [\\#1811](https://github.com/PyO3/pyo3/pull/1811)"
msgstr ""

#: src/changelog.md:440
msgid ""
"[0.14.2](https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2) - 2021-08-09"
msgstr ""

#: src/changelog.md:444
msgid ""
"Add `indexmap` feature to add `ToPyObject`, `IntoPy` and `FromPyObject` "
"implementations for `indexmap::IndexMap`. [\\#1728](https://github.com/PyO3/"
"pyo3/pull/1728)"
msgstr ""

#: src/changelog.md:445
msgid ""
"Add `pyo3_build_config::add_extension_module_link_args` to use in build "
"scripts to set linker arguments (for macOS). [\\#1755](https://github.com/"
"PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:446
msgid ""
"Add `Python::with_gil_unchecked` unsafe variation of `Python::with_gil` to "
"allow obtaining a `Python` in scenarios where `Python::with_gil` would fail. "
"[\\#1769](https://github.com/PyO3/pyo3/pull/1769)"
msgstr ""

#: src/changelog.md:450
msgid ""
"`PyErr::new` no longer acquires the Python GIL internally. [\\#1724](https://"
"github.com/PyO3/pyo3/pull/1724)"
msgstr ""

#: src/changelog.md:451
msgid ""
"Reverted PyO3 0.14.0's use of `cargo:rustc-cdylib-link-arg` in its build "
"script, as Cargo unintentionally allowed crates to pass linker args to "
"downstream crates in this way. Projects supporting macOS may need to restore "
"`.cargo/config.toml` files. [\\#1755](https://github.com/PyO3/pyo3/pull/1755)"
msgstr ""

#: src/changelog.md:455
msgid ""
"Fix regression in 0.14.0 rejecting usage of `#[doc(hidden)]` on structs and "
"functions annotated with PyO3 macros. [\\#1722](https://github.com/PyO3/pyo3/"
"pull/1722)"
msgstr ""

#: src/changelog.md:456
msgid ""
"Fix regression in 0.14.0 leading to incorrect code coverage being computed "
"for `#[pyfunction]`s. [\\#1726](https://github.com/PyO3/pyo3/pull/1726)"
msgstr ""

#: src/changelog.md:457
msgid ""
"Fix incorrect FFI definition of `Py_Buffer` on PyPy. [\\#1737](https://"
"github.com/PyO3/pyo3/pull/1737)"
msgstr ""

#: src/changelog.md:458
msgid ""
"Fix incorrect calculation of `dictoffset` on 32-bit Windows. [\\#1475]"
"(https://github.com/PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:459
msgid ""
"Fix regression in 0.13.2 leading to linking to incorrect Python library on "
"Windows \"gnu\" targets. [\\#1759](https://github.com/PyO3/pyo3/pull/1759)"
msgstr ""

#: src/changelog.md:460
msgid ""
"Fix compiler warning: deny trailing semicolons in expression macro. [\\#1762]"
"(https://github.com/PyO3/pyo3/pull/1762)"
msgstr ""

#: src/changelog.md:461
msgid ""
"Fix incorrect FFI definition of `Py_DecodeLocale`. The 2nd argument is now "
"`*mut Py_ssize_t` instead of `Py_ssize_t`. [\\#1766](https://github.com/PyO3/"
"pyo3/pull/1766)"
msgstr ""

#: src/changelog.md:463
msgid ""
"[0.14.1](https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1) - 2021-07-04"
msgstr ""

#: src/changelog.md:467
msgid ""
"Implement `IntoPy<PyObject>` for `&PathBuf` and `&OsString`. [\\#1712]"
"(https://github.com/PyO3/pyo3/pull/1712)"
msgstr ""

#: src/changelog.md:471
msgid ""
"Fix crashes on PyPy due to incorrect definitions of `PyList_SET_ITEM`. "
"[\\#1713](https://github.com/PyO3/pyo3/pull/1713)"
msgstr ""

#: src/changelog.md:473
msgid ""
"[0.14.0](https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0) - 2021-07-03"
msgstr ""

#: src/changelog.md:477
msgid ""
"Update `num-bigint` optional dependency to 0.4. [\\#1481](https://github.com/"
"PyO3/pyo3/pull/1481)"
msgstr ""

#: src/changelog.md:478
msgid ""
"Update `num-complex` optional dependency to 0.4. [\\#1482](https://github."
"com/PyO3/pyo3/pull/1482)"
msgstr ""

#: src/changelog.md:479
msgid ""
"Extend `hashbrown` optional dependency supported versions to include 0.11. "
"[\\#1496](https://github.com/PyO3/pyo3/pull/1496)"
msgstr ""

#: src/changelog.md:480
msgid "Support PyPy 3.7. [\\#1538](https://github.com/PyO3/pyo3/pull/1538)"
msgstr ""

#: src/changelog.md:484
msgid ""
"Extend conversions for `[T; N]` to all `N` using const generics (on Rust "
"1.51 and up). [\\#1128](https://github.com/PyO3/pyo3/pull/1128)"
msgstr ""

#: src/changelog.md:485
msgid ""
"Add conversions between `OsStr`/ `OsString` and Python strings. [\\#1379]"
"(https://github.com/PyO3/pyo3/pull/1379)"
msgstr ""

#: src/changelog.md:486
msgid ""
"Add conversions between `Path`/ `PathBuf` and Python strings (and `pathlib."
"Path` objects). [\\#1379](https://github.com/PyO3/pyo3/pull/1379) [\\#1654]"
"(https://github.com/PyO3/pyo3/pull/1654)"
msgstr ""

#: src/changelog.md:487
msgid ""
"Add a new set of `#[pyo3(...)]` attributes to control various PyO3 macro "
"functionality:"
msgstr ""

#: src/changelog.md:488
msgid ""
"`#[pyo3(from_py_with = \"...\")]` function arguments and struct fields to "
"override the default from-Python conversion. [\\#1411](https://github.com/"
"PyO3/pyo3/pull/1411)"
msgstr ""

#: src/changelog.md:489
msgid ""
"`#[pyo3(name = \"...\")]` for setting Python names. [\\#1567](https://github."
"com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:490
msgid ""
"`#[pyo3(text_signature = \"...\")]` for setting text signature. [\\#1658]"
"(https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:491
msgid ""
"Add FFI definition `PyCFunction_CheckExact` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:492
msgid ""
"Add FFI definition `Py_IS_TYPE`. [\\#1429](https://github.com/PyO3/pyo3/"
"pull/1429)"
msgstr ""

#: src/changelog.md:493
msgid ""
"Add FFI definition `_Py_InitializeMain`. [\\#1473](https://github.com/PyO3/"
"pyo3/pull/1473)"
msgstr ""

#: src/changelog.md:494
msgid ""
"Add FFI definitions from `cpython/import.h`.[\\#1475](https://github.com/"
"PyO3/pyo3/pull/1475)"
msgstr ""

#: src/changelog.md:495
msgid ""
"Add tuple and unit struct support for `#[pyclass]` macro. [\\#1504](https://"
"github.com/PyO3/pyo3/pull/1504)"
msgstr ""

#: src/changelog.md:496
msgid ""
"Add FFI definition `PyDateTime_TimeZone_UTC`. [\\#1572](https://github.com/"
"PyO3/pyo3/pull/1572)"
msgstr ""

#: src/changelog.md:497
msgid ""
"Add support for `#[pyclass(extends=Exception)]`. [\\#1591](https://github."
"com/PyO3/pyo3/pull/1591)"
msgstr ""

#: src/changelog.md:498
msgid ""
"Add `PyErr::cause` and `PyErr::set_cause`. [\\#1679](https://github.com/PyO3/"
"pyo3/pull/1679)"
msgstr ""

#: src/changelog.md:499
msgid ""
"Add FFI definitions from `cpython/pystate.h`. [\\#1687](https://github.com/"
"PyO3/pyo3/pull/1687/)"
msgstr ""

#: src/changelog.md:500
msgid ""
"Add `wrap_pyfunction!` macro to `pyo3::prelude`. [\\#1695](https://github."
"com/PyO3/pyo3/pull/1695)"
msgstr ""

#: src/changelog.md:504
msgid ""
"Allow only one `#[pymethods]` block per `#[pyclass]` by default, to remove "
"the dependency on `inventory`. Add a `multiple-pymethods` feature to opt-in "
"the original behavior and dependency on `inventory`. [\\#1457](https://"
"github.com/PyO3/pyo3/pull/1457)"
msgstr ""

#: src/changelog.md:505
msgid ""
"Change `PyTimeAccess::get_fold` to return a `bool` instead of a `u8`. "
"[\\#1397](https://github.com/PyO3/pyo3/pull/1397)"
msgstr ""

#: src/changelog.md:506
msgid ""
"Deprecate FFI definition `PyCFunction_Call` for Python 3.9 and up. [\\#1425]"
"(https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:507
msgid ""
"Deprecate FFI definition `PyModule_GetFilename`. [\\#1425](https://github."
"com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:508
msgid ""
"The `auto-initialize` feature is no longer enabled by default. [\\#1443]"
"(https://github.com/PyO3/pyo3/pull/1443)"
msgstr ""

#: src/changelog.md:509
msgid ""
"Change `PyCFunction::new` and `PyCFunction::new_with_keywords` to take "
"`&'static str` arguments rather than implicitly copying (and leaking) them. "
"[\\#1450](https://github.com/PyO3/pyo3/pull/1450)"
msgstr ""

#: src/changelog.md:510
msgid ""
"Deprecate `PyModule::call`, `PyModule::call0`, `PyModule::call1` and "
"`PyModule::get`. [\\#1492](https://github.com/PyO3/pyo3/pull/1492)"
msgstr ""

#: src/changelog.md:511
msgid ""
"Add length information to `PyBufferError`s raised from `PyBuffer::"
"copy_to_slice` and `PyBuffer::copy_from_slice`. [\\#1534](https://github.com/"
"PyO3/pyo3/pull/1534)"
msgstr ""

#: src/changelog.md:512
msgid ""
"Automatically set `-undefined` and `dynamic_lookup` linker arguments on "
"macOS with the `extension-module` feature. [\\#1539](https://github.com/PyO3/"
"pyo3/pull/1539)"
msgstr ""

#: src/changelog.md:513
msgid ""
"Deprecate `#[pyproto]` methods which are easier to implement as "
"`#[pymethods]`: [\\#1560](https://github.com/PyO3/pyo3/pull/1560)"
msgstr ""

#: src/changelog.md:514
msgid "`PyBasicProtocol::__bytes__` and `PyBasicProtocol::__format__`"
msgstr ""

#: src/changelog.md:515
msgid "`PyContextProtocol::__enter__` and `PyContextProtocol::__exit__`"
msgstr ""

#: src/changelog.md:516
msgid "`PyDescrProtocol::__delete__` and `PyDescrProtocol::__set_name__`"
msgstr ""

#: src/changelog.md:517
msgid "`PyMappingProtocol::__reversed__`"
msgstr ""

#: src/changelog.md:518
msgid "`PyNumberProtocol::__complex__` and `PyNumberProtocol::__round__`"
msgstr ""

#: src/changelog.md:519
msgid "`PyAsyncProtocol::__aenter__` and `PyAsyncProtocol::__aexit__`"
msgstr ""

#: src/changelog.md:520
msgid ""
"Deprecate several attributes in favor of the new `#[pyo3(...)]` options:"
msgstr ""

#: src/changelog.md:521
msgid ""
"`#[name = \"...\"]`, replaced by `#[pyo3(name = \"...\")]` [\\#1567](https://"
"github.com/PyO3/pyo3/pull/1567)"
msgstr ""

#: src/changelog.md:522
msgid ""
"`#[pyfn(m, \"name\")]`, replaced by `#[pyfn(m)] #[pyo3(name = \"...\")]`. "
"[\\#1610](https://github.com/PyO3/pyo3/pull/1610)"
msgstr ""

#: src/changelog.md:523
msgid ""
"`#[pymodule(name)]`, replaced by `#[pymodule] #[pyo3(name = \"...\")]` "
"[\\#1650](https://github.com/PyO3/pyo3/pull/1650)"
msgstr ""

#: src/changelog.md:524
msgid ""
"`#[text_signature = \"...\"]`, replaced by `#[pyo3(text_signature = \"..."
"\")]`. [\\#1658](https://github.com/PyO3/pyo3/pull/1658)"
msgstr ""

#: src/changelog.md:525
msgid ""
"Reduce LLVM line counts to improve compilation times. [\\#1604](https://"
"github.com/PyO3/pyo3/pull/1604)"
msgstr ""

#: src/changelog.md:526
msgid ""
"No longer call `PyEval_InitThreads` in `#[pymodule]` init code. [\\#1630]"
"(https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:527
msgid ""
"Use `METH_FASTCALL` argument passing convention, when possible, to improve "
"`#[pyfunction]` and method performance. [\\#1619](https://github.com/PyO3/"
"pyo3/pull/1619), [\\#1660](https://github.com/PyO3/pyo3/pull/1660)"
msgstr ""

#: src/changelog.md:529
msgid ""
"Filter sysconfigdata candidates by architecture when cross-compiling. "
"[\\#1626](https://github.com/PyO3/pyo3/pull/1626)"
msgstr ""

#: src/changelog.md:533
msgid ""
"Remove deprecated exception names `BaseException` etc. [\\#1426](https://"
"github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:534
msgid ""
"Remove deprecated methods `Python::is_instance`, `Python::is_subclass`, "
"`Python::release`, `Python::xdecref`, and `Py::from_owned_ptr_or_panic`. "
"[\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:535
msgid "Remove many FFI definitions which never existed in the Python C-API:"
msgstr ""

#: src/changelog.md:536
msgid ""
"(previously deprecated) `PyGetSetDef_INIT`, `PyGetSetDef_DICT`, "
"`PyCoro_Check`, `PyCoroWrapper_Check`, and `PyAsyncGen_Check` [\\#1426]"
"(https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:537
msgid "`PyMethodDef_INIT` [\\#1426](https://github.com/PyO3/pyo3/pull/1426)"
msgstr ""

#: src/changelog.md:538
msgid "`PyTypeObject_INIT` [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:539
msgid ""
"`PyObject_Check`, `PySuper_Check`, and `FreeFunc` [\\#1438](https://github."
"com/PyO3/pyo3/pull/1438)"
msgstr ""

#: src/changelog.md:540
msgid "`PyModuleDef_INIT` [\\#1630](https://github.com/PyO3/pyo3/pull/1630)"
msgstr ""

#: src/changelog.md:541
msgid "Remove pyclass implementation details from `PyTypeInfo`:"
msgstr ""

#: src/changelog.md:542
msgid ""
"`Type`, `DESCRIPTION`, and `FLAGS` [\\#1456](https://github.com/PyO3/pyo3/"
"pull/1456)"
msgstr ""

#: src/changelog.md:543
msgid ""
"`BaseType`, `BaseLayout`, `Layout`, `Initializer` [\\#1596](https://github."
"com/PyO3/pyo3/pull/1596)"
msgstr ""

#: src/changelog.md:544
msgid ""
"Remove `PYO3_CROSS_INCLUDE_DIR` environment variable and the associated C "
"header parsing functionality. [\\#1521](https://github.com/PyO3/pyo3/"
"pull/1521)"
msgstr ""

#: src/changelog.md:545
msgid ""
"Remove `raw_pycfunction!` macro. [\\#1619](https://github.com/PyO3/pyo3/"
"pull/1619)"
msgstr ""

#: src/changelog.md:546
msgid ""
"Remove `PyClassAlloc` trait. [\\#1657](https://github.com/PyO3/pyo3/"
"pull/1657)"
msgstr ""

#: src/changelog.md:547
msgid ""
"Remove `PyList::get_parked_item`. [\\#1664](https://github.com/PyO3/pyo3/"
"pull/1664)"
msgstr ""

#: src/changelog.md:551
msgid ""
"Remove FFI definition `PyCFunction_ClearFreeList` for Python 3.9 and later. "
"[\\#1425](https://github.com/PyO3/pyo3/pull/1425)"
msgstr ""

#: src/changelog.md:552
msgid ""
"`PYO3_CROSS_LIB_DIR` environment variable no long required when compiling "
"for x86-64 Python from macOS arm64 and reverse. [\\#1428](https://github.com/"
"PyO3/pyo3/pull/1428)"
msgstr ""

#: src/changelog.md:553
msgid ""
"Fix FFI definition `_PyEval_RequestCodeExtraIndex`, which took an argument "
"of the wrong type. [\\#1429](https://github.com/PyO3/pyo3/pull/1429)"
msgstr ""

#: src/changelog.md:554
msgid ""
"Fix FFI definition `PyIndex_Check` missing with the `abi3` feature. [\\#1436]"
"(https://github.com/PyO3/pyo3/pull/1436)"
msgstr ""

#: src/changelog.md:555
msgid ""
"Fix incorrect `TypeError` raised when keyword-only argument passed along "
"with a positional argument in `*args`. [\\#1440](https://github.com/PyO3/"
"pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:556
msgid ""
"Fix inability to use a named lifetime for `&PyTuple` of `*args` in "
"`#[pyfunction]`. [\\#1440](https://github.com/PyO3/pyo3/pull/1440)"
msgstr ""

#: src/changelog.md:557
msgid ""
"Fix use of Python argument for `#[pymethods]` inside macro expansions. "
"[\\#1505](https://github.com/PyO3/pyo3/pull/1505)"
msgstr ""

#: src/changelog.md:558
msgid ""
"No longer include `__doc__` in `__all__` generated for `#[pymodule]`. "
"[\\#1509](https://github.com/PyO3/pyo3/pull/1509)"
msgstr ""

#: src/changelog.md:559
msgid ""
"Always use cross-compiling configuration if any of the `PYO3_CROSS` family "
"of environment variables are set. [\\#1514](https://github.com/PyO3/pyo3/"
"pull/1514)"
msgstr ""

#: src/changelog.md:560
msgid ""
"Support `EnvironmentError`, `IOError`, and `WindowsError` on PyPy. [\\#1533]"
"(https://github.com/PyO3/pyo3/pull/1533)"
msgstr ""

#: src/changelog.md:561
msgid ""
"Fix unnecessary rebuilds when cycling between `cargo check` and `cargo "
"clippy` in a Python virtualenv. [\\#1557](https://github.com/PyO3/pyo3/"
"pull/1557)"
msgstr ""

#: src/changelog.md:562
msgid ""
"Fix segfault when dereferencing `ffi::PyDateTimeAPI` without the GIL. "
"[\\#1563](https://github.com/PyO3/pyo3/pull/1563)"
msgstr ""

#: src/changelog.md:563
msgid ""
"Fix memory leak in `FromPyObject` implementations for `u128` and `i128`. "
"[\\#1638](https://github.com/PyO3/pyo3/pull/1638)"
msgstr ""

#: src/changelog.md:564
msgid ""
"Fix `#[pyclass(extends=PyDict)]` leaking the dict contents on drop. [\\#1657]"
"(https://github.com/PyO3/pyo3/pull/1657)"
msgstr ""

#: src/changelog.md:565
msgid ""
"Fix segfault when calling `PyList::get_item` with negative indices. [\\#1668]"
"(https://github.com/PyO3/pyo3/pull/1668)"
msgstr ""

#: src/changelog.md:566
msgid ""
"Fix FFI definitions of `PyEval_SetProfile`/`PyEval_SetTrace` to take "
"`Option<Py_tracefunc>` parameters. [\\#1692](https://github.com/PyO3/pyo3/"
"pull/1692)"
msgstr ""

#: src/changelog.md:567
msgid ""
"Fix `ToPyObject` impl for `HashSet` to accept non-default hashers. [\\#1702]"
"(https://github.com/PyO3/pyo3/pull/1702)"
msgstr ""

#: src/changelog.md:569
msgid ""
"[0.13.2](https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2) - 2021-02-12"
msgstr ""

#: src/changelog.md:573
msgid ""
"Lower minimum supported Rust version to 1.41. [\\#1421](https://github.com/"
"PyO3/pyo3/pull/1421)"
msgstr ""

#: src/changelog.md:577
msgid ""
"Add unsafe API `with_embedded_python_interpreter` to initialize a Python "
"interpreter, execute a closure, and finalize the interpreter. [\\#1355]"
"(https://github.com/PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:578
msgid ""
"Add `serde` feature which provides implementations of `Serialize` and "
"`Deserialize` for `Py<T>`. [\\#1366](https://github.com/PyO3/pyo3/pull/1366)"
msgstr ""

#: src/changelog.md:579
msgid ""
"Add FFI definition `_PyCFunctionFastWithKeywords` on Python 3.7 and up. "
"[\\#1384](https://github.com/PyO3/pyo3/pull/1384)"
msgstr ""

#: src/changelog.md:580
msgid ""
"Add `PyDateTime::new_with_fold` method. [\\#1398](https://github.com/PyO3/"
"pyo3/pull/1398)"
msgstr ""

#: src/changelog.md:581
msgid ""
"Add `size_hint` impls for `{PyDict,PyList,PySet,PyTuple}Iterator`s. [\\#1699]"
"(https://github.com/PyO3/pyo3/pull/1699)"
msgstr ""

#: src/changelog.md:585
msgid ""
"`prepare_freethreaded_python` will no longer register an `atexit` handler to "
"call `Py_Finalize`. This resolves a number of issues with incompatible C "
"extensions causing crashes at finalization. [\\#1355](https://github.com/"
"PyO3/pyo3/pull/1355)"
msgstr ""

#: src/changelog.md:586
msgid ""
"Mark `PyLayout::py_init`, `PyClassDict::clear_dict`, and `opt_to_pyobj` "
"safe, as they do not perform any unsafe operations. [\\#1404](https://github."
"com/PyO3/pyo3/pull/1404)"
msgstr ""

#: src/changelog.md:590
msgid ""
"Fix support for using `r#raw_idents` as argument names in pyfunctions. "
"[\\#1383](https://github.com/PyO3/pyo3/pull/1383)"
msgstr ""

#: src/changelog.md:591
msgid ""
"Fix typo in FFI definition for `PyFunction_GetCode` (was incorrectly "
"`PyFunction_Code`). [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:592
msgid ""
"Fix FFI definitions `PyMarshal_WriteObjectToString` and "
"`PyMarshal_ReadObjectFromString` as available in limited API. [\\#1387]"
"(https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:593
msgid ""
"Fix FFI definitions `PyListObject` and those from `funcobject.h` as "
"requiring non-limited API. [\\#1387](https://github.com/PyO3/pyo3/pull/1387)"
msgstr ""

#: src/changelog.md:594
msgid ""
"Fix unqualified `Result` usage in `pyobject_native_type_base`. [\\#1402]"
"(https://github.com/PyO3/pyo3/pull/1402)"
msgstr ""

#: src/changelog.md:595
msgid ""
"Fix build on systems where the default Python encoding is not UTF-8. "
"[\\#1405](https://github.com/PyO3/pyo3/pull/1405)"
msgstr ""

#: src/changelog.md:596
msgid ""
"Fix build on mingw / MSYS2. [\\#1423](https://github.com/PyO3/pyo3/pull/1423)"
msgstr ""

#: src/changelog.md:598
msgid ""
"[0.13.1](https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1) - 2021-01-10"
msgstr ""

#: src/changelog.md:602
msgid ""
"Add support for `#[pyclass(dict)]` and `#[pyclass(weakref)]` with the `abi3` "
"feature on Python 3.9 and up. [\\#1342](https://github.com/PyO3/pyo3/"
"pull/1342)"
msgstr ""

#: src/changelog.md:603
msgid ""
"Add FFI definitions `PyOS_BeforeFork`, `PyOS_AfterFork_Parent`, "
"`PyOS_AfterFork_Child` for Python 3.7 and up. [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:604
msgid ""
"Add an `auto-initialize` feature to control whether PyO3 should "
"automatically initialize an embedded Python interpreter. For compatibility "
"this feature is enabled by default in PyO3 0.13.1, but is planned to become "
"opt-in from PyO3 0.14.0. [\\#1347](https://github.com/PyO3/pyo3/pull/1347)"
msgstr ""

#: src/changelog.md:605
msgid ""
"Add support for cross-compiling to Windows without needing "
"`PYO3_CROSS_INCLUDE_DIR`. [\\#1350](https://github.com/PyO3/pyo3/pull/1350)"
msgstr ""

#: src/changelog.md:607 src/changelog.md:667
msgid "Deprecated"
msgstr ""

#: src/changelog.md:609
msgid ""
"Deprecate FFI definitions `PyEval_CallObjectWithKeywords`, "
"`PyEval_CallObject`, `PyEval_CallFunction`, `PyEval_CallMethod` when "
"building for Python 3.9. [\\#1338](https://github.com/PyO3/pyo3/pull/1338)"
msgstr ""

#: src/changelog.md:610
msgid ""
"Deprecate FFI definitions `PyGetSetDef_DICT` and `PyGetSetDef_INIT` which "
"have never been in the Python API. [\\#1341](https://github.com/PyO3/pyo3/"
"pull/1341)"
msgstr ""

#: src/changelog.md:611
msgid ""
"Deprecate FFI definitions `PyGen_NeedsFinalizing`, `PyImport_Cleanup` "
"(removed in 3.9), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github."
"com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:612
msgid ""
"Deprecate FFI definition `PyOS_AfterFork` for Python 3.7 and up. [\\#1348]"
"(https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:613
msgid ""
"Deprecate FFI definitions `PyCoro_Check`, `PyAsyncGen_Check`, and "
"`PyCoroWrapper_Check`, which have never been in the Python API (for the "
"first two, it is possible to use `PyCoro_CheckExact` and "
"`PyAsyncGen_CheckExact` instead; these are the actual functions provided by "
"the Python API). [\\#1348](https://github.com/PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:614
msgid ""
"Deprecate FFI definitions for `PyUnicode_FromUnicode`, `PyUnicode_AsUnicode` "
"and `PyUnicode_AsUnicodeAndSize`, which will be removed from 3.12 and up due "
"to [PEP 623](https://www.python.org/dev/peps/pep-0623/). [\\#1370](https://"
"github.com/PyO3/pyo3/pull/1370)"
msgstr ""

#: src/changelog.md:618
msgid ""
"Remove FFI definition `PyFrame_ClearFreeList` when building for Python 3.9. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:619
msgid ""
"Remove FFI definition `_PyDict_Contains` when building for Python 3.10. "
"[\\#1341](https://github.com/PyO3/pyo3/pull/1341)"
msgstr ""

#: src/changelog.md:620
msgid ""
"Remove FFI definitions `PyGen_NeedsFinalizing` and `PyImport_Cleanup` (for "
"3.9 and up), and `PyOS_InitInterrupts` (3.10). [\\#1348](https://github.com/"
"PyO3/pyo3/pull/1348)"
msgstr ""

#: src/changelog.md:624
msgid ""
"Stop including `Py_TRACE_REFS` config setting automatically if `Py_DEBUG` is "
"set on Python 3.8 and up. [\\#1334](https://github.com/PyO3/pyo3/pull/1334)"
msgstr ""

#: src/changelog.md:625
msgid ""
"Remove `#[deny(warnings)]` attribute (and instead refuse warnings only in "
"CI). [\\#1340](https://github.com/PyO3/pyo3/pull/1340)"
msgstr ""

#: src/changelog.md:626
msgid ""
"Fix deprecation warning for missing `__module__` with `#[pyclass]`. [\\#1343]"
"(https://github.com/PyO3/pyo3/pull/1343)"
msgstr ""

#: src/changelog.md:627
msgid ""
"Correct return type of `PyFrozenSet::empty` to `&PyFrozenSet` (was "
"incorrectly `&PySet`). [\\#1351](https://github.com/PyO3/pyo3/pull/1351)"
msgstr ""

#: src/changelog.md:628
msgid ""
"Fix missing `Py_INCREF` on heap type objects on Python versions before 3.8. "
"[\\#1365](https://github.com/PyO3/pyo3/pull/1365)"
msgstr ""

#: src/changelog.md:630
msgid ""
"[0.13.0](https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0) - 2020-12-22"
msgstr ""

#: src/changelog.md:634
msgid ""
"Drop support for Python 3.5 (as it is now end-of-life). [\\#1250](https://"
"github.com/PyO3/pyo3/pull/1250)"
msgstr ""

#: src/changelog.md:635
msgid ""
"Bump minimum supported Rust version to 1.45. [\\#1272](https://github.com/"
"PyO3/pyo3/pull/1272)"
msgstr ""

#: src/changelog.md:636
msgid ""
"Bump indoc dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:637
msgid ""
"Bump paste dependency to 1.0. [\\#1272](https://github.com/PyO3/pyo3/"
"pull/1272)"
msgstr ""

#: src/changelog.md:638
msgid ""
"Rename internal crates `pyo3cls` and `pyo3-derive-backend` to `pyo3-macros` "
"and `pyo3-macros-backend` respectively. [\\#1317](https://github.com/PyO3/"
"pyo3/pull/1317)"
msgstr ""

#: src/changelog.md:642
msgid ""
"Add support for building for CPython limited API. Opting-in to the limited "
"API enables a single extension wheel built with PyO3 to be installable on "
"multiple Python versions. This required a few minor changes to runtime "
"behaviour of of PyO3 `#[pyclass]` types. See the migration guide for full "
"details. [\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:643
msgid ""
"Add feature flags `abi3-py36`, `abi3-py37`, `abi3-py38` etc. to set the "
"minimum Python version when using the limited API. [\\#1263](https://github."
"com/PyO3/pyo3/pull/1263)"
msgstr ""

#: src/changelog.md:644
msgid ""
"Add argument names to `TypeError` messages generated by pymethod wrappers. "
"[\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:645
msgid ""
"Add FFI definitions for PEP 587 \"Python Initialization Configuration\". "
"[\\#1247](https://github.com/PyO3/pyo3/pull/1247)"
msgstr ""

#: src/changelog.md:646
msgid ""
"Add FFI definitions for `PyEval_SetProfile` and `PyEval_SetTrace`. [\\#1255]"
"(https://github.com/PyO3/pyo3/pull/1255)"
msgstr ""

#: src/changelog.md:647
msgid ""
"Add FFI definitions for context.h functions (`PyContext_New`, etc). [\\#1259]"
"(https://github.com/PyO3/pyo3/pull/1259)"
msgstr ""

#: src/changelog.md:648
msgid ""
"Add `PyAny::is_instance` method. [\\#1276](https://github.com/PyO3/pyo3/"
"pull/1276)"
msgstr ""

#: src/changelog.md:649
msgid ""
"Add support for conversion between `char` and `PyString`. [\\#1282](https://"
"github.com/PyO3/pyo3/pull/1282)"
msgstr ""

#: src/changelog.md:650
msgid ""
"Add FFI definitions for `PyBuffer_SizeFromFormat`, `PyObject_LengthHint`, "
"`PyObject_CallNoArgs`, `PyObject_CallOneArg`, `PyObject_CallMethodNoArgs`, "
"`PyObject_CallMethodOneArg`, `PyObject_VectorcallDict`, and "
"`PyObject_VectorcallMethod`. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1287)"
msgstr ""

#: src/changelog.md:651
msgid ""
"Add conversions between `u128`/`i128` and `PyLong` for PyPy. [\\#1310]"
"(https://github.com/PyO3/pyo3/pull/1310)"
msgstr ""

#: src/changelog.md:652
msgid ""
"Add `Python::version` and `Python::version_info` to get the running "
"interpreter version. [\\#1322](https://github.com/PyO3/pyo3/pull/1322)"
msgstr ""

#: src/changelog.md:653
msgid ""
"Add conversions for tuples of length 10, 11, and 12. [\\#1454](https://"
"github.com/PyO3/pyo3/pull/1454)"
msgstr ""

#: src/changelog.md:657
msgid ""
"Change return type of `PyType::name` from `Cow<str>` to `PyResult<&str>`. "
"[\\#1152](https://github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:658
msgid ""
"`#[pyclass(subclass)]` is now required for subclassing from Rust (was "
"previously just required for subclassing from Python). [\\#1152](https://"
"github.com/PyO3/pyo3/pull/1152)"
msgstr ""

#: src/changelog.md:659
msgid ""
"Change `PyIterator` to be consistent with other native types: it is now used "
"as `&PyIterator` instead of `PyIterator<'a>`. [\\#1176](https://github.com/"
"PyO3/pyo3/pull/1176)"
msgstr ""

#: src/changelog.md:660
msgid ""
"Change formatting of `PyDowncastError` messages to be closer to Python's "
"builtin error messages. [\\#1212](https://github.com/PyO3/pyo3/pull/1212)"
msgstr ""

#: src/changelog.md:661
msgid ""
"Change `Debug` and `Display` impls for `PyException` to be consistent with "
"`PyAny`. [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:662
msgid ""
"Change `Debug` impl of `PyErr` to output more helpful information (acquiring "
"the GIL if necessary). [\\#1275](https://github.com/PyO3/pyo3/pull/1275)"
msgstr ""

#: src/changelog.md:663
msgid ""
"Rename `PyTypeInfo::is_instance` and `PyTypeInfo::is_exact_instance` to "
"`PyTypeInfo::is_type_of` and `PyTypeInfo::is_exact_type_of`. [\\#1278]"
"(https://github.com/PyO3/pyo3/pull/1278)"
msgstr ""

#: src/changelog.md:664
msgid ""
"Optimize `PyAny::call0`, `Py::call0` and `PyAny::call_method0` and `Py::"
"call_method0` on Python 3.9 and up. [\\#1287](https://github.com/PyO3/pyo3/"
"pull/1285)"
msgstr ""

#: src/changelog.md:665
msgid ""
"Require double-quotes for pyclass name argument e.g `#[pyclass(name = "
"\"MyClass\")]`. [\\#1303](https://github.com/PyO3/pyo3/pull/1303)"
msgstr ""

#: src/changelog.md:669
msgid ""
"Deprecate `Python::is_instance`, `Python::is_subclass`, `Python::release`, "
"and `Python::xdecref`. [\\#1292](https://github.com/PyO3/pyo3/pull/1292)"
msgstr ""

#: src/changelog.md:673
msgid ""
"Remove deprecated ffi definitions `PyUnicode_AsUnicodeCopy`, "
"`PyUnicode_GetMax`, `_Py_CheckRecursionLimit`, `PyObject_AsCharBuffer`, "
"`PyObject_AsReadBuffer`, `PyObject_CheckReadBuffer` and "
"`PyObject_AsWriteBuffer`, which will be removed in Python 3.10. [\\#1217]"
"(https://github.com/PyO3/pyo3/pull/1217)"
msgstr ""

#: src/changelog.md:674
msgid ""
"Remove unused `python3` feature. [\\#1235](https://github.com/PyO3/pyo3/"
"pull/1235)"
msgstr ""

#: src/changelog.md:678
msgid ""
"Fix missing field in `PyCodeObject` struct (`co_posonlyargcount`) - caused "
"invalid access to other fields in Python >3.7. [\\#1260](https://github.com/"
"PyO3/pyo3/pull/1260)"
msgstr ""

#: src/changelog.md:679
msgid ""
"Fix building for `x86_64-unknown-linux-musl` target from `x86_64-unknown-"
"linux-gnu` host. [\\#1267](https://github.com/PyO3/pyo3/pull/1267)"
msgstr ""

#: src/changelog.md:680
msgid ""
"Fix `#[text_signature]` interacting badly with rust `r#raw_identifiers`. "
"[\\#1286](https://github.com/PyO3/pyo3/pull/1286)"
msgstr ""

#: src/changelog.md:681
msgid ""
"Fix FFI definitions for `PyObject_Vectorcall` and `PyVectorcall_Call`. "
"[\\#1287](https://github.com/PyO3/pyo3/pull/1285)"
msgstr ""

#: src/changelog.md:682
msgid ""
"Fix building with Anaconda python inside a virtualenv. [\\#1290](https://"
"github.com/PyO3/pyo3/pull/1290)"
msgstr ""

#: src/changelog.md:683
msgid ""
"Fix definition of opaque FFI types. [\\#1312](https://github.com/PyO3/pyo3/"
"pull/1312)"
msgstr ""

#: src/changelog.md:684
msgid ""
"Fix using custom error type in pyclass `#[new]` methods. [\\#1319](https://"
"github.com/PyO3/pyo3/pull/1319)"
msgstr ""

#: src/changelog.md:686
msgid ""
"[0.12.4](https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4) - 2020-11-28"
msgstr ""

#: src/changelog.md:690
msgid ""
"Fix reference count bug in implementation of `From<Py<T>>` for `PyObject`, a "
"regression introduced in PyO3 0.12. [\\#1297](https://github.com/PyO3/pyo3/"
"pull/1297)"
msgstr ""

#: src/changelog.md:692
msgid ""
"[0.12.3](https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3) - 2020-10-12"
msgstr ""

#: src/changelog.md:696
msgid ""
"Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal "
"update to paste 1.0 which was done in PyO3 0.12.2. [\\#1234](https://github."
"com/PyO3/pyo3/pull/1234)"
msgstr ""

#: src/changelog.md:698
msgid ""
"[0.12.2](https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2) - 2020-10-12"
msgstr ""

#: src/changelog.md:702
msgid ""
"Add support for keyword-only arguments without default values in "
"`#[pyfunction]`. [\\#1209](https://github.com/PyO3/pyo3/pull/1209)"
msgstr ""

#: src/changelog.md:703
msgid ""
"Add `Python::check_signals` as a safe a wrapper for `PyErr_CheckSignals`. "
"[\\#1214](https://github.com/PyO3/pyo3/pull/1214)"
msgstr ""

#: src/changelog.md:707
msgid ""
"Fix invalid document for protocol methods. [\\#1169](https://github.com/PyO3/"
"pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:708
msgid ""
"Hide docs of PyO3 private implementation details in `pyo3::class::methods`. "
"[\\#1169](https://github.com/PyO3/pyo3/pull/1169)"
msgstr ""

#: src/changelog.md:709
msgid ""
"Fix unnecessary rebuild on PATH changes when the python interpreter is "
"provided by PYO3_PYTHON. [\\#1231](https://github.com/PyO3/pyo3/pull/1231)"
msgstr ""

#: src/changelog.md:711
msgid ""
"[0.12.1](https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1) - 2020-09-16"
msgstr ""

#: src/changelog.md:715
msgid ""
"Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust "
"toolchain. [\\#1179](https://github.com/PyO3/pyo3/pull/1179)"
msgstr ""

#: src/changelog.md:716
msgid ""
"Fix building on platforms where `c_char` is `u8`. [\\#1182](https://github."
"com/PyO3/pyo3/pull/1182)"
msgstr ""

#: src/changelog.md:718
msgid ""
"[0.12.0](https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0) - 2020-09-12"
msgstr ""

#: src/changelog.md:722
msgid ""
"Add FFI definitions `Py_FinalizeEx`, `PyOS_getsig`, and `PyOS_setsig`. "
"[\\#1021](https://github.com/PyO3/pyo3/pull/1021)"
msgstr ""

#: src/changelog.md:723
msgid ""
"Add `PyString::to_str` for accessing `PyString` as `&str`. [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:724
msgid ""
"Add `Python::with_gil` for executing a closure with the Python GIL. [\\#1037]"
"(https://github.com/PyO3/pyo3/pull/1037)"
msgstr ""

#: src/changelog.md:725
msgid ""
"Add type information to failures in `PyAny::downcast`. [\\#1050](https://"
"github.com/PyO3/pyo3/pull/1050)"
msgstr ""

#: src/changelog.md:726
msgid ""
"Implement `Debug` for `PyIterator`. [\\#1051](https://github.com/PyO3/pyo3/"
"pull/1051)"
msgstr ""

#: src/changelog.md:727
msgid ""
"Add `PyBytes::new_with` and `PyByteArray::new_with` for initialising `bytes` "
"and `bytearray` objects using a closure. [\\#1074](https://github.com/PyO3/"
"pyo3/pull/1074)"
msgstr ""

#: src/changelog.md:728
msgid ""
"Add `#[derive(FromPyObject)]` macro for enums and structs. [\\#1065](https://"
"github.com/PyO3/pyo3/pull/1065)"
msgstr ""

#: src/changelog.md:729
msgid ""
"Add `Py::as_ref` and `Py::into_ref` for converting `Py<T>` to `&T`. [\\#1098]"
"(https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:730
msgid ""
"Add ability to return `Result` types other than `PyResult` from "
"`#[pyfunction]`, `#[pymethod]` and `#[pyproto]` functions. [\\#1106](https://"
"github.com/PyO3/pyo3/pull/1118)."
msgstr ""

#: src/changelog.md:731
msgid ""
"Implement `ToPyObject`, `IntoPy`, and `FromPyObject` for [hashbrown](https://"
"crates.io/crates/hashbrown)'s `HashMap` and `HashSet` types (requires the "
"`hashbrown` feature). [\\#1114](https://github.com/PyO3/pyo3/pull/1114)"
msgstr ""

#: src/changelog.md:732
msgid ""
"Add `#[pyfunction(pass_module)]` and `#[pyfn(pass_module)]` to pass the "
"module object as the first function argument. [\\#1143](https://github.com/"
"PyO3/pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:733
msgid ""
"Add `PyModule::add_function` and `PyModule::add_submodule` as typed "
"alternatives to `PyModule::add_wrapped`. [\\#1143](https://github.com/PyO3/"
"pyo3/pull/1143)"
msgstr ""

#: src/changelog.md:734
msgid ""
"Add native `PyCFunction` and `PyFunction` types. [\\#1163](https://github."
"com/PyO3/pyo3/pull/1163)"
msgstr ""

#: src/changelog.md:738
msgid ""
"Rework exception types: [\\#1024](https://github.com/PyO3/pyo3/pull/1024) "
"[\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:739
msgid ""
"Rename exception types from e.g. `RuntimeError` to `PyRuntimeError`. The old "
"names continue to exist but are deprecated."
msgstr ""

#: src/changelog.md:740
msgid ""
"Exception objects are now accessible as `&T` or `Py<T>`, just like other "
"Python-native types."
msgstr ""

#: src/changelog.md:741
msgid "Rename `PyException::py_err` to `PyException::new_err`."
msgstr ""

#: src/changelog.md:742
msgid "Rename `PyUnicodeDecodeErr::new_err` to `PyUnicodeDecodeErr::new`."
msgstr ""

#: src/changelog.md:743
msgid "Remove `PyStopIteration::stop_iteration`."
msgstr ""

#: src/changelog.md:744
msgid ""
"Require `T: Send` for the return value `T` of `Python::allow_threads`. "
"[\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:745
msgid ""
"Rename `PYTHON_SYS_EXECUTABLE` to `PYO3_PYTHON`. The old name will continue "
"to work (undocumented) but will be removed in a future release. [\\#1039]"
"(https://github.com/PyO3/pyo3/pull/1039)"
msgstr ""

#: src/changelog.md:746
msgid ""
"Remove `unsafe` from signature of `PyType::as_type_ptr`. [\\#1047](https://"
"github.com/PyO3/pyo3/pull/1047)"
msgstr ""

#: src/changelog.md:747
msgid ""
"Change return type of `PyIterator::from_object` to `PyResult<PyIterator>` "
"(was `Result<PyIterator, PyDowncastError>`). [\\#1051](https://github.com/"
"PyO3/pyo3/pull/1051)"
msgstr ""

#: src/changelog.md:748
msgid ""
"`IntoPy` is no longer implied by `FromPy`. [\\#1063](https://github.com/PyO3/"
"pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:749
msgid ""
"Change `PyObject` to be a type alias for `Py<PyAny>`. [\\#1063](https://"
"github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:750
msgid ""
"Rework `PyErr` to be compatible with the `std::error::Error` trait: [\\#1067]"
"(https://github.com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/"
"pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:751
msgid ""
"Implement `Display`, `Error`, `Send` and `Sync` for `PyErr` and "
"`PyErrArguments`."
msgstr ""

#: src/changelog.md:752
msgid "Add `PyErr::instance` for accessing `PyErr` as `&PyBaseException`."
msgstr ""

#: src/changelog.md:753
msgid ""
"`PyErr`'s fields are now an implementation detail. The equivalent values can "
"be accessed with `PyErr::ptype`, `PyErr::pvalue` and `PyErr::ptraceback`."
msgstr ""

#: src/changelog.md:754
msgid ""
"Change receiver of `PyErr::print` and `PyErr::print_and_set_sys_last_vars` "
"to `&self` (was `self`)."
msgstr ""

#: src/changelog.md:755
msgid ""
"Remove `PyErrValue`, `PyErr::from_value`, `PyErr::into_normalized`, and "
"`PyErr::normalize`."
msgstr ""

#: src/changelog.md:756
msgid "Remove `PyException::into`."
msgstr ""

#: src/changelog.md:757
msgid "Remove `Into<PyResult<T>>` for `PyErr` and `PyException`."
msgstr ""

#: src/changelog.md:758
msgid ""
"Change methods generated by `#[pyproto]` to return `NotImplemented` if "
"Python should try a reversed operation. #[1072](https://github.com/PyO3/pyo3/"
"pull/1072)"
msgstr ""

#: src/changelog.md:759
msgid ""
"Change argument to `PyModule::add` to `impl IntoPy<PyObject>` (was `impl "
"ToPyObject`). #[1124](https://github.com/PyO3/pyo3/pull/1124)"
msgstr ""

#: src/changelog.md:763
msgid ""
"Remove many exception and `PyErr` APIs; see the \"changed\" section above. "
"[\\#1024](https://github.com/PyO3/pyo3/pull/1024) [\\#1067](https://github."
"com/PyO3/pyo3/pull/1067) [\\#1115](https://github.com/PyO3/pyo3/pull/1115)"
msgstr ""

#: src/changelog.md:764
msgid ""
"Remove `PyString::to_string` (use new `PyString::to_str`). [\\#1023](https://"
"github.com/PyO3/pyo3/pull/1023)"
msgstr ""

#: src/changelog.md:765
msgid ""
"Remove `PyString::as_bytes`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:766
msgid ""
"Remove `Python::register_any`. [\\#1023](https://github.com/PyO3/pyo3/"
"pull/1023)"
msgstr ""

#: src/changelog.md:767
msgid ""
"Remove `GILGuard::acquire` from the public API. Use `Python::acquire_gil` or "
"`Python::with_gil`. [\\#1036](https://github.com/PyO3/pyo3/pull/1036)"
msgstr ""

#: src/changelog.md:768
msgid ""
"Remove the `FromPy` trait. [\\#1063](https://github.com/PyO3/pyo3/pull/1063)"
msgstr ""

#: src/changelog.md:769
msgid ""
"Remove the `AsPyRef` trait. [\\#1098](https://github.com/PyO3/pyo3/pull/1098)"
msgstr ""

#: src/changelog.md:773
msgid ""
"Correct FFI definitions `Py_SetProgramName` and `Py_SetPythonHome` to take "
"`*const` arguments (was `*mut`). [\\#1021](https://github.com/PyO3/pyo3/"
"pull/1021)"
msgstr ""

#: src/changelog.md:774
msgid ""
"Fix `FromPyObject` for `num_bigint::BigInt` for Python objects with an "
"`__index__` method. [\\#1027](https://github.com/PyO3/pyo3/pull/1027)"
msgstr ""

#: src/changelog.md:775
msgid ""
"Correct FFI definition `_PyLong_AsByteArray` to take `*mut c_uchar` argument "
"(was `*const c_uchar`). [\\#1029](https://github.com/PyO3/pyo3/pull/1029)"
msgstr ""

#: src/changelog.md:776
msgid ""
"Fix segfault with `#[pyclass(dict, unsendable)]`. [\\#1058](https://github."
"com/PyO3/pyo3/pull/1058) [\\#1059](https://github.com/PyO3/pyo3/pull/1059)"
msgstr ""

#: src/changelog.md:777
msgid ""
"Fix using `&Self` as an argument type for functions in a `#[pymethods]` "
"block. [\\#1071](https://github.com/PyO3/pyo3/pull/1071)"
msgstr ""

#: src/changelog.md:778
msgid ""
"Fix best-effort build against PyPy 3.6. [\\#1092](https://github.com/PyO3/"
"pyo3/pull/1092)"
msgstr ""

#: src/changelog.md:779
msgid ""
"Fix many cases of lifetime elision in `#[pyproto]` implementations. [\\#1093]"
"(https://github.com/PyO3/pyo3/pull/1093)"
msgstr ""

#: src/changelog.md:780
msgid ""
"Fix detection of Python build configuration when cross-compiling. [\\#1095]"
"(https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:781
msgid ""
"Always link against libpython on android with the `extension-module` "
"feature. [\\#1095](https://github.com/PyO3/pyo3/pull/1095)"
msgstr ""

#: src/changelog.md:782
msgid ""
"Fix the `+` operator not trying `__radd__` when both `__add__` and "
"`__radd__` are defined in `PyNumberProtocol` (and similar for all other "
"reversible operators). [\\#1107](https://github.com/PyO3/pyo3/pull/1107)"
msgstr ""

#: src/changelog.md:783
msgid ""
"Fix building with Anaconda python. [\\#1175](https://github.com/PyO3/pyo3/"
"pull/1175)"
msgstr ""

#: src/changelog.md:785
msgid ""
"[0.11.1](https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1) - 2020-06-30"
msgstr ""

#: src/changelog.md:789
msgid ""
"`#[pyclass(unsendable)]`. [\\#1009](https://github.com/PyO3/pyo3/pull/1009)"
msgstr ""

#: src/changelog.md:793
msgid ""
"Update `parking_lot` dependency to `0.11`. [\\#1010](https://github.com/PyO3/"
"pyo3/pull/1010)"
msgstr ""

#: src/changelog.md:795
msgid ""
"[0.11.0](https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0) - 2020-06-28"
msgstr ""

#: src/changelog.md:799
msgid ""
"Support stable versions of Rust (>=1.39). [\\#969](https://github.com/PyO3/"
"pyo3/pull/969)"
msgstr ""

#: src/changelog.md:800
msgid ""
"Add FFI definition `PyObject_AsFileDescriptor`. [\\#938](https://github.com/"
"PyO3/pyo3/pull/938)"
msgstr ""

#: src/changelog.md:801
msgid ""
"Add `PyByteArray::data`, `PyByteArray::as_bytes`, and `PyByteArray::"
"as_bytes_mut`. [\\#967](https://github.com/PyO3/pyo3/pull/967)"
msgstr ""

#: src/changelog.md:802
msgid ""
"Add `GILOnceCell` to use in situations where `lazy_static` or `once_cell` "
"can deadlock. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:803
msgid ""
"Add `Py::borrow`, `Py::borrow_mut`, `Py::try_borrow`, and `Py::"
"try_borrow_mut` for accessing `#[pyclass]` values. [\\#976](https://github."
"com/PyO3/pyo3/pull/976)"
msgstr ""

#: src/changelog.md:804
msgid ""
"Add `IterNextOutput` and `IterANextOutput` for returning from `__next__` / "
"`__anext__`. [\\#997](https://github.com/PyO3/pyo3/pull/997)"
msgstr ""

#: src/changelog.md:808
msgid ""
"Simplify internals of `#[pyo3(get)]` attribute. (Remove the hidden API "
"`GetPropertyValue`.) [\\#934](https://github.com/PyO3/pyo3/pull/934)"
msgstr ""

#: src/changelog.md:809
msgid ""
"Call `Py_Finalize` at exit to flush buffers, etc. [\\#943](https://github."
"com/PyO3/pyo3/pull/943)"
msgstr ""

#: src/changelog.md:810
msgid ""
"Add type parameter to PyBuffer. #[951](https://github.com/PyO3/pyo3/pull/951)"
msgstr ""

#: src/changelog.md:811
msgid ""
"Require `Send` bound for `#[pyclass]`. [\\#966](https://github.com/PyO3/pyo3/"
"pull/966)"
msgstr ""

#: src/changelog.md:812
msgid ""
"Add `Python` argument to most methods on `PyObject` and `Py<T>` to ensure "
"GIL safety. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:813
msgid ""
"Change signature of `PyTypeObject::type_object` - now takes `Python` "
"argument and returns `&PyType`. [\\#970](https://github.com/PyO3/pyo3/"
"pull/970)"
msgstr ""

#: src/changelog.md:814
msgid ""
"Change return type of `PyTuple::slice` and `PyTuple::split_from` from "
"`Py<PyTuple>` to `&PyTuple`. [\\#970](https://github.com/PyO3/pyo3/pull/970)"
msgstr ""

#: src/changelog.md:815
msgid ""
"Change return type of `PyTuple::as_slice` to `&[&PyAny]`. [\\#971](https://"
"github.com/PyO3/pyo3/pull/971)"
msgstr ""

#: src/changelog.md:816
msgid ""
"Rename `PyTypeInfo::type_object` to `type_object_raw`, and add `Python` "
"argument. [\\#975](https://github.com/PyO3/pyo3/pull/975)"
msgstr ""

#: src/changelog.md:817
msgid ""
"Update `num-complex` optional dependendency from `0.2` to `0.3`. [\\#977]"
"(https://github.com/PyO3/pyo3/pull/977)"
msgstr ""

#: src/changelog.md:818
msgid ""
"Update `num-bigint` optional dependendency from `0.2` to `0.3`. [\\#978]"
"(https://github.com/PyO3/pyo3/pull/978)"
msgstr ""

#: src/changelog.md:819
msgid ""
"`#[pyproto]` is re-implemented without specialization. [\\#961](https://"
"github.com/PyO3/pyo3/pull/961)"
msgstr ""

#: src/changelog.md:820
msgid ""
"`PyClassAlloc::alloc` is renamed to `PyClassAlloc::new`. [\\#990](https://"
"github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:821
msgid ""
"`#[pyproto]` methods can now have return value `T` or `PyResult<T>` "
"(previously only `PyResult<T>` was supported). [\\#996](https://github.com/"
"PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:822
msgid ""
"`#[pyproto]` methods can now skip annotating the return type if it is `()`. "
"[\\#998](https://github.com/PyO3/pyo3/pull/998)"
msgstr ""

#: src/changelog.md:826
msgid ""
"Remove `ManagedPyRef` (unused, and needs specialization) [\\#930](https://"
"github.com/PyO3/pyo3/pull/930)"
msgstr ""

#: src/changelog.md:830
msgid ""
"Fix passing explicit `None` to `Option<T>` argument `#[pyfunction]` with a "
"default value. [\\#936](https://github.com/PyO3/pyo3/pull/936)"
msgstr ""

#: src/changelog.md:831
msgid ""
"Fix `PyClass.__new__`'s not respecting subclasses when inherited by a Python "
"class. [\\#990](https://github.com/PyO3/pyo3/pull/990)"
msgstr ""

#: src/changelog.md:832
msgid ""
"Fix returning `Option<T>` from `#[pyproto]` methods. [\\#996](https://github."
"com/PyO3/pyo3/pull/996)"
msgstr ""

#: src/changelog.md:833
msgid ""
"Fix accepting `PyRef<Self>` and `PyRefMut<Self>` to `#[getter]` and "
"`#[setter]` methods. [\\#999](https://github.com/PyO3/pyo3/pull/999)"
msgstr ""

#: src/changelog.md:835
msgid ""
"[0.10.1](https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1) - 2020-05-14"
msgstr ""

#: src/changelog.md:839
msgid ""
"Fix deadlock in `Python::acquire_gil` after dropping a `PyObject` or "
"`Py<T>`. [\\#924](https://github.com/PyO3/pyo3/pull/924)"
msgstr ""

#: src/changelog.md:841
msgid ""
"[0.10.0](https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0) - 2020-05-13"
msgstr ""

#: src/changelog.md:845
msgid ""
"Add FFI definition `_PyDict_NewPresized`. [\\#849](https://github.com/PyO3/"
"pyo3/pull/849)"
msgstr ""

#: src/changelog.md:846
msgid ""
"Implement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`. [\\#864](https://"
"github.com/PyO3/pyo3/pull/864)"
msgstr ""

#: src/changelog.md:847
msgid ""
"Add `PyAny::dir` method. [\\#886](https://github.com/PyO3/pyo3/pull/886)"
msgstr ""

#: src/changelog.md:848
msgid ""
"Gate macros behind a `macros` feature (enabled by default). [\\#897](https://"
"github.com/PyO3/pyo3/pull/897)"
msgstr ""

#: src/changelog.md:849
msgid ""
"Add ability to define class attributes using `#[classattr]` on functions in "
"`#[pymethods]`. [\\#905](https://github.com/PyO3/pyo3/pull/905)"
msgstr ""

#: src/changelog.md:850
msgid ""
"Implement `Clone` for `PyObject` and `Py<T>`. [\\#908](https://github.com/"
"PyO3/pyo3/pull/908)"
msgstr ""

#: src/changelog.md:851
msgid ""
"Implement `Deref<Target = PyAny>` for all builtin types. (`PyList`, "
"`PyTuple`, `PyDict` etc.) [\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:852
msgid ""
"Implement `Deref<Target = PyAny>` for `PyCell<T>`. [\\#911](https://github."
"com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:853
msgid ""
"Add `#[classattr]` support for associated constants in `#[pymethods]`. "
"[\\#914](https://github.com/PyO3/pyo3/pull/914)"
msgstr ""

#: src/changelog.md:857
msgid ""
"Panics will now be raised as a Python `PanicException`. [\\#797](https://"
"github.com/PyO3/pyo3/pull/797)"
msgstr ""

#: src/changelog.md:858
msgid ""
"Change `PyObject` and `Py<T>` reference counts to decrement immediately upon "
"drop when the GIL is held. [\\#851](https://github.com/PyO3/pyo3/pull/851)"
msgstr ""

#: src/changelog.md:859
msgid ""
"Allow `PyIterProtocol` methods to use either `PyRef` or `PyRefMut` as the "
"receiver type. [\\#856](https://github.com/PyO3/pyo3/pull/856)"
msgstr ""

#: src/changelog.md:860
msgid ""
"Change the implementation of `FromPyObject` for `Py<T>` to apply to a wider "
"range of `T`, including all `T: PyClass`. [\\#880](https://github.com/PyO3/"
"pyo3/pull/880)"
msgstr ""

#: src/changelog.md:861
msgid ""
"Move all methods from the `ObjectProtocol` trait to the `PyAny` struct. "
"[\\#911](https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:862
msgid ""
"Remove need for `#![feature(specialization)]` in crates depending on PyO3. "
"[\\#917](https://github.com/PyO3/pyo3/pull/917)"
msgstr ""

#: src/changelog.md:866
msgid ""
"Remove `PyMethodsProtocol` trait. [\\#889](https://github.com/PyO3/pyo3/"
"pull/889)"
msgstr ""

#: src/changelog.md:867
msgid ""
"Remove `num-traits` dependency. [\\#895](https://github.com/PyO3/pyo3/"
"pull/895)"
msgstr ""

#: src/changelog.md:868
msgid ""
"Remove `ObjectProtocol` trait. [\\#911](https://github.com/PyO3/pyo3/"
"pull/911)"
msgstr ""

#: src/changelog.md:869
msgid ""
"Remove `PyAny::None`. Users should use `Python::None` instead. [\\#911]"
"(https://github.com/PyO3/pyo3/pull/911)"
msgstr ""

#: src/changelog.md:870
msgid ""
"Remove all `*ProtocolImpl` traits. [\\#917](https://github.com/PyO3/pyo3/"
"pull/917)"
msgstr ""

#: src/changelog.md:874
msgid ""
"Fix support for `__radd__` and other `__r*__` methods as implementations for "
"Python mathematical operators. [\\#839](https://github.com/PyO3/pyo3/"
"pull/839)"
msgstr ""

#: src/changelog.md:875
msgid ""
"Fix panics during garbage collection when traversing objects that were "
"already mutably borrowed. [\\#855](https://github.com/PyO3/pyo3/pull/855)"
msgstr ""

#: src/changelog.md:876
msgid ""
"Prevent `&'static` references to Python objects as arguments to "
"`#[pyfunction]` and `#[pymethods]`. [\\#869](https://github.com/PyO3/pyo3/"
"pull/869)"
msgstr ""

#: src/changelog.md:877
msgid ""
"Fix lifetime safety bug with `AsPyRef::as_ref`. [\\#876](https://github.com/"
"PyO3/pyo3/pull/876)"
msgstr ""

#: src/changelog.md:878
msgid ""
"Fix `#[pyo3(get)]` attribute on `Py<T>` fields. [\\#880](https://github.com/"
"PyO3/pyo3/pull/880)"
msgstr ""

#: src/changelog.md:879
msgid ""
"Fix segmentation faults caused by functions such as `PyList::get_item` "
"returning borrowed objects when it was not safe to do so. [\\#890](https://"
"github.com/PyO3/pyo3/pull/890)"
msgstr ""

#: src/changelog.md:880
msgid ""
"Fix segmentation faults caused by nested `Python::acquire_gil` calls "
"creating dangling references. [\\#893](https://github.com/PyO3/pyo3/pull/893)"
msgstr ""

#: src/changelog.md:881
msgid ""
"Fix segmentatation faults when a panic occurs during a call to `Python::"
"allow_threads`. [\\#912](https://github.com/PyO3/pyo3/pull/912)"
msgstr ""

#: src/changelog.md:883
msgid ""
"[0.9.2](https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2) - 2020-04-09"
msgstr ""

#: src/changelog.md:887
msgid ""
"`FromPyObject` implementations for `HashSet` and `BTreeSet`. [\\#842]"
"(https://github.com/PyO3/pyo3/pull/842)"
msgstr ""

#: src/changelog.md:891
msgid ""
"Correctly detect 32bit architecture. [\\#830](https://github.com/PyO3/pyo3/"
"pull/830)"
msgstr ""

#: src/changelog.md:893
msgid ""
"[0.9.1](https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1) - 2020-03-23"
msgstr ""

#: src/changelog.md:897
msgid ""
"Error messages for `#[pyclass]`. [\\#826](https://github.com/PyO3/pyo3/"
"pull/826)"
msgstr ""

#: src/changelog.md:898
msgid ""
"`FromPyObject` implementation for `PySequence`. [\\#827](https://github.com/"
"PyO3/pyo3/pull/827)"
msgstr ""

#: src/changelog.md:900
msgid ""
"[0.9.0](https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0) - 2020-03-19"
msgstr ""

#: src/changelog.md:904
msgid ""
"`PyCell`, which has RefCell-like features. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:905
msgid ""
"`PyClass`, `PyLayout`, `PyClassInitializer`. [\\#683](https://github.com/"
"PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:906
msgid ""
"Implemented `IntoIterator` for `PySet` and `PyFrozenSet`. [\\#716](https://"
"github.com/PyO3/pyo3/pull/716)"
msgstr ""

#: src/changelog.md:907
msgid ""
"`FromPyObject` is now automatically implemented for `T: Clone` pyclasses. "
"[\\#730](https://github.com/PyO3/pyo3/pull/730)"
msgstr ""

#: src/changelog.md:908
msgid ""
"`#[pyo3(get)]` and `#[pyo3(set)]` will now use the Rust doc-comment from the "
"field for the Python property. [\\#755](https://github.com/PyO3/pyo3/"
"pull/755)"
msgstr ""

#: src/changelog.md:909
msgid ""
"`#[setter]` functions may now take an argument of `Pyo3::Python`. [\\#760]"
"(https://github.com/PyO3/pyo3/pull/760)"
msgstr ""

#: src/changelog.md:910
msgid ""
"`PyTypeInfo::BaseLayout` and `PyClass::BaseNativeType`. [\\#770](https://"
"github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:911
msgid "`PyDowncastImpl`. [\\#770](https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:912
msgid ""
"Implement `FromPyObject` and `IntoPy<PyObject>` traits for arrays (up to "
"32). [\\#778](https://github.com/PyO3/pyo3/pull/778)"
msgstr ""

#: src/changelog.md:913
msgid ""
"`migration.md` and `types.md` in the guide. [\\#795](https://github.com/PyO3/"
"pyo3/pull/795), #[802](https://github.com/PyO3/pyo3/pull/802)"
msgstr ""

#: src/changelog.md:914
msgid ""
"`ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}"
"`. #[820](https://github.com/PyO3/pyo3/pull/820)"
msgstr ""

#: src/changelog.md:918
msgid ""
"`#[new]` does not take `PyRawObject` and can return `Self`. [\\#683](https://"
"github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:919
msgid ""
"The blanket implementations for `FromPyObject` for `&T` and `&mut T` are no "
"longer specializable. Implement `PyTryFrom` for your type to control the "
"behavior of `FromPyObject::extract` for your types. [\\#713](https://github."
"com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:920
msgid ""
"The implementation for `IntoPy<U> for T` where `U: FromPy<T>` is no longer "
"specializable. Control the behavior of this via the implementation of "
"`FromPy`. [\\#713](https://github.com/PyO3/pyo3/pull/713)"
msgstr ""

#: src/changelog.md:921
msgid ""
"Use `parking_lot::Mutex` instead of `spin::Mutex`. [\\#734](https://github."
"com/PyO3/pyo3/pull/734)"
msgstr ""

#: src/changelog.md:922
msgid ""
"Bumped minimum Rust version to `1.42.0-nightly 2020-01-21`. [\\#761](https://"
"github.com/PyO3/pyo3/pull/761)"
msgstr ""

#: src/changelog.md:923
msgid ""
"`PyRef` and `PyRefMut` are renewed for `PyCell`. [\\#770](https://github.com/"
"PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:924
msgid ""
"Some new FFI functions for Python 3.8. [\\#784](https://github.com/PyO3/pyo3/"
"pull/784)"
msgstr ""

#: src/changelog.md:925
msgid ""
"`PyAny` is now on the top level module and prelude. [\\#816](https://github."
"com/PyO3/pyo3/pull/816)"
msgstr ""

#: src/changelog.md:929
msgid "`PyRawObject`. [\\#683](https://github.com/PyO3/pyo3/pull/683)"
msgstr ""

#: src/changelog.md:930
msgid "`PyNoArgsFunction`. [\\#741](https://github.com/PyO3/pyo3/pull/741)"
msgstr ""

#: src/changelog.md:931
msgid ""
"`initialize_type`. To set the module name for a `#[pyclass]`, use the "
"`module` argument to the macro. #[751](https://github.com/PyO3/pyo3/pull/751)"
msgstr ""

#: src/changelog.md:932
msgid ""
"`AsPyRef::as_mut/with/with_mut/into_py/into_mut_py`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:933
msgid ""
"`PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked`. [\\#770]"
"(https://github.com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:934
msgid ""
"`Python::mut_from_owned_ptr/mut_from_borrowed_ptr`. [\\#770](https://github."
"com/PyO3/pyo3/pull/770)"
msgstr ""

#: src/changelog.md:935
msgid ""
"`ObjectProtocol::get_base/get_mut_base`. [\\#770](https://github.com/PyO3/"
"pyo3/pull/770)"
msgstr ""

#: src/changelog.md:939
msgid ""
"Fixed unsoundness of subclassing. [\\#683](https://github.com/PyO3/pyo3/"
"pull/683)."
msgstr ""

#: src/changelog.md:940
msgid ""
"Clear error indicator when the exception is handled on the Rust side. "
"[\\#719](https://github.com/PyO3/pyo3/pull/719)"
msgstr ""

#: src/changelog.md:941
msgid ""
"Usage of raw identifiers with `#[pyo3(set)]`. [\\#745](https://github.com/"
"PyO3/pyo3/pull/745)"
msgstr ""

#: src/changelog.md:942
msgid ""
"Usage of `PyObject` with `#[pyo3(get)]`. [\\#760](https://github.com/PyO3/"
"pyo3/pull/760)"
msgstr ""

#: src/changelog.md:943
msgid ""
"`#[pymethods]` used in conjunction with `#[cfg]`. #[769](https://github.com/"
"PyO3/pyo3/pull/769)"
msgstr ""

#: src/changelog.md:944
msgid ""
"`\"*\"` in a `#[pyfunction()]` argument list incorrectly accepting any "
"number of positional arguments (use `args = \"*\"` when this behaviour is "
"desired). #[792](https://github.com/PyO3/pyo3/pull/792)"
msgstr ""

#: src/changelog.md:945
msgid "`PyModule::dict`. #[809](https://github.com/PyO3/pyo3/pull/809)"
msgstr ""

#: src/changelog.md:946
msgid ""
"Fix the case where `DESCRIPTION` is not null-terminated. #[822](https://"
"github.com/PyO3/pyo3/pull/822)"
msgstr ""

#: src/changelog.md:948
msgid "\\[0.8.5\\] - 2020-01-05"
msgstr ""

#: src/changelog.md:952
msgid "Implemented `FromPyObject` for `HashMap` and `BTreeMap`"
msgstr ""

#: src/changelog.md:953
msgid ""
"Support for `#[name = \"foo\"]` attribute for `#[pyfunction]` and in "
"`#[pymethods]`. [\\#692](https://github.com/PyO3/pyo3/pull/692)"
msgstr ""

#: src/changelog.md:955
msgid ""
"[0.8.4](https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5) - 2019-12-14"
msgstr ""

#: src/changelog.md:959
msgid ""
"Support for `#[text_signature]` attribute. [\\#675](https://github.com/PyO3/"
"pyo3/pull/675)"
msgstr ""

#: src/changelog.md:961
msgid ""
"[0.8.3](https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3) - 2019-11-23"
msgstr ""

#: src/changelog.md:965
msgid "`#[init]` is removed. [\\#658](https://github.com/PyO3/pyo3/pull/658)"
msgstr ""

#: src/changelog.md:969
msgid ""
"Now all `&Py~` types have `!Send` bound. [\\#655](https://github.com/PyO3/"
"pyo3/pull/655)"
msgstr ""

#: src/changelog.md:970
msgid ""
"Fix a compile error raised by the stabilization of `!` type. [\\#672]"
"(https://github.com/PyO3/pyo3/issues/672)."
msgstr ""

#: src/changelog.md:972
msgid ""
"[0.8.2](https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2) - 2019-10-27"
msgstr ""

#: src/changelog.md:976
msgid ""
"FFI compatibility for PEP 590 Vectorcall. [\\#641](https://github.com/PyO3/"
"pyo3/pull/641)"
msgstr ""

#: src/changelog.md:980
msgid ""
"Fix PySequenceProtocol::set_item. [\\#624](https://github.com/PyO3/pyo3/"
"pull/624)"
msgstr ""

#: src/changelog.md:981
msgid ""
"Fix a corner case of BigInt::FromPyObject. [\\#630](https://github.com/PyO3/"
"pyo3/pull/630)"
msgstr ""

#: src/changelog.md:982
msgid ""
"Fix index errors in parameter conversion. [\\#631](https://github.com/PyO3/"
"pyo3/pull/631)"
msgstr ""

#: src/changelog.md:983
msgid ""
"Fix handling of invalid utf-8 sequences in `PyString::as_bytes`. [\\#639]"
"(https://github.com/PyO3/pyo3/pull/639) and `PyString::to_string_lossy` "
"[\\#642](https://github.com/PyO3/pyo3/pull/642)."
msgstr ""

#: src/changelog.md:985
msgid ""
"Remove `__contains__` and `__iter__` from PyMappingProtocol. [\\#644]"
"(https://github.com/PyO3/pyo3/pull/644)"
msgstr ""

#: src/changelog.md:986
msgid ""
"Fix proc-macro definition of PySetAttrProtocol. [\\#645](https://github.com/"
"PyO3/pyo3/pull/645)"
msgstr ""

#: src/changelog.md:988
msgid ""
"[0.8.1](https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1) - 2019-10-08"
msgstr ""

#: src/changelog.md:992
msgid ""
"Conversion between [num-bigint](https://github.com/rust-num/num-bigint) and "
"Python int. [\\#608](https://github.com/PyO3/pyo3/pull/608)"
msgstr ""

#: src/changelog.md:996
msgid ""
"Make sure the right Python interpreter is used in OSX builds. [\\#604]"
"(https://github.com/PyO3/pyo3/pull/604)"
msgstr ""

#: src/changelog.md:997
msgid ""
"Patch specialization being broken by Rust 1.40. [\\#614](https://github.com/"
"PyO3/pyo3/issues/614)"
msgstr ""

#: src/changelog.md:998
msgid ""
"Fix a segfault around PyErr. [\\#597](https://github.com/PyO3/pyo3/pull/597)"
msgstr ""

#: src/changelog.md:1000
msgid ""
"[0.8.0](https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0) - 2019-09-16"
msgstr ""

#: src/changelog.md:1004
msgid ""
"`module` argument to `pyclass` macro. [\\#499](https://github.com/PyO3/pyo3/"
"pull/499)"
msgstr ""

#: src/changelog.md:1005
msgid "`py_run!` macro [\\#512](https://github.com/PyO3/pyo3/pull/512)"
msgstr ""

#: src/changelog.md:1006
msgid ""
"Use existing fields and methods before calling custom **getattr**. [\\#505]"
"(https://github.com/PyO3/pyo3/pull/505)"
msgstr ""

#: src/changelog.md:1007
msgid "`PyBytes` can now be indexed just like `Vec<u8>`"
msgstr ""

#: src/changelog.md:1008
msgid "Implement `IntoPy<PyObject>` for `PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:1012
msgid ""
"Implementing the Using the `gc` parameter for `pyclass` (e.g. "
"`#[pyclass(gc)]`) without implementing the `class::PyGCProtocol` trait is "
"now a compile-time error. Failing to implement this trait could lead to "
"segfaults. [\\#532](https://github.com/PyO3/pyo3/pull/532)"
msgstr ""

#: src/changelog.md:1013
msgid ""
"`PyByteArray::data` has been replaced with `PyDataArray::to_vec` because "
"returning a `&[u8]` is unsound. (See [this comment](https://github.com/PyO3/"
"pyo3/issues/373#issuecomment-512332696) for a great write-up for why that "
"was unsound)"
msgstr ""

#: src/changelog.md:1014
msgid "Replace `mashup` with `paste`."
msgstr ""

#: src/changelog.md:1015
msgid ""
"`GILPool` gained a `Python` marker to prevent it from being misused to "
"release Python objects without the GIL held."
msgstr ""

#: src/changelog.md:1019
msgid "`IntoPyObject` was replaced with `IntoPy<PyObject>`"
msgstr ""

#: src/changelog.md:1020
msgid ""
"`#[pyclass(subclass)]` is hidden a `unsound-subclass` feature because it's "
"causing segmentation faults."
msgstr ""

#: src/changelog.md:1024
msgid ""
"More readable error message for generics in pyclass [\\#503](https://github."
"com/PyO3/pyo3/pull/503)"
msgstr ""

#: src/changelog.md:1026
msgid ""
"[0.7.0](https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0) - 2019-05-26"
msgstr ""

#: src/changelog.md:1030
msgid ""
"PyPy support by omerbenamram in [\\#393](https://github.com/PyO3/pyo3/"
"pull/393)"
msgstr ""

#: src/changelog.md:1031
msgid "Have `PyModule` generate an index of its members (`__all__` list)."
msgstr ""

#: src/changelog.md:1032
msgid "Allow `slf: PyRef<T>` for pyclass(#419)"
msgstr ""

#: src/changelog.md:1033
msgid "Allow to use lifetime specifiers in `pymethods`"
msgstr ""

#: src/changelog.md:1034
msgid "Add `marshal` module. [\\#460](https://github.com/PyO3/pyo3/pull/460)"
msgstr ""

#: src/changelog.md:1038
msgid "`Python::run` returns `PyResult<()>` instead of `PyResult<&PyAny>`."
msgstr ""

#: src/changelog.md:1039
msgid ""
"Methods decorated with `#[getter]` and `#[setter]` can now omit wrapping the "
"result type in `PyResult` if they don't raise exceptions."
msgstr ""

#: src/changelog.md:1044
msgid ""
"`type_object::PyTypeObject` has been marked unsafe because breaking the "
"contract `type_object::PyTypeObject::init_type` can lead to UB."
msgstr ""

#: src/changelog.md:1045
msgid ""
"Fixed automatic derive of `PySequenceProtocol` implementation in [\\#423]"
"(https://github.com/PyO3/pyo3/pull/423)."
msgstr ""

#: src/changelog.md:1046
msgid "Capitalization & better wording to README.md."
msgstr ""

#: src/changelog.md:1047
msgid ""
"Docstrings of properties is now properly set using the doc of the "
"`#[getter]` method."
msgstr ""

#: src/changelog.md:1048
msgid ""
"Fixed issues with `pymethods` crashing on doc comments containing double "
"quotes."
msgstr ""

#: src/changelog.md:1049
msgid ""
"`PySet::new` and `PyFrozenSet::new` now return `PyResult<&Py[Frozen]Set>`; "
"exceptions are raised if the items are not hashable."
msgstr ""

#: src/changelog.md:1051
msgid "Fixed building using `venv` on Windows."
msgstr ""

#: src/changelog.md:1052
msgid "`PyTuple::new` now returns `&PyTuple` instead of `Py<PyTuple>`."
msgstr ""

#: src/changelog.md:1053
msgid ""
"Fixed several issues with argument parsing; notable, the `*args` and "
"`**kwargs` tuple/dict now doesn't contain arguments that are otherwise "
"assigned to parameters."
msgstr ""

#: src/changelog.md:1056
msgid ""
"[0.6.0](https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0) - 2019-03-28"
msgstr ""

#: src/changelog.md:1058
msgid "Regressions"
msgstr ""

#: src/changelog.md:1060
msgid ""
"Currently, [\\#341](https://github.com/PyO3/pyo3/issues/341) causes `cargo "
"test` to fail with weird linking errors when the `extension-module` feature "
"is activated. For now you can work around this by making the `extension-"
"module` feature optional and running the tests with `cargo test --no-default-"
"features`:"
msgstr ""

#: src/changelog.md:1062
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.6.0\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/changelog.md:1073
msgid ""
"Added a `wrap_pymodule!` macro similar to the existing `wrap_pyfunction!` "
"macro. Only available on python 3"
msgstr ""

#: src/changelog.md:1074
msgid ""
"Added support for cross compiling (e.g. to arm v7) by mtp401 in [\\#327]"
"(https://github.com/PyO3/pyo3/pull/327). See the \"Cross Compiling\" section "
"in the \"Building and Distribution\" chapter of the guide for more details."
msgstr ""

#: src/changelog.md:1075
msgid ""
"The `PyRef` and `PyRefMut` types, which allow to differentiate between an "
"instance of a rust struct on the rust heap and an instance that is embedded "
"inside a python object. By kngwyu in [\\#335](https://github.com/PyO3/pyo3/"
"pull/335)"
msgstr ""

#: src/changelog.md:1076
msgid ""
"Added `FromPy<T>` and `IntoPy<T>` which are equivalent to `From<T>` and "
"`Into<T>` except that they require a gil token."
msgstr ""

#: src/changelog.md:1077
msgid ""
"Added `ManagedPyRef`, which should eventually replace `ToBorrowedObject`."
msgstr ""

#: src/changelog.md:1081
msgid "Renamed `PyObjectRef` to `PyAny` in #388"
msgstr ""

#: src/changelog.md:1082
msgid ""
"Renamed `add_function` to `add_wrapped` as it now also supports modules."
msgstr ""

#: src/changelog.md:1083
msgid "Renamed `#[pymodinit]` to `#[pymodule]`"
msgstr ""

#: src/changelog.md:1084
msgid "`py.init(|| value)` becomes `Py::new(value)`"
msgstr ""

#: src/changelog.md:1085
msgid "`py.init_ref(|| value)` becomes `PyRef::new(value)`"
msgstr ""

#: src/changelog.md:1086
msgid "`py.init_mut(|| value)` becomes `PyRefMut::new(value)`."
msgstr ""

#: src/changelog.md:1087
msgid ""
"`PyRawObject::init` is now infallible, e.g. it returns `()` instead of "
"`PyResult<()>`."
msgstr ""

#: src/changelog.md:1088
msgid ""
"Renamed `py_exception!` to `create_exception!` and refactored the error "
"macros."
msgstr ""

#: src/changelog.md:1089
msgid "Renamed `wrap_function!` to `wrap_pyfunction!`"
msgstr ""

#: src/changelog.md:1090
msgid "Renamed `#[prop(get, set)]` to `#[pyo3(get, set)]`"
msgstr ""

#: src/changelog.md:1091
msgid "`#[pyfunction]` now supports the same arguments as `#[pyfn()]`"
msgstr ""

#: src/changelog.md:1092
msgid "Some macros now emit proper spanned errors instead of panics."
msgstr ""

#: src/changelog.md:1093
msgid "Migrated to the 2018 edition"
msgstr ""

#: src/changelog.md:1094
msgid "`crate::types::exceptions` moved to `crate::exceptions`"
msgstr ""

#: src/changelog.md:1095
msgid "Replace `IntoPyTuple` with `IntoPy<Py<PyTuple>>`."
msgstr ""

#: src/changelog.md:1096
msgid "`IntoPyPointer` and `ToPyPointer` moved into the crate root."
msgstr ""

#: src/changelog.md:1097
msgid "`class::CompareOp` moved into `class::basic::CompareOp`"
msgstr ""

#: src/changelog.md:1098
msgid ""
"PyTypeObject is now a direct subtrait PyTypeCreate, removing the old "
"cyclical implementation in [\\#350](https://github.com/PyO3/pyo3/pull/350)"
msgstr ""

#: src/changelog.md:1099
msgid ""
"Add `PyList::{sort, reverse}` by chr1sj0nes in [\\#357](https://github.com/"
"PyO3/pyo3/pull/357) and [\\#358](https://github.com/PyO3/pyo3/pull/358)"
msgstr ""

#: src/changelog.md:1100
msgid "Renamed the `typeob` module to `type_object`"
msgstr ""

#: src/changelog.md:1104
msgid ""
"`PyToken` was removed due to unsoundness (See [\\#94](https://github.com/"
"PyO3/pyo3/issues/94))."
msgstr ""

#: src/changelog.md:1105
msgid "Removed the unnecessary type parameter from `PyObjectAlloc`"
msgstr ""

#: src/changelog.md:1106
msgid "`NoArgs`. Just use an empty tuple"
msgstr ""

#: src/changelog.md:1107
msgid ""
"`PyObjectWithGIL`. `PyNativeType` is sufficient now that PyToken is removed."
msgstr ""

#: src/changelog.md:1111
msgid ""
"A soudness hole where every instances of a `#[pyclass]` struct was "
"considered to be part of a python object, even though you can create "
"instances that are not part of the python heap. This was fixed through "
"`PyRef` and `PyRefMut`."
msgstr ""

#: src/changelog.md:1112
msgid "Fix kwargs support in [\\#328](https://github.com/PyO3/pyo3/pull/328)."
msgstr ""

#: src/changelog.md:1113
msgid ""
"Add full support for `__dict__` in [\\#403](https://github.com/PyO3/pyo3/"
"pull/403)."
msgstr ""

#: src/changelog.md:1115
msgid ""
"[0.5.3](https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3) - 2019-01-04"
msgstr ""

#: src/changelog.md:1119
msgid ""
"Fix memory leak in ArrayList by kngwyu [\\#316](https://github.com/PyO3/pyo3/"
"pull/316)"
msgstr ""

#: src/changelog.md:1121
msgid ""
"[0.5.2](https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.2) - 2018-11-25"
msgstr ""

#: src/changelog.md:1125
msgid ""
"Fix undeterministic segfaults when creating many objects by kngwyu in "
"[\\#281](https://github.com/PyO3/pyo3/pull/281)"
msgstr ""

#: src/changelog.md:1127
msgid "\\[0.5.1\\] - 2018-11-24"
msgstr ""

#: src/changelog.md:1129
msgid "Yanked"
msgstr ""

#: src/changelog.md:1131
msgid ""
"[0.5.0](https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0) - 2018-11-11"
msgstr ""

#: src/changelog.md:1135
msgid "`#[pyclass]` objects can now be returned from rust functions"
msgstr ""

#: src/changelog.md:1136
msgid ""
"`PyComplex` by kngwyu in [\\#226](https://github.com/PyO3/pyo3/pull/226)"
msgstr ""

#: src/changelog.md:1137
msgid "`PyDict::from_sequence`, equivalent to `dict([(key, val), ...])`"
msgstr ""

#: src/changelog.md:1138
msgid ""
"Bindings for the `datetime` standard library types: `PyDate`, `PyTime`, "
"`PyDateTime`, `PyTzInfo`, `PyDelta` with associated `ffi` types, by pganssle "
"[\\#200](https://github.com/PyO3/pyo3/pull/200)."
msgstr ""

#: src/changelog.md:1139
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` now have an `as_bytes` method that "
"returns `&[u8]`."
msgstr ""

#: src/changelog.md:1140
msgid ""
"`PyObjectProtocol::get_type_ptr` by ijl in [\\#242](https://github.com/PyO3/"
"pyo3/pull/242)"
msgstr ""

#: src/changelog.md:1144
msgid ""
"Removes the types from the root module and the prelude. They now live in "
"`pyo3::types` instead."
msgstr ""

#: src/changelog.md:1145
msgid ""
"All exceptions are constructed with `py_err` instead of `new`, as they "
"return `PyErr` and not `Self`."
msgstr ""

#: src/changelog.md:1146
msgid "`as_mut` and friends take and `&mut self` instead of `&self`"
msgstr ""

#: src/changelog.md:1147
msgid ""
"`ObjectProtocol::call` now takes an `Option<&PyDict>` for the kwargs instead "
"of an `IntoPyDictPointer`."
msgstr ""

#: src/changelog.md:1148
msgid ""
"`IntoPyDictPointer` was replace by `IntoPyDict` which doesn't convert "
"`PyDict` itself anymore and returns a `PyDict` instead of `*mut PyObject`."
msgstr ""

#: src/changelog.md:1149
msgid "`PyTuple::new` now takes an `IntoIterator` instead of a slice"
msgstr ""

#: src/changelog.md:1150
msgid "Updated to syn 0.15"
msgstr ""

#: src/changelog.md:1151
msgid ""
"Splitted `PyTypeObject` into `PyTypeObject` without the create method and "
"`PyTypeCreate` with requires `PyObjectAlloc<Self> + PyTypeInfo + Sized`."
msgstr ""

#: src/changelog.md:1152
msgid ""
"Ran `cargo edition --fix` which prefixed path with `crate::` for rust 2018"
msgstr ""

#: src/changelog.md:1153
msgid ""
"Renamed `async` to `pyasync` as async will be a keyword in the 2018 edition."
msgstr ""

#: src/changelog.md:1154
msgid ""
"Starting to use `NonNull<*mut PyObject>` for Py and PyObject by ijl [\\#260]"
"(https://github.com/PyO3/pyo3/pull/260)"
msgstr ""

#: src/changelog.md:1158
msgid ""
"Removed most entries from the prelude. The new prelude is small and clear."
msgstr ""

#: src/changelog.md:1159
msgid "Slowly removing specialization uses"
msgstr ""

#: src/changelog.md:1160
msgid ""
"`PyString`, `PyUnicode`, and `PyBytes` no longer have a `data` method "
"(replaced by `as_bytes`) and `PyStringData` has been removed."
msgstr ""

#: src/changelog.md:1162
msgid "The pyobject_extract macro"
msgstr ""

#: src/changelog.md:1166
msgid ""
"Added an explanation that the GIL can temporarily be released even while "
"holding a GILGuard."
msgstr ""

#: src/changelog.md:1167
msgid "Lots of clippy errors"
msgstr ""

#: src/changelog.md:1168
msgid "Fix segfault on calling an unknown method on a PyObject"
msgstr ""

#: src/changelog.md:1169
msgid ""
"Work around a [bug](https://github.com/rust-lang/rust/issues/55380) in the "
"rust compiler by kngwyu [\\#252](https://github.com/PyO3/pyo3/pull/252)"
msgstr ""

#: src/changelog.md:1170
msgid ""
"Fixed a segfault with subclassing pyo3 create classes and using `__class__` "
"by kngwyu [\\#263](https://github.com/PyO3/pyo3/pull/263)"
msgstr ""

#: src/changelog.md:1172
msgid ""
"[0.4.1](https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1) - 2018-08-20"
msgstr ""

#: src/changelog.md:1176
msgid "PyTryFrom's error is always to `PyDowncastError`"
msgstr ""

#: src/changelog.md:1180
msgid "Fixed compilation on nightly since `use_extern_macros` was stabilized"
msgstr ""

#: src/changelog.md:1184
msgid "The pyobject_downcast macro"
msgstr ""

#: src/changelog.md:1186
msgid ""
"[0.4.0](https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0) - 2018-07-30"
msgstr ""

#: src/changelog.md:1190
msgid "Merged both examples into one"
msgstr ""

#: src/changelog.md:1191
msgid "Rustfmt all the things :heavy_check_mark:"
msgstr ""

#: src/changelog.md:1192
msgid "Switched to [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)"
msgstr ""

#: src/changelog.md:1196
msgid ""
"Conversions from tuples to PyDict due to [rust-lang/rust#52050](https://"
"github.com/rust-lang/rust/issues/52050)"
msgstr ""

#: src/changelog.md:1198
msgid ""
"[0.3.2](https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2) - 2018-07-22"
msgstr ""

#: src/changelog.md:1202
msgid "Replaced `concat_idents` with mashup"
msgstr ""

#: src/changelog.md:1204
msgid ""
"[0.3.1](https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1) - 2018-07-18"
msgstr ""

#: src/changelog.md:1208
msgid "Fixed scoping bug in pyobject_native_type that would break rust-numpy"
msgstr ""

#: src/changelog.md:1210
msgid ""
"[0.3.0](https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0) - 2018-07-18"
msgstr ""

#: src/changelog.md:1214
msgid ""
"A few internal macros became part of the public api ([\\#155](https://github."
"com/PyO3/pyo3/pull/155), [\\#186](https://github.com/PyO3/pyo3/pull/186))"
msgstr ""

#: src/changelog.md:1215
msgid ""
"Always clone in getters. This allows using the get-annotation on all Clone-"
"Types"
msgstr ""

#: src/changelog.md:1219
msgid "Upgraded to syn 0.14 which means much better error messages :tada:"
msgstr ""

#: src/changelog.md:1220
msgid ""
"128 bit integer support by [kngwyu](https://github.com/kngwyu) ([\\#137]"
"(https://github.com/PyO3/pyo3/pull/173))"
msgstr ""

#: src/changelog.md:1221
msgid ""
"`proc_macro` has been stabilized on nightly ([rust-lang/rust#52081](https://"
"github.com/rust-lang/rust/pull/52081)). This means that we can remove the "
"`proc_macro` feature, but now we need the `use_extern_macros` from the 2018 "
"edition instead."
msgstr ""

#: src/changelog.md:1222
msgid ""
"All proc macro are now prefixed with `py` and live in the prelude. This "
"means you can use `#[pyclass]`, `#[pymethods]`, `#[pyproto]`, "
"`#[pyfunction]` and `#[pymodinit]` directly, at least after a `use pyo3::"
"prelude::*`. They were also moved into a module called `proc_macro`. You "
"shouldn't use `#[pyo3::proc_macro::pyclass]` or other longer paths in "
"attributes because `proc_macro_path_invoc` isn't going to be stabilized soon."
msgstr ""

#: src/changelog.md:1223
msgid "Renamed the `base` option in the `pyclass` macro to `extends`."
msgstr ""

#: src/changelog.md:1224
msgid ""
"`#[pymodinit]` uses the function name as module name, unless the name is "
"overrriden with `#[pymodinit(name)]`"
msgstr ""

#: src/changelog.md:1225
msgid "The guide is now properly versioned."
msgstr ""

#: src/changelog.md:1227
msgid ""
"[0.2.7](https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7) - 2018-05-18"
msgstr ""

#: src/changelog.md:1231
msgid "Fix nightly breakage with proc_macro_path"
msgstr ""

#: src/changelog.md:1233
msgid ""
"[0.2.6](https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6) - 2018-04-03"
msgstr ""

#: src/changelog.md:1237
msgid "Fix compatibility with TryFrom trait #137"
msgstr ""

#: src/changelog.md:1239
msgid ""
"[0.2.5](https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5) - 2018-02-21"
msgstr ""

#: src/changelog.md:1243
msgid "CPython 3.7 support"
msgstr ""

#: src/changelog.md:1247
msgid "Embedded CPython 3.7b1 crashes on initialization #110"
msgstr ""

#: src/changelog.md:1248
msgid "Generated extension functions are weakly typed #108"
msgstr ""

#: src/changelog.md:1249
msgid "call_method\\* crashes when the method does not exist #113"
msgstr ""

#: src/changelog.md:1250
msgid "Allow importing exceptions from nested modules #116"
msgstr ""

#: src/changelog.md:1252
msgid ""
"[0.2.4](https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4) - 2018-01-19"
msgstr ""

#: src/changelog.md:1256
msgid "Allow to get mutable ref from PyObject #106"
msgstr ""

#: src/changelog.md:1257
msgid "Drop `RefFromPyObject` trait"
msgstr ""

#: src/changelog.md:1258
msgid "Add Python::register_any method"
msgstr ""

#: src/changelog.md:1262
msgid "Fix impl `FromPyObject` for `Py<T>`"
msgstr ""

#: src/changelog.md:1263
msgid "Mark method that work with raw pointers as unsafe #95"
msgstr ""

#: src/changelog.md:1265
msgid ""
"[0.2.3](https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3) - 11-27-2017"
msgstr ""

#: src/changelog.md:1269
msgid "Rustup to 1.23.0-nightly 2017-11-07"
msgstr ""

#: src/changelog.md:1273
msgid "Proper `c_char` usage #93"
msgstr ""

#: src/changelog.md:1277
msgid "Remove use of now unneeded 'AsciiExt' trait"
msgstr ""

#: src/changelog.md:1279
msgid ""
"[0.2.2](https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2) - 09-26-2017"
msgstr ""

#: src/changelog.md:1283
msgid "Rustup to 1.22.0-nightly 2017-09-30"
msgstr ""

#: src/changelog.md:1285
msgid ""
"[0.2.1](https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1) - 09-26-2017"
msgstr ""

#: src/changelog.md:1289
msgid "Fix rustc const_fn nightly breakage"
msgstr ""

#: src/changelog.md:1291
msgid ""
"[0.2.0](https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0) - 08-12-2017"
msgstr ""

#: src/changelog.md:1295
msgid "Added inheritance support #15"
msgstr ""

#: src/changelog.md:1296
msgid "Added weakref support #56"
msgstr ""

#: src/changelog.md:1297
msgid "Added subclass support #64"
msgstr ""

#: src/changelog.md:1298
msgid "Added `self.__dict__` supoort #68"
msgstr ""

#: src/changelog.md:1299
msgid "Added `pyo3::prelude` module #70"
msgstr ""

#: src/changelog.md:1300
msgid "Better `Iterator` support for PyTuple, PyList, PyDict #75"
msgstr ""

#: src/changelog.md:1301
msgid "Introduce IntoPyDictPointer similar to IntoPyTuple #69"
msgstr ""

#: src/changelog.md:1305
msgid "Allow to add gc support without implementing PyGCProtocol #57"
msgstr ""

#: src/changelog.md:1306
msgid "Refactor `PyErr` implementation. Drop `py` parameter from constructor."
msgstr ""

#: src/changelog.md:1308
msgid "[0.1.0](https://github.com/PyO3/pyo3/tree/0.1.0) - 07-23-2017"
msgstr ""

#: src/changelog.md:1312
msgid "Initial release"
msgstr ""

#: src/contributing.md:1
msgid "Contributing"
msgstr "參與貢獻"

#: src/contributing.md:3
msgid ""
"Thank you for your interest in contributing to PyO3! All are welcome - "
"please consider reading our [Code of Conduct](https://github.com/PyO3/pyo3/"
"blob/main/Code-of-Conduct.md) to keep our community positive and inclusive."
msgstr ""
"感謝你有興趣貢獻 PyO3！歡迎所有人參與——請閱讀我們的[行為準則](https://github."
"com/PyO3/pyo3/blob/main/Code-of-Conduct.md)以維持社群的正向與包容。"

#: src/contributing.md:5
msgid ""
"If you are searching for ideas how to contribute, proceed to the [\"Getting "
"started contributing\"](#getting-started-contributing) section. If you have "
"found a specific issue to contribute to and need information about the "
"development process, you may find the section [\"Writing pull requests\"]"
"(#writing-pull-requests) helpful."
msgstr ""
"如果你正在尋找貢獻方向，請參考[「開始參與貢獻」](#getting-started-"
"contributing)一節。如果你已找到想處理的特定議題並需要開發流程資訊，可參考"
"[「撰寫 Pull Request」](#writing-pull-requests)一節。"

#: src/contributing.md:7
msgid ""
"If you want to become familiar with the codebase, see [Architecture.md]"
"(https://github.com/PyO3/pyo3/blob/main/Architecture.md)."
msgstr ""
"若想熟悉程式碼庫，請參考 [Architecture.md](https://github.com/PyO3/pyo3/blob/"
"main/Architecture.md)。"

#: src/contributing.md:10
msgid "Getting started contributing"
msgstr "開始參與貢獻"

#: src/contributing.md:12
msgid ""
"Please join in with any part of PyO3 which interests you. We use GitHub "
"issues to record all bugs and ideas. Feel free to request an issue to be "
"assigned to you if you want to work on it."
msgstr ""
"歡迎從你感興趣的 PyO3 領域加入。我們使用 GitHub issues 記錄所有錯誤與想法。若"
"你想處理某個議題，請隨時申請指派。"

#: src/contributing.md:14
msgid ""
"You can browse the API of the non-public parts of PyO3 [here](https://pyo3."
"netlify.app/internal/doc/pyo3/index.html)."
msgstr ""
"你可以在[這裡](https://pyo3.netlify.app/internal/doc/pyo3/index.html)瀏覽 "
"PyO3 非公開部分的 API。"

#: src/contributing.md:16
msgid ""
"The following sections also contain specific ideas on where to start "
"contributing to PyO3."
msgstr "以下章節也提供一些適合開始貢獻 PyO3 的具體想法。"

#: src/contributing.md:18
msgid "Setting up a development environment"
msgstr "設定開發環境"

#: src/contributing.md:20
msgid ""
"To work and develop PyO3, you need Python & Rust installed on your system."
msgstr "要開發 PyO3，你需要在系統中安裝 Python 與 Rust。"

#: src/contributing.md:21
msgid ""
"We encourage the use of [rustup](https://rustup.rs/) to be able to select "
"and choose specific toolchains based on the project."
msgstr "我們建議使用 [rustup](https://rustup.rs/) 以便依專案選擇特定工具鏈。"

#: src/contributing.md:22
msgid ""
"[Pyenv](https://github.com/pyenv/pyenv) is also highly recommended for being "
"able to choose a specific Python version."
msgstr ""
"也強烈建議使用 [Pyenv](https://github.com/pyenv/pyenv) 以便選擇特定 Python 版"
"本。"

#: src/contributing.md:23
msgid ""
"[virtualenv](https://virtualenv.pypa.io/en/latest/) can also be used with or "
"without Pyenv to use specific installed Python versions."
msgstr ""
"[virtualenv](https://virtualenv.pypa.io/en/latest/) 也可搭配或不搭配 Pyenv 使"
"用特定已安裝的 Python 版本。"

#: src/contributing.md:24
msgid ""
"[`nox`](https://github.com/theacodes/nox) is used to automate many of our CI "
"tasks."
msgstr "[`nox`](https://github.com/theacodes/nox) 用於自動化多項 CI 任務。"

#: src/contributing.md:26
msgid "Caveats"
msgstr ""

#: src/contributing.md:28
msgid ""
"When using pyenv on macOS, installing a Python version using `--enable-"
"shared` is required to make it work. i.e `env PYTHON_CONFIGURE_OPTS=\"--"
"enable-shared\" pyenv install 3.7.12`"
msgstr ""

#: src/contributing.md:30
msgid "Help users identify bugs"
msgstr "協助使用者找出錯誤"

#: src/contributing.md:32
msgid ""
"The [PyO3 Gitter channel](https://gitter.im/PyO3/Lobby) is very active with "
"users who are new to PyO3, and often completely new to Rust. Helping them "
"debug is a great way to get experience with the PyO3 codebase."
msgstr ""

#: src/contributing.md:34
msgid ""
"Helping others often reveals bugs, documentation weaknesses, and missing "
"APIs. It's a good idea to open GitHub issues for these immediately so the "
"resolution can be designed and implemented!"
msgstr ""
"協助他人常會暴露錯誤、文件不足與缺漏的 API。建議立刻在 GitHub 開 issue，讓解"
"法得以規劃並實作！"

#: src/contributing.md:36
msgid "Implement issues ready for development"
msgstr "實作可直接開發的議題"

#: src/contributing.md:38
msgid ""
"Issues where the solution is clear and work is not in progress use the "
"[needs-implementer](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Aneeds-implemeter) label."
msgstr ""

#: src/contributing.md:40
msgid ""
"Don't be afraid if the solution is not clear to you! The core PyO3 "
"contributors will be happy to mentor you through any questions you have to "
"help you write the solution."
msgstr ""
"若你覺得解法不夠清楚也別擔心！PyO3 核心貢獻者很樂意針對你的任何疑問提供指導，"
"幫助你完成解法。"

#: src/contributing.md:42
msgid "Help write great docs"
msgstr "協助撰寫優質文件"

#: src/contributing.md:44
msgid ""
"PyO3 has a user guide (using mdbook) as well as the usual Rust API docs. The "
"aim is for both of these to be detailed, easy to understand, and up-to-date. "
"Pull requests are always welcome to fix typos, change wording, add examples, "
"etc."
msgstr ""
"PyO3 有使用 mdbook 的使用者指南，以及一般的 Rust API 文件。我們的目標是讓兩者"
"都詳盡、易懂且保持最新。歡迎提出拉取請求來修正錯字、調整措辭、補充範例等。"

#: src/contributing.md:46
msgid ""
"There are some specific areas of focus where help is currently needed for "
"the documentation:"
msgstr "目前文件有一些需要協助的特定重點領域："

#: src/contributing.md:48
msgid ""
"Issues requesting documentation improvements are tracked with the "
"[documentation](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Adocumentation) label."
msgstr ""
"與文件改進相關的議題會以 [documentation](https://github.com/PyO3/pyo3/issues?"
"q=is%3Aissue+is%3Aopen+label%3Adocumentation) 標籤追蹤。"

#: src/contributing.md:49
msgid ""
"Not all APIs had docs or examples when they were made. The goal is to have "
"documentation on all PyO3 APIs ([\\#306](https://github.com/PyO3/pyo3/"
"issues/306)). If you see an API lacking a doc, please write one and open a "
"PR!"
msgstr ""
"並非所有 API 在建立時都有文件或範例。我們的目標是讓所有 PyO3 API 都有文件"
"（[\\#306](https://github.com/PyO3/pyo3/issues/306)）。若你看到某個 API 缺少"
"文件，請撰寫並開啟 PR！"

#: src/contributing.md:51
msgid "You can build the docs (including all features) with"
msgstr ""

#: src/contributing.md:57
msgid "Doctests"
msgstr "文件測試"

#: src/contributing.md:59
msgid ""
"We use lots of code blocks in our docs. Run `cargo test --doc` when making "
"changes to check that the doctests still work, or `cargo test` to run all "
"the tests including doctests. See https://doc.rust-lang.org/rustdoc/"
"documentation-tests.html for a guide on doctests."
msgstr ""

#: src/contributing.md:63
msgid "Building the guide"
msgstr "建置指南"

#: src/contributing.md:65
msgid "You can preview the user guide by building it locally with `mdbook`."
msgstr "你可以使用 `mdbook` 在本地建置以預覽使用者指南。"

#: src/contributing.md:67
msgid ""
"First, install [`mdbook`](https://rust-lang.github.io/mdBook/cli/index.html) "
"and [`nox`](https://github.com/theacodes/nox). Then, run"
msgstr ""

#: src/contributing.md:73
msgid "Help design the next PyO3"
msgstr "協助設計下一代 PyO3"

#: src/contributing.md:75
msgid ""
"Issues which don't yet have a clear solution use the [needs-design](https://"
"github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design) "
"label."
msgstr ""
"尚未有明確解法的議題會使用 [needs-design](https://github.com/PyO3/pyo3/"
"issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design) 標籤。"

#: src/contributing.md:77
msgid ""
"If any of these issues interest you, please join in with the conversation on "
"the issue! All opinions are valued, and if you're interested in going "
"further with e.g. draft PRs to experiment with API designs, even better!"
msgstr ""
"如果這些議題有你感興趣的，請加入該議題的討論！所有意見都很重要；若你還願意透"
"過草稿 PR 嘗試 API 設計，那就更好了！"

#: src/contributing.md:79
msgid "Review pull requests"
msgstr "審查拉取請求"

#: src/contributing.md:81
msgid ""
"Everybody is welcome to submit comments on open PRs. Please help ensure new "
"PyO3 APIs are safe, performant, tidy, and easy to use!"
msgstr ""
"歡迎所有人對開放中的 PR 提出意見。請協助確保新的 PyO3 API 安全、效能良好、整"
"潔且易用！"

#: src/contributing.md:83
msgid "Writing pull requests"
msgstr "撰寫拉取請求"

#: src/contributing.md:85
msgid "Here are a few things to note when you are writing PRs."
msgstr "以下是撰寫 PR 時需要注意的幾點。"

#: src/contributing.md:87
msgid "Continuous Integration"
msgstr ""

#: src/contributing.md:89
msgid ""
"The PyO3 repo uses GitHub Actions. PRs are blocked from merging if CI is not "
"successful."
msgstr ""

#: src/contributing.md:91
msgid ""
"Formatting, linting and tests are checked for all Rust and Python code. In "
"addition, all warnings in Rust code are disallowed (using `RUSTFLAGS=\"-D "
"warnings\"`)."
msgstr ""

#: src/contributing.md:93
msgid ""
"Tests run with all supported Python versions with the latest stable Rust "
"compiler, as well as for Python 3.9 with the minimum supported Rust version."
msgstr ""
"測試會在最新穩定版 Rust 編譯器與所有支援的 Python 版本上執行，並以最低支援的 "
"Rust 版本測試 Python 3.9。"

#: src/contributing.md:95
msgid ""
"If you are adding a new feature, you should add it to the `full` feature in "
"our _Cargo.toml_\\* so that it is tested in CI."
msgstr ""
"如果你新增了功能，請將其加入 _Cargo.toml_\\* 中的 `full` 功能集合，以便在 CI "
"中進行測試。"

#: src/contributing.md:97
msgid ""
"You can run these tests yourself with `cargo xtask ci` See [its "
"documentation](https://github.com/PyO3/pyo3/tree/main/xtask#readme) for more "
"commands you can run."
msgstr ""

#: src/contributing.md:101
msgid "Documenting changes"
msgstr "變更文件化"

#: src/contributing.md:103
msgid ""
"We use [towncrier](https://towncrier.readthedocs.io/en/stable/index.html) to "
"generate a CHANGELOG for each release."
msgstr ""
"我們使用 [towncrier](https://towncrier.readthedocs.io/en/stable/index.html) "
"為每次發行生成變更日誌。"

#: src/contributing.md:105
msgid ""
"To include your changes in the release notes, you should create one (or "
"more) news items in the `newsfragments` directory. Valid news items should "
"be saved as `<PR>.<CATEGORY>.md` where `<PR>` is the pull request number and "
"`<CATEGORY>` is one of the following:"
msgstr ""
"要將你的變更納入發行說明，請在 `newsfragments` 目錄中建立一個或多個新聞項目。"
"有效的新聞項目應儲存為 `<PR>.<CATEGORY>.md`，其中 `<PR>` 為拉取請求編號，"
"`<CATEGORY>` 為下列其中之一："

#: src/contributing.md:106
msgid ""
"`packaging` - for dependency changes and Python / Rust version compatibility "
"changes"
msgstr "`packaging` - 用於相依性變更與 Python／Rust 版本相容性變更"

#: src/contributing.md:107
msgid "`added` - for new features"
msgstr "`added` - 用於新增功能"

#: src/contributing.md:108
msgid ""
"`changed` - for features which already existed but have been altered or "
"deprecated"
msgstr "`changed` - 用於既有功能的修改或棄用"

#: src/contributing.md:109
msgid "`removed` - for features which have been removed"
msgstr "`removed` - 用於移除的功能"

#: src/contributing.md:110
msgid "`fixed` - for \"changed\" features which were classed as a bugfix"
msgstr "`fixed` - 用於被歸類為錯誤修復的「變更」功能"

#: src/contributing.md:112
msgid "Python and Rust version support policy"
msgstr "Python 與 Rust 版本支援政策"

#: src/contributing.md:114
msgid ""
"PyO3 aims to keep sufficient compatibility to make packaging Python "
"extensions built with PyO3 feasible on most common package managers."
msgstr ""
"PyO3 旨在維持足夠的相容性，讓以 PyO3 建置的 Python 擴充能在多數常見軟體包管理"
"系統中可行。"

#: src/contributing.md:116
msgid ""
"To keep package maintainers' lives simpler, PyO3 will commit, wherever "
"possible, to only adjust minimum supported Rust and Python versions at the "
"same time. This bump will only come in an `0.x` release, roughly once per "
"year, after the oldest supported Python version reaches its end-of-life. "
"(Check https://endoflife.date/python for a clear timetable on these.)"
msgstr ""
"為了讓軟體包維護者的工作更簡單，PyO3 會盡可能承諾僅在同一時間調整最低支援的 "
"Rust 與 Python 版本。此升級僅會出現在 `0.x` 版本，約每年一次，並在最舊支援的 "
"Python 版本到達生命週期終點後進行。（可參考 https://endoflife.date/python 了"
"解時間表。）"

#: src/contributing.md:118
msgid ""
"Below are guidelines on what compatibility all PRs are expected to deliver "
"for each language."
msgstr "以下為各語言的相容性指引，所有 PR 都應遵循。"

#: src/contributing.md:120
msgid "Python"
msgstr ""

#: src/contributing.md:122
msgid ""
"PyO3 supports all officially supported Python versions, as well as the "
"latest PyPy3 release. All of these versions are tested in CI."
msgstr ""
"PyO3 支援所有官方支援的 Python 版本，以及最新的 PyPy3 版本。這些版本都會在 "
"CI 中測試。"

#: src/contributing.md:124
msgid "Rust"
msgstr ""

#: src/contributing.md:126
msgid ""
"PyO3 aims to make use of up-to-date Rust language features to keep the "
"implementation as efficient as possible."
msgstr "PyO3 旨在使用最新的 Rust 語言功能，以盡可能提高實作效率。"

#: src/contributing.md:128
msgid ""
"The minimum Rust version supported will be decided when the release which "
"bumps Python and Rust versions is made. At the time, the minimum Rust "
"version will be set no higher than the lowest Rust version shipped in the "
"current Debian, RHEL and Alpine Linux distributions."
msgstr ""
"最低支援的 Rust 版本會在提升 Python 與 Rust 版本的發行時決定。當時設定的最低 "
"Rust 版本不會高於當前 Debian、RHEL 與 Alpine Linux 發行版隨附的最低 Rust 版"
"本。"

#: src/contributing.md:130
msgid ""
"CI tests both the most recent stable Rust version and the minimum supported "
"Rust version. Because of Rust's stability guarantees this is sufficient to "
"confirm support for all Rust versions in between."
msgstr ""
"CI 會測試最新穩定版 Rust 與最低支援 Rust 版本。由於 Rust 的穩定性保證，這足以"
"確認中間所有版本的支援。"

#: src/contributing.md:132
msgid "Benchmarking"
msgstr "效能基準測試"

#: src/contributing.md:134
msgid ""
"PyO3 has two sets of benchmarks for evaluating some aspects of its "
"performance. The benchmark suite is currently very small - please open PRs "
"with new benchmarks if you're interested in helping to expand it!"
msgstr ""
"PyO3 有兩組效能基準測試用於評估部分效能面向。目前測試套件還很小——若你願意協助"
"擴充，歡迎新增基準測試並開 PR！"

#: src/contributing.md:136
msgid ""
"First, there are Rust-based benchmarks located in the `benches` "
"subdirectory. As long as you have a nightly rust compiler available on your "
"system, you can run these benchmarks with:"
msgstr ""

#: src/contributing.md:140
msgid ""
"Second, there is a Python-based benchmark contained in the `pytests` "
"subdirectory. You can read more about it [here](pytests)."
msgstr ""

#: src/contributing.md:142
msgid "Code coverage"
msgstr "程式碼覆蓋率"

#: src/contributing.md:144
msgid ""
"You can view what code is and isn't covered by PyO3's tests. We aim to have "
"100% coverage - please check coverage and add tests if you notice a lack of "
"coverage!"
msgstr ""
"你可以檢視 PyO3 測試涵蓋與未涵蓋的程式碼。我們目標是 100% 覆蓋率——如果你發現"
"覆蓋不足，請檢查覆蓋率並補上測試！"

#: src/contributing.md:146
msgid "First, generate a `lcov.info` file with"
msgstr ""

#: src/contributing.md:150
msgid ""
"You can install an IDE plugin to view the coverage. For example, if you use "
"VSCode:"
msgstr "你可以安裝 IDE 外掛來檢視覆蓋率。例如使用 VSCode："

#: src/contributing.md:151
msgid ""
"Add the [coverage-gutters](https://marketplace.visualstudio.com/items?"
"itemName=ryanluker.vscode-coverage-gutters) plugin."
msgstr ""
"安裝 [coverage-gutters](https://marketplace.visualstudio.com/items?"
"itemName=ryanluker.vscode-coverage-gutters) 外掛。"

#: src/contributing.md:152
msgid "Add these settings to VSCode's `settings.json`:"
msgstr "在 VSCode 的 `settings.json` 加入以下設定："

#: src/contributing.md:155
msgid "\"coverage-gutters.coverageFileNames\""
msgstr ""

#: src/contributing.md:156
msgid "\"lcov.info\""
msgstr ""

#: src/contributing.md:157
msgid "\"cov.xml\""
msgstr ""

#: src/contributing.md:158
msgid "\"coverage.xml\""
msgstr ""

#: src/contributing.md:160
msgid "\"coverage-gutters.showLineCoverage\""
msgstr ""

#: src/contributing.md:163
msgid ""
"You should now be able to see green highlights for code that is tested, and "
"red highlights for code that is not tested."
msgstr ""
"你現在應該可以看到綠色高亮代表已測試的程式碼，紅色高亮代表未測試的程式碼。"

#: src/contributing.md:165
msgid "Sponsor this project"
msgstr "贊助此專案"

#: src/contributing.md:167
msgid ""
"At the moment there is no official organisation that accepts sponsorship on "
"PyO3's behalf. If you're seeking to provide significant funding to the PyO3 "
"ecosystem, please reach out to us on [GitHub](https://github.com/PyO3/pyo3/"
"issues/new) or [Gitter](https://gitter.im/PyO3/Lobby) and we can discuss."
msgstr ""

#: src/contributing.md:169
msgid ""
"In the meanwhile, some of our maintainers have personal GitHub sponsorship "
"pages and would be grateful for your support:"
msgstr "此外，我們部分維護者有個人的 GitHub 贊助頁面，若你願意支持將非常感謝："

#: src/contributing.md:171
msgid "[davidhewitt](https://github.com/sponsors/davidhewitt)"
msgstr "[davidhewitt](https://github.com/sponsors/davidhewitt)"

#: src/contributing.md:172
msgid "[messense](https://github.com/sponsors/messense)"
msgstr "[messense](https://github.com/sponsors/messense)"

#: src/debugging.md:1
msgid "Debugging"
msgstr "除錯"

#: src/debugging.md:5
msgid ""
"PyO3's attributes (`#[pyclass]`, `#[pymodule]`, etc.) are [procedural macros]"
"(https://doc.rust-lang.org/reference/procedural-macros.html), which means "
"that they rewrite the source of the annotated item. You can view the "
"generated source with the following command, which also expands a few other "
"things:"
msgstr ""

#: src/debugging.md:11
msgid ""
"(You might need to install [rustfmt](https://github.com/rust-lang-nursery/"
"rustfmt) if you don't already have it.)"
msgstr ""

#: src/debugging.md:13
msgid "You can also debug classic `!`\\-macros by adding `-Z trace-macros`:"
msgstr ""

#: src/debugging.md:19
msgid ""
"See [cargo expand](https://github.com/dtolnay/cargo-expand) for a more "
"elaborate version of those commands."
msgstr ""

#: src/debugging.md:21
msgid "Running with Valgrind"
msgstr ""

#: src/debugging.md:23
msgid ""
"Valgrind is a tool to detect memory management bugs such as memory leaks."
msgstr ""

#: src/debugging.md:25
msgid ""
"You first need to install a debug build of Python, otherwise Valgrind won't "
"produce usable results. In Ubuntu there's e.g. a `python3-dbg` package."
msgstr ""

#: src/debugging.md:27
msgid ""
"Activate an environment with the debug interpreter and recompile. If you're "
"on Linux, use `ldd` with the name of your binary and check that you're "
"linking e.g. `libpython3.7d.so.1.0` instead of `libpython3.7.so.1.0`."
msgstr ""

#: src/debugging.md:29
msgid ""
"[Download the suppressions file for cpython](https://raw.githubusercontent."
"com/python/cpython/master/Misc/valgrind-python.supp)."
msgstr ""

#: src/debugging.md:31
msgid ""
"Run Valgrind with `valgrind --suppressions=valgrind-python.supp ./my-command "
"--with-options`"
msgstr ""

#: src/debugging.md:33
msgid "Getting a stacktrace"
msgstr ""

#: src/debugging.md:35
msgid ""
"The best start to investigate a crash such as an segmentation fault is a "
"backtrace. You can set `RUST_BACKTRACE=1` as an environment variable to get "
"the stack trace on a `panic!`. Alternatively you can use a debugger such as "
"`gdb` to explore the issue. Rust provides a wrapper, `rust-gdb`, which has "
"pretty-printers for inspecting Rust variables. Since PyO3 uses `cdylib` for "
"Python shared objects, it does not receive the pretty-print debug hooks in "
"`rust-gdb` ([rust-lang/rust#96365](https://github.com/rust-lang/rust/"
"issues/96365)). The mentioned issue contains a workaround for enabling "
"pretty-printers in this case."
msgstr ""

#: src/debugging.md:37
msgid ""
"Link against a debug build of python as described in the previous chapter"
msgstr ""

#: src/debugging.md:38
msgid "Run `rust-gdb <my-binary>`"
msgstr ""

#: src/debugging.md:39
msgid ""
"Set a breakpoint (`b`) on `rust_panic` if you are investigating a `panic!`"
msgstr ""

#: src/debugging.md:40
msgid "Enter `r` to run"
msgstr ""

#: src/debugging.md:41
msgid ""
"After the crash occurred, enter `bt` or `bt full` to print the stacktrace"
msgstr ""

#: src/debugging.md:43
msgid ""
"Often it is helpful to run a small piece of Python code to exercise a "
"section of Rust."
msgstr ""

#: src/debugging.md:45
msgid ""
"```console\n"
"rust-gdb --args python -c \"import my_package; my_package.sum_to_string(1, "
"2)\"\n"
"```"
msgstr ""

#: src/faq.md:1
msgid "Frequently Asked Questions and troubleshooting"
msgstr "常見問題與疑難排解"

#: src/faq.md:3
msgid "I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!"
msgstr ""

#: src/faq.md:5
msgid ""
"`lazy_static` and `once_cell::sync` both use locks to ensure that "
"initialization is performed only by a single thread. Because the Python GIL "
"is an additional lock this can lead to deadlocks in the following way:"
msgstr ""

#: src/faq.md:7
msgid ""
"A thread (thread A) which has acquired the Python GIL starts initialization "
"of a `lazy_static` value."
msgstr ""

#: src/faq.md:8
msgid ""
"The initialization code calls some Python API which temporarily releases the "
"GIL e.g. `Python::import`."
msgstr ""

#: src/faq.md:9
msgid ""
"Another thread (thread B) acquires the Python GIL and attempts to access the "
"same `lazy_static` value."
msgstr ""

#: src/faq.md:10
msgid ""
"Thread B is blocked, because it waits for `lazy_static`'s initialization to "
"lock to release."
msgstr ""

#: src/faq.md:11
msgid ""
"Thread A is blocked, because it waits to re-acquire the GIL which thread B "
"still holds."
msgstr ""

#: src/faq.md:12
msgid "Deadlock."
msgstr "死鎖。"

#: src/faq.md:14
msgid ""
"PyO3 provides a struct [`GILOnceCell`](https://pyo3.rs/main/doc/pyo3/"
"once_cell/struct.GILOnceCell.html) which works equivalently to `OnceCell` "
"but relies solely on the Python GIL for thread safety. This means it can be "
"used in place of `lazy_static` or `once_cell` where you are experiencing the "
"deadlock described above. See the documentation for [`GILOnceCell`](https://"
"pyo3.rs/main/doc/pyo3/once_cell/struct.GILOnceCell.html) for an example how "
"to use it."
msgstr ""

#: src/faq.md:18
msgid ""
"I can't run `cargo test`; or I can't build in a Cargo workspace: I'm having "
"linker issues like \"Symbol not found\" or \"Undefined reference to "
"\\_PyExc_SystemError\"!"
msgstr ""

#: src/faq.md:20
msgid ""
"Currently, [\\#340](https://github.com/PyO3/pyo3/issues/340) causes `cargo "
"test` to fail with linking errors when the `extension-module` feature is "
"activated. Linking errors can also happen when building in a cargo workspace "
"where a different crate also uses PyO3 (see [\\#2521](https://github.com/"
"PyO3/pyo3/issues/2521)). For now, there are three ways we can work around "
"these issues."
msgstr ""

#: src/faq.md:22
msgid ""
"Make the `extension-module` feature optional. Build with `maturin develop --"
"features \"extension-module\"`"
msgstr ""

#: src/faq.md:24
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:32
msgid ""
"Make the `extension-module` feature optional and default. Run tests with "
"`cargo test --no-default-features`:"
msgstr ""

#: src/faq.md:34
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:43
msgid ""
"If you are using a [`pyproject.toml`](https://maturin.rs/metadata.html) file "
"to control maturin settings, add the following section:"
msgstr ""

#: src/faq.md:45
msgid ""
"```toml\n"
"[tool.maturin]\n"
"features = [\"pyo3/extension-module\"]\n"
"# Or for maturin 0.12:\n"
"# cargo-extra-args = [\"--features\", \"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:52
msgid ""
"I can't run `cargo test`: my crate cannot be found for tests in `tests/` "
"directory!"
msgstr ""

#: src/faq.md:54
msgid ""
"The Rust book suggests to [put integration tests inside a `tests/` directory]"
"(https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-"
"tests)."
msgstr ""
"Rust 書籍建議[將整合測試放在 `tests/` 目錄中](https://doc.rust-lang.org/book/"
"ch11-03-test-organization.html#integration-tests)。"

#: src/faq.md:56
msgid ""
"For a PyO3 `extension-module` project where the `crate-type` is set to "
"`\"cdylib\"` in your `Cargo.toml`, the compiler won't be able to find your "
"crate and will display errors such as `E0432` or `E0463`:"
msgstr ""

#: src/faq.md:67
msgid ""
"The best solution is to make your crate types include both `rlib` and "
"`cdylib`:"
msgstr "最佳解法是讓 crate 型別同時包含 `rlib` 與 `cdylib`："

#: src/faq.md:69
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[lib]\n"
"crate-type = [\"cdylib\", \"rlib\"]\n"
"```"
msgstr ""

#: src/faq.md:75
msgid "Ctrl-C doesn't do anything while my Rust code is executing!"
msgstr ""

#: src/faq.md:77
msgid ""
"This is because Ctrl-C raises a SIGINT signal, which is handled by the "
"calling Python process by simply setting a flag to action upon later. This "
"flag isn't checked while Rust code called from Python is executing, only "
"once control returns to the Python interpreter."
msgstr ""
"這是因為 Ctrl-C 會送出 SIGINT 訊號，呼叫端 Python 程序只會設定一個旗標以便稍"
"後處理。當 Python 呼叫的 Rust 程式碼執行中時，不會檢查此旗標，直到控制權回到 "
"Python 直譯器才會處理。"

#: src/faq.md:79
msgid ""
"You can give the Python interpreter a chance to process the signal properly "
"by calling `Python::check_signals`. It's good practice to call this function "
"regularly if you have a long-running Rust function so that your users can "
"cancel it."
msgstr ""
"你可以呼叫 `Python::check_signals` 讓 Python 直譯器有機會正確處理訊號。若你"
"的 Rust 函式會長時間執行，建議定期呼叫此函式，讓使用者能取消。"

#: src/faq.md:81
msgid "`#[pyo3(get)]` clones my field!"
msgstr ""

#: src/faq.md:83
msgid "You may have a nested struct similar to this:"
msgstr "你可能有如下的巢狀結構："

#: src/faq.md:89 src/faq.md:129
msgid "/* fields omitted */"
msgstr ""

#: src/faq.md:106
msgid ""
"When Python code accesses `Outer`'s field, PyO3 will return a new object on "
"every access (note that their addresses are different):"
msgstr ""
"當 Python 程式碼存取 `Outer` 的欄位時，PyO3 會在每次存取時回傳新的物件（注意"
"位址不同）："

#: src/faq.md:114 src/faq.md:154 src/faq.md:155
msgid "\"a: "
msgstr ""

#: src/faq.md:114 src/faq.md:154 src/faq.md:155
msgid "\\nb: "
msgstr ""

#: src/faq.md:114 src/faq.md:154 src/faq.md:155
msgid "\""
msgstr ""

#: src/faq.md:122
msgid ""
"This can be especially confusing if the field is mutable, as getting the "
"field and then mutating it won't persist - you'll just get a fresh clone of "
"the original on the next access. Unfortunately Python and Rust don't agree "
"about ownership - if PyO3 gave out references to (possibly) temporary Rust "
"objects to Python code, Python code could then keep that reference alive "
"indefinitely. Therefore returning Rust objects requires cloning."
msgstr ""
"若欄位是可變的，這會特別令人困惑，因為取得欄位後再修改並不會持久化——下次存取"
"只會拿到原始物件的新複本。不幸的是，Python 與 Rust 對所有權的理解不同——如果 "
"PyO3 將（可能是暫時的）Rust 物件參照交給 Python，Python 可能會無限期保留該參"
"照。因此回傳 Rust 物件需要進行複製。"

#: src/faq.md:124
msgid ""
"If you don't want that cloning to happen, a workaround is to allocate the "
"field on the Python heap and store a reference to that, by using [`Py<...>`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html):"
msgstr ""

#: src/faq.md:147
msgid "This time `a` and `b` _are_ the same object:"
msgstr ""

#: src/faq.md:162
msgid ""
"The downside to this approach is that any Rust code working on the `Outer` "
"struct now has to acquire the GIL to do anything with its field."
msgstr ""

#: src/faq.md:164
msgid ""
"I want to use the `pyo3` crate re-exported from from dependency but the proc-"
"macros fail!"
msgstr ""

#: src/faq.md:166
msgid ""
"All PyO3 proc-macros (`#[pyclass]`, `#[pyfunction]`, "
"`#[derive(FromPyObject)]` and so on) expect the `pyo3` crate to be available "
"under that name in your crate root, which is the normal situation when "
"`pyo3` is a direct dependency of your crate."
msgstr ""

#: src/faq.md:171
msgid ""
"However, when the dependency is renamed, or your crate only indirectly "
"depends on `pyo3`, you need to let the macro code know where to find the "
"crate.  This is done with the `crate` attribute:"
msgstr ""

#: src/faq.md:180
msgid "\"reexported::pyo3\""
msgstr ""

#: src/features.md:1
msgid "Features reference"
msgstr "功能參考"

#: src/features.md:3
msgid ""
"PyO3 provides a number of Cargo features to customise functionality. This "
"chapter of the guide provides detail on each of them."
msgstr ""

#: src/features.md:5
msgid "By default, only the `macros` feature is enabled."
msgstr ""

#: src/features.md:7
msgid "Features for extension module authors"
msgstr ""

#: src/features.md:9
msgid "`extension-module`"
msgstr ""

#: src/features.md:11
msgid ""
"This feature is required when building a Python extension module using PyO3."
msgstr ""

#: src/features.md:13
msgid ""
"It tells PyO3's build script to skip linking against `libpython.so` on Unix "
"platforms, where this must not be done."
msgstr ""

#: src/features.md:15
msgid ""
"See the [building and distribution](building_and_distribution.md#linking) "
"section for further detail."
msgstr ""

#: src/features.md:17
msgid "`abi3`"
msgstr ""

#: src/features.md:19
msgid ""
"This feature is used when building Python extension modules to create wheels "
"which are compatible with multiple Python versions."
msgstr ""

#: src/features.md:21
msgid ""
"It restricts PyO3's API to a subset of the full Python API which is "
"guaranteed by [PEP 384](https://www.python.org/dev/peps/pep-0384/) to be "
"forwards-compatible with future Python versions."
msgstr ""

#: src/features.md:23
msgid ""
"See the [building and distribution](building_and_distribution."
"md#py_limited_apiabi3) section for further detail."
msgstr ""

#: src/features.md:25
msgid "The `abi3-pyXY` features"
msgstr ""

#: src/features.md:27
msgid "(`abi3-py37`, `abi3-py38`, `abi3-py39`, and `abi3-py310`)"
msgstr ""

#: src/features.md:29
msgid ""
"These features are extensions of the `abi3` feature to specify the exact "
"minimum Python version which the multiple-version-wheel will support."
msgstr ""

#: src/features.md:31
msgid ""
"See the [building and distribution](building_and_distribution.md#minimum-"
"python-version-for-abi3) section for further detail."
msgstr ""

#: src/features.md:33
msgid "`generate-import-lib`"
msgstr ""

#: src/features.md:35
msgid ""
"This experimental feature is used to generate import libraries for Python "
"DLL for MinGW-w64 and MSVC (cross-)compile targets."
msgstr ""

#: src/features.md:38
msgid ""
"Enabling it allows to (cross-)compile extension modules to any Windows "
"targets without having to install the Windows Python distribution files for "
"the target."
msgstr ""

#: src/features.md:41
msgid ""
"See the [building and distribution](building_and_distribution.md#building-"
"abi3-extensions-without-a-python-interpreter) section for further detail."
msgstr ""

#: src/features.md:44
msgid "Features for embedding Python in Rust"
msgstr ""

#: src/features.md:46
msgid "`auto-initialize`"
msgstr ""

#: src/features.md:48
msgid ""
"This feature changes [`Python::with_gil`](https://pyo3.rs/main/doc/pyo3/"
"struct.Python.html#method.with_gil) and [`Python::acquire_gil`](https://pyo3."
"rs/main/doc/pyo3/struct.Python.html#method.acquire_gil) to automatically "
"initialize a Python interpreter (by calling [`prepare_freethreaded_python`]"
"(https://pyo3.rs/main/doc/pyo3/fn.prepare_freethreaded_python.html)) if "
"needed."
msgstr ""

#: src/features.md:50
msgid ""
"If you do not enable this feature, you should call `pyo3::"
"prepare_freethreaded_python()` before attempting to call any other Python "
"APIs."
msgstr ""

#: src/features.md:52
msgid "Advanced Features"
msgstr ""

#: src/features.md:54
msgid "`macros`"
msgstr ""

#: src/features.md:56
msgid ""
"This feature enables a dependency on the `pyo3-macros` crate, which provides "
"the procedural macros portion of PyO3's API:"
msgstr ""

#: src/features.md:58
msgid "`#[pymodule]`"
msgstr "`#[pymodule]`"

#: src/features.md:59
msgid "`#[pyfunction]`"
msgstr "`#[pyfunction]`"

#: src/features.md:60
msgid "`#[pyclass]`"
msgstr "`#[pyclass]`"

#: src/features.md:61
msgid "`#[pymethods]`"
msgstr "`#[pymethods]`"

#: src/features.md:62
msgid "`#[derive(FromPyObject)]`"
msgstr "`#[derive(FromPyObject)]`"

#: src/features.md:64
msgid "It also provides the `py_run!` macro."
msgstr ""

#: src/features.md:66
msgid ""
"These macros require a number of dependencies which may not be needed by "
"users who just need PyO3 for Python FFI. Disabling this feature enables "
"faster builds for those users, as these dependencies will not be built if "
"this feature is disabled."
msgstr ""

#: src/features.md:68
msgid ""
"This feature is enabled by default. To disable it, set `default-features = "
"false` for the `pyo3` entry in your Cargo.toml."
msgstr ""

#: src/features.md:70
msgid "`multiple-pymethods`"
msgstr "`multiple-pymethods`"

#: src/features.md:72
msgid ""
"This feature enables a dependency on `inventory`, which enables each "
"`#[pyclass]` to have more than one `#[pymethods]` block. This feature also "
"requires a minimum Rust version of 1.62 due to limitations in the "
"`inventory` crate."
msgstr ""

#: src/features.md:74
msgid ""
"Most users should only need a single `#[pymethods]` per `#[pyclass]`. In "
"addition, not all platforms (e.g. Wasm) are supported by `inventory`. For "
"this reason this feature is not enabled by default, meaning fewer "
"dependencies and faster compilation for the majority of users."
msgstr ""

#: src/features.md:76
msgid ""
"See [the `#[pyclass]` implementation details](class.md#implementation-"
"details) for more information."
msgstr ""

#: src/features.md:78
msgid "`pyproto`"
msgstr ""

#: src/features.md:80
msgid ""
"This feature enables the `#[pyproto]` macro, which is a deprecated "
"alternative to `#[pymethods]` for defining magic methods such as `__eq__`."
msgstr ""

#: src/features.md:82
msgid "`nightly`"
msgstr ""

#: src/features.md:84
msgid ""
"The `nightly` feature needs the nightly Rust compiler. This allows PyO3 to "
"use the auto_traits and negative_impls features to fix the `Python::"
"allow_threads` function."
msgstr ""

#: src/features.md:86
msgid "`resolve-config`"
msgstr ""

#: src/features.md:88
msgid ""
"The `resolve-config` feature of the `pyo3-build-config` crate controls "
"whether that crate's build script automatically resolves a Python "
"interpreter / build configuration. This feature is primarily useful when "
"building PyO3 itself. By default this feature is not enabled, meaning you "
"can freely use `pyo3-build-config` as a standalone library to read or write "
"PyO3 build configuration files or resolve metadata about a Python "
"interpreter."
msgstr ""

#: src/features.md:92
msgid "Optional Dependencies"
msgstr ""

#: src/features.md:94
msgid ""
"These features enable conversions between Python types and types from other "
"Rust crates, enabling easy access to the rest of the Rust ecosystem."
msgstr ""

#: src/features.md:96
msgid "`anyhow`"
msgstr ""

#: src/features.md:98
msgid ""
"Adds a dependency on [anyhow](https://docs.rs/anyhow). Enables a conversion "
"from [anyhow](https://docs.rs/anyhow)’s [`Error`](https://docs.rs/anyhow/"
"latest/anyhow/struct.Error.html) type to [`PyErr`](https://docs.rs/pyo3/"
"latest/pyo3/struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:100
msgid "`chrono`"
msgstr ""

#: src/features.md:102
msgid ""
"Adds a dependency on [chrono](https://docs.rs/chrono). Enables a conversion "
"from [chrono](https://docs.rs/chrono)'s types to python:"
msgstr ""

#: src/features.md:103
msgid ""
"[Duration](https://docs.rs/chrono/latest/chrono/struct.Duration.html) -> "
"[`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:104
msgid ""
"[FixedOffset](https://docs.rs/chrono/latest/chrono/offset/struct.FixedOffset."
"html) -> [`PyDelta`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDelta.html)"
msgstr ""

#: src/features.md:105
msgid ""
"[Utc](https://docs.rs/chrono/latest/chrono/offset/struct.Utc.html) -> "
"[`PyTzInfo`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTzInfo.html)"
msgstr ""

#: src/features.md:106
msgid ""
"[NaiveDate](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDate."
"html) -> [`PyDate`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDate.html)"
msgstr ""

#: src/features.md:107
msgid ""
"[NaiveTime](https://docs.rs/chrono/latest/chrono/naive/struct.NaiveTime."
"html) -> [`PyTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyTime.html)"
msgstr ""

#: src/features.md:108
msgid ""
"[DateTime](https://docs.rs/chrono/latest/chrono/struct.DateTime.html) -> "
"[`PyDateTime`](https://pyo3.rs/main/doc/pyo3/types/struct.PyDateTime.html)"
msgstr ""

#: src/features.md:110
msgid "`eyre`"
msgstr ""

#: src/features.md:112
msgid ""
"Adds a dependency on [eyre](https://docs.rs/eyre). Enables a conversion from "
"[eyre](https://docs.rs/eyre)’s [`Report`](https://docs.rs/eyre/latest/eyre/"
"struct.Report.html) type to [`PyErr`](https://docs.rs/pyo3/latest/pyo3/"
"struct.PyErr.html), for easy error handling."
msgstr ""

#: src/features.md:114
msgid "`hashbrown`"
msgstr ""

#: src/features.md:116
msgid ""
"Adds a dependency on [hashbrown](https://docs.rs/hashbrown) and enables "
"conversions into its [`HashMap`](https://docs.rs/hashbrown/latest/hashbrown/"
"struct.HashMap.html) and [`HashSet`](https://docs.rs/hashbrown/latest/"
"hashbrown/struct.HashSet.html) types."
msgstr ""

#: src/features.md:118
msgid "`indexmap`"
msgstr ""

#: src/features.md:120
msgid ""
"Adds a dependency on [indexmap](https://docs.rs/indexmap) and enables "
"conversions into its [`IndexMap`](https://docs.rs/indexmap/latest/indexmap/"
"map/struct.IndexMap.html) type."
msgstr ""

#: src/features.md:122
msgid "`num-bigint`"
msgstr ""

#: src/features.md:124
msgid ""
"Adds a dependency on [num-bigint](https://docs.rs/num-bigint) and enables "
"conversions into its [`BigInt`](https://docs.rs/num-bigint/latest/num_bigint/"
"struct.BigInt.html) and [`BigUint`](https://docs.rs/num-bigint/latest/"
"num_bigint/struct.BigUInt.html) types."
msgstr ""

#: src/features.md:126
msgid "`num-complex`"
msgstr ""

#: src/features.md:128
msgid ""
"Adds a dependency on [num-complex](https://docs.rs/num-complex) and enables "
"conversions into its [`Complex`](https://docs.rs/num-complex/latest/"
"num_complex/struct.Complex.html) type."
msgstr ""

#: src/features.md:130
msgid "`serde`"
msgstr ""

#: src/features.md:132
msgid ""
"Enables (de)serialization of Py<T> objects via [serde](https://serde.rs/). "
"This allows to use [`#[derive(Serialize, Deserialize)`](https://serde.rs/"
"derive.html) on structs that hold references to `#[pyclass]` instances"
msgstr ""

#: src/features.md:136
msgid "\"serde\""
msgstr ""

#: src/getting_started.md:2
msgid "Installation"
msgstr "安裝"

#: src/getting_started.md:4
msgid ""
"To get started using PyO3 you will need three things: a rust toolchain, a "
"python environment, and a way to build. We'll cover each of these below."
msgstr ""

#: src/getting_started.md:8
msgid ""
"First, make sure you have rust installed on your system. If you haven't "
"already done so you can do so by following the instructions [here](https://"
"www.rust-lang.org/tools/install). PyO3 runs on both the `stable` and "
"`nightly` versions so you can choose whichever one fits you best. The "
"minimum required rust version is Rust 1.48."
msgstr ""

#: src/getting_started.md:10
msgid ""
"if you can run `rustc --version` and the version is high enough you're good "
"to go!"
msgstr ""

#: src/getting_started.md:14
msgid ""
"To use PyO3 you need at least Python 3.7. While you can simply use the "
"default Python version on your system, it is recommended to use a virtual "
"environment."
msgstr ""

#: src/getting_started.md:16
msgid "Virtualenvs"
msgstr "虛擬環境"

#: src/getting_started.md:18
msgid ""
"While you can use any virtualenv manager you like, we recommend the use of "
"`pyenv` especially if you want to develop or test for multiple different "
"python versions, so that is what the examples in this book will use. The "
"installation instructions for `pyenv` can be found [here](https://github.com/"
"pyenv/pyenv#getting-pyenv)."
msgstr ""

#: src/getting_started.md:20
msgid ""
"Note that when using `pyenv` you should also set the following environment "
"variable"
msgstr ""

#: src/getting_started.md:22
msgid "\"--enable-shared\""
msgstr ""

#: src/getting_started.md:25
msgid "Building"
msgstr "建置"

#: src/getting_started.md:27
msgid ""
"There are a number of build and python package management systems such as "
"[`setuptools-rust`](https://github.com/PyO3/setuptools-rust) or [manually]"
"(https://pyo3.rs/latest/building_and_distribution.html#manual-builds)  we "
"recommend the use of `maturin` which you can install [here](https://maturin."
"rs/installation.html). It is developed to work with PyO3 and is the most "
"\"batteries included\" experience. `maturin` is just a python package so you "
"can add it in any way that you install python packages."
msgstr ""

#: src/getting_started.md:29
msgid "System Python:"
msgstr "系統 Python："

#: src/getting_started.md:34
msgid "pipx:"
msgstr "pipx："

#: src/getting_started.md:39
msgid "pyenv:"
msgstr "pyenv："

#: src/getting_started.md:45
msgid "poetry:"
msgstr "poetry："

#: src/getting_started.md:50
msgid ""
"after installation, you can run `maturin --version` to check that you have "
"correctly installed it."
msgstr ""

#: src/getting_started.md:52
msgid "Starting a new project"
msgstr "開始新專案"

#: src/getting_started.md:54
msgid ""
"Firstly you should create the folder and virtual environment that are going "
"to contain your new project. Here we will use the recommended `pyenv`:"
msgstr ""

#: src/getting_started.md:62
msgid ""
"after this, you should install your build manager. In this example, we will "
"use `maturin`. After you've activated your virtualenv add `maturin` to it:"
msgstr ""

#: src/getting_started.md:68
msgid "After this, you can initialise the new project"
msgstr ""

#: src/getting_started.md:74
msgid ""
"If `maturin` is already installed you can create a new project using that "
"directly as well:"
msgstr ""

#: src/getting_started.md:83
msgid "Adding to an existing project"
msgstr "加入既有專案"

#: src/getting_started.md:85
msgid ""
"Sadly currently `maturin` cannot be run in existing projects, so if you want "
"to use python in an existing project you basically have two options:"
msgstr ""

#: src/getting_started.md:87
msgid ""
"create a new project as above and move your existing code into that project"
msgstr ""

#: src/getting_started.md:88
msgid "Manually edit your project configuration as necessary."
msgstr ""

#: src/getting_started.md:90
msgid ""
"If you are opting for the second option, here are the things you need to pay "
"attention to:"
msgstr ""

#: src/getting_started.md:92
msgid "Cargo.toml"
msgstr ""

#: src/getting_started.md:94
msgid ""
"Make sure that the rust you want to be able to access from Python is "
"compiled into a library. You can have a binary output as well, but the code "
"you want to access from python has to be in the library. Also, make sure "
"that the crate type is `cdylib`  and add PyO3 as a dependency as so:"
msgstr ""

#: src/getting_started.md:97
msgid ""
"```toml\n"
"[package]\n"
"# Name of the package. If you already have a package defined in `Cargo."
"toml`, you can remove\n"
"# this section.\n"
"name = \"pyo3_start\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"pyo3_example\"\n"
"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { git = \"https://github.com/pyo3/pyo3\", features = [\"extension-"
"module\"] }\n"
"```"
msgstr ""

#: src/getting_started.md:118
msgid "pyproject.toml"
msgstr ""

#: src/getting_started.md:120
msgid "You should also create a `pyproject.toml` with the following contents:"
msgstr "你也應建立一個 `pyproject.toml`，內容如下："

#: src/getting_started.md:122
msgid ""
"```toml\n"
"[build-system]\n"
"requires = [\"maturin>=0.13,<0.14\"]\n"
"build-backend = \"maturin\"\n"
"\n"
"[project]\n"
"name = \"pyo3_example\"\n"
"requires-python = \">=3.7\"\n"
"classifiers = [\n"
"    \"Programming Language :: Rust\",\n"
"    \"Programming Language :: Python :: Implementation :: CPython\",\n"
"    \"Programming Language :: Python :: Implementation :: PyPy\",\n"
"]\n"
"```"
msgstr ""

#: src/getting_started.md:137
msgid "Running code"
msgstr "執行程式碼"

#: src/getting_started.md:139
msgid ""
"After this you can setup rust code to be available in python as below; for "
"example, you can place this code in `src/lib.rs`"
msgstr ""

#: src/getting_started.md:143
msgid "/// Formats the sum of two numbers as string.\n"
msgstr "/// 將兩個數字的總和格式化為字串。\n"

#: src/getting_started.md:149
msgid ""
"/// A Python module implemented in Rust. The name of this function must "
"match\n"
"/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able "
"to\n"
"/// import the module.\n"
msgstr ""
"/// 以 Rust 實作的 Python 模組。此函式名稱必須\n"
"/// 與 `Cargo.toml` 中的 `lib.name` 設定一致，\n"
"/// 否則 Python 將無法匯入該模組。\n"

#: src/getting_started.md:160
msgid ""
"After this you can run `maturin develop` to prepare the python package after "
"which you can use it like so:"
msgstr ""

#: src/getting_started.md:163
msgid "# lots of progress output as maturin runs the compilation...\n"
msgstr "# maturin 執行編譯時會輸出大量進度訊息...\n"

#: src/getting_started.md:167
msgid "'25'"
msgstr ""

#: src/getting_started.md:171
msgid ""
"For more instructions on how to use python code from rust see the [Python "
"from Rust](python_from_rust.md) page."
msgstr ""

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "Mutability and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`Py::clone_ref`](https://pyo3.rs/main/doc/pyo3/struct.Py.html#method."
"clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe acces to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:47
msgid "Object types"
msgstr ""

#: src/types.md:49
msgid "[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/types.md:51
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, `&PyAny`."
msgstr ""

#: src/types.md:54
msgid ""
"**Used:** Whenever you want to refer to some Python object and will have the "
"GIL for the whole duration you need to access that object. For example, "
"intermediate values and arguments to `pyfunction`s or `pymethod`s "
"implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:59
msgid ""
"Many general methods for interacting with Python objects are on the `PyAny` "
"struct, such as `getattr`, `setattr`, and `.call`."
msgstr ""

#: src/types.md:62 src/types.md:128 src/types.md:166 src/types.md:233
msgid "**Conversions:**"
msgstr ""

#: src/types.md:64
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"Python-native type such as a list:"
msgstr ""

#: src/types.md:72
msgid "// To &PyList with PyAny::downcast\n"
msgstr ""

#: src/types.md:75 src/types.md:96 src/types.md:183
msgid "// To Py<PyAny> (aka PyObject) with .into()\n"
msgstr ""

#: src/types.md:78
msgid "// To Py<PyList> with PyAny::extract\n"
msgstr ""

#: src/types.md:85
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"`#[pyclass]`:"
msgstr ""

#: src/types.md:93
msgid "// To &PyCell<MyClass> with PyAny::downcast\n"
msgstr ""

#: src/types.md:99
msgid "// To Py<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:102
msgid "// To MyClass with PyAny::extract, if MyClass: Clone\n"
msgstr ""

#: src/types.md:105
msgid "// To PyRef<'_, MyClass> or PyRefMut<'_, MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:113
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:115
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:118
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:122
msgid ""
"These types all implement `Deref<Target = PyAny>`, so they all expose the "
"same methods which can be found on `PyAny`."
msgstr ""

#: src/types.md:125
msgid ""
"To see all Python types exposed by `PyO3` you should consult the [`pyo3::"
"types`](https://pyo3.rs/main/doc/pyo3/types/index.html) module."
msgstr ""

#: src/types.md:135
msgid ""
"// Use methods from PyAny on all Python types with Deref implementation\n"
msgstr ""

#: src/types.md:138 src/types.md:265
msgid "// To &PyAny automatically with Deref implementation\n"
msgstr ""

#: src/types.md:141 src/types.md:268
msgid "// To &PyAny explicitly with .as_ref()\n"
msgstr ""

#: src/types.md:144
msgid "// To Py<T> with .into() or Py::from()\n"
msgstr ""

#: src/types.md:147
msgid "// To PyObject with .into() or .to_object(py)\n"
msgstr ""

#: src/types.md:154
msgid "`Py<T>` and `PyObject`"
msgstr ""

#: src/types.md:156
msgid ""
"**Represents:** a GIL-independent reference to a Python object. This can be "
"a Python native type (like `PyTuple`), or a `pyclass` type implemented in "
"Rust. The most commonly-used variant, `Py<PyAny>`, is also known as "
"`PyObject`."
msgstr ""

#: src/types.md:160
msgid ""
"**Used:** Whenever you want to carry around references to a Python object "
"without caring about a GIL lifetime.  For example, storing Python object "
"references in a Rust struct that outlives the Python-Rust FFI boundary, or "
"returning objects from functions implemented in Rust back to Python."
msgstr ""

#: src/types.md:164
msgid "Can be cloned using Python reference counts with `.clone()`."
msgstr ""

#: src/types.md:168
msgid "For a `Py<PyList>`, the conversions are as below:"
msgstr ""

#: src/types.md:175
msgid "// To &PyList with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:179
msgid ""
"// Because `.into_ref()` will consume `list`.\n"
"// To &PyList with Py::into_ref() (moves the pointer into PyO3's object "
"storage)\n"
msgstr ""

#: src/types.md:189
msgid ""
"For a `#[pyclass] struct MyClass`, the conversions for `Py<MyClass>` are "
"below:"
msgstr ""

#: src/types.md:197
msgid "// To &PyCell<MyClass> with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:201
msgid ""
"// Because `.into_ref()` will consume `my_class`.\n"
"// To &PyCell<MyClass> with Py::into_ref() (moves the pointer into PyO3's "
"object storage)\n"
msgstr ""

#: src/types.md:205
msgid "// To Py<PyAny> (aka PyObject) with .into_py(py)\n"
msgstr ""

#: src/types.md:209
msgid "// To PyRef<'_, MyClass> with Py::borrow or Py::try_borrow\n"
msgstr ""

#: src/types.md:212
msgid "// To PyRefMut<'_, MyClass> with Py::borrow_mut or Py::try_borrow_mut\n"
msgstr ""

#: src/types.md:220
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:222
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:226
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:230
msgid ""
"Like pyo3's Python native types, `PyCell<T>` implements `Deref<Target = "
"PyAny>`, so it also exposes all of the methods on `PyAny`."
msgstr ""

#: src/types.md:235
msgid ""
"`PyCell<T>` can be used to access `&T` and `&mut T` via `PyRef<T>` and "
"`PyRefMut<T>` respectively."
msgstr ""

#: src/types.md:242
msgid "// To PyRef<T> with .borrow() or .try_borrow()\n"
msgstr ""

#: src/types.md:247
msgid "// To PyRefMut<T> with .borrow_mut() or .try_borrow_mut()\n"
msgstr ""

#: src/types.md:255
msgid "`PyCell<T>` can also be accessed like a Python-native type."
msgstr ""

#: src/types.md:262
msgid "// Use methods from PyAny on PyCell<T> with Deref implementation\n"
msgstr ""

#: src/types.md:275
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:277
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:280
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:284
msgid "Related traits and types"
msgstr ""

#: src/types.md:286
msgid "`PyClass`"
msgstr ""

#: src/types.md:288
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:291
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:293
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""

#: src/index.md:1
msgid "The PyO3 user guide"
msgstr "PyO3 使用者指南"

#: src/index.md:3
msgid ""
"Welcome to the PyO3 user guide! This book is a companion to [PyO3's API docs]"
"(https://docs.rs/pyo3). It contains examples and documentation to explain "
"all of PyO3's use cases in detail."
msgstr ""
"歡迎閱讀 PyO3 使用者指南！本書是 [PyO3 API 文件](https://docs.rs/pyo3) 的輔助"
"說明，包含範例與文件，詳細解釋 PyO3 的各種使用情境。"

#: src/index.md:5
msgid ""
"Please choose from the chapters on the left to jump to individual topics, or "
"continue below to start with PyO3's README."
msgstr "請從左側章節選擇主題，或繼續往下閱讀 PyO3 的 README。"

#: src/index.md:7
msgid "PyO3"
msgstr ""

#: src/index.md:9
msgid ""
"[![actions status](https://github.com/PyO3/pyo3/workflows/CI/badge.svg)]"
"(https://github.com/PyO3/pyo3/actions) [![benchmark](https://github.com/PyO3/"
"pyo3/actions/workflows/bench.yml/badge.svg)](https://pyo3.rs/dev/bench/) [!"
"[codecov](https://codecov.io/gh/PyO3/pyo3/branch/main/graph/badge.svg)]"
"(https://codecov.io/gh/PyO3/pyo3) [![crates.io](https://img.shields.io/"
"crates/v/pyo3)](https://crates.io/crates/pyo3) [![minimum rustc 1.48]"
"(https://img.shields.io/badge/rustc-1.48+-blue.svg)](https://rust-lang."
"github.io/rfcs/2495-min-rust-version.html) [![dev chat](https://img.shields."
"io/gitter/room/nwjs/nw.js.svg)](https://gitter.im/PyO3/Lobby) [!"
"[contributing notes](https://img.shields.io/badge/contribute-on%20github-"
"Green)](https://github.com/PyO3/pyo3/blob/main/Contributing.md)"
msgstr ""

#: src/index.md:17
msgid ""
"[Rust](https://www.rust-lang.org/) bindings for [Python](https://www.python."
"org/), including tools for creating native Python extension modules. Running "
"and interacting with Python code from a Rust binary is also supported."
msgstr ""
"提供 [Rust](https://www.rust-lang.org/) 對 [Python](https://www.python.org/) "
"的綁定，包含建立原生 Python 擴充模組的工具；也支援在 Rust 二進位程式中執行並"
"與 Python 程式碼互動。"

#: src/index.md:19
msgid "User Guide: [stable](https://pyo3.rs) | [main](https://pyo3.rs/main)"
msgstr "使用者指南：[stable](https://pyo3.rs) | [main](https://pyo3.rs/main)"

#: src/index.md:21
msgid ""
"API Documentation: [stable](https://docs.rs/pyo3/) | [main](https://pyo3.rs/"
"main/doc)"
msgstr ""
"API 文件：[stable](https://docs.rs/pyo3/) | [main](https://pyo3.rs/main/doc)"

#: src/index.md:23
msgid "Usage"
msgstr "使用方式"

#: src/index.md:25
msgid "PyO3 supports the following software versions:"
msgstr ""

#: src/index.md:26
msgid "Python 3.7 and up (CPython and PyPy)"
msgstr ""

#: src/index.md:27
msgid "Rust 1.48 and up"
msgstr ""

#: src/index.md:29
msgid ""
"You can use PyO3 to write a native Python module in Rust, or to embed Python "
"in a Rust binary. The following sections explain each of these in turn."
msgstr ""
"你可以使用 PyO3 以 Rust 撰寫原生 Python 模組，或在 Rust 二進位程式中嵌入 "
"Python。以下各節將依序說明。"

#: src/index.md:31
msgid "Using Rust from Python"
msgstr "從 Python 使用 Rust"

#: src/index.md:33
msgid ""
"PyO3 can be used to generate a native Python module. The easiest way to try "
"this out for the first time is to use [`maturin`](https://github.com/PyO3/"
"maturin). `maturin` is a tool for building and publishing Rust-based Python "
"packages with minimal configuration. The following steps install `maturin`, "
"use it to generate and build a new Python package, and then launch Python to "
"import and execute a function from the package."
msgstr ""
"PyO3 可用來產生原生 Python 模組。第一次嘗試最簡單的方法是使用 [`maturin`]"
"(https://github.com/PyO3/maturin)。`maturin` 是用來以最少設定建置並發布以 "
"Rust 為基礎的 Python 軟體包的工具。以下步驟會安裝 `maturin`、用它產生並建置新"
"的 Python 軟體包，接著啟動 Python 匯入並執行軟體包中的函式。"

#: src/index.md:35
msgid ""
"First, follow the commands below to create a new directory containing a new "
"Python `virtualenv`, and install `maturin` into the virtualenv using "
"Python's package manager, `pip`:"
msgstr ""
"首先，依照以下命令建立一個包含 Python `virtualenv` 的新目錄，並使用 Python 軟"
"體包管理工具 `pip` 將 `maturin` 安裝到該 virtualenv："

#: src/index.md:38
msgid "# (replace string_sum with the desired package name)\n"
msgstr "#（將 string_sum 替換為想要的軟體包名稱）\n"

#: src/index.md:46
msgid ""
"Still inside this `string_sum` directory, now run `maturin init`. This will "
"generate the new package source. When given the choice of bindings to use, "
"select pyo3 bindings:"
msgstr ""
"仍在這個 `string_sum` 目錄中時，執行 `maturin init`。這會產生新的軟體包來源"
"碼。當詢問要使用哪種綁定時，選擇 pyo3 綁定："

#: src/index.md:54
msgid ""
"The most important files generated by this command are `Cargo.toml` and `lib."
"rs`, which will look roughly like the following:"
msgstr "此命令產生的最重要檔案是 `Cargo.toml` 與 `lib.rs`，大致如下："

#: src/index.md:56
msgid "**`Cargo.toml`**"
msgstr "**`Cargo.toml`**"

#: src/index.md:58
msgid ""
"```toml\n"
"[package]\n"
"name = \"string_sum\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"\n"
"[lib]\n"
"# The name of the native library. This is the name which will be used in "
"Python to import the\n"
"# library (i.e. `import string_sum`). If you change this, you must also "
"change the name of the\n"
"# `#[pymodule]` in `src/lib.rs`.\n"
"name = \"string_sum\"\n"
"# \"cdylib\" is necessary to produce a shared library for Python to import "
"from.\n"
"#\n"
"# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) "
"will not be able\n"
"# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also "
"included, e.g.:\n"
"# crate-type = [\"cdylib\", \"rlib\"]\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.17.3\", features = [\"extension-module\"] }\n"
"```"
msgstr ""

#: src/index.md:80
msgid "**`src/lib.rs`**"
msgstr ""

#: src/index.md:101
msgid ""
"Finally, run `maturin develop`. This will build the package and install it "
"into the Python virtualenv previously created and activated. The package is "
"then ready to be used from `python`:"
msgstr ""
"最後，執行 `maturin develop`。這會建置軟體包並安裝到先前建立並啟用的 Python "
"virtualenv。接著即可在 `python` 中使用該軟體包："

#: src/index.md:112
msgid ""
"To make changes to the package, just edit the Rust source code and then re-"
"run `maturin develop` to recompile."
msgstr ""
"要修改軟體包時，只需編輯 Rust 來源碼，然後重新執行 `maturin develop` 以重新編"
"譯。"

#: src/index.md:114
msgid ""
"To run this all as a single copy-and-paste, use the bash script below "
"(replace `string_sum` in the first command with the desired package name):"
msgstr ""
"若要一次複製貼上完成全部步驟，請使用下列 bash 腳本（將第一個命令中的 "
"`string_sum` 替換為想要的軟體包名稱）："

#: src/index.md:117
msgid "\"$_\""
msgstr ""

#: src/index.md:125
msgid ""
"If you want to be able to run `cargo test` or use this project in a Cargo "
"workspace and are running into linker issues, there are some workarounds in "
"[the FAQ](https://pyo3.rs/latest/faq.html#i-cant-run-cargo-test-or-i-cant-"
"build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-"
"undefined-reference-to-_pyexc_systemerror)."
msgstr ""
"如果你想要執行 `cargo test` 或在 Cargo workspace 中使用此專案，但遇到連結器問"
"題，可參考 [FAQ](https://pyo3.rs/latest/faq.html#i-cant-run-cargo-test-or-i-"
"cant-build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-"
"found-or-undefined-reference-to-_pyexc_systemerror) 的替代做法。"

#: src/index.md:127
msgid ""
"As well as with `maturin`, it is possible to build using [`setuptools-rust`]"
"(https://github.com/PyO3/setuptools-rust) or [manually](https://pyo3.rs/"
"latest/building_and_distribution.html#manual-builds). Both offer more "
"flexibility than `maturin` but require more configuration to get started."
msgstr ""

#: src/index.md:129
msgid "Using Python from Rust"
msgstr "從 Rust 使用 Python"

#: src/index.md:131
msgid ""
"To embed Python into a Rust binary, you need to ensure that your Python "
"installation contains a shared library. The following steps demonstrate how "
"to ensure this (for Ubuntu), and then give some example code which runs an "
"embedded Python interpreter."
msgstr ""
"若要在 Rust 二進位程式中嵌入 Python，你需要確保 Python 安裝包含共享函式庫。以"
"下步驟示範如何在 Ubuntu 上完成此設定，並提供一段執行嵌入式 Python 直譯器的範"
"例程式碼。"

#: src/index.md:133
msgid "To install the Python shared library on Ubuntu:"
msgstr "在 Ubuntu 上安裝 Python 共享函式庫："

#: src/index.md:139
msgid ""
"Start a new project with `cargo new` and add  `pyo3` to the `Cargo.toml` "
"like this:"
msgstr "使用 `cargo new` 建立新專案，並在 `Cargo.toml` 中加入 `pyo3`："

#: src/index.md:141
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"version = \"0.17.3\"\n"
"features = [\"auto-initialize\"]\n"
"```"
msgstr ""

#: src/index.md:147
msgid ""
"Example program displaying the value of `sys.version` and the current user "
"name:"
msgstr "顯示 `sys.version` 與目前使用者名稱的範例程式："

#: src/index.md:156
msgid "\"version\""
msgstr ""

#: src/index.md:158
msgid "\"os\""
msgstr ""

#: src/index.md:159
msgid "\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\""
msgstr ""

#: src/index.md:162
msgid "\"Hello {}, I'm Python {}\""
msgstr ""

#: src/index.md:168
msgid ""
"The guide has [a section](https://pyo3.rs/latest/python_from_rust.html) with "
"lots of examples about this topic."
msgstr ""

#: src/index.md:171
msgid "Tools and libraries"
msgstr "工具與程式庫"

#: src/index.md:173
msgid ""
"[maturin](https://github.com/PyO3/maturin) _Build and publish crates with "
"pyo3, rust-cpython or cffi bindings as well as rust binaries as python "
"packages_"
msgstr ""
"[maturin](https://github.com/PyO3/maturin) _使用 pyo3、rust-cpython 或 cffi "
"綁定建置並發布 crate，並將 Rust 二進位程式打包為 Python 軟體包_"

#: src/index.md:174
msgid ""
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) _Setuptools "
"plugin for Rust support_."
msgstr ""
"[setuptools-rust](https://github.com/PyO3/setuptools-rust) _為 Rust 提供支援"
"的 Setuptools 外掛_。"

#: src/index.md:175
msgid ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _Simple macro to expose "
"metadata obtained with the [`built`](https://crates.io/crates/built) crate "
"as a [`PyDict`](https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html)_"
msgstr ""
"[pyo3-built](https://github.com/PyO3/pyo3-built) _透過簡單的巨集將 [`built`]"
"(https://crates.io/crates/built) crate 取得的中繼資料以 [`PyDict`](https://"
"docs.rs/pyo3/*/pyo3/types/struct.PyDict.html) 形式暴露_"

#: src/index.md:176
msgid ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _Rust binding of NumPy C-"
"API_"
msgstr ""
"[rust-numpy](https://github.com/PyO3/rust-numpy) _NumPy C-API 的 Rust 綁定_"

#: src/index.md:177
msgid ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject to automatically transform Python dicts into Rust structs_"
msgstr ""
"[dict-derive](https://github.com/gperinazzo/dict-derive) _Derive "
"FromPyObject 以自動將 Python dict 轉為 Rust struct_"

#: src/index.md:178
msgid ""
"[pyo3-log](https://github.com/vorner/pyo3-log) _Bridge from Rust to Python "
"logging_"
msgstr ""
"[pyo3-log](https://github.com/vorner/pyo3-log) _將 Rust 連接到 Python 日誌系"
"統的橋接_"

#: src/index.md:179
msgid ""
"[pythonize](https://github.com/davidhewitt/pythonize) _Serde serializer for "
"converting Rust objects to JSON-compatible Python objects_"
msgstr ""
"[pythonize](https://github.com/davidhewitt/pythonize) _用於將 Rust 物件轉成相"
"容 JSON 的 Python 物件的 Serde 序列化工具_"

#: src/index.md:180
msgid ""
"[pyo3-asyncio](https://github.com/awestlake87/pyo3-asyncio) _Utilities for "
"working with Python's Asyncio library and async functions_"
msgstr ""

#: src/index.md:181
msgid ""
"[rustimport](https://github.com/mityax/rustimport) _Directly import Rust "
"files or crates from Python, without manual compilation step. Provides pyo3 "
"integration by default and generates pyo3 binding code automatically._"
msgstr ""
"[rustimport](https://github.com/mityax/rustimport) _可在 Python 直接匯入 "
"Rust 檔案或 crate，無需手動編譯；預設提供 pyo3 整合並自動產生 pyo3 綁定程式碼"
"_"

#: src/index.md:183
msgid "Examples"
msgstr "範例"

#: src/index.md:185
msgid ""
"[hyperjson](https://github.com/mre/hyperjson) _A hyper-fast Python module "
"for reading/writing JSON data using Rust's serde-json_"
msgstr ""

#: src/index.md:186
msgid ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/main/examples/"
"html-py-ever) _Using [html5ever](https://github.com/servo/html5ever) through "
"[kuchiki](https://github.com/kuchiki-rs/kuchiki) to speed up html parsing "
"and css-selecting._"
msgstr ""
"[html-py-ever](https://github.com/PyO3/setuptools-rust/tree/main/examples/"
"html-py-ever) _透過 [kuchiki](https://github.com/kuchiki-rs/kuchiki) 使用 "
"[html5ever](https://github.com/servo/html5ever) 加速 HTML 解析與 CSS 選取_"

#: src/index.md:187
msgid ""
"[point-process](https://github.com/ManifoldFR/point-process-rust/tree/master/"
"pylib) _High level API for pointprocesses as a Python library_"
msgstr ""

#: src/index.md:188
msgid ""
"[autopy](https://github.com/autopilot-rs/autopy) _A simple, cross-platform "
"GUI automation library for Python and Rust._"
msgstr ""

#: src/index.md:189
msgid ""
"Contains an example of building wheels on TravisCI and appveyor using "
"[cibuildwheel](https://github.com/pypa/cibuildwheel)"
msgstr ""

#: src/index.md:190
msgid "[orjson](https://github.com/ijl/orjson) _Fast Python JSON library_"
msgstr ""

#: src/index.md:191
msgid ""
"[inline-python](https://github.com/fusion-engineering/inline-python) _Inline "
"Python code directly in your Rust code_"
msgstr ""

#: src/index.md:192
msgid ""
"[Rogue-Gym](https://github.com/kngwyu/rogue-gym) _Customizable rogue-like "
"game for AI experiments_"
msgstr ""

#: src/index.md:193
msgid "Contains an example of building wheels on Azure Pipelines"
msgstr ""

#: src/index.md:194
msgid ""
"[fastuuid](https://github.com/thedrow/fastuuid/) _Python bindings to Rust's "
"UUID library_"
msgstr ""

#: src/index.md:195
msgid ""
"[wasmer-python](https://github.com/wasmerio/wasmer-python) _Python library "
"to run WebAssembly binaries_"
msgstr ""

#: src/index.md:196
msgid ""
"[mocpy](https://github.com/cds-astro/mocpy) _Astronomical Python library "
"offering data structures for describing any arbitrary coverage regions on "
"the unit sphere_"
msgstr ""

#: src/index.md:197
msgid ""
"[tokenizers](https://github.com/huggingface/tokenizers/tree/main/bindings/"
"python) _Python bindings to the Hugging Face tokenizers (NLP) written in "
"Rust_"
msgstr ""

#: src/index.md:198
msgid ""
"[pyre](https://github.com/Project-Dream-Weaver/pyre-http) _Fast Python HTTP "
"server written in Rust_"
msgstr ""

#: src/index.md:199
msgid ""
"[jsonschema-rs](https://github.com/Stranger6667/jsonschema-rs/tree/master/"
"bindings/python) _Fast JSON Schema validation library_"
msgstr ""

#: src/index.md:200
msgid ""
"[css-inline](https://github.com/Stranger6667/css-inline/tree/master/bindings/"
"python) _CSS inlining for Python implemented in Rust_"
msgstr ""

#: src/index.md:201
msgid ""
"[cryptography](https://github.com/pyca/cryptography/tree/main/src/rust) "
"_Python cryptography library with some functionality in Rust_"
msgstr ""

#: src/index.md:202
msgid ""
"[polaroid](https://github.com/daggy1234/polaroid) _Hyper Fast and safe image "
"manipulation library for Python written in Rust_"
msgstr ""

#: src/index.md:203
msgid ""
"[ormsgpack](https://github.com/aviramha/ormsgpack) _Fast Python msgpack "
"library_"
msgstr ""

#: src/index.md:204
msgid ""
"[bed-reader](https://github.com/fastlmm/bed-reader) _Read and write the "
"PLINK BED format, simply and efficiently_"
msgstr ""

#: src/index.md:205
msgid ""
"Shows Rayon/ndarray::parallel (including capturing errors, controlling "
"thread num), Python types to Rust generics, Github Actions"
msgstr ""
"展示 Rayon/ndarray::parallel（包含錯誤擷取與控制執行緒數）、Python 型別到 "
"Rust 泛型，以及 GitHub Actions"

#: src/index.md:206
msgid ""
"[pyheck](https://github.com/kevinheavey/pyheck) _Fast case conversion "
"library, built by wrapping [heck](https://github.com/withoutboats/heck)_"
msgstr ""

#: src/index.md:207
msgid "Quite easy to follow as there's not much code."
msgstr ""

#: src/index.md:208
msgid ""
"[polars](https://github.com/pola-rs/polars) _Fast multi-threaded DataFrame "
"library in Rust | Python | Node.js_"
msgstr ""

#: src/index.md:209
msgid ""
"[rust-python-coverage](https://github.com/cjermain/rust-python-coverage) "
"_Example PyO3 project with automated test coverage for Rust and Python_"
msgstr ""

#: src/index.md:210
msgid ""
"[forust](https://github.com/jinlow/forust) _A lightweight gradient boosted "
"decision tree library written in Rust._"
msgstr ""
"[forust](https://github.com/jinlow/forust) _以 Rust 撰寫的輕量級梯度提升決策"
"樹函式庫_"

#: src/index.md:211
msgid ""
"[ril-py](https://github.com/Cryptex-github/ril-py) _A performant and high-"
"level image processing library for Python written in Rust_"
msgstr ""

#: src/index.md:212
msgid ""
"[fastbloom](https://github.com/yankun1992/fastbloom) _A fast [bloom filter]"
"(https://github.com/yankun1992/fastbloom#BloomFilter) | [counting bloom "
"filter](https://github.com/yankun1992/fastbloom#countingbloomfilter) "
"implemented by Rust for Rust and Python!_"
msgstr ""
"[fastbloom](https://github.com/yankun1992/fastbloom) _以 Rust 實作的快速 "
"[bloom filter](https://github.com/yankun1992/fastbloom#BloomFilter) | "
"[counting bloom filter](https://github.com/yankun1992/"
"fastbloom#countingbloomfilter)，同時支援 Rust 與 Python_"

#: src/index.md:213
msgid ""
"[river](https://github.com/online-ml/river) _Online machine learning in "
"python, the computationally heavy statistics algorithms are implemented in "
"Rust_"
msgstr ""

#: src/index.md:214
msgid ""
"[feos](https://github.com/feos-org/feos) _Lightning fast thermodynamic "
"modeling in Rust with fully developed Python interface_"
msgstr ""

#: src/index.md:216
msgid "Articles and other media"
msgstr "文章及其他媒體"

#: src/index.md:218
msgid ""
"[Nine Rules for Writing Python Extensions in Rust](https://"
"towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-"
"d35ea3a4ec29?sk=f8d808d5f414154fdb811e4137011437) - Dec 31, 2021"
msgstr ""
"[以 Rust 撰寫 Python 擴充的九條規則](https://towardsdatascience.com/nine-"
"rules-for-writing-python-extensions-in-rust-d35ea3a4ec29?"
"sk=f8d808d5f414154fdb811e4137011437) - 2021/12/31"

#: src/index.md:219
msgid ""
"[Calling Rust from Python using PyO3](https://saidvandeklundert.net/"
"learn/2021-11-18-calling-rust-from-python-using-pyo3/) - Nov 18, 2021"
msgstr ""
"[使用 PyO3 從 Python 呼叫 Rust](https://saidvandeklundert.net/"
"learn/2021-11-18-calling-rust-from-python-using-pyo3/) - 2021/11/18"

#: src/index.md:220
msgid ""
"[davidhewitt's 2021 talk at Rust Manchester meetup](https://www.youtube.com/"
"watch?v=-XyWG_klSAw&t=320s) - Aug 19, 2021"
msgstr ""
"[davidhewitt 在 Rust Manchester meetup 的 2021 演講](https://www.youtube.com/"
"watch?v=-XyWG_klSAw&t=320s) - 2021/08/19"

#: src/index.md:221
msgid ""
"[Incrementally porting a small Python project to Rust](https://blog."
"waleedkhan.name/port-python-to-rust/) - Apr 29, 2021"
msgstr ""
"[逐步將小型 Python 專案移植到 Rust](https://blog.waleedkhan.name/port-python-"
"to-rust/) - 2021/04/29"

#: src/index.md:222
msgid ""
"[Vortexa - Integrating Rust into Python](https://www.vortexa.com/insight/"
"integrating-rust-into-python) - Apr 12, 2021"
msgstr ""

#: src/index.md:223
msgid ""
"[Writing and publishing a Python module in Rust](https://blog.yossarian."
"net/2020/08/02/Writing-and-publishing-a-python-module-in-rust) - Aug 2, 2020"
msgstr ""
"[以 Rust 撰寫並發布 Python 模組](https://blog.yossarian.net/2020/08/02/"
"Writing-and-publishing-a-python-module-in-rust) - 2020/08/02"

#: src/index.md:227
msgid ""
"Everyone is welcomed to contribute to PyO3! There are many ways to support "
"the project, such as:"
msgstr "歡迎大家參與 PyO3！你可以用許多方式支持專案，例如："

#: src/index.md:229
msgid "help PyO3 users with issues on GitHub and Gitter"
msgstr ""

#: src/index.md:230
msgid "improve documentation"
msgstr "改善文件"

#: src/index.md:231
msgid "write features and bugfixes"
msgstr "撰寫功能與修復錯誤"

#: src/index.md:232
msgid "publish blogs and examples of how to use PyO3"
msgstr "發表如何使用 PyO3 的部落格與範例"

#: src/index.md:234
msgid ""
"Our [contributing notes](https://github.com/PyO3/pyo3/blob/main/Contributing."
"md) and [architecture guide](https://github.com/PyO3/pyo3/blob/main/"
"Architecture.md) have more resources if you wish to volunteer time for PyO3 "
"and are searching where to start."
msgstr ""
"若你願意投入時間參與 PyO3，但不確定從哪裡開始，可參考我們的[貢獻說明]"
"(https://github.com/PyO3/pyo3/blob/main/Contributing.md)與[架構指南](https://"
"github.com/PyO3/pyo3/blob/main/Architecture.md)取得更多資源。"

#: src/index.md:236
msgid ""
"If you don't have time to contribute yourself but still wish to support the "
"project's future success, some of our maintainers have GitHub sponsorship "
"pages:"
msgstr ""
"如果你沒有時間親自貢獻，但仍想支持專案的長期發展，部分維護者有 GitHub 贊助頁"
"面："

#: src/index.md:241
msgid "License"
msgstr "授權條款"

#: src/index.md:243
msgid ""
"PyO3 is licensed under the [Apache-2.0 license](https://opensource.org/"
"licenses/APACHE-2.0). Python is licensed under the [Python License](https://"
"docs.python.org/3/license.html)."
msgstr ""

#: src/index.md:246
msgid ""
"<a href=\"https://www.netlify.com\"> <img src=\"https://www.netlify.com/v3/"
"img/components/netlify-color-accent.svg\" alt=\"Deploys by Netlify\" /> </a>"
msgstr ""

#: src/memory.md:3
msgid ""
"Rust and Python have very different notions of memory management.  Rust has "
"a strict memory model with concepts of ownership, borrowing, and lifetimes, "
"where memory is freed at predictable points in program execution.  Python "
"has a looser memory model in which variables are reference-counted with "
"shared, mutable state by default. A global interpreter lock (GIL) is needed "
"to prevent race conditions, and a garbage collector is needed to break "
"reference cycles. Memory in Python is freed eventually by the garbage "
"collector, but not usually in a predictable way."
msgstr ""

#: src/memory.md:12
msgid ""
"PyO3 bridges the Rust and Python memory models with two different strategies "
"for accessing memory allocated on Python's heap from inside Rust.  These are "
"GIL-bound, or \"owned\" references, and GIL-independent `Py<Any>` smart "
"pointers."
msgstr ""

#: src/memory.md:16
msgid "GIL-bound memory"
msgstr ""

#: src/memory.md:18
msgid ""
"PyO3's GIL-bound, \"owned references\" (`&PyAny` etc.) make PyO3 more "
"ergonomic to use by ensuring that their lifetime can never be longer than "
"the duration the Python GIL is held.  This means that most of PyO3's API can "
"assume the GIL is held. (If PyO3 could not assume this, every PyO3 API would "
"need to take a `Python` GIL token to prove that the GIL is held.)  This "
"allows us to write very simple and easy-to-understand programs like this:"
msgstr ""

#: src/memory.md:30 src/memory.md:52 src/memory.md:80 src/memory.md:101
#: src/memory.md:139 src/memory.md:161 src/memory.md:192 src/memory.md:215
msgid "\"\\\"Hello World!\\\"\""
msgstr ""

#: src/memory.md:31 src/memory.md:53 src/memory.md:81 src/memory.md:102
#: src/memory.md:140 src/memory.md:166 src/memory.md:197 src/memory.md:220
msgid "\"Python says: {}\""
msgstr ""

#: src/memory.md:38
msgid ""
"Internally, calling `Python::with_gil()` or `Python::acquire_gil()` creates "
"a `GILPool` which owns the memory pointed to by the reference.  In the "
"example above, the lifetime of the reference `hello` is bound to the "
"`GILPool`.  When the `with_gil()` closure ends or the `GILGuard` from "
"`acquire_gil()` is dropped, the `GILPool` is also dropped and the Python "
"reference counts of the variables it owns are decreased, releasing them to "
"the Python garbage collector.  Most of the time we don't have to think about "
"this, but consider the following:"
msgstr ""

#: src/memory.md:55
msgid "// There are 10 copies of `hello` on Python's heap here.\n"
msgstr ""

#: src/memory.md:62
msgid ""
"We might assume that the `hello` variable's memory is freed at the end of "
"each loop iteration, but in fact we create 10 copies of `hello` on Python's "
"heap. This may seem surprising at first, but it is completely consistent "
"with Rust's memory model.  The `hello` variable is dropped at the end of "
"each loop, but it is only a reference to the memory owned by the `GILPool`, "
"and its lifetime is bound to the `GILPool`, not the for loop.  The `GILPool` "
"isn't dropped until the end of the `with_gil()` closure, at which point the "
"10 copies of `hello` are finally released to the Python garbage collector."
msgstr ""

#: src/memory.md:71
msgid ""
"In general we don't want unbounded memory growth during loops!  One "
"workaround is to acquire and release the GIL with each iteration of the loop."
msgstr ""

#: src/memory.md:83
msgid "// only one copy of `hello` at a time\n"
msgstr ""

#: src/memory.md:89
msgid ""
"It might not be practical or performant to acquire and release the GIL so "
"many times.  Another workaround is to work with the `GILPool` object "
"directly, but this is unsafe."
msgstr ""

#: src/memory.md:110
msgid ""
"The unsafe method `Python::new_pool` allows you to create a nested `GILPool` "
"from which you can retrieve a new `py: Python` GIL token.  Variables created "
"with this new GIL token are bound to the nested `GILPool` and will be "
"released when the nested `GILPool` is dropped.  Here, the nested `GILPool` "
"is dropped at the end of each loop iteration, before the `with_gil()` "
"closure ends."
msgstr ""

#: src/memory.md:116
msgid ""
"When doing this, you must be very careful to ensure that once the `GILPool` "
"is dropped you do not retain access to any owned references created after "
"the `GILPool` was created.  Read the [documentation for `Python::new_pool()`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/struct.Python.html#method.new_pool) "
"for more information on safety."
msgstr ""

#: src/memory.md:122
msgid "GIL-independent memory"
msgstr ""

#: src/memory.md:124
msgid ""
"Sometimes we need a reference to memory on Python's heap that can outlive "
"the GIL.  Python's `Py<PyAny>` is analogous to `Rc<T>`, but for variables "
"whose memory is allocated on Python's heap.  Cloning a `Py<PyAny>` increases "
"its internal reference count just like cloning `Rc<T>`.  The smart pointer "
"can outlive the GIL from which it was created.  It isn't magic, though.  We "
"need to reacquire the GIL to access the memory pointed to by the `Py<PyAny>`."
msgstr ""

#: src/memory.md:131
msgid ""
"What happens to the memory when the last `Py<PyAny>` is dropped and its "
"reference count reaches zero?  It depends whether or not we are holding the "
"GIL."
msgstr ""

#: src/memory.md:147
msgid ""
"At the end of the `Python::with_gil()` closure `hello` is dropped, and then "
"the GIL is dropped.  Since `hello` is dropped while the GIL is still held by "
"the current thread, its memory is released to the Python garbage collector "
"immediately."
msgstr ""

#: src/memory.md:152
msgid ""
"This example wasn't very interesting.  We could have just used a GIL-bound "
"`&PyString` reference.  What happens when the last `Py<Any>` is dropped "
"while we are _not_ holding the GIL?"
msgstr ""

#: src/memory.md:162
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program we want to access `hello`.\n"
msgstr ""

#: src/memory.md:167
msgid "// Now we're done with `hello`.\n"
msgstr ""

#: src/memory.md:169
msgid ""
"// Memory *not* released here.\n"
"// Sometime later we need the GIL again for something...\n"
msgstr ""

#: src/memory.md:172
msgid "// Memory for `hello` is released here.\n"
msgstr ""

#: src/memory.md:179
msgid ""
"When `hello` is dropped _nothing_ happens to the pointed-to memory on "
"Python's heap because nothing _can_ happen if we're not holding the GIL.  "
"Fortunately, the memory isn't leaked.  PyO3 keeps track of the memory "
"internally and will release it the next time we acquire the GIL."
msgstr ""

#: src/memory.md:184
msgid ""
"We can avoid the delay in releasing memory if we are careful to drop the "
"`Py<Any>` while the GIL is held."
msgstr ""

#: src/memory.md:193 src/memory.md:216
msgid ""
"// Do some stuff...\n"
"// Now sometime later in the program:\n"
msgstr ""

#: src/memory.md:198
msgid "// Memory released here.\n"
msgstr ""

#: src/memory.md:204
msgid ""
"We could also have used `Py::into_ref()`, which consumes `self`, instead of "
"`Py::as_ref()`.  But note that in addition to being slower than `as_ref()`, "
"`into_ref()` binds the memory to the lifetime of the `GILPool`, which means "
"that rather than being released immediately, the memory will not be released "
"until the GIL is dropped."
msgstr ""

#: src/memory.md:221
msgid ""
"// Memory not released yet.\n"
"    // Do more stuff...\n"
"    // Memory released here at end of `with_gil()` closure.\n"
msgstr ""

#: src/parallelism.md:1
msgid "Parallelism"
msgstr "平行化"

#: src/parallelism.md:3
msgid ""
"CPython has the infamous [Global Interpreter Lock](https://docs.python.org/3/"
"glossary.html#term-global-interpreter-lock), which prevents several threads "
"from executing Python bytecode in parallel. This makes threading in Python a "
"bad fit for [CPU-bound](https://stackoverflow.com/questions/868568/) tasks "
"and often forces developers to accept the overhead of multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a "
"look at our [word-count](https://github.com/PyO3/pyo3/blob/main/examples/"
"word-count/src/lib.rs) example, where we have a `search` function that "
"utilizes the [rayon](https://github.com/rayon-rs/rayon) crate to count words "
"in parallel."
msgstr ""

#: src/parallelism.md:9
msgid "// These traits let us use `par_lines` and `map`.\n"
msgstr "// 這些特徵讓我們可以使用 `par_lines` 和 `map`。\n"

#: src/parallelism.md:13
msgid "/// Count the occurrences of needle in line, case insensitive\n"
msgstr "/// 計算某行中 needle 出現次數，不區分大小寫\n"

#: src/parallelism.md:17 src/parallelism.md:39 src/parallelism.md:59
msgid "' '"
msgstr ""

#: src/parallelism.md:34
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""
"假設你有一個耗時的 Rust 函式，想要平行執行多次。以下以字數統計的序列版作為範"
"例："

#: src/parallelism.md:52
msgid ""
"To enable parallel execution of this function, the [`Python::allow_threads`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.allow_threads) "
"method can be used to temporarily release the GIL, thus allowing other "
"Python threads to run. We then have a function exposed to the Python runtime "
"which calls `search_sequential` inside a closure passed to [`Python::"
"allow_threads`](https://pyo3.rs/main/doc/pyo3/struct.Python.html#method."
"allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:76
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""
"現在 Python 執行緒可使用多個 CPU 核心，解決了 Python 多執行緒通常只適合 I/O-"
"bound 任務的限制："

#: src/parallelism.md:93
msgid "Benchmark"
msgstr "基準測試"

#: src/parallelism.md:95
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr "讓我們對 `word-count` 範例做基準測試，確認 PyO3 確實解鎖了平行化。"

#: src/parallelism.md:97
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr "我們使用 `pytest-benchmark` 來測試四個字數統計函式："

#: src/parallelism.md:99
msgid "Pure Python version"
msgstr "純 Python 版本"

#: src/parallelism.md:100
msgid "Rust parallel version"
msgstr "Rust 平行版本"

#: src/parallelism.md:101
msgid "Rust sequential version"
msgstr "Rust 序列版本"

#: src/parallelism.md:102
msgid "Rust sequential version executed twice with two Python threads"
msgstr "Rust 序列版本在兩個 Python 執行緒中執行兩次"

#: src/parallelism.md:104
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `nox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""
"基準測試腳本在[這裡](https://github.com/PyO3/pyo3/blob/main/examples/word-"
"count/tests/test_word_count.py)，我們可在 `word-count` 資料夾中執行 `nox` 進"
"行測試。"

#: src/parallelism.md:106
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr "雖然基準測試結果會因機器而異，但相對結果應與下圖（2020 年中）相近："

#: src/parallelism.md:118
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""
"可以看到 Python 執行緒版本沒有比 Rust 序列版本慢太多，這代表相較於單一 CPU 核"
"心的執行，速度翻倍。"

#: src/class.md:1
msgid "Python classes"
msgstr "Python 類別"

#: src/class.md:3
msgid ""
"PyO3 exposes a group of attributes powered by Rust's proc macro system for "
"defining Python classes as Rust structs."
msgstr ""

#: src/class.md:5
msgid ""
"The main attribute is `#[pyclass]`, which is placed upon a Rust `struct` or "
"a fieldless `enum` (a.k.a. C-like enum) to generate a Python type for it. "
"They will usually also have _one_ `#[pymethods]`\\-annotated `impl` block "
"for the struct, which is used to define Python methods and constants for the "
"generated Python type. (If the [`multiple-pymethods`](features.md#multiple-"
"pymethods) feature is enabled each `#[pyclass]` is allowed to have multiple "
"`#[pymethods]` blocks.) `#[pymethods]` may also have implementations for "
"Python magic methods such as `__str__`."
msgstr ""

#: src/class.md:7
msgid ""
"This chapter will discuss the functionality and configuration these "
"attributes offer. Below is a list of links to the relevant section of this "
"chapter for each:"
msgstr ""

#: src/class.md:9
msgid "[`#[pyclass]`](#defining-a-new-class)"
msgstr ""

#: src/class.md:10
msgid "[`#[pyo3(get, set)]`](#object-properties-using-pyo3get-set)"
msgstr ""

#: src/class.md:11
msgid "[`#[pymethods]`](#instance-methods)"
msgstr "[`#[pymethods]`](#instance-methods)"

#: src/class.md:12
msgid "[`#[new]`](#constructor)"
msgstr "[`#[new]`](#constructor)"

#: src/class.md:13
msgid "[`#[getter]`](#object-properties-using-getter-and-setter)"
msgstr "[`#[getter]`](#object-properties-using-getter-and-setter)"

#: src/class.md:14
msgid "[`#[setter]`](#object-properties-using-getter-and-setter)"
msgstr "[`#[setter]`](#object-properties-using-getter-and-setter)"

#: src/class.md:15
msgid "[`#[staticmethod]`](#static-methods)"
msgstr "[`#[staticmethod]`](#static-methods)"

#: src/class.md:16
msgid "[`#[classmethod]`](#class-methods)"
msgstr "[`#[classmethod]`](#class-methods)"

#: src/class.md:17
msgid "[`#[classattr]`](#class-attributes)"
msgstr "[`#[classattr]`](#class-attributes)"

#: src/class.md:18
msgid "[`#[args]`](#method-arguments)"
msgstr "[`#[args]`](#method-arguments)"

#: src/class.md:19
msgid "[Magic methods and slots](class/protocols.html)"
msgstr ""

#: src/class.md:21
msgid "Defining a new class"
msgstr "定義新類別"

#: src/class.md:23
msgid ""
"To define a custom Python class, add the `#[pyclass]` attribute to a Rust "
"struct or a fieldless enum."
msgstr ""

#: src/class.md:32
msgid "// A \"tuple\" struct\n"
msgstr ""

#: src/class.md:36
msgid "// PyO3 supports custom discriminants in enums\n"
msgstr ""

#: src/class.md:43
msgid "// ...\n"
msgstr ""

#: src/class.md:49
msgid "// PyO3 supports custom discriminants.\n"
msgstr ""

#: src/class.md:53
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html) and [`PyClass`](https://"
"pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html) for `MyClass` and "
"`MyEnum`. To see these generated implementations, refer to the "
"[implementation details](#implementation-details) at the end of this chapter."
msgstr ""

#: src/class.md:55
msgid "Restrictions"
msgstr ""

#: src/class.md:57
msgid ""
"To integrate Rust types with Python, PyO3 needs to place some restrictions "
"on the types which can be annotated with `#[pyclass]`. In particular, they "
"must have no lifetime parameters, no generic parameters, and must implement "
"`Send`. The reason for each of these is explained below."
msgstr ""

#: src/class.md:59
msgid "No lifetime parameters"
msgstr ""

#: src/class.md:61
msgid ""
"Rust lifetimes are used by the Rust compiler to reason about a program's "
"memory safety. They are a compile-time only concept; there is no way to "
"access Rust lifetimes at runtime from a dynamic language like Python."
msgstr ""

#: src/class.md:63
msgid ""
"As soon as Rust data is exposed to Python, there is no guarantee which the "
"Rust compiler can make on how long the data will live. Python is a reference-"
"counted language and those references can be held for an arbitrarily long "
"time which is untraceable by the Rust compiler. The only possible way to "
"express this correctly is to require that any `#[pyclass]` does not borrow "
"data for any lifetime shorter than the `'static` lifetime, i.e. the "
"`#[pyclass]` cannot have any lifetime parameters."
msgstr ""

#: src/class.md:65
msgid ""
"When you need to share ownership of data between Python and Rust, instead of "
"using borrowed references with lifetimes consider using reference-counted "
"smart pointers such as [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc."
"html) or [`Py`](https://pyo3.rs/main/doc/pyo3/struct.Py.html)."
msgstr ""

#: src/class.md:67
msgid "No generic parameters"
msgstr ""

#: src/class.md:69
msgid ""
"A Rust `struct Foo<T>` with a generic parameter `T` generates new compiled "
"implementations each time it is used with a different concrete type for `T`. "
"These new implementations are generated by the compiler at each usage site. "
"This is incompatible with wrapping `Foo` in Python, where there needs to be "
"a single compiled implementation of `Foo` which is integrated with the "
"Python interpreter."
msgstr ""

#: src/class.md:71
msgid "Must be send"
msgstr ""

#: src/class.md:73
msgid ""
"Because Python objects are freely shared between threads by the Python "
"interpreter, there is no guarantee which thread will eventually drop the "
"object. Therefore all types annotated with `#[pyclass]` must implement "
"`Send` (unless annotated with [`#[pyclass(unsendable)]`](#customizing-the-"
"class))."
msgstr ""

#: src/class.md:75
msgid "Constructor"
msgstr ""

#: src/class.md:77
msgid ""
"By default it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:95
msgid ""
"Alternatively, if your `new` method may fail you can return `PyResult<Self>`."
msgstr ""

#: src/class.md:108
msgid "\"cannot be zero\""
msgstr ""

#: src/class.md:116
msgid ""
"As you can see, the Rust method name is not important here; this way you can "
"still use `new()` for a Rust-level constructor."
msgstr ""

#: src/class.md:119
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:122
msgid "For arguments, see the `Method arguments` section below."
msgstr ""

#: src/class.md:124
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:126
msgid ""
"The next step is to create the module initializer and add our class to it"
msgstr ""

#: src/class.md:140
msgid "PyCell and interior mutability"
msgstr ""

#: src/class.md:142
msgid ""
"You sometimes need to convert your `pyclass` into a Python object and access "
"it from Rust code (e.g., for testing it). [`PyCell`](https://pyo3.rs/main/"
"doc/pyo3/pycell/struct.PyCell.html) is the primary interface for that."
msgstr ""

#: src/class.md:146
msgid ""
"`PyCell<T: PyClass>` is always allocated in the Python heap, so Rust doesn't "
"have ownership of it. In other words, Rust code can only extract a "
"`&PyCell<T>`, not a `PyCell<T>`."
msgstr ""

#: src/class.md:149
msgid ""
"Thus, to mutate data behind `&PyCell` safely, PyO3 employs the [Interior "
"Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-"
"mutability.html) like [`RefCell`](https://doc.rust-lang.org/std/cell/struct."
"RefCell.html)."
msgstr ""

#: src/class.md:153
msgid ""
"Users who are familiar with `RefCell` can use `PyCell` just like `RefCell`."
msgstr ""

#: src/class.md:155
msgid ""
"For users who are not very familiar with `RefCell`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:156
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:157
msgid "References must always be valid."
msgstr ""

#: src/class.md:159
msgid ""
"`PyCell`, like `RefCell`, ensures these borrowing rules by tracking "
"references at runtime."
msgstr ""

#: src/class.md:171
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:173
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:177
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:179
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:184
msgid "// You can convert `&PyCell` to a Python object\n"
msgstr ""

#: src/class.md:185
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:189
msgid ""
"`&PyCell<T>` is bounded by the same lifetime as a [`GILGuard`](https://pyo3."
"rs/main/doc/pyo3/struct.GILGuard.html). To make the object longer lived (for "
"example, to store it in a struct on the Rust side), you can use `Py<T>`, "
"which stores an object longer than the GIL lifetime, and therefore needs a "
"`Python<'_>` token to access."
msgstr ""

#: src/class.md:208
msgid "// Py<MyClass>::as_ref returns &PyCell<MyClass>\n"
msgstr ""

#: src/class.md:209
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:214
msgid "Customizing the class"
msgstr ""

#: src/class.md:216
msgid "`#[pyclass]` can be used with the following parameters:"
msgstr ""

#: src/class.md:218
msgid "Parameter"
msgstr ""

#: src/class.md:218
msgid "Description"
msgstr "說明"

#: src/class.md:220
msgid "<span style=\"white-space: pre\">`crate = \"some::path\"`</span>"
msgstr ""

#: src/class.md:220
msgid "Path to import the `pyo3` crate, if it's not accessible at `::pyo3`."
msgstr ""

#: src/class.md:221
msgid "`dict`"
msgstr ""

#: src/class.md:221
msgid ""
"Gives instances of this class an empty `__dict__` to store custom attributes."
msgstr ""

#: src/class.md:222
msgid "<span style=\"white-space: pre\">`extends = BaseType`</span>"
msgstr ""

#: src/class.md:222
msgid ""
"Use a custom baseclass. Defaults to [`PyAny`](https://docs.rs/pyo3/latest/"
"pyo3/struct.PyAny.html)"
msgstr ""

#: src/class.md:223
msgid "<span style=\"white-space: pre\">`freelist = N`</span>"
msgstr ""

#: src/class.md:223
msgid ""
"Implements a [free list](https://en.wikipedia.org/wiki/Free_list) of size N. "
"This can improve performance for types that are often created and deleted in "
"quick succession. Profile your code to see whether `freelist` is right for "
"you."
msgstr ""

#: src/class.md:224
msgid "<span style=\"white-space: pre\">`frozen`</span>"
msgstr ""

#: src/class.md:224
msgid ""
"Declares that your pyclass is immutable. It removes the borrowchecker "
"overhead when retrieving a shared reference to the Rust struct, but disables "
"the ability to get a mutable reference."
msgstr ""

#: src/class.md:225
msgid "`mapping`"
msgstr ""

#: src/class.md:225
msgid ""
"Inform PyO3 that this class is a [`Mapping`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its implementation of "
"sequence C-API slots empty."
msgstr ""

#: src/class.md:226
msgid "<span style=\"white-space: pre\">`module = \"module_name\"`</span>"
msgstr ""

#: src/class.md:226
msgid ""
"Python code will see the class as being defined in this module. Defaults to "
"`builtins`."
msgstr ""

#: src/class.md:227
msgid "<span style=\"white-space: pre\">`name = \"python_name\"`</span>"
msgstr ""

#: src/class.md:227
msgid ""
"Sets the name that Python sees this class as. Defaults to the name of the "
"Rust struct."
msgstr ""

#: src/class.md:228
msgid "`sequence`"
msgstr ""

#: src/class.md:228
msgid ""
"Inform PyO3 that this class is a [`Sequence`](https://pyo3.rs/latest/class/"
"protocols.html#mapping--sequence-types), and so leave its C-API mapping "
"length slot empty."
msgstr ""

#: src/class.md:229
msgid "`subclass`"
msgstr ""

#: src/class.md:229
msgid ""
"Allows other Python classes and `#[pyclass]` to inherit from this class. "
"Enums cannot be subclassed."
msgstr ""

#: src/class.md:230
msgid ""
"<span style=\"white-space: pre\">`text_signature = \"(arg1, arg2, ...)\"`</"
"span>"
msgstr ""

#: src/class.md:230
msgid "Sets the text signature for the Python class' `__new__` method."
msgstr ""

#: src/class.md:231
msgid "`unsendable`"
msgstr ""

#: src/class.md:231
msgid ""
"Required if your struct is not [`Send`](https://doc.rust-lang.org/std/marker/"
"trait.Send.html). Rather than using `unsendable`, consider implementing your "
"struct in a threadsafe way by e.g. substituting [`Rc`](https://doc.rust-lang."
"org/std/rc/struct.Rc.html) with [`Arc`](https://doc.rust-lang.org/std/sync/"
"struct.Arc.html). By using `unsendable`, your class will panic when accessed "
"by another thread."
msgstr ""

#: src/class.md:232
msgid "`weakref`"
msgstr ""

#: src/class.md:232
msgid ""
"Allows this class to be [weakly referenceable](https://docs.python.org/3/"
"library/weakref.html)."
msgstr ""

#: src/class.md:234
msgid ""
"All of these parameters can either be passed directly on the "
"`#[pyclass(...)]` annotation, or as one or more accompanying `#[pyo3(...)]` "
"annotations, e.g.:"
msgstr ""

#: src/class.md:238
msgid "// Argument supplied directly to the `#[pyclass]` annotation.\n"
msgstr ""

#: src/class.md:239 src/class.md:244
msgid "\"SomeName\""
msgstr ""

#: src/class.md:241
msgid "// Argument supplied as a separate annotation.\n"
msgstr ""

#: src/class.md:257
msgid "These parameters are covered in various sections of this guide."
msgstr ""

#: src/class.md:259
msgid "Return type"
msgstr ""

#: src/class.md:261
msgid ""
"Generally, `#[new]` method have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:264
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:267
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:267
msgid "**May fail**"
msgstr ""

#: src/class.md:269
msgid "**No inheritance**"
msgstr ""

#: src/class.md:269
msgid "`T`"
msgstr "`T`"

#: src/class.md:269
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:270
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:270
msgid "`(T, U)`"
msgstr "`(T, U)`"

#: src/class.md:270
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:271
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:271
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/main/doc/pyo3/pyclass_init/struct."
"PyClassInitializer.html)"
msgstr ""

#: src/class.md:271
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:273
msgid "Inheritance"
msgstr ""

#: src/class.md:275
msgid ""
"By default, `PyAny` is used as the base class. To override this default, use "
"the `extends` parameter for `pyclass` with the full path to the base class."
msgstr ""

#: src/class.md:278
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the baseclass of `T`. But for more deeply nested inheritance, you have to "
"return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:283
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/main/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_ref()` as `&Self::BaseClass`, or by `self_.into_super()` as `PyRef<Self::"
"BaseClass>`."
msgstr ""

#: src/class.md:321
msgid "// Get &BaseClass\n"
msgstr ""

#: src/class.md:341
msgid "// Get PyRef<'_, SubClass>\n"
msgstr ""

#: src/class.md:347
msgid "\"assert subsub.method3() == 3000\""
msgstr ""

#: src/class.md:351
msgid ""
"You can also inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/main/doc/pyo3/type_object/trait."
"PySizedLayout.html). However, this is not supported when building for the "
"Python limited API (aka the `abi3` feature of PyO3)."
msgstr ""

#: src/class.md:354
msgid ""
"However, because of some technical problems, we don't currently provide safe "
"upcasting methods for types that inherit native types. Even in such cases, "
"you can unsafely get a base class by raw pointer conversion."
msgstr ""

#: src/class.md:385
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:390
msgid ""
"If `SubClass` does not provide a baseclass initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:413
msgid "Object properties"
msgstr ""

#: src/class.md:415
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:416
msgid ""
"For simple struct fields with no side effects, a `#[pyo3(get, set)]` "
"attribute can be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:417
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the [`#[pymethods]`](#instance-methods) block."
msgstr ""

#: src/class.md:419
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:421
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:423
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:434
msgid ""
"The above would make the `num` field available for reading and writing as a "
"`self.num` Python property. To expose the property with a different name to "
"the field, specify this alongside the rest of the options, e.g. `#[pyo3(get, "
"set, name = \"custom_name\")]`."
msgstr ""

#: src/class.md:436
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:438
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:439
msgid ""
"For `get` the field type must implement both `IntoPy<PyObject>` and `Clone`."
msgstr ""

#: src/class.md:440
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:442
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:444
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:446
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:464
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:467
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:494
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:496
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:520
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:522
msgid ""
"Attributes defined by `#[setter]` or `#[pyo3(set)]` will always raise "
"`AttributeError` on `del` operations. Support for defining custom `del` "
"behavior is tracked in [\\#1778](https://github.com/PyO3/pyo3/issues/1778)."
msgstr ""

#: src/class.md:526
msgid "Instance methods"
msgstr ""

#: src/class.md:528
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:532
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust. However to have multiple `#[pymethods]`\\-annotated `impl` blocks for "
"the same struct you must enable the [`multiple-pymethods`](features."
"md#multiple-pymethods) feature of PyO3."
msgstr ""

#: src/class.md:555
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:559
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:577
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:579
msgid "Class methods"
msgstr ""

#: src/class.md:581
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:602
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:604
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:606
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:607
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:608
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:610
msgid "Static methods"
msgstr ""

#: src/class.md:612
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:632
msgid "Class attributes"
msgstr ""

#: src/class.md:634
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute."
msgstr ""

#: src/class.md:645
msgid "\"hello\""
msgstr ""

#: src/class.md:651
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:655
msgid ""
"Note: if the method has a `Result` return type and returns an `Err`, PyO3 "
"will panic during class creation."
msgstr ""

#: src/class.md:658
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:668
msgid "\"foobar\""
msgstr ""

#: src/class.md:672
msgid "Method arguments"
msgstr ""

#: src/class.md:674
msgid ""
"Similar to `#[pyfunction]`, the `#[args]` attribute can be used to specify "
"the way that `#[pymethods]` accept arguments. Consult the documentation for "
"[`function signatures`](./function/signature.md) to see the parameters this "
"attribute accepts."
msgstr ""

#: src/class.md:676
msgid ""
"The following example defines a class `MyClass` with a method `method`. This "
"method has an `#[args]` attribute which sets default values for `num` and "
"`name`, and indicates that `py_args` should collect all extra positional "
"arguments and `py_kwargs` all extra keyword arguments:"
msgstr ""

#: src/class.md:689
msgid "\"-1\""
msgstr ""

#: src/class.md:695
msgid "\"10\""
msgstr ""

#: src/class.md:696
msgid "\"*\""
msgstr ""

#: src/class.md:697
msgid "\"\\\"Hello\\\"\""
msgstr ""

#: src/class.md:698
msgid "\"**\""
msgstr ""

#: src/class.md:710
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={} num_before={}\""
msgstr ""

#: src/class.md:717
msgid "In Python this might be used like:"
msgstr ""

#: src/class.md:722 src/class.md:724
msgid "\"World\""
msgstr ""

#: src/class.md:723
msgid "'World'"
msgstr ""

#: src/class.md:723
msgid "'x'"
msgstr ""

#: src/class.md:723
msgid "'y'"
msgstr ""

#: src/class.md:728
msgid "Making class method signatures available to Python"
msgstr ""

#: src/class.md:730
msgid ""
"The [`text_signature = \"...\"`](./function.md#text_signature) option for "
"`#[pyfunction]` also works for classes and methods:"
msgstr ""

#: src/class.md:736
msgid "// it works even if the item is not documented:\n"
msgstr ""

#: src/class.md:738 src/class.md:781
msgid "\"(c, d, /)\""
msgstr ""

#: src/class.md:743
msgid ""
"// the signature for the constructor is attached\n"
"    // to the struct definition instead.\n"
msgstr ""

#: src/class.md:749
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/class.md:750
msgid "\"($self, e, f)\""
msgstr ""

#: src/class.md:755 src/class.md:810
msgid "\"(cls, e, f)\""
msgstr ""

#: src/class.md:760 src/class.md:822
msgid "\"(e, f)\""
msgstr ""

#: src/class.md:768
msgid "\"inspect\""
msgstr ""

#: src/class.md:768
msgid "\"signature\""
msgstr ""

#: src/class.md:769
msgid "\"my_module\""
msgstr ""

#: src/class.md:771 src/class.md:985
msgid "\"MyClass\""
msgstr ""

#: src/class.md:774 src/class.md:783 src/class.md:792 src/class.md:804
#: src/class.md:816
msgid "\"__doc__\""
msgstr ""

#: src/class.md:779 src/class.md:796 src/class.md:808 src/class.md:820
msgid "\"__str__\""
msgstr ""

#: src/class.md:786
msgid ""
"\"`text_signature` on classes is not compatible with compilation in `abi3` "
"mode until Python 3.10 or greater\""
msgstr ""

#: src/class.md:790
msgid "\"my_method\""
msgstr ""

#: src/class.md:798
msgid "\"(self, /, e, f)\""
msgstr ""

#: src/class.md:802
msgid "\"my_class_method\""
msgstr ""

#: src/class.md:814
msgid "\"my_static_method\""
msgstr ""

#: src/class.md:830
msgid ""
"Note that `text_signature` on classes is not compatible with compilation in "
"`abi3` mode until Python 3.10 or greater."
msgstr ""

#: src/class.md:833
msgid "\\#\\[pyclass\\] enums"
msgstr ""

#: src/class.md:835
msgid ""
"Currently PyO3 only supports fieldless enums. PyO3 adds a class attribute "
"for each variant, so you can access them in Python without defining "
"`#[new]`. PyO3 also provides default implementations of `__richcmp__` and "
"`__int__`, so they can be compared using `==`:"
msgstr ""

#: src/class.md:849
msgid ""
"r#\"\n"
"        assert x == cls.Variant\n"
"        assert y == cls.OtherVariant\n"
"        assert x != y\n"
"    \"#"
msgstr ""

#: src/class.md:857
msgid "You can also convert your enums into `int`:"
msgstr ""

#: src/class.md:869
msgid "// The exact value is assigned by the compiler.\n"
msgstr ""

#: src/class.md:870
msgid ""
"r#\"\n"
"        assert int(cls.Variant) == x\n"
"        assert int(cls.OtherVariant) == 10\n"
"        assert cls.OtherVariant == 10  # You can also compare against int.\n"
"        assert 10 == cls.OtherVariant\n"
"    \"#"
msgstr ""

#: src/class.md:879
msgid "PyO3 also provides `__repr__` for enums:"
msgstr ""

#: src/class.md:892
msgid ""
"r#\"\n"
"        assert repr(x) == 'MyEnum.Variant'\n"
"        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'\n"
"    \"#"
msgstr ""

#: src/class.md:899
msgid ""
"All methods defined by PyO3 can be overridden. For example here's how you "
"override `__repr__`:"
msgstr ""

#: src/class.md:911
msgid "\"42\""
msgstr ""

#: src/class.md:917
msgid "\"assert repr(cls.Answer) == '42'\""
msgstr ""

#: src/class.md:921
msgid "Enums and their variants can also be renamed using `#[pyo3(name)]`."
msgstr ""

#: src/class.md:925
msgid "\"RenamedEnum\""
msgstr ""

#: src/class.md:927
msgid "\"UPPERCASE\""
msgstr ""

#: src/class.md:934
msgid ""
"r#\"\n"
"        assert repr(x) == 'RenamedEnum.UPPERCASE'\n"
"        assert x == cls.UPPERCASE\n"
"    \"#"
msgstr ""

#: src/class.md:941
msgid ""
"You may not use enums as a base class or let enums inherit from other "
"classes."
msgstr ""

#: src/class.md:963
msgid ""
"`#[pyclass]` enums are currently not interoperable with `IntEnum` in Python."
msgstr ""

#: src/class.md:965
msgid "Implementation details"
msgstr ""

#: src/class.md:967
msgid ""
"The `#[pyclass]` macros rely on a lot of conditional code generation: each "
"`#[pyclass]` can optionally have a `#[pymethods]` block."
msgstr ""

#: src/class.md:969
msgid ""
"To support this flexibility the `#[pyclass]` macro expands to a blob of "
"boilerplate code which sets up the structure for [\"dtolnay specialization\"]"
"(https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/"
"README.md). This implementation pattern enables the Rust compiler to use "
"`#[pymethods]` implementations when they are present, and fall back to "
"default (empty) definitions when they are not."
msgstr ""

#: src/class.md:971
msgid ""
"This simple technique works for the case when there is zero or one "
"implementations. To support multiple `#[pymethods]` for a `#[pyclass]` (in "
"the [`multiple-pymethods`](features.md#multiple-pymethods) feature), a "
"registry mechanism provided by the [`inventory`](https://github.com/dtolnay/"
"inventory) crate is used instead. This collects `impl`s at library load "
"time, but isn't supported on all platforms. See [inventory: how it works]"
"(https://github.com/dtolnay/inventory#how-it-works) for more details."
msgstr ""

#: src/class.md:973
msgid ""
"The `#[pyclass]` macro expands to roughly the code seen below. The "
"`PyClassImplCollector` is the type used internally by PyO3 for dtolnay "
"specialization:"
msgstr ""

#: src/class.md:976
msgid "\"multiple-pymethods\""
msgstr ""

#: src/class.md:977
msgid ""
"// Note: the implementation differs slightly with the `pyproto` or `multiple-"
"pymethods` features enabled.\n"
msgstr ""

#: src/class.md:1026
msgid "\"Class for demonstration\\u{0}\""
msgstr ""

#: src/class.md:1047
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""

#: src/class/protocols.md:1
msgid "Magic methods and slots"
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. You may be "
"familiar with implementing these protocols in Python classes by \"magic\" "
"methods, such as `__str__` or `__repr__`. Because of the double-underscores "
"surrounding their name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"In the Python C-API which PyO3 is implemented upon, many of these magic "
"methods have to be placed into special \"slots\" on the class type object, "
"as covered in the previous section. There are two ways in which this can be "
"done:"
msgstr ""

#: src/class/protocols.md:7
msgid ""
"In `#[pymethods]`, if the name of the method is a recognised magic method, "
"PyO3 will place it in the type object automatically."
msgstr ""

#: src/class/protocols.md:8
msgid ""
"\\[Deprecated since PyO3 0.16\\] In special traits combined with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class/protocols.md:10
msgid ""
"(There are also many magic methods which don't have a special slot, such as "
"`__dir__`. These methods can be implemented as normal in `#[pymethods]`.)"
msgstr ""

#: src/class/protocols.md:12
msgid ""
"If a function name in `#[pymethods]` is a recognised magic method, it will "
"be automatically placed into the correct slot in the Python type object. The "
"function name is taken from the usual rules for naming `#[pymethods]`: the "
"`#[pyo3(name = \"...\")]` attribute is used if present, otherwise the Rust "
"function name is used."
msgstr ""

#: src/class/protocols.md:14
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the the subset which "
"have slots as [defined here](https://docs.python.org/3/c-api/typeobj.html). "
"Some of the slots do not have a magic method in Python, which leads to a few "
"additional magic methods defined only in PyO3:"
msgstr ""

#: src/class/protocols.md:15
msgid "Magic methods for garbage collection"
msgstr ""

#: src/class/protocols.md:16
msgid "Magic methods for the buffer protocol"
msgstr ""

#: src/class/protocols.md:18
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:19
msgid "The `#[pyo3(text_signature = \"...\")]` attribute is not allowed"
msgstr ""

#: src/class/protocols.md:20
msgid "The signature is restricted to match the magic method"
msgstr ""

#: src/class/protocols.md:22
msgid ""
"The following sections list of all magic methods PyO3 currently handles.  "
"The given signatures should be interpreted as follows:"
msgstr ""

#: src/class/protocols.md:24
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `PyCell` reference like `self_: PyRef<'_, Self>` "
"and `self_: PyRefMut<'_, Self>`, as described [here](../class."
"md#inheritance)."
msgstr ""

#: src/class/protocols.md:27
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:28
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:29
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:31
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:33
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:35
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:40 src/class/protocols.md:418
msgid "Basic object customization"
msgstr "基本物件自訂"

#: src/class/protocols.md:42
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:43
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:45
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:47
msgid ""
"Objects that compare equal must have the same hash value. Any type up to 64 "
"bits may be returned instead of `isize`, PyO3 will convert to an isize "
"automatically (wrapping unsigned types like `u64` and `usize`)."
msgstr ""

#: src/class/protocols.md:66
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:68
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `CompareOp` argument indicates the comparison operation being "
"performed."
msgstr ""

#: src/class/protocols.md:71
msgid ""
"_Note that implementing `__richcmp__` will cause Python not to generate a "
"default `__hash__` implementation, so consider implementing `__hash__` when "
"implementing `__richcmp__`._"
msgstr ""

#: src/class/protocols.md:78
msgid ""
"You can use [`CompareOp::matches`](https://pyo3.rs/main/doc/pyo3/pyclass/"
"enum.CompareOp.html#method.matches) to adapt a Rust `std::cmp::Ordering` "
"result to the requested comparison."
msgstr ""

#: src/class/protocols.md:82
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:83
msgid "`__getattribute__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:93
msgid "`__setattr__(<self>, value: object) -> ()`"
msgstr ""

#: src/class/protocols.md:94
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:96
msgid "Overrides attribute access."
msgstr ""

#: src/class/protocols.md:98
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:100
msgid "Determines the \"truthyness\" of an object."
msgstr ""

#: src/class/protocols.md:102
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:105
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:107
msgid "Iterators can be defined using these methods:"
msgstr ""

#: src/class/protocols.md:109
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:110
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:112
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items."
msgstr ""

#: src/class/protocols.md:114 src/class/protocols.md:379
msgid "Example:"
msgstr ""

#: src/class/protocols.md:135
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, the "
"iterable only needs to implement `__iter__()` while the iterator must "
"implement both `__iter__()` and `__next__()`. For example:"
msgstr ""

#: src/class/protocols.md:177
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:178
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:182
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:185
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:187
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration.  In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://pyo3.rs/"
"main/doc/pyo3/class/iter/enum.IterNextOutput.html) enum to both `Yield` "
"values and `Return` a final value - see its docs for further details and an "
"example."
msgstr ""

#: src/class/protocols.md:192
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:194
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:195
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:196
msgid "`__anext__(<self>) -> Option<object> or IterANextOutput`"
msgstr ""

#: src/class/protocols.md:198
msgid "Mapping & Sequence types"
msgstr ""

#: src/class/protocols.md:200
msgid ""
"The magic methods in this section can be used to implement Python container "
"types. They are two main categories of container in Python: \"mappings\" "
"such as `dict`, with arbitrary keys, and \"sequences\" such as `list` and "
"`tuple`, with integer keys."
msgstr ""

#: src/class/protocols.md:202
msgid ""
"The Python C-API which PyO3 is built upon has separate \"slots\" for "
"sequences and mappings. When writing a `class` in pure Python, there is no "
"such distinction in the implementation - a `__getitem__` implementation will "
"fill the slots for both the mapping and sequence forms, for example."
msgstr ""

#: src/class/protocols.md:204
msgid ""
"By default PyO3 reproduces the Python behaviour of filling both mapping and "
"sequence slots. This makes sense for the \"simple\" case which matches "
"Python, and also for sequences, where the mapping slot is used anyway to "
"implement slice indexing."
msgstr ""

#: src/class/protocols.md:206
msgid ""
"Mapping types usually will not want the sequence slots filled. Having them "
"filled will lead to outcomes which may be unwanted, such as:"
msgstr ""

#: src/class/protocols.md:207
msgid ""
"The mapping type will successfully cast to [`PySequence`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PySequence.html). This may lead to consumers of "
"the type handling it incorrectly."
msgstr ""

#: src/class/protocols.md:208
msgid ""
"Python provides a default implementation of `__iter__` for sequences, which "
"calls `__getitem__` with consecutive positive integers starting from 0 until "
"an `IndexError` is returned. Unless the mapping only contains consecutive "
"positive integer keys, this `__iter__` implementation will likely not be the "
"intended behavior."
msgstr ""

#: src/class/protocols.md:210
msgid ""
"Use the `#[pyclass(mapping)]` annotation to instruct PyO3 to only fill the "
"mapping slots, leaving the sequence ones empty. This will apply to "
"`__getitem__`, `__setitem__`, and `__delitem__`."
msgstr ""

#: src/class/protocols.md:212
msgid ""
"Use the `#[pyclass(sequence)]` annotation to instruct PyO3 to fill the "
"`sq_length` slot instead of the `mp_length` slot for `__len__`. This will "
"help libraries such as `numpy` recognise the class as a sequence, however "
"will also cause CPython to automatically add the sequence length to any "
"negative indices before passing them to `__getitem__`. (`__getitem__`, "
"`__setitem__` and `__delitem__` mapping slots are still used for sequences, "
"for slice operations.)"
msgstr ""

#: src/class/protocols.md:214
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:216
msgid "Implements the built-in function `len()`."
msgstr ""

#: src/class/protocols.md:218
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:220 src/class/protocols.md:535
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that don’t define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:228
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:247
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:249
msgid "Implements retrieval of the `self[a]` element."
msgstr ""

#: src/class/protocols.md:251
msgid "_Note:_ Negative integer indexes are not handled specially."
msgstr ""

#: src/class/protocols.md:253
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:255
msgid ""
"Implements assignment to the `self[a]` element. Should only be implemented "
"if elements can be replaced."
msgstr ""

#: src/class/protocols.md:258
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:260
msgid ""
"Implements deletion of the `self[a]` element. Should only be implemented if "
"elements can be deleted."
msgstr ""

#: src/class/protocols.md:263 src/class/protocols.md:540
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:265
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `__add__` and `__radd__` methods."
msgstr ""

#: src/class/protocols.md:269 src/class/protocols.md:546
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:271
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `__mul__` and `__rmul__` methods."
msgstr ""

#: src/class/protocols.md:275
msgid ""
"`fn __inplace_concat__(&self, other: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:277
msgid ""
"Concatenates two sequences. Used by the `+=` operator, after trying the "
"numeric addition via the `__iadd__` method."
msgstr ""

#: src/class/protocols.md:281
msgid ""
"`fn __inplace_repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:283
msgid ""
"Concatenates two sequences. Used by the `*=` operator, after trying the "
"numeric multiplication via the `__imul__` method."
msgstr ""

#: src/class/protocols.md:287
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:289
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:290
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:291
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:293
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:295
msgid ""
"Binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, "
"`divmod()`, `pow()` and `**`, `<<`, `>>`, `&`, `^`, and `|`) and their "
"reflected versions:"
msgstr ""

#: src/class/protocols.md:298
msgid ""
"(If the `object` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`.)"
msgstr ""

#: src/class/protocols.md:301
msgid "`__add__(<self>, object) -> object`"
msgstr "`__add__(<self>, object) -> object`"

#: src/class/protocols.md:302
msgid "`__radd__(<self>, object) -> object`"
msgstr "`__radd__(<self>, object) -> object`"

#: src/class/protocols.md:303
msgid "`__sub__(<self>, object) -> object`"
msgstr "`__sub__(<self>, object) -> object`"

#: src/class/protocols.md:304
msgid "`__rsub__(<self>, object) -> object`"
msgstr "`__rsub__(<self>, object) -> object`"

#: src/class/protocols.md:305
msgid "`__mul__(<self>, object) -> object`"
msgstr "`__mul__(<self>, object) -> object`"

#: src/class/protocols.md:306
msgid "`__rmul__(<self>, object) -> object`"
msgstr "`__rmul__(<self>, object) -> object`"

#: src/class/protocols.md:307
msgid "`__matmul__(<self>, object) -> object`"
msgstr "`__matmul__(<self>, object) -> object`"

#: src/class/protocols.md:308
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr "`__rmatmul__(<self>, object) -> object`"

#: src/class/protocols.md:309
msgid "`__floordiv__(<self>, object) -> object`"
msgstr "`__floordiv__(<self>, object) -> object`"

#: src/class/protocols.md:310
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr "`__rfloordiv__(<self>, object) -> object`"

#: src/class/protocols.md:311
msgid "`__truediv__(<self>, object) -> object`"
msgstr "`__truediv__(<self>, object) -> object`"

#: src/class/protocols.md:312
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:313
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:314
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:315
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:316
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:317
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:318
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:319
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:320
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:321
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:322
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:323
msgid "`__xor__(<self>, object) -> object`"
msgstr "`__xor__(<self>, object) -> object`"

#: src/class/protocols.md:324
msgid "`__rxor__(<self>, object) -> object`"
msgstr "`__rxor__(<self>, object) -> object`"

#: src/class/protocols.md:325
msgid "`__or__(<self>, object) -> object`"
msgstr "`__or__(<self>, object) -> object`"

#: src/class/protocols.md:326
msgid "`__ror__(<self>, object) -> object`"
msgstr "`__ror__(<self>, object) -> object`"

#: src/class/protocols.md:327
msgid "`__pow__(<self>, object, object) -> object`"
msgstr "`__pow__(<self>, object, object) -> object`"

#: src/class/protocols.md:328
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr "`__rpow__(<self>, object, object) -> object`"

#: src/class/protocols.md:330
msgid ""
"In-place assignment operations (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, "
"`**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:333
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:334
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:335
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:336
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:337
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:338
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:339
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:340
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:341
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:342
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:343
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:344
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:345
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:347
msgid "Unary operations (`-`, `+`, `abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:349
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:350
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:351
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:352
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:354
msgid "Coercions:"
msgstr ""

#: src/class/protocols.md:356
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:357
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:358
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:360
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:362
msgid "`__getbuffer__(<self>, *mut ffi::Py_buffer, flags) -> ()`"
msgstr ""

#: src/class/protocols.md:363
msgid ""
"`__releasebuffer__(<self>, *mut ffi::Py_buffer)` (no return value, not even "
"`PyResult`)"
msgstr ""

#: src/class/protocols.md:365 src/class/protocols.md:609
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:367
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references.  To do this, implement the two methods `__traverse__` and "
"`__clear__`.  These correspond to the slots `tp_traverse` and `tp_clear` in "
"the Python C API. `__traverse__` must call `visit.call()` for each reference "
"to another Python object.  `__clear__` must clear out any mutable references "
"to other Python objects (thus breaking reference cycles). Immutable "
"references do not have to be cleared, as every cycle must contain at least "
"one mutable reference."
msgstr ""

#: src/class/protocols.md:376
msgid ""
"`__traverse__(<self>, pyo3::class::gc::PyVisit<'_>) -> Result<(), pyo3::"
"class::gc::PyTraverseError>`"
msgstr ""

#: src/class/protocols.md:377
msgid "`__clear__(<self>) -> ()`"
msgstr ""

#: src/class/protocols.md:401
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:410
msgid "`#[pyproto]` traits"
msgstr ""

#: src/class/protocols.md:412
msgid ""
"PyO3 can use the `#[pyproto]` attribute in combination with special traits "
"to implement the magic methods which need slots. The special traits are "
"listed below. See also the [documentation for the `pyo3::class` module]"
"(https://pyo3.rs/main/doc/pyo3/class/index.html)."
msgstr ""

#: src/class/protocols.md:414
msgid ""
"Due to complexity in the implementation and usage, these traits were "
"deprecated in PyO3 0.16 in favour of the `#[pymethods]` solution."
msgstr ""

#: src/class/protocols.md:416
msgid ""
"All `#[pyproto]` methods can return `T` instead of `PyResult<T>` if the "
"method implementation is infallible. In addition, if the return type is "
"`()`, it can be omitted altogether."
msgstr ""

#: src/class/protocols.md:420
msgid ""
"The [`PyObjectProtocol`](https://pyo3.rs/main/doc/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provides several basic customizations."
msgstr ""

#: src/class/protocols.md:422
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:423
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:424
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class/protocols.md:425
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:426
msgid ""
"`fn __getattr__(&self, name: impl FromPyObject) -> PyResult<impl "
"IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:427
msgid ""
"`fn __setattr__(&mut self, name: impl FromPyObject, value: impl "
"FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:428
msgid "`fn __delattr__(&mut self, name: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:429
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:431
msgid "Emulating numeric types"
msgstr "仿真數值型別"

#: src/class/protocols.md:433
msgid ""
"The [`PyNumberProtocol`](https://pyo3.rs/main/doc/pyo3/class/number/trait."
"PyNumberProtocol.html) trait can be implemented to emulate [numeric types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types)."
msgstr ""

#: src/class/protocols.md:435
msgid ""
"`fn __add__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:436
msgid ""
"`fn __sub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:437
msgid ""
"`fn __mul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:438
msgid ""
"`fn __matmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:439
msgid ""
"`fn __truediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:440
msgid ""
"`fn __floordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:441
msgid ""
"`fn __mod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:442
msgid ""
"`fn __divmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:443
msgid ""
"`fn __pow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:444
msgid ""
"`fn __lshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:445
msgid ""
"`fn __rshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:446
msgid ""
"`fn __and__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:447
msgid ""
"`fn __or__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:448
msgid ""
"`fn __xor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:450
msgid "These methods are called to implement the binary arithmetic operations."
msgstr ""

#: src/class/protocols.md:452
msgid "The reflected operations are also available:"
msgstr ""

#: src/class/protocols.md:454
msgid ""
"`fn __radd__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:455
msgid ""
"`fn __rsub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:456
msgid ""
"`fn __rmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:457
msgid ""
"`fn __rmatmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:458
msgid ""
"`fn __rtruediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:459
msgid ""
"`fn __rfloordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:460
msgid ""
"`fn __rmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:461
msgid ""
"`fn __rdivmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:462
msgid ""
"`fn __rpow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:463
msgid ""
"`fn __rlshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:464
msgid ""
"`fn __rrshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:465
msgid ""
"`fn __rand__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:466
msgid ""
"`fn __ror__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:467
msgid ""
"`fn __rxor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:469
msgid ""
"The code generated for these methods expect that all arguments match the "
"signature, or raise a TypeError."
msgstr ""

#: src/class/protocols.md:472
msgid "`fn __iadd__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:473
msgid "`fn __isub__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:474
msgid "`fn __imul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:475
msgid ""
"`fn __imatmul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:476
msgid ""
"`fn __itruediv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:477
msgid ""
"`fn __ifloordiv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:478
msgid "`fn __imod__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:479
msgid ""
"`fn __ipow__(&'p mut self, other: impl FromPyObject, modulo: impl "
"FromPyObject) -> PyResult<()>` on Python 3.8^"
msgstr ""

#: src/class/protocols.md:480
msgid ""
"`fn __ipow__(&'p mut self, other: impl FromPyObject) -> PyResult<()>` on "
"Python 3.7 see https://bugs.python.org/issue36379"
msgstr ""

#: src/class/protocols.md:481
msgid ""
"`fn __ilshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:482
msgid ""
"`fn __irshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:483
msgid "`fn __iand__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:484
msgid "`fn __ior__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:485
msgid "`fn __ixor__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:488
msgid "The following methods implement the unary arithmetic operations:"
msgstr ""

#: src/class/protocols.md:490
msgid "`fn __neg__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:491
msgid "`fn __pos__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:492
msgid "`fn __abs__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:493
msgid "`fn __invert__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:495
msgid "Support for coercions:"
msgstr ""

#: src/class/protocols.md:497
msgid "`fn __int__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:498
msgid "`fn __float__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:499
msgid "`fn __index__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:501
msgid "Emulating sequential containers (such as lists or tuples)"
msgstr ""

#: src/class/protocols.md:503
msgid ""
"The [`PySequenceProtocol`](https://pyo3.rs/main/doc/pyo3/class/sequence/"
"trait.PySequenceProtocol.html) trait can be implemented to emulate "
"[sequential container types](https://docs.python.org/3/reference/datamodel."
"html#emulating-container-types)."
msgstr ""

#: src/class/protocols.md:506
msgid ""
"For a sequence, the keys are the integers _k_ for which _0 \\<= k \\< N_, "
"where _N_ is the length of the sequence."
msgstr ""

#: src/class/protocols.md:509 src/class/protocols.md:571
msgid "`fn __len__(&self) -> PyResult<usize>`"
msgstr ""

#: src/class/protocols.md:511
msgid "Implements the built-in function `len()` for the sequence."
msgstr ""

#: src/class/protocols.md:513
msgid "`fn __getitem__(&self, idx: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:515
msgid ""
"Implements evaluation of the `self[idx]` element. If the `idx` value is "
"outside the set of indexes for the sequence, `IndexError` should be raised."
msgstr ""

#: src/class/protocols.md:518
msgid ""
"_Note:_ Negative integer indexes are handled as follows: if `__len__()` is "
"defined, it is called and the sequence length is used to compute a positive "
"index, which is passed to `__getitem__()`. If `__len__()` is not defined, "
"the index is passed as is to the function."
msgstr ""

#: src/class/protocols.md:523
msgid ""
"`fn __setitem__(&mut self, idx: isize, value: impl FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class/protocols.md:525
msgid ""
"Implements assignment to the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"replaced."
msgstr ""

#: src/class/protocols.md:528
msgid "`fn __delitem__(&mut self, idx: isize) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:530
msgid ""
"Implements deletion of the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"deleted."
msgstr ""

#: src/class/protocols.md:533
msgid "`fn __contains__(&self, item: impl FromPyObject) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:542
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:548
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:552
msgid ""
"`fn __inplace_concat__(&mut self, other: impl FromPyObject) -> "
"PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:554
msgid ""
"Concatenates two sequences in place. Returns the modified first operand. "
"Used by the `+=` operator, after trying the numeric in place addition via "
"the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:558
msgid "`fn __inplace_repeat__(&mut self, count: isize) -> PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:560
msgid ""
"Repeats the sequence `count` times in place. Returns the modified first "
"operand. Used by the `*=` operator, after trying the numeric in place "
"multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:564
msgid "Emulating mapping containers (such as dictionaries)"
msgstr ""

#: src/class/protocols.md:566
msgid ""
"The [`PyMappingProtocol`](https://pyo3.rs/main/doc/pyo3/class/mapping/trait."
"PyMappingProtocol.html) trait allows to emulate [mapping container types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-container-"
"types)."
msgstr ""

#: src/class/protocols.md:569
msgid "For a mapping, the keys may be Python objects of arbitrary type."
msgstr ""

#: src/class/protocols.md:573
msgid "Implements the built-in function `len()` for the mapping."
msgstr ""

#: src/class/protocols.md:575
msgid ""
"`fn __getitem__(&self, key: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:577
msgid ""
"Implements evaluation of the `self[key]` element. If `key` is of an "
"inappropriate type, `TypeError` may be raised; if `key` is missing (not in "
"the container), `KeyError` should be raised."
msgstr ""

#: src/class/protocols.md:581
msgid ""
"`fn __setitem__(&mut self, key: impl FromPyObject, value: impl FromPyObject) "
"-> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:583
msgid ""
"Implements assignment to the `self[key]` element or insertion of a new `key` "
"mapping to `value`. Should only be implemented if the mapping support "
"changes to the values for keys, or if new keys can be added. The same "
"exceptions should be raised for improper key values as for the "
"`__getitem__()` method."
msgstr ""

#: src/class/protocols.md:590
msgid "`fn __delitem__(&mut self, key: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:592
msgid ""
"Implements deletion of the `self[key]` element. Should only be implemented "
"if the mapping supports removal of keys. The same exceptions should be "
"raised for improper key values as for the `__getitem__()` method."
msgstr ""

#: src/class/protocols.md:597
msgid "Iterator Types"
msgstr ""

#: src/class/protocols.md:599
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://pyo3.rs/main/"
"doc/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class/protocols.md:601
msgid ""
"`fn __iter__(slf: PyRefMut<'_, Self>) -> PyResult<impl IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:602
msgid ""
"`fn __next__(slf: PyRefMut<'_, Self>) -> PyResult<Option<impl "
"IntoPy<PyObject>>>`"
msgstr ""

#: src/class/protocols.md:604
msgid ""
"These two methods can be take either `PyRef<'_, Self>` or `PyRefMut<'_, "
"Self>` as their first argument, so that mutable borrow can be avoided if "
"needed."
msgstr ""

#: src/class/protocols.md:607
msgid "For details, look at the `#[pymethods]` regarding iterator methods."
msgstr ""

#: src/class/protocols.md:611
msgid ""
"Implement the [`PyGCProtocol`](https://pyo3.rs/main/doc/pyo3/class/gc/trait."
"PyGCProtocol.html) trait for your struct. For details, look at the "
"`#[pymethods]` regarding GC methods."
msgstr ""

#: src/class/object.md:3
msgid "Recall the `Number` class from the previous chapter:"
msgstr ""

#: src/class/object.md:26
msgid ""
"At this point Python code can import the module, access the class and create "
"class instances - but nothing else."
msgstr ""

#: src/class/object.md:40
msgid "String representations"
msgstr "字串表示法"

#: src/class/object.md:42
msgid ""
"It can't even print an user-readable representation of itself! We can fix "
"that by defining the `__repr__` and `__str__` methods inside a "
"`#[pymethods]` block. We do this by accessing the value contained inside "
"`Number`."
msgstr ""

#: src/class/object.md:54
msgid ""
"// For `__repr__` we want to return a string that Python code could use to "
"recreate\n"
msgstr ""

#: src/class/object.md:55
msgid "// the `Number`, like `Number(5)` for example.\n"
msgstr ""

#: src/class/object.md:57
msgid ""
"// We use the `format!` macro to create a string. Its first argument is a\n"
msgstr ""

#: src/class/object.md:58
msgid ""
"// format string, followed by any number of parameters which replace the\n"
msgstr ""

#: src/class/object.md:59
msgid "// `{}`'s in the format string.\n"
msgstr ""

#: src/class/object.md:60
msgid "//\n"
msgstr ""

#: src/class/object.md:61
msgid "//                       👇 Tuple field access in Rust uses a dot\n"
msgstr ""

#: src/class/object.md:62 src/class/object.md:239
msgid "\"Number({})\""
msgstr ""

#: src/class/object.md:65
msgid ""
"// `__str__` is generally used to create an \"informal\" representation, so "
"we\n"
msgstr ""

#: src/class/object.md:66
msgid ""
"// just forward to `i32`'s `ToString` trait implementation to print a bare "
"number.\n"
msgstr ""

#: src/class/object.md:73
msgid "Hashing"
msgstr ""

#: src/class/object.md:76
msgid ""
"Let's also implement hashing. We'll just hash the `i32`. For that we need a "
"[`Hasher`](https://doc.rust-lang.org/std/hash/trait.Hasher.html). The one "
"provided by `std` is [`DefaultHasher`](https://doc.rust-lang.org/std/"
"collections/hash_map/struct.DefaultHasher.html), which uses the [SipHash]"
"(https://en.wikipedia.org/wiki/SipHash) algorithm."
msgstr ""

#: src/class/object.md:81
msgid ""
"// Required to call the `.hash` and `.finish` methods, which are defined on "
"traits.\n"
msgstr ""

#: src/class/object.md:100
msgid ""
"**Note**: When implementing `__hash__` and comparisons, it is important that "
"the following property holds:"
msgstr ""

#: src/class/object.md:106
msgid ""
"In other words, if two keys are equal, their hashes must also be equal. In "
"addition you must take care that your classes' hash doesn't change during "
"its lifetime. In this tutorial we do that by not letting Python code change "
"our `Number` class. In other words, it is immutable."
msgstr ""

#: src/class/object.md:110
msgid ""
"By default, all `#[pyclass]` types have a default hash implementation from "
"Python. Types which should not be hashable can override this by setting "
"`__hash__` to None. This is the same mechanism as for a pure-Python class. "
"This is done like so:"
msgstr ""

#: src/class/object.md:126
msgid "Comparisons"
msgstr ""

#: src/class/object.md:128
msgid ""
"Unlike in Python, PyO3 does not provide the magic comparison methods you "
"might expect like `__eq__`, `__lt__` and so on. Instead you have to "
"implement all six operations at once with `__richcmp__`. This method will be "
"called with a value of `CompareOp` depending on the operation."
msgstr ""

#: src/class/object.md:155
msgid ""
"If you obtain the result by comparing two Rust values, as in this example, "
"you can take a shortcut using `CompareOp::matches`:"
msgstr ""

#: src/class/object.md:174
msgid ""
"It checks that the `std::cmp::Ordering` obtained from Rust's `Ord` matches "
"the given `CompareOp`."
msgstr ""

#: src/class/object.md:177
msgid ""
"Alternatively, if you want to leave some operations unimplemented, you can "
"return `py.NotImplemented()` for some of the operations:"
msgstr ""

#: src/class/object.md:201
msgid "Truthyness"
msgstr ""

#: src/class/object.md:203
msgid "We'll consider `Number` to be `True` if it is nonzero:"
msgstr ""

#: src/class/object.md:219
msgid "Final code"
msgstr ""

#: src/class/call.md:1
msgid "Emulating callable objects"
msgstr "仿真可呼叫物件"

#: src/class/call.md:3
msgid ""
"Classes can be callable if they have a `#[pymethod]` named `__call__`. This "
"allows instances of a class to behave similar to functions."
msgstr ""

#: src/class/call.md:6
msgid ""
"This method's signature must look like `__call__(<self>, ...) -> object` - "
"here, any argument list can be defined as for normal pymethods"
msgstr ""

#: src/class/call.md:9
msgid "Example: Implementing a call counter"
msgstr ""

#: src/class/call.md:11
msgid ""
"The following pyclass is a basic decorator - its constructor takes a Python "
"object as argument and calls that object when called. An equivalent Python "
"implementation is linked at the end."
msgstr ""

#: src/class/call.md:15
msgid ""
"An example crate containing this pyclass can be found [here](https://github."
"com/PyO3/pyo3/tree/main/examples/decorator)"
msgstr ""

#: src/class/call.md:21
msgid ""
"/// A function decorator that keeps track how often it is called.\n"
"///\n"
"/// It otherwise doesn't do anything special.\n"
msgstr ""

#: src/class/call.md:25
msgid "\"Counter\""
msgstr ""

#: src/class/call.md:27
msgid ""
"// Keeps track of how many calls have gone through.\n"
"    //\n"
"    // See the discussion at the end for why `Cell` is used.\n"
msgstr ""

#: src/class/call.md:32
msgid "// This is the actual function being wrapped.\n"
msgstr ""

#: src/class/call.md:38
msgid ""
"// Note that we don't validate whether `wraps` is actually callable.\n"
"    //\n"
"    // While we could use `PyAny::is_callable` for that, it has some flaws:\n"
"    //    1. It doesn't guarantee the object can actually be called "
"successfully\n"
"    //    2. We still need to handle any exceptions that the function might "
"raise\n"
msgstr ""

#: src/class/call.md:66 src/class/call.md:152
msgid "\"__name__\""
msgstr ""

#: src/class/call.md:68 src/class/call.md:154
msgid "\"{} has been called {} time(s).\""
msgstr ""

#: src/class/call.md:70 src/class/call.md:156
msgid ""
"// After doing something, we finally forward the call to the wrapped "
"function\n"
msgstr ""

#: src/class/call.md:73
msgid ""
"// We could do something with the return value of\n"
"        // the function before returning it\n"
msgstr ""

#: src/class/call.md:86
msgid "Python code:"
msgstr ""

#: src/class/call.md:102
msgid "Output:"
msgstr "輸出："

#: src/class/call.md:115
msgid "Pure Python implementation"
msgstr "純 Python 實現"

#: src/class/call.md:117
msgid "A Python implementation of this looks similar to the Rust version:"
msgstr ""

#: src/class/call.md:127 src/class/call.md:139
msgid " has been called "
msgstr ""

#: src/class/call.md:127 src/class/call.md:139
msgid " time(s)\""
msgstr ""

#: src/class/call.md:131
msgid "Note that it can also be implemented as a higher order function:"
msgstr ""

#: src/class/call.md:144
msgid "What is the `Cell` for?"
msgstr ""

#: src/class/call.md:146
msgid ""
"A [previous implementation](https://github.com/PyO3/pyo3/discussions/2598 "
"\"Thread Safe Decorator <Help Wanted> · Discussion #2598 · PyO3/pyo3\") used "
"a normal `u64`, which meant it required a `&mut self` receiver to update the "
"count:"
msgstr ""

#: src/class/call.md:159
msgid ""
"// We could do something with the return value of\n"
"    // the function before returning it\n"
msgstr ""

#: src/class/call.md:165
msgid ""
"The problem with this is that the `&mut self` receiver means PyO3 has to "
"borrow it exclusively, and hold this borrow across the`self.wraps.call(py, "
"args, kwargs)` call. This call returns control to the user's Python code "
"which is free to call arbitrary things, _including_ the decorated function. "
"If that happens PyO3 is unable to create a second unique borrow and will be "
"forced to raise an exception."
msgstr ""

#: src/class/call.md:169
msgid "As a result, something innocent like this will raise an exception:"
msgstr ""

#: src/class/call.md:175
msgid "\"hello from decorator\""
msgstr ""

#: src/class/call.md:177
msgid "# RuntimeError: Already borrowed\n"
msgstr ""

#: src/class/call.md:181
msgid ""
"The implementation in this chapter fixes that by never borrowing "
"exclusively; all the methods take `&self` as receivers, of which multiple "
"may exist simultaneously. This requires a shared counter and the easiest way "
"to do that is to use [`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell."
"html \"Cell in std::cell - Rust\"), so that's what is used here."
msgstr ""

#: src/class/call.md:183
msgid ""
"This shows the dangers of running arbitrary Python code - note that "
"\"running arbitrary Python code\" can be far more subtle than the example "
"above:"
msgstr ""

#: src/class/call.md:184
msgid ""
"Python's asynchronous executor may park the current thread in the middle of "
"Python code, even in Python code that _you_ control, and let other Python "
"code run."
msgstr ""

#: src/class/call.md:185
msgid ""
"Dropping arbitrary Python objects may invoke destructors defined in Python "
"(`__del__` methods)."
msgstr ""

#: src/class/call.md:186
msgid ""
"Calling Python's C-api (most PyO3 apis call C-api functions internally) may "
"raise exceptions, which may allow Python code in signal handlers to run."
msgstr ""

#: src/class/call.md:188
msgid ""
"This is especially important if you are writing unsafe code; Python code "
"must never be able to cause undefined behavior. You must ensure that your "
"Rust code is in a consistent state before doing any of the above things."
msgstr ""

#: src/class/numeric.md:3
msgid ""
"At this point we have a `Number` class that we can't actually do any math on!"
msgstr ""

#: src/class/numeric.md:5
msgid ""
"Before proceeding, we should think about how we want to handle overflows. "
"There are three obvious solutions:"
msgstr ""

#: src/class/numeric.md:6
msgid ""
"We can have infinite precision just like Python's `int`. However that would "
"be quite boring - we'd be reinventing the wheel."
msgstr ""

#: src/class/numeric.md:8
msgid ""
"We can raise exceptions whenever `Number` overflows, but that makes the API "
"painful to use."
msgstr ""

#: src/class/numeric.md:9
msgid ""
"We can wrap around the boundary of `i32`. This is the approach we'll take "
"here. To do that we'll just forward to `i32`'s `wrapping_*` methods."
msgstr ""

#: src/class/numeric.md:12
msgid "Fixing our constructor"
msgstr ""

#: src/class/numeric.md:14
msgid "Let's address the first overflow, in `Number`'s constructor:"
msgstr ""

#: src/class/numeric.md:22
msgid ""
"```text\n"
"Traceback (most recent call last):\n"
"  File \"example.py\", line 3, in <module>\n"
"    n = Number(1 << 1337)\n"
"OverflowError: Python int too large to convert to C long\n"
"```"
msgstr ""

#: src/class/numeric.md:29
msgid ""
"Instead of relying on the default [`FromPyObject`](https://docs.rs/pyo3/"
"latest/pyo3/conversion/trait.FromPyObject.html) extraction to parse "
"arguments, we can specify our own extraction function, using the "
"`#[pyo3(from_py_with = \"...\")]` attribute. Unfortunately PyO3 doesn't "
"provide a way to wrap Python integers out of the box, but we can do a Python "
"call to mask it and cast it to an `i32`."
msgstr ""

#: src/class/numeric.md:39 src/class/numeric.md:52 src/class/numeric.md:219
msgid "\"__and__\""
msgstr ""

#: src/class/numeric.md:41
msgid "//     👇 This intentionally overflows!\n"
msgstr ""

#: src/class/numeric.md:45
msgid ""
"We also add documentation, via `///` comments and the `#[pyo3(text_signature "
"= \"...\")]` attribute, both of which are visible to Python users."
msgstr ""

#: src/class/numeric.md:56 src/class/numeric.md:222
msgid ""
"/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought "
"not.\n"
"/// It's not a story C would tell you. It's a Rust legend.\n"
msgstr ""

#: src/class/numeric.md:60 src/class/numeric.md:226
msgid "\"(int)\""
msgstr ""

#: src/class/numeric.md:73
msgid "With that out of the way, let's implement some operators:"
msgstr ""

#: src/class/numeric.md:100 src/class/numeric.md:107 src/class/numeric.md:280
#: src/class/numeric.md:287
msgid "\"division by zero\""
msgstr ""

#: src/class/numeric.md:114 src/class/numeric.md:121 src/class/numeric.md:294
#: src/class/numeric.md:301
msgid "\"negative shift count\""
msgstr ""

#: src/class/numeric.md:127
msgid "Unary arithmetic operations"
msgstr "一元算數運算"

#: src/class/numeric.md:155
msgid "Support for the `complex()`, `int()` and `float()` built-in functions."
msgstr ""

#: src/class/numeric.md:181
msgid ""
"We do not implement the in-place operations like `__iadd__` because we do "
"not wish to mutate `Number`. Similarly we're not interested in supporting "
"operations with different types, so we do not implement the reflected "
"operations like `__radd__` either."
msgstr ""

#: src/class/numeric.md:185
msgid "Now Python can use our `Number` class:"
msgstr ""

#: src/class/numeric.md:191
msgid ""
"'''\n"
"\tA version of Daniel J. Bernstein's djb2 string hashing algorithm\n"
"\tLike many hashing algorithms, it relies on integer wrapping.\n"
"\t'''"
msgstr ""

#: src/class/numeric.md:203
msgid "'l50_50'"
msgstr ""

#: src/class/numeric.md:335
msgid ""
"r#\"\n"
"# def hash_djb2(s: str):\n"
"#     n = Number(0)\n"
"#     five = Number(5)\n"
"#\n"
"#     for x in s:\n"
"#         n = Number(ord(x)) + ((n << five) - n)\n"
"#     return n\n"
"#\n"
"# assert hash_djb2('l50_50') == Number(-1152549421)\n"
"# assert hash_djb2('logo') == Number(3327403)\n"
"# assert hash_djb2('horizon') == Number(1097468315)\n"
"#\n"
"#\n"
"# assert Number(2) + Number(2) == Number(4)\n"
"# assert Number(2) + Number(2) != Number(5)\n"
"#\n"
"# assert Number(13) - Number(7) == Number(6)\n"
"# assert Number(13) - Number(-7) == Number(20)\n"
"#\n"
"# assert Number(13) / Number(7) == Number(1)\n"
"# assert Number(13) // Number(7) == Number(1)\n"
"#\n"
"# assert Number(13) * Number(7) == Number(13*7)\n"
"#\n"
"# assert Number(13) > Number(7)\n"
"# assert Number(13) < Number(20)\n"
"# assert Number(13) == Number(13)\n"
"# assert Number(13) >= Number(7)\n"
"# assert Number(13) <= Number(20)\n"
"# assert Number(13) == Number(13)\n"
"#\n"
"#\n"
"# assert (True if Number(1) else False)\n"
"# assert (False if Number(0) else True)\n"
"#\n"
"#\n"
"# assert int(Number(13)) == 13\n"
"# assert float(Number(13)) == 13\n"
"# assert Number.__doc__ == \"Did you ever hear the tragedy of Darth Signed "
"The Overfloweth? I thought not.\\nIt's not a story C would tell you. It's a "
"Rust legend.\"\n"
"# assert Number(12345234523452) == Number(1498514748)\n"
"# try:\n"
"#     import inspect\n"
"#     assert inspect.signature(Number).__str__() == '(int)'\n"
"# except ValueError:\n"
"#     # Not supported with `abi3` before Python 3.10\n"
"#     pass\n"
"# assert Number(1337).__str__() == '1337'\n"
"# assert Number(1337).__repr__() == 'Number(1337)'\n"
"\"#"
msgstr ""

#: src/class/numeric.md:392
msgid "\"Number\""
msgstr ""

#: src/class/numeric.md:401
msgid "Appendix: Writing some unsafe code"
msgstr "附錄：編寫一些不安全的程式碼"

#: src/class/numeric.md:403
msgid ""
"At the beginning of this chapter we said that PyO3 doesn't provide a way to "
"wrap Python integers out of the box but that's a half truth. There's not a "
"PyO3 API for it, but there's a Python C API function that does:"
msgstr ""

#: src/class/numeric.md:411
msgid ""
"We can call this function from Rust by using [`pyo3::ffi::"
"PyLong_AsUnsignedLongMask`](https://docs.rs/pyo3/latest/pyo3/ffi/fn."
"PyLong_AsUnsignedLongMask.html). This is an _unsafe_ function, which means "
"we have to use an unsafe block to call it and take responsibility for "
"upholding the contracts of this function. Let's review those contracts:"
msgstr ""

#: src/class/numeric.md:414
msgid ""
"The GIL must be held. If it's not, calling this function causes a data race."
msgstr ""

#: src/class/numeric.md:415
msgid ""
"The pointer must be valid, i.e. it must be properly aligned and point to a "
"valid Python object."
msgstr ""

#: src/class/numeric.md:417
msgid ""
"Let's create that helper function. The signature has to be `fn(&PyAny) -> "
"PyResult<T>`."
msgstr ""

#: src/class/numeric.md:418
msgid ""
"`&PyAny` represents a checked borrowed reference, so the pointer derived "
"from it is valid (and not null)."
msgstr ""

#: src/class/numeric.md:419
msgid ""
"Whenever we have borrowed references to Python objects in scope, it is "
"guaranteed that the GIL is held. This reference is also where we can get a "
"[`Python`](https://docs.rs/pyo3/latest/pyo3/struct.Python.html) token to use "
"in our call to [`PyErr::take`](https://docs.rs/pyo3/latest/pyo3/prelude/"
"struct.PyErr.html#method.take)."
msgstr ""

#: src/exception.md:1
msgid "Python exceptions"
msgstr "Python 例外狀況"

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"You can use the [`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"create_exception.html) macro to define a new exception type:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr "例如："

#: src/exception.md:27 src/exception.md:46
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:28
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:29
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:33
msgid ""
"When using PyO3 to create an extension module, you can add the new exception "
"to the module like this, so that it is importable from Python:"
msgstr ""

#: src/exception.md:45
msgid "// ... other elements added to module ...\n"
msgstr ""

#: src/exception.md:53
msgid "Raising an exception"
msgstr "拋出例外狀況"

#: src/exception.md:55
msgid ""
"As described in the [function error handling](./function/error_handling.md) "
"chapter, to raise an exception from a `#[pyfunction]` or `#[pymethods]`, "
"return an `Err(PyErr)`. PyO3 will automatically raise this exception for you "
"when returing the result to Python."
msgstr ""

#: src/exception.md:57
msgid ""
"You can also manually write and fetch errors in the Python interpreter's "
"global state:"
msgstr ""

#: src/exception.md:64
msgid "\"Error\""
msgstr ""

#: src/exception.md:70
msgid "Checking exception types"
msgstr ""

#: src/exception.md:72
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type. In PyO3 every object has "
"the [`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#method.is_instance) and [`PyAny::is_instance_of`](https://pyo3.rs/main/"
"doc/pyo3/struct.PyAny.html#method.is_instance_of) methods which do the same "
"thing."
msgstr ""

#: src/exception.md:87
msgid "To check the type of an exception, you can similarly do:"
msgstr ""

#: src/exception.md:98
msgid "Using exceptions defined in Python code"
msgstr "使用 Python 程式碼中定義的例外狀況"

#: src/exception.md:100
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The `import_exception!` macro allows importing a specific exception "
"class and defines a Rust type for that exception."
msgstr ""

#: src/exception.md:113
msgid "\"tell\""
msgstr ""

#: src/exception.md:114
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:121
msgid ""
"[`pyo3::exceptions`](https://pyo3.rs/main/doc/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""

#: src/function.md:1
msgid "Python functions"
msgstr "Python 函式"

#: src/function.md:3
msgid ""
"The `#[pyfunction]` attribute is used to define a Python function from a "
"Rust function. Once defined, the function needs to be added to a [module](./"
"module.md) using the `wrap_pyfunction!` macro."
msgstr ""

#: src/function.md:5
msgid ""
"The following example defines a function called `double` in a Python module "
"called `my_extension`:"
msgstr ""

#: src/function.md:22
msgid ""
"This chapter of the guide explains full usage of the `#[pyfunction]` "
"attribute. In this first section, the following topics are covered:"
msgstr ""

#: src/function.md:24
msgid "[Function options](#function-options)"
msgstr ""

#: src/function.md:25
msgid "[`#[pyo3(name = \"...\")]`](#name)"
msgstr ""

#: src/function.md:26
msgid "[`#[pyo3(text_signature = \"...\")]`](#text_signature)"
msgstr ""

#: src/function.md:27
msgid "[`#[pyo3(pass_module)]`](#pass_module)"
msgstr ""

#: src/function.md:28
msgid "[Per-argument options](#per-argument-options)"
msgstr ""

#: src/function.md:29
msgid "[Advanced function patterns](#advanced-function-patterns)"
msgstr ""

#: src/function.md:30
msgid "[`#[pyfn]` shorthand](#pyfn-shorthand)"
msgstr ""

#: src/function.md:32
msgid "There are also additional sections on the following topics:"
msgstr ""

#: src/function.md:34
msgid "[Function Signatures](./function/signature.md)"
msgstr ""

#: src/function.md:36
msgid "Function options"
msgstr ""

#: src/function.md:38
msgid ""
"The `#[pyo3]` attribute can be used to modify properties of the generated "
"Python function. It can take any combination of the following options:"
msgstr ""

#: src/function.md:40
msgid "<a name=\"name\"></a> `#[pyo3(name = \"...\")]`"
msgstr ""

#: src/function.md:42
msgid "Overrides the name exposed to Python."
msgstr ""

#: src/function.md:44
msgid ""
"In the following example, the Rust function `no_args_py` will be added to "
"the Python module `module_with_functions` as the Python function `no_args`:"
msgstr ""

#: src/function.md:51 src/function.md:62
msgid "\"no_args\""
msgstr ""

#: src/function.md:63
msgid "\"no_args_py\""
msgstr ""

#: src/function.md:67
msgid "<a name=\"text_signature\"></a> `#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function.md:69
msgid ""
"Sets the function signature visible in Python tooling (such as via [`inspect."
"signature`](https://docs.python.org/3/library/inspect.html#inspect."
"signature))."
msgstr ""

#: src/function.md:71
msgid ""
"The example below creates a function `add` which has a signature describing "
"two positional-only arguments `a` and `b`."
msgstr ""

#: src/function.md:77
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:79 src/function.md:96
msgid "\"(a, b, /)\""
msgstr ""

#: src/function.md:89
msgid "\"This function adds two unsigned 64-bit integers.\""
msgstr ""

#: src/function.md:103
msgid "<a name=\"pass_module\" ></a> `#[pyo3(pass_module)]`"
msgstr ""

#: src/function.md:105
msgid ""
"Set this option to make PyO3 pass the containing module as the first "
"argument to the function. It is then possible to use the module in the "
"function body. The first argument **must** be of type `&PyModule`."
msgstr ""

#: src/function.md:107
msgid ""
"The following example creates a function `pyfunction_with_module` which "
"returns the containing module's name (i.e. `module_with_fn`):"
msgstr ""

#: src/function.md:124
msgid "Per-argument options"
msgstr ""

#: src/function.md:126
msgid ""
"The `#[pyo3]` attribute can be used on individual arguments to modify "
"properties of them in the generated function. It can take any combination of "
"the following options:"
msgstr ""

#: src/function.md:128
msgid "<a name=\"from_py_with\"></a> `#[pyo3(from_py_with = \"...\")]`"
msgstr ""

#: src/function.md:130
msgid ""
"Set this on an option to specify a custom function to convert the function "
"argument from Python to the desired Rust type, instead of using the default "
"`FromPyObject` extraction. The function signature must be `fn(&PyAny) -> "
"PyResult<T>` where `T` is the Rust type of the argument."
msgstr ""

#: src/function.md:132
msgid ""
"The following example uses `from_py_with` to convert the input Python object "
"to its length:"
msgstr ""

#: src/function.md:155
msgid "Advanced function patterns"
msgstr ""

#: src/function.md:157
msgid "Making the function signature available to Python (old method)"
msgstr ""

#: src/function.md:159
msgid ""
"Alternatively, simply make sure the first line of your docstring is "
"formatted like in the following example. Please note that the newline after "
"the `--` is mandatory. The `/` signifies the end of positional-only "
"arguments."
msgstr ""

#: src/function.md:163
msgid ""
"`#[pyo3(text_signature)]` should be preferred, since it will override "
"automatically generated signatures when those are added in a future version "
"of PyO3."
msgstr ""

#: src/function.md:169
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:178
msgid ""
"// a function with a signature but without docs. Both blank lines after the "
"`--` are mandatory.\n"
msgstr ""

#: src/function.md:180
msgid ""
"/// sub(a, b, /)\n"
"/// --\n"
"///\n"
"///\n"
msgstr ""

#: src/function.md:191
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:200
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:202
msgid ""
"You can pass Python `def`'d functions and built-in functions to Rust "
"functions [`PyFunction`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFunction.html) corresponds to regular Python functions while "
"[`PyCFunction`](https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html) "
"describes built-ins such as `repr()`."
msgstr ""

#: src/function.md:206
msgid ""
"You can also use [`PyAny::is_callable`](https://pyo3.rs/main/doc/pyo3/struct."
"PyAny.html#tymethod.is_callable) to check if you have a callable object. "
"`is_callable` will return `true` for functions (including lambdas), methods "
"and objects with a `__call__` method. You can call the object with [`PyAny::"
"call`](https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call) with "
"the args as first parameter and the kwargs (or `None`) as second parameter. "
"There are also [`PyAny::call0`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#tymethod.call0) with no args and [`PyAny::call1`](https://pyo3.rs/main/"
"doc/pyo3/struct.PyAny.html#tymethod.call1) with only positional args."
msgstr ""

#: src/function.md:212
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:214
msgid ""
"The ways to convert a Rust function into a Python object vary depending on "
"the function:"
msgstr ""

#: src/function.md:216
msgid ""
"Named functions, e.g. `fn foo()`: add `#[pyfunction]` and then use "
"[`wrap_pyfunction!`](https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction."
"html) to get the corresponding [`PyCFunction`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyCFunction.html)."
msgstr ""

#: src/function.md:217
msgid "Anonymous functions (or closures), e.g. `foo: fn()` either:"
msgstr ""

#: src/function.md:218
msgid ""
"use a `#[pyclass]` struct which stores the function as a field and implement "
"`__call__` to call the stored function."
msgstr ""

#: src/function.md:219
msgid ""
"use `PyFunction::new_closure` to create an object directly from the function."
msgstr ""

#: src/function.md:230
msgid "Accessing the FFI functions"
msgstr ""

#: src/function.md:232
msgid ""
"In order to make Rust functions callable from Python, PyO3 generates an "
"`extern \"C\"` function whose exact signature depends on the Rust "
"signature.  (PyO3 chooses the optimal Python argument passing convention.) "
"It then embeds the call to the Rust function inside this FFI-wrapper "
"function. This wrapper handles extraction of the regular arguments and the "
"keyword arguments from the input `PyObject`s."
msgstr ""

#: src/function.md:238
msgid ""
"The `wrap_pyfunction` macro can be used to directly get a `PyCFunction` "
"given a `#[pyfunction]` and a `PyModule`: `wrap_pyfunction!(rust_fun, "
"module)`."
msgstr ""

#: src/function.md:241
msgid "`#[pyfn]` shorthand"
msgstr ""

#: src/function.md:243
msgid ""
"There is a shorthand to `#[pyfunction]` and `wrap_pymodule!`: the function "
"can be placed inside the module definition and annotated with `#[pyfn]`. To "
"simplify PyO3, it is expected that `#[pyfn]` may be removed in a future "
"release (See [\\#694](https://github.com/PyO3/pyo3/issues/694))."
msgstr ""

#: src/function.md:246
msgid "An example of `#[pyfn]` is below:"
msgstr ""

#: src/function.md:263
msgid ""
"`#[pyfn(m)]` is just syntactic sugar for `#[pyfunction]`, and takes all the "
"same options documented in the rest of this chapter. The code above is "
"expanded to the following:"
msgstr ""

#: src/function/error_handling.md:3
msgid ""
"This chapter contains a little background of error handling in Rust and how "
"PyO3 integrates this with Python exceptions."
msgstr ""

#: src/function/error_handling.md:5
msgid ""
"This covers enough detail to create a `#[pyfunction]` which raises Python "
"exceptions from errors originating in Rust."
msgstr ""

#: src/function/error_handling.md:7
msgid ""
"There is a later section of the guide on [Python exceptions](../exception."
"md) which covers exception types in more detail."
msgstr ""

#: src/function/error_handling.md:9
msgid "Representing Python exceptions"
msgstr ""

#: src/function/error_handling.md:11
msgid ""
"Rust code uses the generic [`Result<T, E>`](https://doc.rust-lang.org/stable/"
"std/result/enum.Result.html) enum to propagate errors. The error type `E` is "
"chosen by the code author to describe the possible errors which can happen."
msgstr ""

#: src/function/error_handling.md:13
msgid ""
"PyO3 has the [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct.PyErr.html) type "
"which represents a Python exception. If a PyO3 API could result in a Python "
"exception being raised, the return type of that `API` will be [`PyResult<T>`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/function/error_handling.md:15
msgid "In summary:"
msgstr ""

#: src/function/error_handling.md:16
msgid ""
"When Python exceptions are raised and caught by PyO3, the exception will "
"stored in the `Err` variant of the `PyResult`."
msgstr ""

#: src/function/error_handling.md:17
msgid ""
"Passing Python exceptions through Rust code then uses all the \"normal\" "
"techniques such as the `?` operator, with `PyErr` as the error type."
msgstr ""

#: src/function/error_handling.md:18
msgid ""
"Finally, when a `PyResult` crosses from Rust back to Python via PyO3, if the "
"result is an `Err` variant the contained exception will be raised."
msgstr ""

#: src/function/error_handling.md:20
msgid ""
"(There are many great tutorials on Rust error handling and the `?` operator, "
"so this guide will not go into detail on Rust-specific topics.)"
msgstr ""

#: src/function/error_handling.md:22
msgid "Raising an exception from a function"
msgstr ""

#: src/function/error_handling.md:24
msgid ""
"As indicated in the previous section, when a `PyResult` containing an `Err` "
"crosses from Rust to Python, PyO3 will raise the exception contained within."
msgstr ""

#: src/function/error_handling.md:26
msgid ""
"Accordingly, to raise an exception from a `#[pyfunction]`, change the return "
"type `T` to `PyResult<T>`. When the function returns an `Err` it will raise "
"a Python exception. (Other `Result<T, E>` types can be used as long as the "
"error `E` has a `From` conversion for `PyErr`, see [implementing a "
"conversion](#implementing-an-error-conversion) below.)"
msgstr ""

#: src/function/error_handling.md:28
msgid "This also works for functions in `#[pymethods]`."
msgstr ""

#: src/function/error_handling.md:30
msgid ""
"For example, the following `check_positive` function raises a `ValueError` "
"when the input is negative:"
msgstr ""

#: src/function/error_handling.md:39
msgid "\"x is negative\""
msgstr ""

#: src/function/error_handling.md:54
msgid ""
"All built-in Python exception types are defined in the [`pyo3::exceptions`]"
"(https://pyo3.rs/main/doc/pyo3/exceptions/index.html) module. They have a "
"`new_err` constructor to directly build a `PyErr`, as seen in the example "
"above."
msgstr ""

#: src/function/error_handling.md:56
msgid "Custom Rust error types"
msgstr ""

#: src/function/error_handling.md:58
msgid ""
"PyO3 will automatically convert a `Result<T, E>` returned by a "
"`#[pyfunction]` into a `PyResult<T>` as long as there is an implementation "
"of `std::from::From<E> for PyErr`. Many error types in the Rust standard "
"library have a [`From`](https://doc.rust-lang.org/stable/std/convert/trait."
"From.html) conversion defined in this way."
msgstr ""

#: src/function/error_handling.md:60
msgid ""
"If the type `E` you are handling is defined in a third-party crate, see the "
"section on [foreign rust error types](#foreign-rust-error-types) below for "
"ways to work with this error."
msgstr ""

#: src/function/error_handling.md:62
msgid ""
"The following example makes use of the implementation of "
"`From<ParseIntError> for PyErr` to raise exceptions encountered when parsing "
"strings as integers:"
msgstr ""

#: src/function/error_handling.md:76
msgid "\"5\""
msgstr ""

#: src/function/error_handling.md:82
msgid ""
"When passed a string which doesn't contain a floating-point number, the "
"exception raised will look like the below:"
msgstr ""

#: src/function/error_handling.md:85
msgid "\"bar\""
msgstr ""

#: src/function/error_handling.md:87
msgid "\"<stdin>\""
msgstr ""

#: src/function/error_handling.md:91
msgid ""
"As a more complete example, the following snippet defines a Rust error named "
"`CustomIOError`. It then defines a `From<CustomIOError> for PyErr`, which "
"returns a `PyErr` representing Python's `OSError`. Finally, it"
msgstr ""

#: src/function/error_handling.md:105
msgid "\"Oh no!\""
msgstr ""

#: src/function/error_handling.md:115 src/function/error_handling.md:121
msgid "/* ... */"
msgstr ""

#: src/function/error_handling.md:118 src/function/error_handling.md:134
msgid "\"0.0.0.0\""
msgstr ""

#: src/function/error_handling.md:140
msgid ""
"If lazy construction of the Python exception instance is desired, the "
"[`PyErrArguments`](https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html) "
"trait can be implemented instead of `From`. In that case, actual exception "
"argument creation is delayed until the `PyErr` is needed."
msgstr ""

#: src/function/error_handling.md:145
msgid ""
"A final note is that any errors `E` which have a `From` conversion can be "
"used with the `?` (\"try\") operator with them. An alternative "
"implementation of the above `parse_int` which instead returns `PyResult` is "
"below:"
msgstr ""

#: src/function/error_handling.md:160
msgid "\"1\""
msgstr ""

#: src/function/error_handling.md:161
msgid "\"1337\""
msgstr ""

#: src/function/error_handling.md:166
msgid "\"foo\""
msgstr ""

#: src/function/error_handling.md:169
msgid "\"13.37\""
msgstr ""

#: src/function/error_handling.md:176
msgid "Foreign Rust error types"
msgstr ""

#: src/function/error_handling.md:178
msgid ""
"The Rust compiler will not permit implementation of traits for types outside "
"of the crate where the type is defined. (This is known as the \"orphan "
"rule\".)"
msgstr ""

#: src/function/error_handling.md:180
msgid ""
"Given a type `OtherError` which is defined in third-party code, there are "
"two main strategies available to integrate it with PyO3:"
msgstr ""

#: src/function/error_handling.md:182
msgid ""
"Create a newtype wrapper, e.g. `MyOtherError`. Then implement "
"`From<MyOtherError> for PyErr` (or `PyErrArguments`), as well as "
"`From<OtherError>` for `MyOtherError`."
msgstr ""

#: src/function/error_handling.md:183
msgid ""
"Use Rust's Result combinators such as `map_err` to write code freely to "
"convert `OtherError` into whatever is needed. This requires boilerplate at "
"every usage however gives unlimited flexibility."
msgstr ""

#: src/function/error_handling.md:185
msgid ""
"To detail the newtype strategy a little further, the key trick is to return "
"`Result<T, MyOtherError>` from the `#[pyfunction]`. This means that PyO3 "
"will make use of `From<MyOtherError> for PyErr` to create Python exceptions "
"while the `#[pyfunction]` implementation can use `?` to convert `OtherError` "
"to `MyOtherError` automatically."
msgstr ""

#: src/function/error_handling.md:187
msgid ""
"The following example demonstrates this for some imaginary third-party crate "
"`some_crate` with a function `get_x` returning `Result<i32, OtherError>`:"
msgstr ""

#: src/function/error_handling.md:193
msgid "\"some error occurred\""
msgstr ""

#: src/function/error_handling.md:218
msgid "// get_x is a function returning Result<i32, OtherError>\n"
msgstr ""

#: src/function/signature.md:1
msgid "Function signatures"
msgstr "函式簽名"

#: src/function/signature.md:3
msgid ""
"The `#[pyfunction]` attribute also accepts parameters to control how the "
"generated Python function accepts arguments. Just like in Python, arguments "
"can be positional-only, keyword-only, or accept either. `*args` lists and "
"`**kwargs` dicts can also be accepted. These parameters also work for "
"`#[pymethods]` which will be introduced in the [Python Classes](../class.md) "
"section of the guide."
msgstr ""

#: src/function/signature.md:5
msgid ""
"Like Python, by default PyO3 accepts all arguments as either positional or "
"keyword arguments. The extra arguments to `#[pyfunction]` modify this "
"behaviour. For example, below is a function that accepts arbitrary keyword "
"arguments (`**kwargs` in Python syntax) and returns the number that was "
"passed:"
msgstr ""

#: src/function/signature.md:23
msgid ""
"The following parameters can be passed to the `#[pyfunction]` attribute:"
msgstr ""

#: src/function/signature.md:25
msgid ""
"`\"/\"`: positional-only arguments separator, each parameter defined before "
"`\"/\"` is a positional-only parameter. Corresponds to python's `def "
"meth(arg1, arg2, ..., /, argN..)`."
msgstr ""

#: src/function/signature.md:28
msgid ""
"`\"*\"`: var arguments separator, each parameter defined after `\"*\"` is a "
"keyword-only parameter. Corresponds to python's `def meth(*, arg1.., "
"arg2=..)`."
msgstr ""

#: src/function/signature.md:30
msgid ""
"`args=\"*\"`: \"args\" is var args, corresponds to Python's `def "
"meth(*args)`. Type of the `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/function/signature.md:32
msgid ""
"`kwargs=\"**\"`: \"kwargs\" receives keyword arguments, corresponds to "
"Python's `def meth(**kwargs)`. The type of the `kwargs` parameter has to be "
"`Option<&PyDict>`."
msgstr ""

#: src/function/signature.md:34
msgid ""
"`arg=\"Value\"`: arguments with default value. Corresponds to Python's `def "
"meth(arg=Value)`. If the `arg` argument is defined after var arguments, it "
"is treated as a keyword-only argument. Note that `Value` has to be valid "
"rust code, PyO3 just inserts it into the generated code unmodified."
msgstr ""

#: src/function/signature.md:71
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={}\""
msgstr ""

#: src/function/signature.md:78
msgid "\"num={}\""
msgstr ""

#: src/function/signature.md:82
msgid ""
"N.B. the position of the `\"/\"` and `\"*\"` arguments (if included) control "
"the system of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/function/signature.md:91
msgid "Produces output:"
msgstr ""

#: src/module.md:1
msgid "Python modules"
msgstr "Python 模組"

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr "您可以使用 `#[pymodule]` 建立模組："

#: src/module.md:12
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:21
msgid ""
"The `#[pymodule]` procedural macro takes care of exporting the "
"initialization function of your module to Python."
msgstr ""

#: src/module.md:24
msgid ""
"The module's name defaults to the name of the Rust function. You can "
"override the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:36
msgid "\"custom_name\""
msgstr ""

#: src/module.md:43
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:47
msgid "To import the module, either:"
msgstr ""

#: src/module.md:48
msgid ""
"copy the shared library as described in [Manual builds]"
"(building_and_distribution.html#manual-builds), or"
msgstr ""

#: src/module.md:49
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:52
msgid "Documentation"
msgstr "文件"

#: src/module.md:54
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the module initialization function will be applied "
"automatically as the Python docstring of your module."
msgstr ""

#: src/module.md:57
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:65
msgid "Python submodules"
msgstr "Python 子模組"

#: src/module.md:67
msgid ""
"You can create a module hierarchy within a single extension module by using "
"[`PyModule.add_submodule()`](https://pyo3.rs/main/doc/pyo3/prelude/struct."
"PyModule.html#method.add_submodule). For example, you could define the "
"modules `parent_module` and `parent_module.child_module`."
msgstr ""

#: src/module.md:81
msgid "\"child_module\""
msgstr ""

#: src/module.md:89
msgid "\"func\""
msgstr ""

#: src/module.md:96
msgid "\"parent_module\""
msgstr ""

#: src/module.md:98
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:102
msgid ""
"Note that this does not define a package, so this won’t allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:107
msgid ""
"It is not necessary to add `#[pymodule]` on nested modules, which is only "
"required on the top-level module."
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "摘要"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "介紹"

#: src/SUMMARY.md:7
msgid "Getting started"
msgstr "開始使用"

#: src/SUMMARY.md:13
msgid "Class customizations"
msgstr "類別自訂"

#: src/SUMMARY.md:17
msgid "Type conversions"
msgstr "型別轉換"

#: src/SUMMARY.md:18
msgid "Mapping of Rust types to Python types\\]"
msgstr ""

#: src/SUMMARY.md:19
msgid "Conversion traits\\]"
msgstr ""

#: src/SUMMARY.md:21
msgid "Calling Python from Rust"
msgstr "從 Rust 呼叫 Python"

#: src/SUMMARY.md:22
msgid "GIL, mutability and object types"
msgstr ""

#: src/SUMMARY.md:30
msgid "Useful crates"
msgstr "實用 crate"

#: src/SUMMARY.md:31
msgid "Logging"
msgstr "日誌"

#: src/SUMMARY.md:32
msgid "Using `async` and `await`"
msgstr "使用 `async` 和 `await`"

#: src/SUMMARY.md:33
msgid "FAQ and troubleshooting"
msgstr "常見問題與疑難排解"

#: src/SUMMARY.md:37
msgid ""
"Appendix A: Migration guide Appendix B: PyO3 and rust-cpython Appendix C: "
"Trait bounds Appendix D: Python typing hints CHANGELOG"
msgstr ""

#: src/conversions.md:3
msgid ""
"In this portion of the guide we'll talk about the mapping of Python types to "
"Rust types offered by PyO3, as well as the traits available to perform "
"conversions between them."
msgstr ""
"本節指南將介紹 PyO3 提供的 Python 型別到 Rust 型別的對應，以及用於在兩者之間"
"進行轉換的特徵。"

#: src/conversions/traits.md:1
msgid "Conversion traits"
msgstr "轉換特徵"

#: src/conversions/traits.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr "PyO3 提供一些方便的特徵，用於在 Python 與 Rust 型別之間進行轉換。"

#: src/conversions/traits.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr "`.extract()` 與 `FromPyObject` 特徵"

#: src/conversions/traits.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions/traits.md:16 src/conversions/traits.md:423
msgid "b\"foo\""
msgstr ""

#: src/conversions/traits.md:24
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)."
msgstr ""
"這個方法可用於多種 Python 物件型別，並能產生各式各樣的 Rust 型別；你可以在 "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) 的實作清單中查看。"

#: src/conversions/traits.md:28
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](../class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions/traits.md:35
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"
msgstr ""
"衍生 [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"

#: src/conversions/traits.md:37
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) can be automatically derived for many kinds of structs and enums if "
"the member types themselves implement `FromPyObject`. This even includes "
"members with a generic type `T: FromPyObject`. Derivation for empty enums, "
"enum variants and structs is not supported."
msgstr ""
"若成員型別本身實作 `FromPyObject`，則可為多種結構與列舉自動衍生 "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html)。這甚至包含泛型成員 `T: FromPyObject`。不支援對空列舉、列舉變體與結構進"
"行衍生。"

#: src/conversions/traits.md:42
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for structs"
msgstr ""
"為結構衍生 [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"

#: src/conversions/traits.md:44
msgid ""
"The derivation generates code that will attempt to access the attribute  "
"`my_string` on the Python object, i.e. `obj.getattr(\"my_string\")`, and "
"call `extract()` on the attribute."
msgstr ""
"衍生會產生程式碼，嘗試存取 Python 物件上的 `my_string` 屬性，也就是 `obj."
"getattr(\"my_string\")`，並對該屬性呼叫 `extract()`。"

#: src/conversions/traits.md:59
msgid ""
"\"class Foo:\n"
"#             def __init__(self):\n"
"#                 self.my_string = 'test'\""
msgstr ""

#: src/conversions/traits.md:66 src/conversions/traits.md:125
#: src/conversions/traits.md:323 src/conversions/traits.md:347
msgid "\"Foo\""
msgstr ""

#: src/conversions/traits.md:75
msgid ""
"By setting the `#[pyo3(item)]` attribute on the field, PyO3 will attempt to "
"extract the value by calling the `get_item` method on the Python object."
msgstr ""
"在欄位上設定 `#[pyo3(item)]` 屬性時，PyO3 會嘗試透過呼叫 Python 物件的 "
"`get_item` 方法來提取值。"

#: src/conversions/traits.md:91
msgid "\"my_string\""
msgstr ""

#: src/conversions/traits.md:100
msgid "The argument passed to `getattr` and `get_item` can also be configured:"
msgstr "傳給 `getattr` 與 `get_item` 的引數也可進行設定："

#: src/conversions/traits.md:117
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.name = 'test'\n"
"#                 self['key'] = 'test2'\""
msgstr ""

#: src/conversions/traits.md:129 src/conversions/traits.md:156
#: src/conversions/traits.md:160
msgid "\"test2\""
msgstr ""

#: src/conversions/traits.md:136
msgid ""
"This tries to extract `string_attr` from the attribute `name` and "
"`string_in_mapping` from a mapping with the key `\"key\"`. The arguments for "
"`attribute` are restricted to non-empty string literals while `item` can "
"take any valid literal that implements `ToBorrowedObject`."
msgstr ""
"這會嘗試從 `name` 屬性提取 `string_attr`，並從鍵為 `\"key\"` 的對映中提取 "
"`string_in_mapping`。`attribute` 的引數限制為非空字串常值，而 `item` 可接受任"
"何實作 `ToBorrowedObject` 的有效常值。"

#: src/conversions/traits.md:141
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for tuple structs"
msgstr ""
"為元組結構衍生 [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/"
"trait.FromPyObject.html)"

#: src/conversions/traits.md:143
msgid ""
"Tuple structs are also supported but do not allow customizing the "
"extraction. The input is always assumed to be a Python tuple with the same "
"length as the Rust type, the `n`th field is extracted from the `n`th item in "
"the Python tuple."
msgstr ""
"元組結構也受支援，但不允許自訂提取方式。輸入一律視為與 Rust 型別長度相同的 "
"Python tuple，第 `n` 個欄位會從 Python tuple 的第 `n` 個項目提取。"

#: src/conversions/traits.md:167
msgid ""
"Tuple structs with a single field are treated as wrapper types which are "
"described in the following section. To override this behaviour and ensure "
"that the input is in fact a tuple, specify the struct as"
msgstr ""
"只有單一欄位的元組結構會被視為包裝型別，並在下一節說明。若要覆寫此行為並確保"
"輸入確實為 tuple，請將結構指定為"

#: src/conversions/traits.md:189
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for wrapper types"
msgstr ""
"為包裝型別衍生 [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/"
"trait.FromPyObject.html)"

#: src/conversions/traits.md:191
msgid ""
"The `pyo3(transparent)` attribute can be used on structs with exactly one "
"field. This results in extracting directly from the input object, i.e. `obj."
"extract()`, rather than trying to access an item or attribute. This "
"behaviour is enabled per default for newtype structs and tuple-variants with "
"a single field."
msgstr ""
"`pyo3(transparent)` 屬性可用於只有一個欄位的結構。這會直接從輸入物件提取（即 "
"`obj.extract()`），而不是嘗試存取項目或屬性。此行為預設啟用於 newtype 結構與"
"單一欄位的元組變體。"

#: src/conversions/traits.md:224
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for enums"
msgstr ""
"為列舉衍生 [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"

#: src/conversions/traits.md:226
msgid ""
"The `FromPyObject` derivation for enums generates code that tries to extract "
"the variants in the order of the fields. As soon as a variant can be "
"extracted successfully, that variant is returned. This makes it possible to "
"extract Python union types like `str | int`."
msgstr ""
"針對列舉的 `FromPyObject` 衍生會產生程式碼，依欄位順序嘗試提取各變體。一旦某"
"個變體成功提取，就會回傳該變體。這使得提取 `str | int` 等 Python union 型別成"
"為可能。"

#: src/conversions/traits.md:230
msgid ""
"The same customizations and restrictions described for struct derivations "
"apply to enum variants, i.e. a tuple variant assumes that the input is a "
"Python tuple, and a struct variant defaults to extracting fields as "
"attributes but can be configured in the same manner. The `transparent` "
"attribute can be applied to single-field-variants."
msgstr ""
"結構衍生的相同自訂與限制也適用於列舉變體：元組變體假設輸入為 Python tuple，結"
"構變體預設以屬性提取欄位，但可用相同方式設定。`transparent` 屬性可套用於單一"
"欄位的變體。"

#: src/conversions/traits.md:241
msgid "// input is a positive int\n"
msgstr ""

#: src/conversions/traits.md:242
msgid "// input is a string\n"
msgstr ""

#: src/conversions/traits.md:243
msgid "// input is a 2-tuple with positive ints\n"
msgstr ""

#: src/conversions/traits.md:244
msgid "// input is a 2-tuple with String and int\n"
msgstr ""

#: src/conversions/traits.md:245
msgid "// needs to be in front of 2d\n"
msgstr ""

#: src/conversions/traits.md:250
msgid "// only gets checked if the input did not have `z`\n"
msgstr ""

#: src/conversions/traits.md:251
msgid "\"x\""
msgstr ""

#: src/conversions/traits.md:253
msgid "\"y\""
msgstr ""

#: src/conversions/traits.md:257
msgid "// This extraction never fails\n"
msgstr ""

#: src/conversions/traits.md:271 src/conversions/traits.md:283
#: src/conversions/traits.md:295 src/conversions/traits.md:307
#: src/conversions/traits.md:331 src/conversions/traits.md:355
#: src/conversions/traits.md:368 src/conversions/traits.md:404
#: src/conversions/traits.md:417
msgid "\"Error extracting: {:?}\""
msgstr ""

#: src/conversions/traits.md:276 src/conversions/traits.md:280
msgid "\"text\""
msgstr ""

#: src/conversions/traits.md:314
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 0\n"
"#                 self.y = 1\n"
"#                 self.z = 2\""
msgstr ""

#: src/conversions/traits.md:339
msgid ""
"\"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 3\n"
"#                 self.y = 4\""
msgstr ""

#: src/conversions/traits.md:361 src/conversions/traits.md:365
msgid "b\"text\""
msgstr ""

#: src/conversions/traits.md:377
msgid ""
"If none of the enum variants match, a `PyTypeError` containing the names of "
"the tested variants is returned. The names reported in the error message can "
"be customized through the `#[pyo3(annotation = \"name\")]` attribute, e.g. "
"to use conventional Python type names:"
msgstr ""

#: src/conversions/traits.md:388
msgid "\"str\""
msgstr ""

#: src/conversions/traits.md:390
msgid "\"int\""
msgstr ""

#: src/conversions/traits.md:433
msgid ""
"If the input is neither a string nor an integer, the error message will be: "
"`\"'<INPUT_TYPE>' cannot be converted to 'str | int'\"`."
msgstr ""

#: src/conversions/traits.md:436
msgid "`#[derive(FromPyObject)]` Container Attributes"
msgstr ""

#: src/conversions/traits.md:437
msgid "`pyo3(transparent)`"
msgstr ""

#: src/conversions/traits.md:438
msgid ""
"extract the field directly from the object as `obj.extract()` instead of "
"`get_item()` or `getattr()`"
msgstr ""

#: src/conversions/traits.md:440
msgid ""
"Newtype structs and tuple-variants are treated as transparent per default."
msgstr ""

#: src/conversions/traits.md:441
msgid "only supported for single-field structs and enum variants"
msgstr ""

#: src/conversions/traits.md:442
msgid "`pyo3(annotation = \"name\")`"
msgstr ""

#: src/conversions/traits.md:443
msgid ""
"changes the name of the failed variant in the generated error message in "
"case of failure."
msgstr ""

#: src/conversions/traits.md:444
msgid "e.g. `pyo3(\"int\")` reports the variant's type as `int`."
msgstr ""

#: src/conversions/traits.md:445
msgid "only supported for enum variants"
msgstr ""

#: src/conversions/traits.md:447
msgid "`#[derive(FromPyObject)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:448
msgid "`pyo3(attribute)`, `pyo3(attribute(\"name\"))`"
msgstr ""

#: src/conversions/traits.md:449
msgid ""
"retrieve the field from an attribute, possibly with a custom name specified "
"as an argument"
msgstr ""

#: src/conversions/traits.md:450
msgid "argument must be a string-literal."
msgstr ""

#: src/conversions/traits.md:451
msgid "`pyo3(item)`, `pyo3(item(\"key\"))`"
msgstr ""

#: src/conversions/traits.md:452
msgid ""
"retrieve the field from a mapping, possibly with the custom key specified as "
"an argument."
msgstr ""

#: src/conversions/traits.md:453
msgid "can be any literal that implements `ToBorrowedObject`"
msgstr ""

#: src/conversions/traits.md:454
msgid "`pyo3(from_py_with = \"...\")`"
msgstr ""

#: src/conversions/traits.md:455
msgid ""
"apply a custom function to convert the field from Python the desired Rust "
"type."
msgstr ""

#: src/conversions/traits.md:456
msgid "the argument must be the name of the function as a string."
msgstr ""

#: src/conversions/traits.md:457
msgid ""
"the function signature must be `fn(&PyAny) -> PyResult<T>` where `T` is the "
"Rust type of the argument."
msgstr ""

#: src/conversions/traits.md:459
msgid "`IntoPy<T>`"
msgstr ""

#: src/conversions/traits.md:461
msgid ""
"This trait defines the to-python conversion for a Rust type. It is usually "
"implemented as `IntoPy<PyObject>`, which is the trait needed for returning a "
"value from `#[pyfunction]` and `#[pymethods]`."
msgstr ""

#: src/conversions/traits.md:465
msgid ""
"All types in PyO3 implement this trait, as does a `#[pyclass]` which doesn't "
"use `extends`."
msgstr ""

#: src/conversions/traits.md:467
msgid ""
"Occasionally you may choose to implement this for custom types which are "
"mapped to Python types _without_ having a unique python type."
msgstr ""

#: src/conversions/traits.md:482
msgid "The `ToPyObject` trait"
msgstr ""

#: src/conversions/traits.md:484
msgid ""
"[`ToPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.ToPyObject."
"html) is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://pyo3.rs/main/doc/pyo3/type.PyObject.html). "
"`IntoPy<PyObject>` serves the same purpose, except that it consumes `self`."
msgstr ""

#: src/conversions/tables.md:1
msgid "Mapping of Rust types to Python types"
msgstr "Rust 型別對應到 Python 型別"

#: src/conversions/tables.md:3
msgid ""
"When writing functions callable from Python (such as a `#[pyfunction]` or in "
"a `#[pymethods]` block), the trait `FromPyObject` is required for function "
"arguments, and `IntoPy<PyObject>` is required for function return values."
msgstr ""

#: src/conversions/tables.md:5
msgid ""
"Consult the tables in the following section to find the Rust types provided "
"by PyO3 which implement these traits."
msgstr "請參考下一節的表格，找出 PyO3 提供且實作這些特徵的 Rust 型別。"

#: src/conversions/tables.md:7
msgid "Argument Types"
msgstr "引數型別"

#: src/conversions/tables.md:9
msgid ""
"When accepting a function argument, it is possible to either use Rust "
"library types or PyO3's Python-native types. (See the next section for "
"discussion on when to use each.)"
msgstr ""
"接受函式引數時，可以使用 Rust 函式庫型別或 PyO3 的 Python 原生型別。（何時使"
"用哪種型別，請見下一節。）"

#: src/conversions/tables.md:11
msgid ""
"The table below contains the Python type and the corresponding function "
"argument types that will accept them:"
msgstr "下表列出 Python 型別及其對應可接受的函式引數型別："

#: src/conversions/tables.md:13
msgid "Rust (Python-native)"
msgstr "Rust（Python 原生）"

#: src/conversions/tables.md:15
msgid "`object`"
msgstr ""

#: src/conversions/tables.md:15 src/conversions/tables.md:28
#: src/conversions/tables.md:29 src/conversions/tables.md:30
#: src/conversions/tables.md:31 src/conversions/tables.md:32
#: src/conversions/tables.md:33 src/conversions/tables.md:34
#: src/conversions/tables.md:35 src/conversions/tables.md:36
#: src/conversions/tables.md:39 src/conversions/tables.md:40
msgid "\\-"
msgstr ""

#: src/conversions/tables.md:15
msgid "`&PyAny`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:79
#: src/conversions/tables.md:80
msgid "`str`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`String`, `Cow<str>`, `&str`, `OsString`, `PathBuf`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`&PyUnicode`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`bytes`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`Vec<u8>`, `&[u8]`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`&PyBytes`"
msgstr ""

#: src/conversions/tables.md:18 src/conversions/tables.md:81
msgid "`bool`"
msgstr ""

#: src/conversions/tables.md:18
msgid "`&PyBool`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "`int`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "Any integer type (`i32`, `u32`, `usize`, etc)"
msgstr ""

#: src/conversions/tables.md:19
msgid "`&PyLong`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`float`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`f32`, `f64`"
msgstr ""

#: src/conversions/tables.md:20
msgid "`&PyFloat`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`complex`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`num_complex::Complex`[^1]"
msgstr ""

#: src/conversions/tables.md:21
msgid "`&PyComplex`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`list[T]`"
msgstr ""

#: src/conversions/tables.md:22 src/conversions/tables.md:37
#: src/conversions/tables.md:86
msgid "`Vec<T>`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`&PyList`"
msgstr ""

#: src/conversions/tables.md:23
msgid "`dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:23 src/conversions/tables.md:38
msgid ""
"`HashMap<K, V>`, `BTreeMap<K, V>`, `hashbrown::HashMap<K, V>`[^2], "
"`indexmap::IndexMap<K, V>`[^3]"
msgstr ""

#: src/conversions/tables.md:23
msgid "`&PyDict`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`(T, U)`, `Vec<T>`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`&PyTuple`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`set[T]`"
msgstr ""

#: src/conversions/tables.md:25 src/conversions/tables.md:26
msgid "`HashSet<T>`, `BTreeSet<T>`, `hashbrown::HashSet<T>`[^2]"
msgstr ""

#: src/conversions/tables.md:25
msgid "`&PySet`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`frozenset[T]`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`&PyFrozenSet`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`bytearray`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`Vec<u8>`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`&PyByteArray`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`slice`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`&PySlice`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`type`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`&PyType`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`module`"
msgstr "`module`"

#: src/conversions/tables.md:30
msgid "`&PyModule`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`datetime.datetime`"
msgstr "`datetime.datetime`"

#: src/conversions/tables.md:31
msgid "`&PyDateTime`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`datetime.date`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`&PyDate`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`datetime.time`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`&PyTime`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`datetime.tzinfo`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`&PyTzInfo`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`datetime.timedelta`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`&PyDelta`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`typing.Optional[T]`"
msgstr ""

#: src/conversions/tables.md:36 src/conversions/tables.md:84
msgid "`Option<T>`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`typing.Sequence[T]`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`&PySequence`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`typing.Mapping[K, V]`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`&PyMapping`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`typing.Iterator[Any]`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`&PyIterator`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`typing.Union[...]`"
msgstr ""

#: src/conversions/tables.md:40
msgid ""
"See [`#[derive(FromPyObject)]`](traits.html#deriving-a-"
"hrefhttpsdocsrspyo3latestpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-"
"for-enums)"
msgstr ""

#: src/conversions/tables.md:42
msgid ""
"There are also a few special types related to the GIL and Rust-defined "
"`#[pyclass]`es which may come in useful:"
msgstr ""

#: src/conversions/tables.md:44
msgid "What"
msgstr "項目"

#: src/conversions/tables.md:46
msgid "`Python`"
msgstr ""

#: src/conversions/tables.md:46
msgid ""
"A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL"
msgstr ""

#: src/conversions/tables.md:47
msgid "`Py<T>`"
msgstr ""

#: src/conversions/tables.md:47
msgid ""
"A Python object isolated from the GIL lifetime. This can be sent to other "
"threads."
msgstr ""

#: src/conversions/tables.md:48
msgid "`PyObject`"
msgstr ""

#: src/conversions/tables.md:48
msgid "An alias for `Py<PyAny>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "`&PyCell<T>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "A `#[pyclass]` value owned by Python."
msgstr ""

#: src/conversions/tables.md:50
msgid "`PyRef<T>`"
msgstr ""

#: src/conversions/tables.md:50
msgid "A `#[pyclass]` borrowed immutably."
msgstr "不可變借用的 `#[pyclass]`。"

#: src/conversions/tables.md:51
msgid "`PyRefMut<T>`"
msgstr ""

#: src/conversions/tables.md:51
msgid "A `#[pyclass]` borrowed mutably."
msgstr "可變借用的 `#[pyclass]`。"

#: src/conversions/tables.md:53
msgid ""
"For more detail on accepting `#[pyclass]` values as function arguments, see "
"[the section of this guide on Python Classes](../class.md)."
msgstr ""
"更多關於將 `#[pyclass]` 作為函式引數的細節，請見本指南的[Python 類別章節](../"
"class.md)。"

#: src/conversions/tables.md:55
msgid "Using Rust library types vs Python-native types"
msgstr "使用 Rust 函式庫型別 vs Python 原生型別"

#: src/conversions/tables.md:57
msgid ""
"Using Rust library types as function arguments will incur a conversion cost "
"compared to using the Python-native types. Using the Python-native types is "
"almost zero-cost (they just require a type check similar to the Python "
"builtin function `isinstance()`)."
msgstr ""
"使用 Rust 函式庫型別作為函式引數，相較於 Python 原生型別會產生轉換成本。使用 "
"Python 原生型別幾乎是零成本（只需進行類似 Python 內建函式 `isinstance()` 的型"
"別檢查）。"

#: src/conversions/tables.md:59
msgid ""
"However, once that conversion cost has been paid, the Rust standard library "
"types offer a number of benefits:"
msgstr "不過，一旦付出轉換成本，Rust 標準函式庫型別會帶來多項好處："

#: src/conversions/tables.md:60
msgid ""
"You can write functionality in native-speed Rust code (free of Python's "
"runtime costs)."
msgstr "你可以用原生速度的 Rust 程式碼實作功能（不受 Python 執行期成本影響）。"

#: src/conversions/tables.md:61
msgid "You get better interoperability with the rest of the Rust ecosystem."
msgstr "可與 Rust 生態系的其他元件有更好的互通性。"

#: src/conversions/tables.md:62
msgid ""
"You can use `Python::allow_threads` to release the Python GIL and let other "
"Python threads make progress while your Rust code is executing."
msgstr ""

#: src/conversions/tables.md:63
msgid ""
"You also benefit from stricter type checking. For example you can specify "
"`Vec<i32>`, which will only accept a Python `list` containing integers. The "
"Python-native equivalent, `&PyList`, would accept a Python `list` containing "
"Python objects of any type."
msgstr ""
"你也會受益於更嚴格的型別檢查。例如指定 `Vec<i32>`，只會接受包含整數的 Python "
"`list`。相對的 Python 原生等價型別 `&PyList` 會接受包含任何型別 Python 物件"
"的 `list`。"

#: src/conversions/tables.md:65
msgid ""
"For most PyO3 usage the conversion cost is worth paying to get these "
"benefits. As always, if you're not sure it's worth it in your case, "
"benchmark it!"
msgstr ""
"對於多數 PyO3 使用情境，付出轉換成本以換取上述好處是值得的。一如往常，若不確"
"定是否值得，請進行基準測試！"

#: src/conversions/tables.md:67
msgid "Returning Rust values to Python"
msgstr "將 Rust 值回傳給 Python"

#: src/conversions/tables.md:69
msgid ""
"When returning values from functions callable from Python, Python-native "
"types (`&PyAny`, `&PyDict` etc.) can be used with zero cost."
msgstr ""

#: src/conversions/tables.md:71
msgid ""
"Because these types are references, in some situations the Rust compiler may "
"ask for lifetime annotations. If this is the case, you should use "
"`Py<PyAny>`, `Py<PyDict>` etc. instead - which are also zero-cost. For all "
"of these Python-native types `T`, `Py<T>` can be created from `T` with an `."
"into()` conversion."
msgstr ""

#: src/conversions/tables.md:73
msgid ""
"If your function is fallible, it should return `PyResult<T>` or `Result<T, "
"E>` where `E` implements `From<E> for PyErr`. This will raise a `Python` "
"exception if the `Err` variant is returned."
msgstr ""
"若函式可能失敗，應回傳 `PyResult<T>` 或 `Result<T, E>`，其中 `E` 需實作 "
"`From<E> for PyErr`。若回傳 `Err` 變體，將拋出 `Python` 例外。"

#: src/conversions/tables.md:75
msgid ""
"Finally, the following Rust types are also able to convert to Python as "
"return values:"
msgstr "最後，以下 Rust 型別也可作為回傳值轉換為 Python："

#: src/conversions/tables.md:77
msgid "Rust type"
msgstr "Rust 型別"

#: src/conversions/tables.md:77
msgid "Resulting Python Type"
msgstr "對應的 Python 型別"

#: src/conversions/tables.md:79
msgid "`String`"
msgstr ""

#: src/conversions/tables.md:80
msgid "`&str`"
msgstr ""

#: src/conversions/tables.md:84
msgid "`Optional[T]`"
msgstr "`Optional[T]`"

#: src/conversions/tables.md:85
msgid "`Tuple[T, U]`"
msgstr "`Tuple[T, U]`"

#: src/conversions/tables.md:86
msgid "`List[T]`"
msgstr "`List[T]`"

#: src/conversions/tables.md:87
msgid "`HashMap<K, V>`"
msgstr "`HashMap<K, V>`"

#: src/conversions/tables.md:87 src/conversions/tables.md:88
msgid "`Dict[K, V]`"
msgstr "`Dict[K, V]`"

#: src/conversions/tables.md:88
msgid "`BTreeMap<K, V>`"
msgstr "`BTreeMap<K, V>`"

#: src/conversions/tables.md:89
msgid "`HashSet<T>`"
msgstr "`HashSet<T>`"

#: src/conversions/tables.md:89 src/conversions/tables.md:90
msgid "`Set[T]`"
msgstr "`Set[T]`"

#: src/conversions/tables.md:90
msgid "`BTreeSet<T>`"
msgstr "`BTreeSet<T>`"

#: src/conversions/tables.md:91
msgid "`&PyCell<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:92
msgid "`PyRef<T: PyClass>`"
msgstr "`PyRef<T: PyClass>`"

#: src/conversions/tables.md:93
msgid "`PyRefMut<T: PyClass>`"
msgstr "`PyRefMut<T: PyClass>`"

#: src/conversions/tables.md:95
msgid "Requires the `num-complex` optional feature."
msgstr "需要 `num-complex` 選用功能。"

#: src/conversions/tables.md:97
msgid "Requires the `hashbrown` optional feature."
msgstr "需要 `hashbrown` 選用功能。"

#: src/conversions/tables.md:99
msgid "Requires the `indexmap` optional feature."
msgstr "需要 `indexmap` 選用功能。"

#: src/ecosystem.md:1
msgid "The PyO3 ecosystem"
msgstr "PyO3 生態系"

#: src/ecosystem.md:3
msgid ""
"This portion of the guide is dedicated to crates which are external to the "
"main PyO3 project and provide additional functionality you might find useful."
msgstr ""
"本指南此部分介紹主 PyO3 專案之外的軟體箱，它們提供你可能覺得有用的額外功能。"

#: src/ecosystem.md:5
msgid ""
"Because these projects evolve independently of the PyO3 repository the "
"content of these articles may fall out of date over time; please file issues "
"on the PyO3 Github to alert maintainers when this is the case."
msgstr ""

#: src/ecosystem/logging.md:3
msgid ""
"It is desirable if both the Python and Rust parts of the application end up "
"logging using the same configuration into the same place."
msgstr ""
"理想情況是應用程式中的 Python 與 Rust 部分都使用相同設定，並將日誌輸出到同一"
"位置。"

#: src/ecosystem/logging.md:6
msgid ""
"This section of the guide briefly discusses how to connect the two "
"languages' logging ecosystems together. The recommended way for Python "
"extension modules is to configure Rust's logger to send log messages to "
"Python using the `pyo3-log` crate. For users who want to do the opposite and "
"send Python log messages to Rust, see the note at the end of this guide."
msgstr ""
"本節簡要說明如何連結兩種語言的日誌生態系。對於 Python 擴充模組，建議的方式是"
"使用 `pyo3-log` 軟體箱設定 Rust 的 logger，將日誌訊息送到 Python。若你想反向"
"將 Python 日誌送到 Rust，請見本指南最後的說明。"

#: src/ecosystem/logging.md:12
msgid "Using `pyo3-log` to send Rust log messages to Python"
msgstr "使用 `pyo3-log` 將 Rust 日誌訊息送到 Python"

#: src/ecosystem/logging.md:14
msgid ""
"The [pyo3-log](https://crates.io/crates/pyo3-log) crate allows sending the "
"messages from the Rust side to Python's [logging](https://docs.python.org/3/"
"library/logging.html) system. This is mostly suitable for writing native "
"extensions for Python programs."
msgstr ""
"[pyo3-log](https://crates.io/crates/pyo3-log) 軟體箱允許將 Rust 端訊息傳送到 "
"Python 的 [logging](https://docs.python.org/3/library/logging.html) 系統。這"
"主要適用於為 Python 程式撰寫原生擴充。"

#: src/ecosystem/logging.md:18
msgid ""
"Use [`pyo3_log::init`](https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html) to "
"install the logger in its default configuration. It's also possible to tweak "
"its configuration (mostly to tune its performance)."
msgstr ""
"使用 [`pyo3_log::init`](https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html) 以"
"預設設定安裝 logger。也可以調整其設定（多半用於效能調校）。"

#: src/ecosystem/logging.md:27
msgid ""
"// This will use the logger installed in `my_module` to send the `info`\n"
"    // message to the Python logging facilities.\n"
msgstr ""

#: src/ecosystem/logging.md:29
msgid "\"Something!\""
msgstr ""

#: src/ecosystem/logging.md:34
msgid "// A good place to install the Rust -> Python logger.\n"
msgstr "// 安裝 Rust -> Python logger 的好位置。\n"

#: src/ecosystem/logging.md:42
msgid ""
"Then it is up to the Python side to actually output the messages somewhere."
msgstr "接著由 Python 端負責將訊息實際輸出到某處。"

#: src/ecosystem/logging.md:48
msgid ""
"'%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'"
msgstr ""

#: src/ecosystem/logging.md:54
msgid ""
"It is important to initialize the Python loggers first, before calling any "
"Rust functions that may log. This limitation can be worked around if it is "
"not possible to satisfy, read the documentation about [caching](https://docs."
"rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching)."
msgstr ""
"在呼叫任何可能產生日誌的 Rust 函式之前，務必先初始化 Python 的 logger。若無法"
"滿足此限制，仍可用替代方式處理，請閱讀[快取](https://docs.rs/pyo3-log/*/"
"pyo3_log/#performance-filtering-and-caching)相關文件。"

#: src/ecosystem/logging.md:58
msgid "The Python to Rust direction"
msgstr "Python 到 Rust 的方向"

#: src/ecosystem/logging.md:60
msgid ""
"To best of our knowledge nobody implemented the reverse direction yet, "
"though it should be possible. If interested, the `pyo3` community would be "
"happy to provide guidance."
msgstr ""

#: src/ecosystem/async-await.md:3
msgid ""
"If you are working with a Python library that makes use of async functions "
"or wish to provide Python bindings for an async Rust library, [`pyo3-"
"asyncio`](https://github.com/awestlake87/pyo3-asyncio) likely has the tools "
"you need. It provides conversions between async functions in both Python and "
"Rust and was designed with first-class support for popular Rust runtimes "
"such as [`tokio`](https://tokio.rs/) and [`async-std`](https://async.rs/). "
"In addition, all async Python code runs on the default `asyncio` event loop, "
"so `pyo3-asyncio` should work just fine with existing Python libraries."
msgstr ""

#: src/ecosystem/async-await.md:11
msgid ""
"In the following sections, we'll give a general overview of `pyo3-asyncio` "
"explaining how to call async Python functions with PyO3, how to call async "
"Rust functions from Python, and how to configure your codebase to manage the "
"runtimes of both."
msgstr ""

#: src/ecosystem/async-await.md:15
msgid "Quickstart"
msgstr ""

#: src/ecosystem/async-await.md:17
msgid ""
"Here are some examples to get you started right away! A more detailed "
"breakdown of the concepts in these examples can be found in the following "
"sections."
msgstr ""

#: src/ecosystem/async-await.md:20
msgid "Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:21
msgid ""
"Here we initialize the runtime, import Python's `asyncio` library and run "
"the given future to completion using Python's default `EventLoop` and `async-"
"std`. Inside the future, we convert `asyncio` sleep into a Rust future and "
"await it."
msgstr ""

#: src/ecosystem/async-await.md:24
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"async-std-"
"runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:33 src/ecosystem/async-await.md:63
#: src/ecosystem/async-await.md:522
msgid "//! main.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:40 src/ecosystem/async-await.md:70
#: src/ecosystem/async-await.md:383
msgid "\"asyncio\""
msgstr ""

#: src/ecosystem/async-await.md:41 src/ecosystem/async-await.md:71
#: src/ecosystem/async-await.md:385
msgid "// convert asyncio.sleep into a Rust Future\n"
msgstr ""

#: src/ecosystem/async-await.md:42 src/ecosystem/async-await.md:72
#: src/ecosystem/async-await.md:387
msgid "\"sleep\""
msgstr ""

#: src/ecosystem/async-await.md:51
msgid ""
"The same application can be written to use `tokio` instead using the "
"`#[pyo3_asyncio::tokio::main]` attribute."
msgstr ""

#: src/ecosystem/async-await.md:54
msgid ""
"```toml\n"
"# Cargo.toml dependencies\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\" }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"tokio-"
"runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:81
msgid ""
"More details on the usage of this library can be found in the [API docs]"
"(https://awestlake87.github.io/pyo3-asyncio/master/doc) and the primer below."
msgstr ""

#: src/ecosystem/async-await.md:83
msgid "PyO3 Native Rust Modules"
msgstr ""

#: src/ecosystem/async-await.md:85
msgid ""
"PyO3 Asyncio can also be used to write native modules with async functions."
msgstr ""

#: src/ecosystem/async-await.md:87
msgid ""
"Add the `[lib]` section to `Cargo.toml` to make your library a `cdylib` that "
"Python can import."
msgstr ""

#: src/ecosystem/async-await.md:88
msgid ""
"```toml\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:94
msgid ""
"Make your project depend on `pyo3` with the `extension-module` feature "
"enabled and select your `pyo3-asyncio` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:97
msgid "For `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:98
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"async-std = \"1.9\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:105
msgid "For `tokio`:"
msgstr ""

#: src/ecosystem/async-await.md:106
msgid ""
"```toml\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:113
msgid "Export an async function that makes use of `async-std`:"
msgstr ""

#: src/ecosystem/async-await.md:116 src/ecosystem/async-await.md:140
#: src/ecosystem/async-await.md:464
msgid "//! lib.rs\n"
msgstr ""

#: src/ecosystem/async-await.md:137
msgid ""
"If you want to use `tokio` instead, here's what your module should look like:"
msgstr ""

#: src/ecosystem/async-await.md:159
msgid ""
"You can build your module with maturin (see the [Using Rust in Python]"
"(https://pyo3.rs/main/#using-rust-from-python) section in the PyO3 guide for "
"setup instructions). After that you should be able to run the Python REPL to "
"try it out."
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"help\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"copyright\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"credits\""
msgstr ""

#: src/ecosystem/async-await.md:168 src/ecosystem/async-await.md:491
msgid "\"license\""
msgstr ""

#: src/ecosystem/async-await.md:181
msgid "Awaiting an Async Python Function in Rust"
msgstr ""

#: src/ecosystem/async-await.md:183
msgid "Let's take a look at a dead simple async Python function:"
msgstr ""

#: src/ecosystem/async-await.md:186
msgid "# Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:191
msgid ""
"**Async functions in Python are simply functions that return a `coroutine` "
"object**. For our purposes, we really don't need to know much about these "
"`coroutine` objects. The key factor here is that calling an `async` function "
"is _just like calling a regular function_, the only difference is that we "
"have to do something special with the object that it returns."
msgstr ""

#: src/ecosystem/async-await.md:196
msgid ""
"Normally in Python, that something special is the `await` keyword, but in "
"order to await this coroutine in Rust, we first need to convert it into "
"Rust's version of a `coroutine`: a `Future`. That's where `pyo3-asyncio` "
"comes in. [`pyo3_asyncio::into_future`](https://docs.rs/pyo3-asyncio/latest/"
"pyo3_asyncio/fn.into_future.html) performs this conversion for us."
msgstr ""

#: src/ecosystem/async-await.md:202
msgid ""
"The following example uses `into_future` to call the `py_sleep` function "
"shown above and then await the coroutine object returned from the call:"
msgstr ""

#: src/ecosystem/async-await.md:211
msgid "// import the module containing the py_sleep function\n"
msgstr ""

#: src/ecosystem/async-await.md:214
msgid ""
"// calling the py_sleep method like a normal function\n"
"        // returns a coroutine\n"
msgstr ""

#: src/ecosystem/async-await.md:216
msgid "\"py_sleep\""
msgstr ""

#: src/ecosystem/async-await.md:218
msgid ""
"// convert the coroutine into a Rust future using the\n"
"        // tokio runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:223 src/ecosystem/async-await.md:241
#: src/ecosystem/async-await.md:272
msgid "// await the future\n"
msgstr ""

#: src/ecosystem/async-await.md:230
msgid ""
"Alternatively, the below example shows how to write a `#[pyfunction]` which "
"uses `into_future` to receive and await a coroutine argument:"
msgstr ""

#: src/ecosystem/async-await.md:236 src/ecosystem/async-await.md:267
msgid ""
"// convert the coroutine into a Rust future using the\n"
"    // async_std runtime\n"
msgstr ""

#: src/ecosystem/async-await.md:248
msgid "This could be called from Python as:"
msgstr ""

#: src/ecosystem/async-await.md:259
msgid ""
"If for you wanted to pass a callable function to the `#[pyfunction]` "
"instead, (i.e. the last line becomes `await_coro(py_sleep))`, then the above "
"example needs to be tweaked to first call the callable to get the coroutine:"
msgstr ""

#: src/ecosystem/async-await.md:264
msgid "// get the coroutine by calling the callable\n"
msgstr ""

#: src/ecosystem/async-await.md:279
msgid ""
"This can be particularly helpful where you need to repeatedly create and "
"await a coroutine. Trying to await the same coroutine multiple times will "
"raise an error:"
msgstr ""

#: src/ecosystem/async-await.md:285
msgid ""
"If you're interested in learning more about `coroutines` and `awaitables` in "
"general, check out the [Python 3 `asyncio` docs](https://docs.python.org/3/"
"library/asyncio-task.html) for more information."
msgstr ""

#: src/ecosystem/async-await.md:288
msgid "Awaiting a Rust Future in Python"
msgstr ""

#: src/ecosystem/async-await.md:290
msgid ""
"Here we have the same async function as before written in Rust using the "
"[`async-std`](https://async.rs/) runtime:"
msgstr ""

#: src/ecosystem/async-await.md:294
msgid "/// Sleep for 1 second\n"
msgstr ""

#: src/ecosystem/async-await.md:300
msgid ""
"Similar to Python, Rust's async functions also return a special object "
"called a `Future`:"
msgstr ""

#: src/ecosystem/async-await.md:307
msgid ""
"We can convert this `Future` object into Python to make it `awaitable`. This "
"tells Python that you can use the `await` keyword with it. In order to do "
"this, we'll call [`pyo3_asyncio::async_std::future_into_py`](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html):"
msgstr ""

#: src/ecosystem/async-await.md:327
msgid ""
"In Python, we can call this pyo3 function just like any other async function:"
msgstr ""

#: src/ecosystem/async-await.md:336
msgid "Managing Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:338
msgid ""
"Python's event loop requires some special treatment, especially regarding "
"the main thread. Some of Python's `asyncio` features, like proper signal "
"handling, require control over the main thread, which doesn't always play "
"well with Rust."
msgstr ""

#: src/ecosystem/async-await.md:342
msgid ""
"Luckily, Rust's event loops are pretty flexible and don't _need_ control "
"over the main thread, so in `pyo3-asyncio`, we decided the best way to "
"handle Rust/Python interop was to just surrender the main thread to Python "
"and run Rust's event loops in the background. Unfortunately, since most "
"event loop implementations _prefer_ control over the main thread, this can "
"still make some things awkward."
msgstr ""

#: src/ecosystem/async-await.md:347
msgid "PyO3 Asyncio Initialization"
msgstr ""

#: src/ecosystem/async-await.md:349
msgid ""
"Because Python needs to control the main thread, we can't use the convenient "
"proc macros from Rust runtimes to handle the `main` function or `#[test]` "
"functions. Instead, the initialization for PyO3 has to be done from the "
"`main` function and the main thread must block on [`pyo3_asyncio::"
"run_forever`](https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn."
"run_forever.html) or [`pyo3_asyncio::async_std::run_until_complete`](https://"
"docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete."
"html)."
msgstr ""

#: src/ecosystem/async-await.md:353
msgid ""
"Because we have to block on one of those functions, we can't use "
"[`#[async_std::main]`](https://docs.rs/async-std/latest/async_std/attr.main."
"html) or [`#[tokio::main]`](https://docs.rs/tokio/1.1.0/tokio/attr.main."
"html) since it's not a good idea to make long blocking calls during an async "
"function."
msgstr ""

#: src/ecosystem/async-await.md:356
msgid ""
"Internally, these `#[main]` proc macros are expanded to something like this:"
msgstr ""

#: src/ecosystem/async-await.md:359
msgid "// your async main fn\n"
msgstr ""

#: src/ecosystem/async-await.md:364
msgid ""
"Making a long blocking call inside the `Future` that's being driven by "
"`block_on` prevents that thread from doing anything else and can spell "
"trouble for some runtimes (also this will actually deadlock a single-"
"threaded runtime!). Many runtimes have some sort of `spawn_blocking` "
"mechanism that can avoid this problem, but again that's not something we can "
"use here since we need it to block on the _main_ thread."
msgstr ""

#: src/ecosystem/async-await.md:370
msgid ""
"For this reason, `pyo3-asyncio` provides its own set of proc macros to "
"provide you with this initialization. These macros are intended to mirror "
"the initialization of `async-std` and `tokio` while also satisfying the "
"Python runtime's needs."
msgstr ""

#: src/ecosystem/async-await.md:374
msgid ""
"Here's a full example of PyO3 initialization with the `async-std` runtime:"
msgstr ""

#: src/ecosystem/async-await.md:380
msgid "// PyO3 is initialized - Ready to go\n"
msgstr ""

#: src/ecosystem/async-await.md:397
msgid "A Note About `asyncio.run`"
msgstr ""

#: src/ecosystem/async-await.md:399
msgid ""
"In Python 3.7+, the recommended way to run a top-level coroutine with "
"`asyncio` is with `asyncio.run`. In `v0.13` we recommended against using "
"this function due to initialization issues, but in `v0.14` it's perfectly "
"valid to use this function... with a caveat."
msgstr ""

#: src/ecosystem/async-await.md:402
msgid ""
"Since our Rust \\<\\--> Python conversions require a reference to the Python "
"event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that "
"defines a `rust_sleep` function like in previous examples. You might "
"rightfully assume that you can call pass this directly into `asyncio.run` "
"like this:"
msgstr ""

#: src/ecosystem/async-await.md:413
msgid "You might be surprised to find out that this throws an error:"
msgstr ""

#: src/ecosystem/async-await.md:416
msgid "\"example.py\""
msgstr ""

#: src/ecosystem/async-await.md:421
msgid ""
"What's happening here is that we are calling `rust_sleep` _before_ the "
"future is actually running on the event loop created by `asyncio.run`. This "
"is counter-intuitive, but expected behaviour, and unfortunately there "
"doesn't seem to be a good way of solving this problem within PyO3 Asyncio "
"itself."
msgstr ""

#: src/ecosystem/async-await.md:424
msgid "However, we can make this example work with a simple workaround:"
msgstr ""

#: src/ecosystem/async-await.md:430
msgid ""
"# Calling main will just construct the coroutine that later calls "
"rust_sleep.\n"
"# - This ensures that rust_sleep will be called when the event loop is "
"running,\n"
"#   not before.\n"
msgstr ""

#: src/ecosystem/async-await.md:436
msgid "# Run the main() coroutine at the top-level instead\n"
msgstr ""

#: src/ecosystem/async-await.md:441
msgid "Non-standard Python Event Loops"
msgstr ""

#: src/ecosystem/async-await.md:443
msgid ""
"Python allows you to use alternatives to the default `asyncio` event loop. "
"One popular alternative is `uvloop`. In `v0.13` using non-standard event "
"loops was a bit of an ordeal, but in `v0.14` it's trivial."
msgstr ""

#: src/ecosystem/async-await.md:447
msgid "Using `uvloop` in a PyO3 Asyncio Native Extensions"
msgstr ""

#: src/ecosystem/async-await.md:449
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[lib]\n"
"name = \"my_async_module\"\n"
"crate-type = [\"cdylib\"]\n"
"\n"
"[dependencies]\n"
"pyo3 = { version = \"0.14\", features = [\"extension-module\"] }\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\n"
"async-std = \"1.9\"\n"
"tokio = \"1.4\"\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:506
msgid "Using `uvloop` in Rust Applications"
msgstr ""

#: src/ecosystem/async-await.md:508
msgid ""
"Using `uvloop` in Rust applications is a bit trickier, but it's still "
"possible with relatively few modifications."
msgstr ""

#: src/ecosystem/async-await.md:511
msgid ""
"Unfortunately, we can't make use of the `#[pyo3_asyncio::<runtime>::main]` "
"attribute with non-standard event loops. This is because the "
"`#[pyo3_asyncio::<runtime>::main]` proc macro has to interact with the "
"Python event loop before we can install the `uvloop` policy."
msgstr ""

#: src/ecosystem/async-await.md:514
msgid ""
"```toml\n"
"[dependencies]\n"
"async-std = \"1.9\"\n"
"pyo3 = \"0.14\"\n"
"pyo3-asyncio = { version = \"0.14\", features = [\"async-std-runtime\"] }\n"
"```"
msgstr ""

#: src/ecosystem/async-await.md:530
msgid "\"uvloop\""
msgstr ""

#: src/ecosystem/async-await.md:531
msgid "\"install\""
msgstr ""

#: src/ecosystem/async-await.md:533
msgid "// store a reference for the assertion\n"
msgstr ""

#: src/ecosystem/async-await.md:537
msgid "// verify that we are on a uvloop.Loop\n"
msgstr ""

#: src/ecosystem/async-await.md:542
msgid "\"Loop\""
msgstr ""

#: src/ecosystem/async-await.md:557
msgid "Additional Information"
msgstr "補充資訊"

#: src/ecosystem/async-await.md:558
msgid ""
"Managing event loop references can be tricky with pyo3-asyncio. See [Event "
"Loop References](https://docs.rs/pyo3-asyncio/#event-loop-references) in the "
"API docs to get a better intuition for how event loop references are managed "
"in this library."
msgstr ""

#: src/ecosystem/async-await.md:559
msgid ""
"Testing pyo3-asyncio libraries and applications requires a custom test "
"harness since Python requires control over the main thread. You can find a "
"testing guide in the [API docs for the `testing` module](https://docs.rs/"
"pyo3-asyncio/latest/pyo3_asyncio/testing)"
msgstr ""
