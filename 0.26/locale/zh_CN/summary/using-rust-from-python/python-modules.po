msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:34:06Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/module.md:1
msgid "Python modules"
msgstr ""

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr ""

#: src/module.md:12
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:20
msgid ""
"The `#[pymodule]` procedural macro takes care of exporting the "
"initialization function of your module to Python."
msgstr ""

#: src/module.md:23
msgid ""
"The module's name defaults to the name of the Rust function. You can "
"override the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:34
msgid "\"custom_name\""
msgstr ""

#: src/module.md:40
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:44
msgid "To import the module, either:"
msgstr ""

#: src/module.md:45
msgid ""
"copy the shared library as described in [Manual builds](building-and-"
"distribution.md#manual-builds), or"
msgstr ""

#: src/module.md:46
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:49
msgid "Documentation"
msgstr ""

#: src/module.md:51
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the module initialization function will be applied "
"automatically as the Python docstring of your module."
msgstr ""

#: src/module.md:54
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:62
msgid "Python submodules"
msgstr ""

#: src/module.md:64
msgid ""
"You can create a module hierarchy within a single extension module by using "
"[`Bound<'_, PyModule>::add_submodule()`](https://pyo3.rs/main/doc/pyo3/"
"prelude/trait.PyModuleMethods.html#tymethod.add_submodule). For example, you "
"could define the modules `parent_module` and `parent_module.child_module`."
msgstr ""

#: src/module.md:78
msgid "\"child_module\""
msgstr ""

#: src/module.md:85
msgid "\"func\""
msgstr ""

#: src/module.md:93
msgid "\"parent_module\""
msgstr ""

#: src/module.md:95
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:99
msgid ""
"Note that this does not define a package, so this wonâ€™t allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:104
msgid ""
"It is not necessary to add `#[pymodule]` on nested modules, which is only "
"required on the top-level module."
msgstr ""

#: src/module.md:106
msgid "Declarative modules"
msgstr ""

#: src/module.md:108
msgid ""
"Another syntax based on Rust inline modules is also available to declare "
"modules."
msgstr ""

#: src/module.md:110
msgid "For example:"
msgstr ""

#: src/module.md:125
msgid "// Exports the double function as part of the module\n"
msgstr ""

#: src/module.md:128
msgid "// Exports PI constant as part of the module\n"
msgstr ""

#: src/module.md:130 src/module.md:135 src/module.md:176
msgid "// This will be part of the module\n"
msgstr ""

#: src/module.md:140 src/module.md:174
msgid "// This is a submodule\n"
msgstr ""

#: src/module.md:145
msgid "// Arbitrary code to run at the module initialization\n"
msgstr ""

#: src/module.md:146
msgid "\"double2\""
msgstr ""

#: src/module.md:146
msgid "\"double\""
msgstr ""

#: src/module.md:152
msgid ""
"The `#[pymodule]` macro automatically sets the `module` attribute of the "
"`#[pyclass]` macros declared inside of it with its name. For nested modules, "
"the name of the parent module is automatically added. In the following "
"example, the `Unit` class will have for `module` `my_extension.submodule` "
"because it is properly nested but the `Ext` class will have for `module` the "
"default `builtins` because it not nested."
msgstr ""

#: src/module.md:182
msgid ""
"It is possible to customize the `module` value for a `#[pymodule]` with the "
"`#[pyo3(module = \"MY_MODULE\")]` option."
msgstr ""

#: src/module.md:184
msgid ""
"You can provide the `submodule` argument to `pymodule()` for modules that "
"are not top-level modules -- it is automatically set for modules nested "
"inside of a `#[pymodule]`."
msgstr ""
