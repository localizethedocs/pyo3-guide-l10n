msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:17Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/module.md:1
msgid "Python modules"
msgstr ""

#: src/module.md:3
msgid "You can create a module using `#[pymodule]`:"
msgstr ""

#: src/module.md:13
msgid "/// This module is implemented in Rust.\n"
msgstr ""

#: src/module.md:20
msgid ""
"// The double function is made available from Python, works also with "
"classes\n"
msgstr ""

#: src/module.md:22
msgid "// Inline definition of a pyfunction, also made availlable to Python\n"
msgstr ""

#: src/module.md:30
msgid ""
"The `#[pymodule]` procedural macro takes care of creating the initialization "
"function of your module and exposing it to Python."
msgstr ""

#: src/module.md:33
msgid ""
"The module's name defaults to the name of the Rust module. You can override "
"the module name by using `#[pyo3(name = \"custom_name\")]`:"
msgstr ""

#: src/module.md:45
msgid "\"custom_name\""
msgstr ""

#: src/module.md:53
msgid ""
"The name of the module must match the name of the `.so` or `.pyd` file. "
"Otherwise, you will get an import error in Python with the following "
"message: `ImportError: dynamic module does not define module export function "
"(PyInit_name_of_your_module)`"
msgstr ""

#: src/module.md:57
msgid "To import the module, either:"
msgstr ""

#: src/module.md:59
msgid ""
"copy the shared library as described in [Manual builds](building-and-"
"distribution.md#manual-builds), or"
msgstr ""

#: src/module.md:60
msgid ""
"use a tool, e.g. `maturin develop` with [maturin](https://github.com/PyO3/"
"maturin) or `python setup.py develop` with [setuptools-rust](https://github."
"com/PyO3/setuptools-rust)."
msgstr ""

#: src/module.md:63
msgid "Documentation"
msgstr ""

#: src/module.md:65
msgid ""
"The [Rust doc comments](https://doc.rust-lang.org/stable/book/ch03-04-"
"comments.html) of the Rust module will be applied automatically as the "
"Python docstring of your module."
msgstr ""

#: src/module.md:67
msgid ""
"For example, building off of the above code, this will print `This module is "
"implemented in Rust.`:"
msgstr ""

#: src/module.md:75
msgid "Python submodules"
msgstr ""

#: src/module.md:77
msgid ""
"You can create a module hierarchy within a single extension module by just "
"`use`ing modules like functions or classes. For example, you could define "
"the modules `parent_module` and `parent_module.child_module`:"
msgstr ""

#: src/module.md:97
msgid "\"func\""
msgstr ""

#: src/module.md:106
msgid "\"parent_module\""
msgstr ""

#: src/module.md:108
msgid "\"assert parent_module.child_module.func() == 'func'\""
msgstr ""

#: src/module.md:113
msgid ""
"Note that this does not define a package, so this wonâ€™t allow Python code to "
"directly import submodules by using `from parent_module import "
"child_module`. For more information, see [\\#759](https://github.com/PyO3/"
"pyo3/issues/759) and [\\#1517](https://github.com/PyO3/pyo3/"
"issues/1517#issuecomment-808664021)."
msgstr ""

#: src/module.md:118
msgid ""
"You can provide the `submodule` argument to `#[pymodule()]` for modules that "
"are not top-level modules in order for them to properly generate the "
"`#[pyclass]` `module` attribute automatically."
msgstr ""

#: src/module.md:120
msgid "Inline declaration"
msgstr ""

#: src/module.md:122
msgid ""
"It is possible to declare functions, classes, sub-modules and constants "
"inline in a module:"
msgstr ""

#: src/module.md:124
msgid "For example:"
msgstr ""

#: src/module.md:133
msgid "// Exports PI constant as part of the module\n"
msgstr ""

#: src/module.md:135 src/module.md:140
msgid "// This will be part of the module\n"
msgstr ""

#: src/module.md:145
msgid "// This is a submodule\n"
msgstr ""

#: src/module.md:155
msgid ""
"In this case, `#[pymodule]` macro automatically sets the `module` attribute "
"of the `#[pyclass]` macros declared inside of it with its name. For nested "
"modules, the name of the parent module is automatically added. In the "
"previous example, the `Nested` class will have for `module` `my_extension."
"submodule`."
msgstr ""

#: src/module.md:159
msgid "Procedural initialization"
msgstr ""

#: src/module.md:161
msgid ""
"If the macros provided by PyO3 are not enough, it is possible to run code at "
"the module initialization:"
msgstr ""

#: src/module.md:176
msgid "// Arbitrary code to run at the module initialization\n"
msgstr ""

#: src/module.md:177
msgid "\"double2\""
msgstr ""

#: src/module.md:177
msgid "\"double\""
msgstr ""
