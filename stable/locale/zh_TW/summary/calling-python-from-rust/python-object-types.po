msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:17Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/types.md:1
msgid "Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"PyO3 offers two main sets of types to interact with Python objects. This "
"section of the guide expands into detail about these types and how to choose "
"which to use."
msgstr ""

#: src/types.md:5
msgid ""
"The first set of types are the [smart pointers](https://doc.rust-lang.org/"
"book/ch15-00-smart-pointers.html) which all Python objects are wrapped in. "
"These are `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`. The [first "
"section below](#pyo3s-smart-pointers) expands on each of these in detail and "
"why there are three of them."
msgstr ""

#: src/types.md:7
msgid ""
"The second set of types are types which fill in the generic parameter `T` of "
"the smart pointers. The most common is `PyAny`, which represents any Python "
"object (similar to Python's `typing.Any`). There are also concrete types for "
"many Python built-in types, such as `PyList`, `PyDict`, and `PyTuple`. User "
"defined `#[pyclass]` types also fit this category. The [second section below]"
"(#concrete-python-types) expands on how to use these types."
msgstr ""

#: src/types.md:9
msgid "PyO3's smart pointers"
msgstr ""

#: src/types.md:11
msgid ""
"PyO3's API offers three generic smart pointers: `Py<T>`, `Bound<'py, T>` and "
"`Borrowed<'a, 'py, T>`. For each of these the type parameter `T` will be "
"filled by a [concrete Python type](#concrete-python-types). For example, a "
"Python list object can be represented by `Py<PyList>`, `Bound<'py, PyList>`, "
"and `Borrowed<'a, 'py, PyList>`."
msgstr ""

#: src/types.md:13
msgid ""
"These smart pointers behave differently due to their lifetime parameters. "
"`Py<T>` has no lifetime parameters, `Bound<'py, T>` has [the `'py` lifetime]"
"(./python-from-rust.md#the-py-lifetime) as a parameter, and `Borrowed<'a, "
"'py, T>` has the `'py` lifetime plus an additional lifetime `'a` to denote "
"the lifetime it is borrowing data for. (You can read more about these "
"lifetimes in the subsections below)."
msgstr ""

#: src/types.md:15
msgid ""
"Python objects are reference counted, like [`std::sync::Arc`](https://doc."
"rust-lang.org/stable/std/sync/struct.Arc.html). A major reason for these "
"smart pointers is to bring Python's reference counting to a Rust API."
msgstr ""

#: src/types.md:17
msgid ""
"The recommendation of when to use each of these smart pointers is as follows:"
msgstr ""

#: src/types.md:19
msgid ""
"Use `Bound<'py, T>` for as much as possible, as it offers the most efficient "
"and complete API."
msgstr ""

#: src/types.md:20
msgid ""
"Use `Py<T>` mostly just for storage inside Rust `struct`s which do not want "
"to or can't add a lifetime parameter for `Bound<'py, T>`."
msgstr ""

#: src/types.md:21
msgid ""
"`Borrowed<'a, 'py, T>` is almost never used. It is occasionally present at "
"the boundary between Rust and the Python interpreter, for example when "
"borrowing data from Python tuples (which is safe because they are immutable)."
msgstr ""

#: src/types.md:23
msgid ""
"The sections below also explain these smart pointers in a little more detail."
msgstr ""

#: src/types.md:25
msgid "`Py<T>`"
msgstr ""

#: src/types.md:27
msgid ""
"[`Py<T>`](https://pyo3.rs/main/doc/pyo3/struct.Py.html) is the foundational "
"smart pointer in PyO3's API. The type parameter `T` denotes the type of the "
"Python object. Very frequently this is `PyAny`, meaning any Python object."
msgstr ""

#: src/types.md:29
msgid ""
"Because `Py<T>` is not bound to [the `'py` lifetime](./python-from-rust."
"md#the-py-lifetime), it is the type to use when storing a Python object "
"inside a Rust `struct` or `enum` which do not want to have a lifetime "
"parameter. In particular, [`#[pyclass]`](class.md) types are not permitted "
"to have a lifetime, so `Py<T>` is the correct type to store Python objects "
"inside them."
msgstr ""

#: src/types.md:31
msgid "The lack of binding to the `'py` lifetime also carries drawbacks:"
msgstr ""

#: src/types.md:33
msgid ""
"Almost all methods on `Py<T>` require a `Python<'py>` token as the first "
"argument"
msgstr ""

#: src/types.md:34
msgid ""
"Other functionality, such as [`Drop`](https://doc.rust-lang.org/std/ops/"
"trait.Drop.html), needs to check at runtime for attachment to the Python "
"interpreter, at a small performance cost"
msgstr ""

#: src/types.md:36
msgid ""
"Because of the drawbacks `Bound<'py, T>` is preferred for many of PyO3's "
"APIs. In particular, `Bound<'py, T>` is better for function arguments."
msgstr ""

#: src/types.md:38
msgid ""
"To convert a `Py<T>` into a `Bound<'py, T>`, the `Py::bind` and `Py::"
"into_bound` methods are available. `Bound<'py, T>` can be converted back "
"into `Py<T>` using [`Bound::unbind`](https://pyo3.rs/main/doc/pyo3/struct."
"Bound.html#method.unbind)."
msgstr ""

#: src/types.md:40
msgid "`Bound<'py, T>`"
msgstr ""

#: src/types.md:42
msgid ""
"[`Bound<'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html) is the "
"counterpart to `Py<T>` which is also bound to the `'py` lifetime. It can be "
"thought of as equivalent to the Rust tuple `(Python<'py>, Py<T>)`."
msgstr ""

#: src/types.md:44
msgid ""
"By having the binding to the `'py` lifetime, `Bound<'py, T>` can offer the "
"complete PyO3 API at maximum efficiency. This means that `Bound<'py, T>` "
"should usually be used whenever carrying this lifetime is acceptable, and "
"`Py<T>` otherwise."
msgstr ""

#: src/types.md:46
msgid ""
"`Bound<'py, T>` engages in Python reference counting. This means that "
"`Bound<'py, T>` owns a Python object. Rust code which just wants to borrow a "
"Python object should use a shared reference `&Bound<'py, T>`. Just like "
"`std::sync::Arc`, using `.clone()` and `drop()` will cheaply increment and "
"decrement the reference count of the object (just in this case, the "
"reference counting is implemented by the Python interpreter itself)."
msgstr ""

#: src/types.md:48
msgid ""
"To give an example of how `Bound<'py, T>` is PyO3's primary API type, "
"consider the following Python code:"
msgstr ""

#: src/types.md:52
msgid "# create a Python list\n"
msgstr ""

#: src/types.md:53
msgid "# append the integer 1 to it\n"
msgstr ""

#: src/types.md:54
msgid "# create a second reference to the list\n"
msgstr ""

#: src/types.md:55
msgid "# delete the original reference\n"
msgstr ""

#: src/types.md:58
msgid ""
"Using PyO3's API, and in particular `Bound<'py, PyList>`, this code "
"translates into the following Rust code:"
msgstr ""

#: src/types.md:67
msgid "// y is a new reference to the same list\n"
msgstr ""

#: src/types.md:68
msgid "// release the original reference x\n"
msgstr ""

#: src/types.md:74
msgid "Or, without the type annotations:"
msgstr ""

#: src/types.md:90
msgid "Function argument lifetimes"
msgstr ""

#: src/types.md:92
msgid ""
"Because the `'py` lifetime often appears in many function arguments as part "
"of the `Bound<'py, T>` smart pointer, the Rust compiler will often require "
"annotations of input and output lifetimes. This occurs when the function "
"output has at least one lifetime, and there is more than one lifetime "
"present on the inputs."
msgstr ""

#: src/types.md:94
msgid ""
"To demonstrate, consider this function which takes accepts Python objects "
"and applies the [Python `+` operation](https://pyo3.rs/main/doc/pyo3/types/"
"trait.PyAnyMethods.html#tymethod.add) to them:"
msgstr ""

#: src/types.md:103
msgid ""
"Because the Python `+` operation might raise an exception, this function "
"returns `PyResult<Bound<'_, PyAny>>`. It doesn't need ownership of the "
"inputs, so it takes `&Bound<'_, PyAny>` shared references. To demonstrate "
"the point, all lifetimes have used the wildcard `'_` to allow the Rust "
"compiler to attempt to infer them. Because there are four input lifetimes "
"(two lifetimes of the shared references, and two `'py` lifetimes unnamed "
"inside the `Bound<'_, PyAny>` pointers), the compiler cannot reason about "
"which must be connected to the output."
msgstr ""

#: src/types.md:105
msgid ""
"The correct way to solve this is to add the `'py` lifetime as a parameter "
"for the function, and name all the `'py` lifetimes inside the `Bound<'py, "
"PyAny>` smart pointers. For the shared references, it's also fine to reduce "
"`&'_` to just `&`. The working end result is below:"
msgstr ""

#: src/types.md:116 src/types.md:130
msgid "\"s\""
msgstr ""

#: src/types.md:117 src/types.md:131
msgid "\"ss\""
msgstr ""

#: src/types.md:121
msgid ""
"If naming the `'py` lifetime adds unwanted complexity to the function "
"signature, it is also acceptable to return `Py<PyAny>`, which has no "
"lifetime. The cost is instead paid by a slight increase in implementation "
"complexity, as seen by the introduction of a call to [`Bound::unbind`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Bound.html#method.unbind):"
msgstr ""

#: src/types.md:135
msgid "`Borrowed<'a, 'py, T>`"
msgstr ""

#: src/types.md:137
msgid ""
"[`Borrowed<'a, 'py, T>`](https://pyo3.rs/main/doc/pyo3/struct.Borrowed.html) "
"is an advanced type used just occasionally at the edge of interaction with "
"the Python interpreter. It can be thought of as analogous to the shared "
"reference `&'a Bound<'py, T>`. The difference is that `Borrowed<'a, 'py, T>` "
"is just a smart pointer rather than a reference-to-a-smart-pointer, which is "
"a helpful reduction in indirection in specific interactions with the Python "
"interpreter."
msgstr ""

#: src/types.md:139
msgid ""
"`Borrowed<'a, 'py, T>` dereferences to `Bound<'py, T>`, so all methods on "
"`Bound<'py, T>` are available on `Borrowed<'a, 'py, T>`."
msgstr ""

#: src/types.md:141
msgid ""
"An example where `Borrowed<'a, 'py, T>` is used is in [`PyTupleMethods::"
"get_borrowed_item`](https://pyo3.rs/main/doc/pyo3/types/trait.PyTupleMethods."
"html#tymethod.get_item):"
msgstr ""

#: src/types.md:147
msgid "// Create a new tuple with the elements (0, 1, 2)\n"
msgstr ""

#: src/types.md:152
msgid ""
"// `PyAnyMethods::extract` is available on `Borrowed`\n"
"    // via the dereference to `Bound`\n"
msgstr ""

#: src/types.md:162
msgid "Casting between smart pointer types"
msgstr ""

#: src/types.md:164
msgid ""
"To convert between `Py<T>` and `Bound<'py, T>` use the `bind()` / "
"`into_bound()` methods. Use the `as_unbound()` / `unbind()` methods to go "
"back from `Bound<'py, T>` to `Py<T>`."
msgstr ""

#: src/types.md:175
msgid ""
"To convert between `Bound<'py, T>` and `Borrowed<'a, 'py, T>` use the "
"`as_borrowed()` method. `Borrowed<'a, 'py, T>` has a deref coercion to "
"`Bound<'py, T>`. Use the `to_owned()` method to increment the Python "
"reference count and to create a new `Bound<'py, T>` from the `Borrowed<'a, "
"'py, T>`."
msgstr ""

#: src/types.md:180
msgid "// deref coercion\n"
msgstr ""

#: src/types.md:183
msgid "// create a new Bound by increase the Python reference count\n"
msgstr ""

#: src/types.md:188
msgid ""
"To convert between `Py<T>` and `Borrowed<'a, 'py, T>` use the "
"`bind_borrowed()` method. Use either `as_unbound()` or `.to_owned()."
"unbind()` to go back to `Py<T>` from `Borrowed<'a, 'py, T>`, via `Bound<'py, "
"T>`."
msgstr ""

#: src/types.md:193
msgid "// via deref coercion to Bound and then using Bound::as_unbound\n"
msgstr ""

#: src/types.md:196
msgid ""
"// via a new Bound by increasing the Python reference count, and unbind it\n"
msgstr ""

#: src/types.md:201
msgid "Concrete Python types"
msgstr ""

#: src/types.md:203
msgid ""
"In all of `Py<T>`, `Bound<'py, T>`, and `Borrowed<'a, 'py, T>`, the type "
"parameter `T` denotes the type of the Python object referred to by the smart "
"pointer."
msgstr ""

#: src/types.md:205
msgid "This parameter `T` can be filled by:"
msgstr ""

#: src/types.md:207
msgid ""
"[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html), which "
"represents any Python object,"
msgstr ""

#: src/types.md:208
msgid "Native Python types such as `PyList`, `PyTuple`, and `PyDict`, and"
msgstr ""

#: src/types.md:209
msgid "[`#[pyclass]`](class.md) types defined from Rust"
msgstr ""

#: src/types.md:211
msgid ""
"The following subsections covers some further detail about how to work with "
"these types:"
msgstr ""

#: src/types.md:213
msgid "the APIs that are available for these concrete types,"
msgstr ""

#: src/types.md:214
msgid "how to cast `Bound<'py, T>` to a specific concrete type, and"
msgstr ""

#: src/types.md:215
msgid "how to get Rust data out of a `Bound<'py, T>`."
msgstr ""

#: src/types.md:217
msgid "Using APIs for concrete Python types"
msgstr ""

#: src/types.md:219
msgid ""
"Each concrete Python type such as `PyAny`, `PyTuple` and `PyDict` exposes "
"its API on the corresponding bound smart pointer `Bound<'py, PyAny>`, "
"`Bound<'py, PyTuple>` and `Bound<'py, PyDict>`."
msgstr ""

#: src/types.md:221
msgid ""
"Each type's API is exposed as a trait: [`PyAnyMethods`](https://pyo3.rs/main/"
"doc/pyo3/types/trait.PyAnyMethods.html), [`PyTupleMethods`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyTupleMethods.html), [`PyDictMethods`](https://"
"pyo3.rs/main/doc/pyo3/types/trait.PyDictMethods.html), and so on for all "
"concrete types. Using traits rather than associated methods on the `Bound` "
"smart pointer is done for a couple of reasons:"
msgstr ""

#: src/types.md:223
msgid ""
"Clarity of documentation: each trait gets its own documentation page in the "
"PyO3 API docs. If all methods were on the `Bound` smart pointer directly, "
"the vast majority of PyO3's API would be on a single, extremely long, "
"documentation page."
msgstr ""

#: src/types.md:224
msgid ""
"Consistency: downstream code implementing Rust APIs for existing Python "
"types can also follow this pattern of using a trait. Downstream code would "
"not be allowed to add new associated methods directly on the `Bound` type."
msgstr ""

#: src/types.md:225
msgid ""
"Future design: it is hoped that a future Rust with [arbitrary self types]"
"(https://github.com/rust-lang/rust/issues/44874) will remove the need for "
"these traits in favour of placing the methods directly on `PyAny`, "
"`PyTuple`, `PyDict`, and so on."
msgstr ""

#: src/types.md:227
msgid ""
"These traits are all included in the `pyo3::prelude` module, so with the "
"glob import `use pyo3::prelude::*` the full PyO3 API is made available to "
"downstream code."
msgstr ""

#: src/types.md:229
msgid ""
"The following function accesses the first item in the input Python list, "
"using the `.get_item()` method from the `PyListMethods` trait:"
msgstr ""

#: src/types.md:239 src/types.md:240
msgid "\"hello world\""
msgstr ""

#: src/types.md:244
msgid "Casting between Python object types"
msgstr ""

#: src/types.md:246
msgid ""
"To cast `Bound<'py, T>` smart pointers to some other type, use the [`."
"cast()`](https://pyo3.rs/main/doc/pyo3/struct.Bound.html#method.cast) family "
"of functions. This converts `&Bound<'py, T>` to a different `&Bound<'py, "
"U>`, without transferring ownership. There is also [`.cast_into()`](https://"
"pyo3.rs/main/doc/pyo3/struct.Bound.html#method.cast_into) to convert "
"`Bound<'py, T>` to `Bound<'py, U>` with transfer of ownership. These methods "
"are available for all types `T` which implement the [`PyTypeCheck`](https://"
"pyo3.rs/main/doc/pyo3/type_object/trait.PyTypeCheck.html) trait."
msgstr ""

#: src/types.md:248
msgid ""
"Casting to `Bound<'py, PyAny>` can be done with `.as_any()` or `.into_any()`."
msgstr ""

#: src/types.md:250
msgid ""
"For example, the following snippet shows how to cast `Bound<'py, PyAny>` to "
"`Bound<'py, PyTuple>`:"
msgstr ""

#: src/types.md:255 src/types.md:277 src/types.md:300
msgid ""
"// create a new Python `tuple`, and use `.into_any()` to erase the type\n"
msgstr ""

#: src/types.md:258
msgid "// use `.cast()` to cast to `PyTuple` without transferring ownership\n"
msgstr ""

#: src/types.md:261
msgid "// use `.cast_into()` to cast to `PyTuple` with transfer of ownership\n"
msgstr ""

#: src/types.md:269
msgid ""
"Custom [`#[pyclass]`](class.md) types implement [`PyTypeCheck`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeCheck.html), so `.cast()` also "
"works for these types. The snippet below is the same as the snippet above "
"casting instead to a custom type `MyClass`:"
msgstr ""

#: src/types.md:280
msgid "// use `.cast()` to cast to `MyClass` without transferring ownership\n"
msgstr ""

#: src/types.md:283
msgid "// use `.cast_into()` to cast to `MyClass` with transfer of ownership\n"
msgstr ""

#: src/types.md:291
msgid "Extracting Rust data from Python objects"
msgstr ""

#: src/types.md:293
msgid ""
"To extract Rust data from Python objects, use [`.extract()`](https://pyo3.rs/"
"main/doc/pyo3/types/trait.PyAnyMethods.html#tymethod.extract) instead of `."
"cast()`. This method is available for all types which implement the "
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) trait."
msgstr ""

#: src/types.md:295
msgid ""
"For example, the following snippet extracts a Rust tuple of integers from a "
"Python tuple:"
msgstr ""

#: src/types.md:303
msgid "// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple\n"
msgstr ""

#: src/types.md:312
msgid ""
"To avoid copying data, [`#[pyclass]`](class.md) types can directly reference "
"Rust data stored within the Python objects without needing to `.extract()`. "
"See the [corresponding documentation in the class section of the guide](./"
"class.md#bound-and-interior-mutability) for more detail."
msgstr ""
