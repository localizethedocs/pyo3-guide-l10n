msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class/protocols.md:1
msgid "Magic methods and slots"
msgstr ""

#: src/class/protocols.md:3
msgid ""
"Python's object model defines several protocols for different object "
"behavior, such as the sequence, mapping, and number protocols. You may be "
"familiar with implementing these protocols in Python classes by \"magic\" "
"methods, such as `__str__` or `__repr__`. Because of the double-underscores "
"surrounding their name, these are also known as \"dunder\" methods."
msgstr ""

#: src/class/protocols.md:5
msgid ""
"In the Python C-API which PyO3 is implemented upon, many of these magic "
"methods have to be placed into special \"slots\" on the class type object, "
"as covered in the previous section. There are two ways in which this can be "
"done:"
msgstr ""

#: src/class/protocols.md:7
msgid ""
"\\[New in PyO3 0.15, recommended in PyO3 0.16\\] In `#[pymethods]`, if the "
"name of the method is a recognised magic method, PyO3 will place it in the "
"type object automatically."
msgstr ""

#: src/class/protocols.md:8
msgid ""
"\\[Deprecated in PyO3 0.16\\] In special traits combined with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class/protocols.md:10
msgid ""
"(There are also many magic methods which don't have a special slot, such as "
"`__dir__`. These methods can be implemented as normal in `#[pymethods]`.)"
msgstr ""

#: src/class/protocols.md:12
msgid ""
"If a function name in `#[pymethods]` is a recognised magic method, it will "
"be automatically placed into the correct slot in the Python type object. The "
"function name is taken from the usual rules for naming `#[pymethods]`: the "
"`#[pyo3(name = \"...\")]` attribute is used if present, otherwise the Rust "
"function name is used."
msgstr ""

#: src/class/protocols.md:14
msgid ""
"The magic methods handled by PyO3 are very similar to the standard Python "
"ones on [this page](https://docs.python.org/3/reference/datamodel."
"html#special-method-names) - in particular they are the the subset which "
"have slots as [defined here](https://docs.python.org/3/c-api/typeobj.html). "
"Some of the slots do not have a magic method in Python, which leads to a few "
"additional magic methods defined only in PyO3:"
msgstr ""

#: src/class/protocols.md:15
msgid "Magic methods for garbage collection"
msgstr ""

#: src/class/protocols.md:16
msgid "Magic methods for the buffer protocol"
msgstr ""

#: src/class/protocols.md:18
msgid ""
"When PyO3 handles a magic method, a couple of changes apply compared to "
"other `#[pymethods]`:"
msgstr ""

#: src/class/protocols.md:19
msgid "The `#[pyo3(text_signature = \"...\")]` attribute is not allowed"
msgstr ""

#: src/class/protocols.md:20
msgid "The signature is restricted to match the magic method"
msgstr ""

#: src/class/protocols.md:22
msgid ""
"The following sections list of all magic methods PyO3 currently handles.  "
"The given signatures should be interpreted as follows:"
msgstr ""

#: src/class/protocols.md:24
msgid ""
"All methods take a receiver as first argument, shown as `<self>`. It can be "
"`&self`, `&mut self` or a `PyCell` reference like `self_: PyRef<'_, Self>` "
"and `self_: PyRefMut<'_, Self>`, as described [here](../class."
"md#inheritance)."
msgstr ""

#: src/class/protocols.md:27
msgid ""
"An optional `Python<'py>` argument is always allowed as the first argument."
msgstr ""

#: src/class/protocols.md:28
msgid "Return values can be optionally wrapped in `PyResult`."
msgstr ""

#: src/class/protocols.md:29
msgid ""
"`object` means that any type is allowed that can be extracted from a Python "
"object (if argument) or converted to a Python object (if return value)."
msgstr ""

#: src/class/protocols.md:31
msgid ""
"Other types must match what's given, e.g. `pyo3::basic::CompareOp` for "
"`__richcmp__`'s second argument."
msgstr ""

#: src/class/protocols.md:33
msgid ""
"For the comparison and arithmetic methods, extraction errors are not "
"propagated as exceptions, but lead to a return of `NotImplemented`."
msgstr ""

#: src/class/protocols.md:35
msgid ""
"For some magic methods, the return values are not restricted by PyO3, but "
"checked by the Python interpreter. For example, `__str__` needs to return a "
"string object.  This is indicated by `object (Python type)`."
msgstr ""

#: src/class/protocols.md:40 src/class/protocols.md:411
msgid "Basic object customization"
msgstr ""

#: src/class/protocols.md:42
msgid "`__str__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:43
msgid "`__repr__(<self>) -> object (str)`"
msgstr ""

#: src/class/protocols.md:45
msgid "`__hash__(<self>) -> isize`"
msgstr ""

#: src/class/protocols.md:47
msgid "Objects that compare equal must have the same hash value."
msgstr ""

#: src/class/protocols.md:66
msgid "`__richcmp__(<self>, object, pyo3::basic::CompareOp) -> object`"
msgstr ""

#: src/class/protocols.md:68
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `CompareOp` argument indicates the comparison operation being "
"performed."
msgstr ""

#: src/class/protocols.md:77
msgid "`__getattr__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:78
msgid "`__getattribute__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:88
msgid "`__setattr__(<self>, value: object) -> ()`"
msgstr ""

#: src/class/protocols.md:89
msgid "`__delattr__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:91
msgid "Overrides attribute access."
msgstr ""

#: src/class/protocols.md:93
msgid "`__bool__(<self>) -> bool`"
msgstr ""

#: src/class/protocols.md:95
msgid "Determines the \"truthyness\" of an object."
msgstr ""

#: src/class/protocols.md:97
msgid ""
"`__call__(<self>, ...) -> object` - here, any argument list can be defined "
"as for normal `pymethods`"
msgstr ""

#: src/class/protocols.md:100
msgid "Iterable objects"
msgstr ""

#: src/class/protocols.md:102
msgid "Iterators can be defined using these methods:"
msgstr ""

#: src/class/protocols.md:104
msgid "`__iter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:105
msgid ""
"`__next__(<self>) -> Option<object> or IterNextOutput` ([see details]"
"(#returning-a-value-from-iteration))"
msgstr ""

#: src/class/protocols.md:107
msgid ""
"Returning `None` from `__next__` indicates that that there are no further "
"items."
msgstr ""

#: src/class/protocols.md:109 src/class/protocols.md:372
msgid "Example:"
msgstr ""

#: src/class/protocols.md:130
msgid ""
"In many cases you'll have a distinction between the type being iterated over "
"(i.e. the _iterable_) and the iterator it provides. In this case, the "
"iterable only needs to implement `__iter__()` while the iterator must "
"implement both `__iter__()` and `__next__()`. For example:"
msgstr ""

#: src/class/protocols.md:172
msgid "\"assert list(inst) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:173
msgid "\"assert list(iter(iter(inst))) == [1, 2, 3, 4]\""
msgstr ""

#: src/class/protocols.md:177
msgid ""
"For more details on Python's iteration protocols, check out [the \"Iterator "
"Types\" section of the library documentation](https://docs.python.org/"
"library/stdtypes.html#iterator-types)."
msgstr ""

#: src/class/protocols.md:180
msgid "Returning a value from iteration"
msgstr ""

#: src/class/protocols.md:182
msgid ""
"This guide has so far shown how to use `Option<T>` to implement yielding "
"values during iteration.  In Python a generator can also return a value. To "
"express this in Rust, PyO3 provides the [`IterNextOutput`](https://pyo3.rs/"
"main/doc/pyo3/class/iter/enum.IterNextOutput.html) enum to both `Yield` "
"values and `Return` a final value - see its docs for further details and an "
"example."
msgstr ""

#: src/class/protocols.md:187
msgid "Awaitable objects"
msgstr ""

#: src/class/protocols.md:189
msgid "`__await__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:190
msgid "`__aiter__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:191
msgid "`__anext__(<self>) -> Option<object> or IterANextOutput`"
msgstr ""

#: src/class/protocols.md:193
msgid "Mapping & Sequence types"
msgstr ""

#: src/class/protocols.md:195
msgid ""
"The magic methods in this section can be used to implement Python container "
"types. They are two main categories of container in Python: \"mappings\" "
"such as `dict`, with arbitrary keys, and \"sequences\" such as `list` and "
"`tuple`, with integer keys."
msgstr ""

#: src/class/protocols.md:197
msgid ""
"The Python C-API which PyO3 is built upon has separate \"slots\" for "
"sequences and mappings. When writing a `class` in pure Python, there is no "
"such distinction in the implementation - a `__getitem__` implementation will "
"fill the slots for both the mapping and sequence forms, for example."
msgstr ""

#: src/class/protocols.md:199
msgid ""
"By default PyO3 reproduces the Python behaviour of filling both mapping and "
"sequence slots. This makes sense for the \"simple\" case which matches "
"Python, and also for sequences, where the mapping slot is used anyway to "
"implement slice indexing."
msgstr ""

#: src/class/protocols.md:201
msgid ""
"Mapping types usually will not want the sequence slots filled. Having them "
"filled will lead to outcomes which may be unwanted, such as:"
msgstr ""

#: src/class/protocols.md:202
msgid ""
"The mapping type will successfully cast to [`PySequence`](https://pyo3.rs/"
"main/doc/pyo3/types/struct.PySequence.html). This may lead to consumers of "
"the type handling it incorrectly."
msgstr ""

#: src/class/protocols.md:203
msgid ""
"Python provides a default implementation of `__iter__` for sequences, which "
"calls `__getitem__` with consecutive positive integers starting from 0 until "
"an `IndexError` is returned. Unless the mapping only contains consecutive "
"positive integer keys, this `__iter__` implementation will likely not be the "
"intended behavior."
msgstr ""

#: src/class/protocols.md:205
msgid ""
"Use the `#[pyclass(mapping)]` annotation to instruct PyO3 to only fill the "
"mapping slots, leaving the sequence ones empty. This will apply to "
"`__getitem__`, `__setitem__`, and `__delitem__`."
msgstr ""

#: src/class/protocols.md:207
msgid "`__len__(<self>) -> usize`"
msgstr ""

#: src/class/protocols.md:209 src/class/protocols.md:504
msgid "Implements the built-in function `len()` for the sequence."
msgstr ""

#: src/class/protocols.md:211
msgid "`__contains__(<self>, object) -> bool`"
msgstr ""

#: src/class/protocols.md:213 src/class/protocols.md:528
msgid ""
"Implements membership test operators. Should return true if `item` is in "
"`self`, false otherwise. For objects that donâ€™t define `__contains__()`, the "
"membership test simply traverses the sequence until it finds a match."
msgstr ""

#: src/class/protocols.md:221
msgid ""
"By default, all `#[pyclass]` types with an `__iter__` method support a "
"default implementation of the `in` operator. Types which do not want this "
"can override this by setting `__contains__` to `None`. This is the same "
"mechanism as for a pure-Python class. This is done like so:"
msgstr ""

#: src/class/protocols.md:240
msgid "`__getitem__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:242
msgid "Implements retrieval of the `self[a]` element."
msgstr ""

#: src/class/protocols.md:244
msgid "_Note:_ Negative integer indexes are not handled specially."
msgstr ""

#: src/class/protocols.md:246
msgid "`__setitem__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:248
msgid ""
"Implements assignment to the `self[a]` element. Should only be implemented "
"if elements can be replaced."
msgstr ""

#: src/class/protocols.md:251
msgid "`__delitem__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:253
msgid ""
"Implements deletion of the `self[a]` element. Should only be implemented if "
"elements can be deleted."
msgstr ""

#: src/class/protocols.md:256 src/class/protocols.md:533
msgid ""
"`fn __concat__(&self, other: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:258
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `__add__` and `__radd__` methods."
msgstr ""

#: src/class/protocols.md:262 src/class/protocols.md:539
msgid "`fn __repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:264
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `__mul__` and `__rmul__` methods."
msgstr ""

#: src/class/protocols.md:268
msgid ""
"`fn __inplace_concat__(&self, other: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:270
msgid ""
"Concatenates two sequences. Used by the `+=` operator, after trying the "
"numeric addition via the `__iadd__` method."
msgstr ""

#: src/class/protocols.md:274
msgid ""
"`fn __inplace_repeat__(&self, count: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:276
msgid ""
"Concatenates two sequences. Used by the `*=` operator, after trying the "
"numeric multiplication via the `__imul__` method."
msgstr ""

#: src/class/protocols.md:280
msgid "Descriptors"
msgstr ""

#: src/class/protocols.md:282
msgid "`__get__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:283
msgid "`__set__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:284
msgid "`__delete__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:286
msgid "Numeric types"
msgstr ""

#: src/class/protocols.md:288
msgid ""
"Binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, "
"`divmod()`, `pow()` and `**`, `<<`, `>>`, `&`, `^`, and `|`) and their "
"reflected versions:"
msgstr ""

#: src/class/protocols.md:291
msgid ""
"(If the `object` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`.)"
msgstr ""

#: src/class/protocols.md:294
msgid "`__add__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:295
msgid "`__radd__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:296
msgid "`__sub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:297
msgid "`__rsub__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:298
msgid "`__mul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:299
msgid "`__rmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:300
msgid "`__matmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:301
msgid "`__rmatmul__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:302
msgid "`__floordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:303
msgid "`__rfloordiv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:304
msgid "`__truediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:305
msgid "`__rtruediv__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:306
msgid "`__divmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:307
msgid "`__rdivmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:308
msgid "`__mod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:309
msgid "`__rmod__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:310
msgid "`__lshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:311
msgid "`__rlshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:312
msgid "`__rshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:313
msgid "`__rrshift__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:314
msgid "`__and__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:315
msgid "`__rand__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:316
msgid "`__xor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:317
msgid "`__rxor__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:318
msgid "`__or__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:319
msgid "`__ror__(<self>, object) -> object`"
msgstr ""

#: src/class/protocols.md:320
msgid "`__pow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:321
msgid "`__rpow__(<self>, object, object) -> object`"
msgstr ""

#: src/class/protocols.md:323
msgid ""
"In-place assignment operations (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, "
"`**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`):"
msgstr ""

#: src/class/protocols.md:326
msgid "`__iadd__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:327
msgid "`__isub__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:328
msgid "`__imul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:329
msgid "`__imatmul__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:330
msgid "`__itruediv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:331
msgid "`__ifloordiv__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:332
msgid "`__imod__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:333
msgid "`__ipow__(<self>, object, object) -> ()`"
msgstr ""

#: src/class/protocols.md:334
msgid "`__ilshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:335
msgid "`__irshift__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:336
msgid "`__iand__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:337
msgid "`__ixor__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:338
msgid "`__ior__(<self>, object) -> ()`"
msgstr ""

#: src/class/protocols.md:340
msgid "Unary operations (`-`, `+`, `abs()` and `~`):"
msgstr ""

#: src/class/protocols.md:342
msgid "`__pos__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:343
msgid "`__neg__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:344
msgid "`__abs__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:345
msgid "`__invert__(<self>) -> object`"
msgstr ""

#: src/class/protocols.md:347
msgid "Coercions:"
msgstr ""

#: src/class/protocols.md:349
msgid "`__index__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:350
msgid "`__int__(<self>) -> object (int)`"
msgstr ""

#: src/class/protocols.md:351
msgid "`__float__(<self>) -> object (float)`"
msgstr ""

#: src/class/protocols.md:353
msgid "Buffer objects"
msgstr ""

#: src/class/protocols.md:355
msgid "`__getbuffer__(<self>, *mut ffi::Py_buffer, flags) -> ()`"
msgstr ""

#: src/class/protocols.md:356
msgid ""
"`__releasebuffer__(<self>, *mut ffi::Py_buffer)` (no return value, not even "
"`PyResult`)"
msgstr ""

#: src/class/protocols.md:358 src/class/protocols.md:602
msgid "Garbage Collector Integration"
msgstr ""

#: src/class/protocols.md:360
msgid ""
"If your type owns references to other Python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references.  To do this, implement the two methods `__traverse__` and "
"`__clear__`.  These correspond to the slots `tp_traverse` and `tp_clear` in "
"the Python C API. `__traverse__` must call `visit.call()` for each reference "
"to another Python object.  `__clear__` must clear out any mutable references "
"to other Python objects (thus breaking reference cycles). Immutable "
"references do not have to be cleared, as every cycle must contain at least "
"one mutable reference."
msgstr ""

#: src/class/protocols.md:369
msgid ""
"`__traverse__(<self>, pyo3::class::gc::PyVisit<'_>) -> Result<(), pyo3::"
"class::gc::PyTraverseError>`"
msgstr ""

#: src/class/protocols.md:370
msgid "`__clear__(<self>) -> ()`"
msgstr ""

#: src/class/protocols.md:394
msgid "// Clear reference, this decrements ref counter.\n"
msgstr ""

#: src/class/protocols.md:403
msgid "`#[pyproto]` traits"
msgstr ""

#: src/class/protocols.md:405
msgid ""
"PyO3 can use the `#[pyproto]` attribute in combination with special traits "
"to implement the magic methods which need slots. The special traits are "
"listed below. See also the [documentation for the `pyo3::class` module]"
"(https://pyo3.rs/main/doc/pyo3/class/index.html)."
msgstr ""

#: src/class/protocols.md:407
msgid ""
"Due to complexity in the implementation and usage, these traits are "
"deprecated in PyO3 0.16 in favour of the `#[pymethods]` solution."
msgstr ""

#: src/class/protocols.md:409
msgid ""
"All `#[pyproto]` methods can return `T` instead of `PyResult<T>` if the "
"method implementation is infallible. In addition, if the return type is "
"`()`, it can be omitted altogether."
msgstr ""

#: src/class/protocols.md:413
msgid ""
"The [`PyObjectProtocol`](https://pyo3.rs/main/doc/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provides several basic customizations."
msgstr ""

#: src/class/protocols.md:415
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:416
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class/protocols.md:417
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class/protocols.md:418
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:419
msgid ""
"`fn __getattr__(&self, name: impl FromPyObject) -> PyResult<impl "
"IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:420
msgid ""
"`fn __setattr__(&mut self, name: impl FromPyObject, value: impl "
"FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:421
msgid "`fn __delattr__(&mut self, name: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:422
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:424
msgid "Emulating numeric types"
msgstr ""

#: src/class/protocols.md:426
msgid ""
"The [`PyNumberProtocol`](https://pyo3.rs/main/doc/pyo3/class/number/trait."
"PyNumberProtocol.html) trait can be implemented to emulate [numeric types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types)."
msgstr ""

#: src/class/protocols.md:428
msgid ""
"`fn __add__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:429
msgid ""
"`fn __sub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:430
msgid ""
"`fn __mul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:431
msgid ""
"`fn __matmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:432
msgid ""
"`fn __truediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:433
msgid ""
"`fn __floordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:434
msgid ""
"`fn __mod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:435
msgid ""
"`fn __divmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:436
msgid ""
"`fn __pow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:437
msgid ""
"`fn __lshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:438
msgid ""
"`fn __rshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:439
msgid ""
"`fn __and__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:440
msgid ""
"`fn __or__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:441
msgid ""
"`fn __xor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:443
msgid "These methods are called to implement the binary arithmetic operations."
msgstr ""

#: src/class/protocols.md:445
msgid "The reflected operations are also available:"
msgstr ""

#: src/class/protocols.md:447
msgid ""
"`fn __radd__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:448
msgid ""
"`fn __rsub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:449
msgid ""
"`fn __rmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:450
msgid ""
"`fn __rmatmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:451
msgid ""
"`fn __rtruediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:452
msgid ""
"`fn __rfloordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:453
msgid ""
"`fn __rmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:454
msgid ""
"`fn __rdivmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:455
msgid ""
"`fn __rpow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: "
"Option<impl FromPyObject>) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:456
msgid ""
"`fn __rlshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:457
msgid ""
"`fn __rrshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:458
msgid ""
"`fn __rand__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:459
msgid ""
"`fn __ror__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> PyResult<impl "
"ToPyObject>`"
msgstr ""

#: src/class/protocols.md:460
msgid ""
"`fn __rxor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:462
msgid ""
"The code generated for these methods expect that all arguments match the "
"signature, or raise a TypeError."
msgstr ""

#: src/class/protocols.md:465
msgid "`fn __iadd__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:466
msgid "`fn __isub__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:467
msgid "`fn __imul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:468
msgid ""
"`fn __imatmul__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:469
msgid ""
"`fn __itruediv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:470
msgid ""
"`fn __ifloordiv__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:471
msgid "`fn __imod__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:472
msgid ""
"`fn __ipow__(&'p mut self, other: impl FromPyObject, modulo: impl "
"FromPyObject) -> PyResult<()>` on Python 3.8^"
msgstr ""

#: src/class/protocols.md:473
msgid ""
"`fn __ipow__(&'p mut self, other: impl FromPyObject) -> PyResult<()>` on "
"Python 3.7 see https://bugs.python.org/issue36379"
msgstr ""

#: src/class/protocols.md:474
msgid ""
"`fn __ilshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:475
msgid ""
"`fn __irshift__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:476
msgid "`fn __iand__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:477
msgid "`fn __ior__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:478
msgid "`fn __ixor__(&'p mut self, other: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:481
msgid "The following methods implement the unary arithmetic operations:"
msgstr ""

#: src/class/protocols.md:483
msgid "`fn __neg__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:484
msgid "`fn __pos__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:485
msgid "`fn __abs__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:486
msgid "`fn __invert__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:488
msgid "Support for coercions:"
msgstr ""

#: src/class/protocols.md:490
msgid "`fn __int__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:491
msgid "`fn __float__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:492
msgid "`fn __index__(&'p self) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:494
msgid "Emulating sequential containers (such as lists or tuples)"
msgstr ""

#: src/class/protocols.md:496
msgid ""
"The [`PySequenceProtocol`](https://pyo3.rs/main/doc/pyo3/class/sequence/"
"trait.PySequenceProtocol.html) trait can be implemented to emulate "
"[sequential container types](https://docs.python.org/3/reference/datamodel."
"html#emulating-container-types)."
msgstr ""

#: src/class/protocols.md:499
msgid ""
"For a sequence, the keys are the integers _k_ for which _0 \\<= k \\< N_, "
"where _N_ is the length of the sequence."
msgstr ""

#: src/class/protocols.md:502 src/class/protocols.md:564
msgid "`fn __len__(&self) -> PyResult<usize>`"
msgstr ""

#: src/class/protocols.md:506
msgid "`fn __getitem__(&self, idx: isize) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:508
msgid ""
"Implements evaluation of the `self[idx]` element. If the `idx` value is "
"outside the set of indexes for the sequence, `IndexError` should be raised."
msgstr ""

#: src/class/protocols.md:511
msgid ""
"_Note:_ Negative integer indexes are handled as follows: if `__len__()` is "
"defined, it is called and the sequence length is used to compute a positive "
"index, which is passed to `__getitem__()`. If `__len__()` is not defined, "
"the index is passed as is to the function."
msgstr ""

#: src/class/protocols.md:516
msgid ""
"`fn __setitem__(&mut self, idx: isize, value: impl FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class/protocols.md:518
msgid ""
"Implements assignment to the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"replaced."
msgstr ""

#: src/class/protocols.md:521
msgid "`fn __delitem__(&mut self, idx: isize) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:523
msgid ""
"Implements deletion of the `self[idx]` element. Same note as for "
"`__getitem__()`. Should only be implemented if sequence elements can be "
"deleted."
msgstr ""

#: src/class/protocols.md:526
msgid "`fn __contains__(&self, item: impl FromPyObject) -> PyResult<bool>`"
msgstr ""

#: src/class/protocols.md:535
msgid ""
"Concatenates two sequences. Used by the `+` operator, after trying the "
"numeric addition via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:541
msgid ""
"Repeats the sequence `count` times. Used by the `*` operator, after trying "
"the numeric multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:545
msgid ""
"`fn __inplace_concat__(&mut self, other: impl FromPyObject) -> "
"PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:547
msgid ""
"Concatenates two sequences in place. Returns the modified first operand. "
"Used by the `+=` operator, after trying the numeric in place addition via "
"the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:551
msgid "`fn __inplace_repeat__(&mut self, count: isize) -> PyResult<Self>`"
msgstr ""

#: src/class/protocols.md:553
msgid ""
"Repeats the sequence `count` times in place. Returns the modified first "
"operand. Used by the `*=` operator, after trying the numeric in place "
"multiplication via the `PyNumberProtocol` trait method."
msgstr ""

#: src/class/protocols.md:557
msgid "Emulating mapping containers (such as dictionaries)"
msgstr ""

#: src/class/protocols.md:559
msgid ""
"The [`PyMappingProtocol`](https://pyo3.rs/main/doc/pyo3/class/mapping/trait."
"PyMappingProtocol.html) trait allows to emulate [mapping container types]"
"(https://docs.python.org/3/reference/datamodel.html#emulating-container-"
"types)."
msgstr ""

#: src/class/protocols.md:562
msgid "For a mapping, the keys may be Python objects of arbitrary type."
msgstr ""

#: src/class/protocols.md:566
msgid "Implements the built-in function `len()` for the mapping."
msgstr ""

#: src/class/protocols.md:568
msgid ""
"`fn __getitem__(&self, key: impl FromPyObject) -> PyResult<impl ToPyObject>`"
msgstr ""

#: src/class/protocols.md:570
msgid ""
"Implements evaluation of the `self[key]` element. If `key` is of an "
"inappropriate type, `TypeError` may be raised; if `key` is missing (not in "
"the container), `KeyError` should be raised."
msgstr ""

#: src/class/protocols.md:574
msgid ""
"`fn __setitem__(&mut self, key: impl FromPyObject, value: impl FromPyObject) "
"-> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:576
msgid ""
"Implements assignment to the `self[key]` element or insertion of a new `key` "
"mapping to `value`. Should only be implemented if the mapping support "
"changes to the values for keys, or if new keys can be added. The same "
"exceptions should be raised for improper key values as for the "
"`__getitem__()` method."
msgstr ""

#: src/class/protocols.md:583
msgid "`fn __delitem__(&mut self, key: impl FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class/protocols.md:585
msgid ""
"Implements deletion of the `self[key]` element. Should only be implemented "
"if the mapping supports removal of keys. The same exceptions should be "
"raised for improper key values as for the `__getitem__()` method."
msgstr ""

#: src/class/protocols.md:590
msgid "Iterator Types"
msgstr ""

#: src/class/protocols.md:592
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://pyo3.rs/main/"
"doc/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class/protocols.md:594
msgid ""
"`fn __iter__(slf: PyRefMut<'_, Self>) -> PyResult<impl IntoPy<PyObject>>`"
msgstr ""

#: src/class/protocols.md:595
msgid ""
"`fn __next__(slf: PyRefMut<'_, Self>) -> PyResult<Option<impl "
"IntoPy<PyObject>>>`"
msgstr ""

#: src/class/protocols.md:597
msgid ""
"These two methods can be take either `PyRef<'_, Self>` or `PyRefMut<'_, "
"Self>` as their first argument, so that mutable borrow can be avoided if "
"needed."
msgstr ""

#: src/class/protocols.md:600
msgid "For details, look at the `#[pymethods]` regarding iterator methods."
msgstr ""

#: src/class/protocols.md:604
msgid ""
"Implement the [`PyGCProtocol`](https://pyo3.rs/main/doc/pyo3/class/gc/trait."
"PyGCProtocol.html) trait for your struct. For details, look at the "
"`#[pymethods]` regarding GC methods."
msgstr ""
