msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/function.md:1
msgid "Python Functions"
msgstr ""

#: src/function.md:3
msgid ""
"The `#[pyfunction]` attribute is used to define a Python function from a "
"Rust function. Once defined, the function needs to be added to a [module](./"
"module.md) using the `wrap_pyfunction!` macro."
msgstr ""

#: src/function.md:5
msgid ""
"The following example defines a function called `double` in a Python module "
"called `my_extension`:"
msgstr ""

#: src/function.md:22
msgid ""
"This chapter of the guide explains full usage of the `#[pyfunction]` "
"attribute. The following topics are covered:"
msgstr ""

#: src/function.md:24
msgid "[Function options](#function-options)"
msgstr ""

#: src/function.md:25
msgid "[`#[pyo3(name = \"...\")]`](#name)"
msgstr ""

#: src/function.md:26
msgid "[`#[pyo3(text_signature = \"...\")]`](#text_signature)"
msgstr ""

#: src/function.md:27
msgid "[`#[pyo3(pass_module)]`](#pass_module)"
msgstr ""

#: src/function.md:28
msgid "[Argument parsing](#argument-parsing)"
msgstr ""

#: src/function.md:29
msgid "[`#[pyo3(from_py_with = \"...\")]`](#from_py_with)"
msgstr ""

#: src/function.md:30
msgid "[Advanced function patterns](#advanced-function-patterns)"
msgstr ""

#: src/function.md:31
msgid "[`#[pyfn]` shorthand](#pyfn-shorthand)"
msgstr ""

#: src/function.md:33
msgid "Function options"
msgstr ""

#: src/function.md:35
msgid ""
"The `#[pyo3]` attribute can be used to modify properties of the generated "
"Python function. It can take any combination of the following options:"
msgstr ""

#: src/function.md:37
msgid "<a name=\"name\"></a> `#[pyo3(name = \"...\")]`"
msgstr ""

#: src/function.md:39
msgid "Overrides the name exposed to Python."
msgstr ""

#: src/function.md:41
msgid ""
"In the following example, the Rust function `no_args_py` will be added to "
"the Python module `module_with_functions` as the Python function `no_args`:"
msgstr ""

#: src/function.md:48 src/function.md:59
msgid "\"no_args\""
msgstr ""

#: src/function.md:60
msgid "\"no_args_py\""
msgstr ""

#: src/function.md:64
msgid "<a name=\"text_signature\"></a> `#[pyo3(text_signature = \"...\")]`"
msgstr ""

#: src/function.md:66
msgid ""
"Sets the function signature visible in Python tooling (such as via [`inspect."
"signature`](https://docs.python.org/3/library/inspect.html#inspect."
"signature))."
msgstr ""

#: src/function.md:68
msgid ""
"The example below creates a function `add` which has a signature describing "
"two positional-only arguments `a` and `b`."
msgstr ""

#: src/function.md:74
msgid "/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:76 src/function.md:93
msgid "\"(a, b, /)\""
msgstr ""

#: src/function.md:85
msgid "\"__doc__\""
msgstr ""

#: src/function.md:86
msgid "\"This function adds two unsigned 64-bit integers.\""
msgstr ""

#: src/function.md:88
msgid "\"inspect\""
msgstr ""

#: src/function.md:88
msgid "\"signature\""
msgstr ""

#: src/function.md:91
msgid "\"__str__\""
msgstr ""

#: src/function.md:100
msgid "<a name=\"pass_module\" ></a> `#[pyo3(pass_module)]`"
msgstr ""

#: src/function.md:102
msgid ""
"Set this option to make PyO3 pass the containing module as the first "
"argument to the function. It is then possible to use the module in the "
"function body. The first argument **must** be of type `&PyModule`."
msgstr ""

#: src/function.md:104
msgid ""
"The following example creates a function `pyfunction_with_module` which "
"returns the containing module's name (i.e. `module_with_fn`):"
msgstr ""

#: src/function.md:121
msgid "Argument parsing"
msgstr ""

#: src/function.md:123
msgid ""
"The `#[pyfunction]` attribute supports specifying details of argument "
"parsing. The details are given in the section [\"Method arguments\" of the "
"Classes chapter](class.md#method-arguments).  Here is an example for a "
"function that accepts arbitrary keyword arguments (`**kwargs` in Python "
"syntax) and returns the number that was passed:"
msgstr ""

#: src/function.md:129
msgid "\"**\""
msgstr ""

#: src/function.md:141
msgid "Per-argument options"
msgstr ""

#: src/function.md:143
msgid ""
"The `#[pyo3]` attribute can be used on individual arguments to modify "
"properties of them in the generated function. It can take any combination of "
"the following options:"
msgstr ""

#: src/function.md:145
msgid "<a name=\"from_py_with\"></a> `#[pyo3(from_py_with = \"...\")]`"
msgstr ""

#: src/function.md:147
msgid ""
"Set this on an option to specify a custom function to convert the function "
"argument from Python to the desired Rust type, instead of using the default "
"`FromPyObject` extraction. The function signature must be `fn(&PyAny) -> "
"PyResult<T>` where `T` is the Rust type of the argument."
msgstr ""

#: src/function.md:149
msgid ""
"The following example uses `from_py_with` to convert the input Python object "
"to its length:"
msgstr ""

#: src/function.md:172
msgid "Advanced function patterns"
msgstr ""

#: src/function.md:174
msgid "Making the function signature available to Python (old method)"
msgstr ""

#: src/function.md:176
msgid ""
"Alternatively, simply make sure the first line of your docstring is "
"formatted like in the following example. Please note that the newline after "
"the `--` is mandatory. The `/` signifies the end of positional-only "
"arguments."
msgstr ""

#: src/function.md:180
msgid ""
"`#[pyo3(text_signature)]` should be preferred, since it will override "
"automatically generated signatures when those are added in a future version "
"of PyO3."
msgstr ""

#: src/function.md:186
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:195
msgid ""
"// a function with a signature but without docs. Both blank lines after the "
"`--` are mandatory.\n"
msgstr ""

#: src/function.md:197
msgid ""
"/// sub(a, b, /)\n"
"/// --\n"
"///\n"
"///\n"
msgstr ""

#: src/function.md:208
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:217
msgid "Closures"
msgstr ""

#: src/function.md:219
msgid ""
"Currently, there are no conversions between `Fn`s in Rust and callables in "
"Python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:223
msgid "Calling Python functions in Rust"
msgstr ""

#: src/function.md:225
msgid ""
"You can pass Python `def`'d functions and built-in functions to Rust "
"functions [`PyFunction`](https://pyo3.rs/main/doc/pyo3/types/struct."
"PyFunction.html) corresponds to regular Python functions while "
"[`PyCFunction`](https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html) "
"describes built-ins such as `repr()`."
msgstr ""

#: src/function.md:229
msgid ""
"You can also use [`PyAny::is_callable`](https://pyo3.rs/main/doc/pyo3/struct."
"PyAny.html#tymethod.is_callable) to check if you have a callable object. "
"`is_callable` will return `true` for functions (including lambdas), methods "
"and objects with a `__call__` method. You can call the object with [`PyAny::"
"call`](https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call) with "
"the args as first parameter and the kwargs (or `None`) as second parameter. "
"There are also [`PyAny::call0`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#tymethod.call0) with no args and [`PyAny::call1`](https://pyo3.rs/main/"
"doc/pyo3/struct.PyAny.html#tymethod.call1) with only positional args."
msgstr ""

#: src/function.md:235
msgid "Calling Rust functions in Python"
msgstr ""

#: src/function.md:237
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use [`wrap_pyfunction!`](https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction."
"html) to get the corresponding [`PyCFunction`](https://pyo3.rs/main/doc/pyo3/"
"types/struct.PyCFunction.html). For dynamic functions, e.g. lambdas and "
"functions that were passed as arguments, you must put them in some kind of "
"owned container, e.g. a `Box`. (A long-term solution will be a special "
"container similar to wasm-bindgen's `Closure`). You can then use a "
"`#[pyclass]` struct with that container as a field as a way to pass the "
"function over the FFI barrier. You can even make that class callable with "
"`__call__` so it looks like a function in Python code."
msgstr ""

#: src/function.md:254
msgid "Accessing the FFI functions"
msgstr ""

#: src/function.md:256
msgid ""
"In order to make Rust functions callable from Python, PyO3 generates an "
"`extern \"C\"` function whose exact signature depends on the Rust "
"signature.  (PyO3 chooses the optimal Python argument passing convention.) "
"It then embeds the call to the Rust function inside this FFI-wrapper "
"function. This wrapper handles extraction of the regular arguments and the "
"keyword arguments from the input `PyObject`s."
msgstr ""

#: src/function.md:262
msgid ""
"The `wrap_pyfunction` macro can be used to directly get a `PyCFunction` "
"given a `#[pyfunction]` and a `PyModule`: `wrap_pyfunction!(rust_fun, "
"module)`."
msgstr ""

#: src/function.md:265
msgid "`#[pyfn]` shorthand"
msgstr ""

#: src/function.md:267
msgid ""
"There is a shorthand to `#[pyfunction]` and `wrap_pymodule!`: the function "
"can be placed inside the module definition and annotated with `#[pyfn]`. To "
"simplify PyO3, it is expected that `#[pyfn]` may be removed in a future "
"release (See [\\#694](https://github.com/PyO3/pyo3/issues/694))."
msgstr ""

#: src/function.md:270
msgid "An example of `#[pyfn]` is below:"
msgstr ""

#: src/function.md:287
msgid ""
"`#[pyfn(m)]` is just syntactic sugar for `#[pyfunction]`, and takes all the "
"same options documented in the rest of this chapter. The code above is "
"expanded to the following:"
msgstr ""
