msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:54Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/faq.md:1
msgid "Frequently Asked Questions and troubleshooting"
msgstr "常見問題與疑難排解"

#: src/faq.md:3
msgid ""
"Sorry that you're having trouble using PyO3. If you can't find the answer to "
"your problem in the list below, you can also reach out for help on [GitHub "
"Discussions](https://github.com/PyO3/pyo3/discussions) and on [Discord]"
"(https://discord.gg/33kcChzH7f)."
msgstr ""
"很抱歉你在使用 PyO3 時遇到問題。如果在下列清單中找不到答案，也可以到 [GitHub "
"Discussions](https://github.com/PyO3/pyo3/discussions) 或 [Discord](https://"
"discord.gg/33kcChzH7f) 尋求協助。"

#: src/faq.md:5
msgid ""
"I'm experiencing deadlocks using PyO3 with `std::sync::OnceLock`, `std::"
"sync::LazyLock`, `lazy_static`, and `once_cell`"
msgstr ""
"使用 PyO3 搭配 `std::sync::OnceLock`、`std::sync::LazyLock`、`lazy_static` "
"與 `once_cell` 時遇到死鎖"

#: src/faq.md:7
msgid ""
"`OnceLock`, `LazyLock`, and their thirdparty predecessors use blocking to "
"ensure only one thread ever initializes them. Because the Python interpreter "
"can introduce additional locks (the Python GIL and GC can both require all "
"other threads to pause) this can lead to deadlocks in the following way:"
msgstr ""
"`OnceLock`、`LazyLock` 以及其第三方前身會透過阻塞來確保只有一個執行緒進行初始"
"化。由於 Python 直譯器可能引入額外鎖（Python 的 GIL 與 GC 都可能要求其他執行"
"緒暫停），因此可能以以下方式造成死鎖："

#: src/faq.md:9
msgid ""
"A thread (thread A) which is attached to the Python interpreter starts "
"initialization of a `OnceLock` value."
msgstr "已附著到 Python 直譯器的執行緒（執行緒 A）開始初始化 `OnceLock` 值。"

#: src/faq.md:10
msgid ""
"The initialization code calls some Python API which temporarily detaches "
"from the interpreter e.g. `Python::import`."
msgstr ""
"初始化程式碼呼叫了會暫時與直譯器分離的 Python API，例如 `Python::import`。"

#: src/faq.md:11
msgid ""
"Another thread (thread B) attaches to the Python interpreter and attempts to "
"access the same `OnceLock` value."
msgstr ""
"另一個執行緒（執行緒 B）附著到 Python 直譯器並嘗試存取相同的 `OnceLock` 值。"

#: src/faq.md:12
msgid ""
"Thread B is blocked, because it waits for `OnceLock`'s initialization to "
"lock to release."
msgstr "執行緒 B 被阻塞，因為它在等待 `OnceLock` 的初始化鎖釋放。"

#: src/faq.md:13
msgid ""
"On non-free-threaded Python, thread A is now also blocked, because it waits "
"to re-attach to the interpreter (by taking the GIL which thread B still "
"holds)."
msgstr ""
"在非自由執行緒的 Python 中，執行緒 A 現在也會被阻塞，因為它等待重新附著到直譯"
"器（必須取得執行緒 B 仍持有的 GIL）。"

#: src/faq.md:14
msgid "Deadlock."
msgstr "死鎖。"

#: src/faq.md:16
msgid ""
"PyO3 provides a struct [`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/"
"struct.PyOnceLock.html) which implements a single-initialization API based "
"on these types that avoids deadlocks. You can also make use of the "
"[`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt.html) and "
"[`OnceLockExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceLockExt.html) "
"extension traits that enable using the standard library types for this "
"purpose by providing new methods for these types that avoid the risk of "
"deadlocking with the Python interpreter. This means they can be used in "
"place of other choices when you are experiencing the deadlock described "
"above. See the documentation for [`PyOnceLock`](https://pyo3.rs/main/doc/"
"pyo3/sync/struct.PyOnceLock.html) and [`OnceExt`](https://pyo3.rs/main/doc/"
"pyo3/sync/trait.OnceExt.html) for further details and an example how to use "
"them."
msgstr ""
"PyO3 提供 [`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/struct."
"PyOnceLock.html) 結構，基於這些型別實作單次初始化 API，可避免死鎖。你也可以使"
"用 [`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt.html) 與 "
"[`OnceLockExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceLockExt.html) 擴"
"充 trait，透過為標準函式庫型別提供新方法來避免與 Python 直譯器死鎖的風險。當"
"你遇到上述死鎖時，可用它們取代其他選擇。更多細節與使用範例請參考 "
"[`PyOnceLock`](https://pyo3.rs/main/doc/pyo3/sync/struct.PyOnceLock.html) 與 "
"[`OnceExt`](https://pyo3.rs/main/doc/pyo3/sync/trait.OnceExt.html) 文件。"

#: src/faq.md:22
msgid ""
"I can't run `cargo test`; or I can't build in a Cargo workspace: I'm having "
"linker issues like \"Symbol not found\" or \"Undefined reference to "
"\\_PyExc_SystemError\""
msgstr ""
"無法執行 `cargo test`；或在 Cargo workspace 中無法建置：遇到連結器錯誤如"
"「Symbol not found」或「Undefined reference to \\_PyExc_SystemError」"

#: src/faq.md:24
msgid ""
"Currently, [\\#340](https://github.com/PyO3/pyo3/issues/340) causes `cargo "
"test` to fail with linking errors when the `extension-module` feature is "
"activated. Linking errors can also happen when building in a cargo workspace "
"where a different crate also uses PyO3 (see [\\#2521](https://github.com/"
"PyO3/pyo3/issues/2521)). For now, there are three ways we can work around "
"these issues."
msgstr ""

#: src/faq.md:26
msgid ""
"Make the `extension-module` feature optional. Build with `maturin develop --"
"features \"extension-module\"`"
msgstr ""

#: src/faq.md:28
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:36
msgid ""
"Make the `extension-module` feature optional and default. Run tests with "
"`cargo test --no-default-features`:"
msgstr ""

#: src/faq.md:38
msgid ""
"```toml\n"
"[dependencies.pyo3]\n"
"git = \"https://github.com/pyo3/pyo3\"\n"
"\n"
"[features]\n"
"extension-module = [\"pyo3/extension-module\"]\n"
"default = [\"extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:47
msgid ""
"If you are using a [`pyproject.toml`](https://maturin.rs/metadata.html) file "
"to control maturin settings, add the following section:"
msgstr ""

#: src/faq.md:49
msgid ""
"```toml\n"
"[tool.maturin]\n"
"features = [\"pyo3/extension-module\"]\n"
"# Or for maturin 0.12:\n"
"# cargo-extra-args = [\"--features\", \"pyo3/extension-module\"]\n"
"```"
msgstr ""

#: src/faq.md:56
msgid ""
"I can't run `cargo test`: my crate cannot be found for tests in `tests/` "
"directory"
msgstr "無法執行 `cargo test`：`tests/` 目錄中的測試找不到我的 crate"

#: src/faq.md:58
msgid ""
"The Rust book suggests to [put integration tests inside a `tests/` directory]"
"(https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-"
"tests)."
msgstr ""
"Rust 書籍建議[將整合測試放在 `tests/` 目錄中](https://doc.rust-lang.org/book/"
"ch11-03-test-organization.html#integration-tests)。"

#: src/faq.md:60
msgid ""
"For a PyO3 `extension-module` project where the `crate-type` is set to "
"`\"cdylib\"` in your `Cargo.toml`, the compiler won't be able to find your "
"crate and will display errors such as `E0432` or `E0463`:"
msgstr ""

#: src/faq.md:71
msgid ""
"The best solution is to make your crate types include both `rlib` and "
"`cdylib`:"
msgstr "最佳解法是讓 crate 型別同時包含 `rlib` 與 `cdylib`："

#: src/faq.md:73
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[lib]\n"
"crate-type = [\"cdylib\", \"rlib\"]\n"
"```"
msgstr ""

#: src/faq.md:79
msgid "Ctrl-C doesn't do anything while my Rust code is executing"
msgstr "在 Rust 程式碼執行期間按 Ctrl-C 沒有效果"

#: src/faq.md:81
msgid ""
"This is because Ctrl-C raises a SIGINT signal, which is handled by the "
"calling Python process by simply setting a flag to action upon later. This "
"flag isn't checked while Rust code called from Python is executing, only "
"once control returns to the Python interpreter."
msgstr ""
"這是因為 Ctrl-C 會送出 SIGINT 訊號，呼叫端 Python 程序只會設定一個旗標以便稍"
"後處理。當 Python 呼叫的 Rust 程式碼執行中時，不會檢查此旗標，直到控制權回到 "
"Python 直譯器才會處理。"

#: src/faq.md:83
msgid ""
"You can give the Python interpreter a chance to process the signal properly "
"by calling `Python::check_signals`. It's good practice to call this function "
"regularly if you have a long-running Rust function so that your users can "
"cancel it."
msgstr ""
"你可以呼叫 `Python::check_signals` 讓 Python 直譯器有機會正確處理訊號。若你"
"的 Rust 函式會長時間執行，建議定期呼叫此函式，讓使用者能取消。"

#: src/faq.md:85
msgid "`#[pyo3(get)]` clones my field"
msgstr "`#[pyo3(get)]` 會複製我的欄位"

#: src/faq.md:87
msgid "You may have a nested struct similar to this:"
msgstr "你可能有如下的巢狀結構："

#: src/faq.md:93 src/faq.md:133
msgid "/* fields omitted */"
msgstr ""

#: src/faq.md:110
msgid ""
"When Python code accesses `Outer`'s field, PyO3 will return a new object on "
"every access (note that their addresses are different):"
msgstr ""
"當 Python 程式碼存取 `Outer` 的欄位時，PyO3 會在每次存取時回傳新的物件（注意"
"位址不同）："

#: src/faq.md:118 src/faq.md:164 src/faq.md:165
msgid "\"a: "
msgstr ""

#: src/faq.md:118 src/faq.md:164 src/faq.md:165
msgid "\\nb: "
msgstr ""

#: src/faq.md:118 src/faq.md:164 src/faq.md:165
msgid "\""
msgstr ""

#: src/faq.md:126
msgid ""
"This can be especially confusing if the field is mutable, as getting the "
"field and then mutating it won't persist - you'll just get a fresh clone of "
"the original on the next access. Unfortunately Python and Rust don't agree "
"about ownership - if PyO3 gave out references to (possibly) temporary Rust "
"objects to Python code, Python code could then keep that reference alive "
"indefinitely. Therefore returning Rust objects requires cloning."
msgstr ""
"若欄位是可變的，這會特別令人困惑，因為取得欄位後再修改並不會持久化——下次存取"
"只會拿到原始物件的新複本。不幸的是，Python 與 Rust 對所有權的理解不同——如果 "
"PyO3 將（可能是暫時的）Rust 物件參照交給 Python，Python 可能會無限期保留該參"
"照。因此回傳 Rust 物件需要進行複製。"

#: src/faq.md:128
msgid ""
"If you don't want that cloning to happen, a workaround is to allocate the "
"field on the Python heap and store a reference to that, by using [`Py<...>`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html):"
msgstr ""

#: src/faq.md:156
msgid "This time `a` and `b` _are_ the same object:"
msgstr ""

#: src/faq.md:173
msgid ""
"The downside to this approach is that any Rust code working on the `Outer` "
"struct potentially has to attach to the Python interpreter to do anything "
"with the `inner` field. (If `Inner` is `#[pyclass(frozen)]` and implements "
"`Sync`, then `Py::get` may be used to access the `Inner` contents from "
"`Py<Inner>` without needing to attach to the interpreter.)"
msgstr ""

#: src/faq.md:176
msgid ""
"I want to use the `pyo3` crate re-exported from dependency but the proc-"
"macros fail"
msgstr ""

#: src/faq.md:178
msgid ""
"All PyO3 proc-macros (`#[pyclass]`, `#[pyfunction]`, "
"`#[derive(FromPyObject)]` and so on) expect the `pyo3` crate to be available "
"under that name in your crate root, which is the normal situation when "
"`pyo3` is a direct dependency of your crate."
msgstr ""

#: src/faq.md:183
msgid ""
"However, when the dependency is renamed, or your crate only indirectly "
"depends on `pyo3`, you need to let the macro code know where to find the "
"crate.  This is done with the `crate` attribute:"
msgstr ""

#: src/faq.md:193
msgid "\"reexported::pyo3\""
msgstr ""

#: src/faq.md:197
msgid ""
"I'm trying to call Python from Rust but I get `STATUS_DLL_NOT_FOUND` or "
"`STATUS_ENTRYPOINT_NOT_FOUND`"
msgstr ""

#: src/faq.md:199
msgid ""
"This happens on Windows when linking to the python DLL fails or the wrong "
"one is linked. The Python DLL on Windows will usually be called something "
"like:"
msgstr ""

#: src/faq.md:201
msgid "`python3X.dll` for Python 3.X, e.g. `python310.dll` for Python 3.10"
msgstr ""

#: src/faq.md:202
msgid "`python3.dll` when using PyO3's `abi3` feature"
msgstr ""

#: src/faq.md:204
msgid ""
"The DLL needs to be locatable using the [Windows DLL search order](https://"
"learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-"
"order#standard-search-order-for-unpackaged-apps). Some ways to achieve this "
"are:"
msgstr ""

#: src/faq.md:206
msgid "Put the Python DLL in the same folder as your build artifacts"
msgstr ""

#: src/faq.md:207
msgid ""
"Add the directory containing the Python DLL to your `PATH` environment "
"variable, for example `C:"
"\\Users\\<You>\\AppData\\Local\\Programs\\Python\\Python310`"
msgstr ""

#: src/faq.md:208
msgid ""
"If this happens when you are _distributing_ your program, consider using "
"[PyOxidizer](https://github.com/indygreg/PyOxidizer) to package it with your "
"binary."
msgstr ""

#: src/faq.md:210
msgid ""
"If the wrong DLL is linked it is possible that this happened because another "
"program added itself and its own Python DLLs to `PATH`. Rearrange your "
"`PATH` variables to give the correct DLL priority."
msgstr ""

#: src/faq.md:212
msgid ""
"**Note**: Changes to `PATH` (or any other environment variable) are not "
"visible to existing shells. Restart it for changes to take effect."
msgstr ""

#: src/faq.md:214
msgid ""
"For advanced troubleshooting, [Dependency Walker](https://www."
"dependencywalker.com/) can be used to diagnose linking errors."
msgstr ""
