msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:54Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/trait-bounds.md:1
msgid "Using in Python a Rust function with trait bounds"
msgstr "在 Python 中使用帶有 trait bounds 的 Rust 函式"

#: src/trait-bounds.md:3
msgid ""
"PyO3 allows for easy conversion from Rust to Python for certain functions "
"and classes (see the [conversion table](conversions/tables.md)). However, it "
"is not always straightforward to convert Rust code that requires a given "
"trait implementation as an argument."
msgstr ""
"PyO3 讓某些函式與類別可輕鬆在 Rust 與 Python 間轉換（見[轉換表](conversions/"
"tables.md)）。不過，當 Rust 程式碼需要以特定 trait 實作作為參數時，轉換就未必"
"那麼直接。"

#: src/trait-bounds.md:6
msgid ""
"This tutorial explains how to convert a Rust function that takes a trait as "
"argument for use in Python with classes implementing the same methods as the "
"trait."
msgstr ""
"本教學說明如何將以 trait 作為參數的 Rust 函式轉換成可在 Python 中使用，並讓具"
"備相同方法的 Python 類別能夠配合使用。"

#: src/trait-bounds.md:8
msgid "Why is this useful?"
msgstr "為什麼這很有用？"

#: src/trait-bounds.md:10
msgid "Pros"
msgstr "優點"

#: src/trait-bounds.md:12
msgid "Make your Rust code available to Python users"
msgstr "讓你的 Rust 程式碼可供 Python 使用者使用"

#: src/trait-bounds.md:13
msgid "Code complex algorithms in Rust with the help of the borrow checker"
msgstr "在 Rust 中編寫複雜演算法並受惠於借用檢查器"

#: src/trait-bounds.md:15
msgid "Cons"
msgstr "缺點"

#: src/trait-bounds.md:17
msgid ""
"Not as fast as native Rust (type conversion has to be performed and one part "
"of the code runs in Python)"
msgstr "不如原生 Rust 快（需要進行型別轉換，且部分程式碼在 Python 端執行）"

#: src/trait-bounds.md:18
msgid "You need to adapt your code to expose it"
msgstr "你需要調整程式碼以便對外暴露"

#: src/trait-bounds.md:20
msgid "Example"
msgstr "範例"

#: src/trait-bounds.md:22
msgid ""
"Let's work with the following basic example of an implementation of a "
"optimization solver operating on a given model."
msgstr "讓我們以一個基本範例開始：一個在給定模型上運作的最佳化求解器實作。"

#: src/trait-bounds.md:24
msgid ""
"Let's say we have a function `solve` that operates on a model and mutates "
"its state. The argument of the function can be any model that implements the "
"`Model` trait :"
msgstr ""
"假設我們有一個 `solve` 函式，會在模型上運作並改變其狀態。該函式的參數可以是任"
"何實作 `Model` trait 的模型："

#: src/trait-bounds.md:36 src/trait-bounds.md:479
msgid "\"Magic solver that mutates the model into a resolved state\""
msgstr ""

#: src/trait-bounds.md:40
msgid "Let's assume we have the following constraints:"
msgstr "假設我們有以下限制："

#: src/trait-bounds.md:42
msgid "We cannot change that code as it runs on many Rust models."
msgstr "我們不能修改該程式碼，因為它已用在許多 Rust 模型上。"

#: src/trait-bounds.md:43
msgid ""
"We also have many Python models that cannot be solved as this solver is not "
"available in that language."
msgstr "我們也有許多 Python 模型無法被求解，因為該求解器在那個語言中不可用。"

#: src/trait-bounds.md:45
msgid ""
"Rewriting it in Python would be cumbersome and error-prone, as everything is "
"already available in Rust."
msgstr "由於一切都已在 Rust 中可用，把它改寫成 Python 既繁瑣又容易出錯。"

#: src/trait-bounds.md:47
msgid "How could we expose this solver to Python thanks to PyO3 ?"
msgstr "那我們該如何透過 PyO3 將此求解器提供給 Python 使用？"

#: src/trait-bounds.md:49
msgid "Implementation of the trait bounds for the Python class"
msgstr "為 Python 類別實作 trait bounds"

#: src/trait-bounds.md:51
msgid ""
"If a Python class implements the same three methods as the `Model` trait, it "
"seems logical it could be adapted to use the solver. However, it is not "
"possible to pass a `Py<PyAny>` to it as it does not implement the Rust trait "
"(even if the Python model has the required methods)."
msgstr ""
"如果某個 Python 類別實作了與 `Model` trait 相同的三個方法，直覺上它應該能配合"
"此求解器。但實際上無法傳入 `Py<PyAny>`，因為它沒有實作 Rust 的 trait（即便 "
"Python 模型具備所需方法也一樣）。"

#: src/trait-bounds.md:54
msgid ""
"In order to implement the trait, we must write a wrapper around the calls in "
"Rust to the Python model. The method signatures must be the same as the "
"trait, keeping in mind that the Rust trait cannot be changed for the purpose "
"of making the code available in Python."
msgstr ""
"為了實作該 trait，我們必須在 Rust 端撰寫一個包裝器來呼叫 Python 模型。方法簽"
"章必須與 trait 相同，因為 Rust trait 不能為了讓程式碼可在 Python 使用而被修"
"改。"

#: src/trait-bounds.md:57
msgid ""
"The Python model we want to expose is the following one, which already "
"contains all the required methods:"
msgstr "以下是我們想要對外暴露的 Python 模型，已包含所有必要方法："

#: src/trait-bounds.md:69
msgid ""
"The following wrapper will call the Python model from Rust, using a struct "
"to hold the model as a `PyAny` object:"
msgstr ""
"以下包裝器會從 Rust 呼叫 Python 模型，使用結構來持有該模型的 `PyAny` 物件："

#: src/trait-bounds.md:88 src/trait-bounds.md:188 src/trait-bounds.md:367
#: src/trait-bounds.md:426 src/trait-bounds.md:523
msgid "\"Rust calling Python to set the variables\""
msgstr ""

#: src/trait-bounds.md:92 src/trait-bounds.md:191 src/trait-bounds.md:370
#: src/trait-bounds.md:429 src/trait-bounds.md:527
msgid "\"set_variables\""
msgstr ""

#: src/trait-bounds.md:98 src/trait-bounds.md:197 src/trait-bounds.md:356
msgid "\"Rust calling Python to get the results\""
msgstr ""

#: src/trait-bounds.md:102 src/trait-bounds.md:201 src/trait-bounds.md:360
#: src/trait-bounds.md:412 src/trait-bounds.md:538
msgid "\"get_results\""
msgstr ""

#: src/trait-bounds.md:110 src/trait-bounds.md:209 src/trait-bounds.md:376
#: src/trait-bounds.md:435 src/trait-bounds.md:553
msgid "\"Rust calling Python to perform the computation\""
msgstr ""

#: src/trait-bounds.md:114 src/trait-bounds.md:213 src/trait-bounds.md:380
#: src/trait-bounds.md:439 src/trait-bounds.md:557
msgid "\"compute\""
msgstr ""

#: src/trait-bounds.md:121
msgid ""
"Now that this bit is implemented, let's expose the model wrapper to Python. "
"Let's add the PyO3 annotations and add a constructor:"
msgstr ""
"上述部分完成後，讓我們將模型包裝器對外暴露給 Python。加上 PyO3 標註並新增建構"
"子："

#: src/trait-bounds.md:154
msgid "Now we add the PyO3 annotations to the trait implementation:"
msgstr "接著在 trait 實作上加入 PyO3 標註："

#: src/trait-bounds.md:159
msgid "// the previous trait implementation\n"
msgstr "// 前述的 trait 實作\n"

#: src/trait-bounds.md:163
msgid ""
"However, the previous code will not compile. The compilation error is the "
"following one: `error: #[pymethods] cannot be used on trait impl blocks`"
msgstr ""
"然而，前述程式碼無法編譯。錯誤訊息如下：`error: #[pymethods] cannot be used "
"on trait impl blocks`"

#: src/trait-bounds.md:166
msgid ""
"That's a bummer! However, we can write a second wrapper around these "
"functions to call them directly. This wrapper will also perform the type "
"conversions between Python and Rust."
msgstr ""
"這很可惜！不過，我們可以再寫一個包裝器來直接呼叫這些函式。該包裝器也會負責在 "
"Python 與 Rust 之間進行型別轉換。"

#: src/trait-bounds.md:223 src/trait-bounds.md:501
msgid "\"Set variables from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 來設定變數\""

#: src/trait-bounds.md:228 src/trait-bounds.md:506
msgid "\"Get results from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 取得結果\""

#: src/trait-bounds.md:233
msgid "\"Compute from Python calling Rust\""
msgstr "\"從 Python 呼叫 Rust 執行計算\""

#: src/trait-bounds.md:239
msgid ""
"This wrapper handles the type conversion between the PyO3 requirements and "
"the trait. In order to meet PyO3 requirements, this wrapper must:"
msgstr ""
"這個包裝器會處理 PyO3 要求與 trait 之間的型別轉換。為了符合 PyO3 的要求，此包"
"裝器必須："

#: src/trait-bounds.md:242
msgid "return an object of type `PyResult`"
msgstr "回傳 `PyResult` 型別的物件"

#: src/trait-bounds.md:243
msgid "use only values, not references in the method signatures"
msgstr "在方法簽章中僅使用值，而非參照"

#: src/trait-bounds.md:245
msgid "Let's run the file python file:"
msgstr "讓我們執行這個 Python 檔案："

#: src/trait-bounds.md:256
msgid "\"__main__\""
msgstr ""

#: src/trait-bounds.md:262
msgid "\"Print value from Python: \""
msgstr ""

#: src/trait-bounds.md:264
msgid "\"Print value from Python through Rust: \""
msgstr ""

#: src/trait-bounds.md:265
msgid "\"Print value directly from Python: \""
msgstr ""

#: src/trait-bounds.md:268
msgid "This outputs:"
msgstr ""

#: src/trait-bounds.md:282
msgid ""
"We have now successfully exposed a Rust model that implements the `Model` "
"trait to Python!"
msgstr ""

#: src/trait-bounds.md:284
msgid ""
"We will now expose the `solve` function, but before, let's talk about types "
"errors."
msgstr ""

#: src/trait-bounds.md:286
msgid "Type errors in Python"
msgstr ""

#: src/trait-bounds.md:288
msgid ""
"What happens if you have type errors when using Python and how can you "
"improve the error messages?"
msgstr ""

#: src/trait-bounds.md:290
msgid "Wrong types in Python function arguments"
msgstr ""

#: src/trait-bounds.md:292
msgid ""
"Let's assume in the first case that you will use in your Python file "
"`my_rust_model.set_variables(2.0)` instead of `my_rust_model."
"set_variables([2.0])`."
msgstr ""

#: src/trait-bounds.md:294
msgid ""
"The Rust signature expects a vector, which corresponds to a list in Python. "
"What happens if instead of a vector, we pass a single value ?"
msgstr ""

#: src/trait-bounds.md:297
msgid "At the execution of Python, we get :"
msgstr ""

#: src/trait-bounds.md:299
msgid ""
"```block\n"
"File \"main.py\", line 15, in <module>\n"
"   my_rust_model.set_variables(2)\n"
"TypeError\n"
"```"
msgstr ""

#: src/trait-bounds.md:305
msgid ""
"It is a type error and Python points to it, so it's easy to identify and "
"solve."
msgstr ""

#: src/trait-bounds.md:307
msgid "Wrong types in Python method signatures"
msgstr ""

#: src/trait-bounds.md:309
msgid ""
"Let's assume now that the return type of one of the methods of our Model "
"class is wrong, for example the `get_results` method that is expected to "
"return a `Vec<f64>` in Rust, a list in Python."
msgstr ""

#: src/trait-bounds.md:319
msgid "#return self.results <-- this is the expected output\n"
msgstr ""

#: src/trait-bounds.md:322
msgid "This call results in the following panic:"
msgstr ""

#: src/trait-bounds.md:328
msgid ""
"This error code is not helpful for a Python user that does not know anything "
"about Rust, or someone that does not know PyO3 was used to interface the "
"Rust code."
msgstr ""

#: src/trait-bounds.md:330
msgid ""
"However, as we are responsible for making the Rust code available to Python, "
"we can do something about it."
msgstr ""

#: src/trait-bounds.md:332
msgid ""
"The issue is that we called `unwrap` anywhere we could, and therefore any "
"panic from PyO3 will be directly forwarded to the end user."
msgstr ""

#: src/trait-bounds.md:334
msgid ""
"Let's modify the code performing the type conversion to give a helpful error "
"message to the Python user:"
msgstr ""

#: src/trait-bounds.md:336
msgid ""
"We used in our `get_results` method the following call that performs the "
"type conversion:"
msgstr ""

#: src/trait-bounds.md:387
msgid "Let's break it down in order to perform better error handling:"
msgstr ""

#: src/trait-bounds.md:407 src/trait-bounds.md:533
msgid "\"Get results from Rust calling Python\""
msgstr ""

#: src/trait-bounds.md:415 src/trait-bounds.md:541
msgid "\"list\""
msgstr ""

#: src/trait-bounds.md:417 src/trait-bounds.md:543
msgid "\"Expected a list for the get_results() method signature, got {}\""
msgstr ""

#: src/trait-bounds.md:446
msgid ""
"By doing so, you catch the result of the Python computation and check its "
"type in order to be able to deliver a better error message before performing "
"the unwrapping."
msgstr ""

#: src/trait-bounds.md:448
msgid ""
"Of course, it does not cover all the possible wrong outputs: the user could "
"return a list of strings instead of a list of floats. In this case, a "
"runtime panic would still occur due to PyO3, but with an error message much "
"more difficult to decipher for non-rust user."
msgstr ""

#: src/trait-bounds.md:452
msgid ""
"It is up to the developer exposing the rust code to decide how much effort "
"to invest into Python type error handling and improved error messages."
msgstr ""

#: src/trait-bounds.md:454
msgid "The final code"
msgstr ""

#: src/trait-bounds.md:456
msgid ""
"Now let's expose the `solve()` function to make it available from Python."
msgstr ""

#: src/trait-bounds.md:458
msgid ""
"It is not possible to directly expose the `solve` function to Python, as the "
"type conversion cannot be performed. It requires an object implementing the "
"`Model` trait as input."
msgstr ""

#: src/trait-bounds.md:461
msgid ""
"However, the `UserModel` already implements this trait. Because of this, we "
"can write a function wrapper that takes the `UserModel`\\--which has already "
"been exposed to Python--as an argument in order to call the core function "
"`solve`."
msgstr ""

#: src/trait-bounds.md:464
msgid "It is also required to make the struct public."
msgstr ""

#: src/trait-bounds.md:483
msgid "\"solve\""
msgstr ""
