msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:53Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/exception.md:1
msgid "Python Exception"
msgstr ""

#: src/exception.md:3
msgid "Define a new exception"
msgstr ""

#: src/exception.md:5
msgid "You can use the `py_exception!` macro to define a new exception type:"
msgstr ""

#: src/exception.md:11
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:12
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:14
msgid "For example:"
msgstr "例如："

#: src/exception.md:28
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:30
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:31
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:35
msgid "Raise an exception"
msgstr ""

#: src/exception.md:37
msgid ""
"To raise an exception, first you need to obtain an exception type and "
"construct a new [`PyErr`](https://pyo3.github.io/pyo3/pyo3/struct.PyErr."
"html), then call [`PyErr::restore()`](https://pyo3.github.io/pyo3/pyo3/"
"struct.PyErr.html#method.restore) method to write the exception back to the "
"Python interpreter's global state."
msgstr ""

#: src/exception.md:47
msgid "\"Error\""
msgstr ""

#: src/exception.md:53
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance()`](https://pyo3.github.io/pyo3/pyo3/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:59
msgid ""
"If rust type exists for exception, then it is possible to use `new` method. "
"For example each standard exception defined in `exc` module has "
"corresponding rust type, exceptions defined by `py_exception!` and "
"`import_exception!` macro have rust type as well."
msgstr ""

#: src/exception.md:68
msgid "\"argument is wrong\""
msgstr ""

#: src/exception.md:76
msgid "Check exception type"
msgstr ""

#: src/exception.md:78
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check object type, in `PyO3` there is a [`Python::"
"is_instance()`](https://pyo3.github.io/pyo3/pyo3/struct.Python.html#method."
"is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:96
msgid ""
"[`Python::is_instance()`](https://pyo3.github.io/pyo3/pyo3/struct.Python."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://pyo3.github.io/pyo3/pyo3/struct.PyType.html#method.is_instance) "
"method to do the actual work."
msgstr ""

#: src/exception.md:98
msgid "To check the type of an exception, you can simply do:"
msgstr ""

#: src/exception.md:101
msgid "\"Error calling is_instance\""
msgstr ""

#: src/exception.md:104
msgid "Handle Rust Error"
msgstr ""

#: src/exception.md:106
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://pyo3.github.io/pyo3/pyo3/type.PyResult.html). This is an alias for "
"the type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:109
msgid ""
"A [`PyErr`](https://pyo3.github.io/pyo3/pyo3/struct.PyErr.html) represents a "
"Python exception. Errors within the `PyO3` library are also exposed as "
"Python exceptions."
msgstr ""

#: src/exception.md:112
msgid ""
"PyO3 library handles python exception in two stages. During first stage "
"`PyErr` instance get created. At this stage python GIL is not required. "
"During second stage, actual python exception instance get crated and set to "
"python interpreter."
msgstr ""

#: src/exception.md:116
msgid ""
"In simple case, for custom errors support implementation of `std::convert::"
"From<T>` trait for this custom error is enough. `PyErr::new` accepts "
"arguments in form of `ToPyObject + 'static`. In case if `'static` constraint "
"can not be satisfied or more complex arguments are required [`PyErrArgument`]"
"(https://pyo3.github.io/pyo3/pyo3/trait.PyErrArguments.html) trait can be "
"implemented. In that case actual exception arguments creation get delayed "
"until `Python` object is available."
msgstr ""

#: src/exception.md:135
msgid "\"127.0.0.1:80\""
msgstr ""

#: src/exception.md:141
msgid ""
"The code snippet above will raise `OSError` in Python if `TcpListener::"
"bind()` return an error."
msgstr ""

#: src/exception.md:143
msgid ""
"`std::convert::From<T>` trait is implemented for most of the standard "
"library's error types so `try!` macro or `?` operator can be used."
msgstr ""

#: src/exception.md:154
msgid ""
"The code snippet above will raise `ValueError` in Python if `String::"
"parse()` return an error."
msgstr ""

#: src/exception.md:157
msgid "Using exceptions defined in python code"
msgstr ""

#: src/exception.md:159
msgid ""
"It is possible to use exception defined in python code as native rust types. "
"`import_exception!` macro allows to import specific exception class and "
"defined zst type for that exception."
msgstr ""

#: src/exception.md:178
msgid ""
"[`exc`](https://pyo3.github.io/pyo3/pyo3/exc/index.html) defines exceptions "
"for several standard library modules."
msgstr ""
