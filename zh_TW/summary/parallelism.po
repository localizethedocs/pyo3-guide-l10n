msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:54Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/parallelism.md:1
msgid "Parallelism"
msgstr "平行化"

#: src/parallelism.md:3
msgid ""
"Historically, CPython was limited by the [global interpreter lock](https://"
"docs.python.org/3/glossary.html#term-global-interpreter-lock) (GIL), which "
"only allowed a single thread to drive the Python interpreter at a time. This "
"made threading in Python a bad fit for [CPU-bound](https://en.wikipedia.org/"
"wiki/CPU-bound) tasks and often forced developers to accept the overhead of "
"multiprocessing."
msgstr ""
"歷史上，CPython 受[全域直譯器鎖](https://docs.python.org/3/glossary."
"html#term-global-interpreter-lock)（GIL）限制，一次只允許單一執行緒驅動 "
"Python 直譯器。這使得 Python 的執行緒對[CPU-bound](https://en.wikipedia.org/"
"wiki/CPU-bound) 任務不太合適，並常迫使開發者接受多行程的額外負擔。"

#: src/parallelism.md:5
msgid ""
"Rust is well-suited to multithreaded code, and libraries like [`rayon`]"
"(https://github.com/rayon-rs/rayon) can help you leverage safe parallelism "
"with minimal effort. The [`Python::detach`](https://pyo3.rs/main/doc/pyo3/"
"marker/struct.Python.html#method.detach) method can be used to allow the "
"Python interpreter to do other work while the Rust work is ongoing."
msgstr ""
"Rust 很適合多執行緒程式碼，而像 [`rayon`](https://github.com/rayon-rs/rayon) "
"這樣的函式庫能讓你以最小成本運用安全的平行化。[`Python::detach`](https://"
"pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) 方法可讓 "
"Python 直譯器在 Rust 工作進行時處理其他工作。"

#: src/parallelism.md:7
msgid ""
"To enable full parallelism in your application, consider also using [free-"
"threaded Python](./free-threading.md) which is supported since Python 3.14."
msgstr ""
"若要在應用程式中啟用完整平行化，也可考慮使用自 Python 3.14 起支援的[自由執行"
"緒 Python](./free-threading.md)。"

#: src/parallelism.md:9
msgid "Parallelism under the Python GIL"
msgstr "Python GIL 下的平行化"

#: src/parallelism.md:11
msgid ""
"Let's take a look at our [word-count](https://github.com/PyO3/pyo3/blob/main/"
"examples/word-count/src/lib.rs) example, where we have a `search` function "
"that utilizes the [`rayon`](https://github.com/rayon-rs/rayon) crate to "
"count words in parallel."
msgstr ""
"我們來看看 [word-count](https://github.com/PyO3/pyo3/blob/main/examples/word-"
"count/src/lib.rs) 範例，其中的 `search` 函式使用 [`rayon`](https://github."
"com/rayon-rs/rayon) 軟體箱以平行方式計算字數。"

#: src/parallelism.md:16
msgid "// These traits let us use `par_lines` and `map`.\n"
msgstr "// 這些特徵讓我們可以使用 `par_lines` 和 `map`。\n"

#: src/parallelism.md:20
msgid "/// Count the occurrences of needle in line, case insensitive\n"
msgstr "/// 計算某行中 needle 出現次數，不區分大小寫\n"

#: src/parallelism.md:24 src/parallelism.md:47 src/parallelism.md:68
msgid "' '"
msgstr ""

#: src/parallelism.md:41
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""
"假設你有一個耗時的 Rust 函式，想要平行執行多次。以下以字數統計的序列版作為範"
"例："

#: src/parallelism.md:60
msgid ""
"To enable parallel execution of this function, the [`Python::detach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) "
"method can be used to temporarily release the GIL, thus allowing other "
"Python threads to run. We then have a function exposed to the Python runtime "
"which calls `search_sequential` inside a closure passed to [`Python::detach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) to "
"enable true parallelism:"
msgstr ""
"要讓此函式平行執行，可以使用 [`Python::detach`](https://pyo3.rs/main/doc/"
"pyo3/marker/struct.Python.html#method.detach) 暫時釋放 GIL，讓其他 Python 執"
"行緒得以運作。接著我們提供一個暴露給 Python 執行環境的函式，將 "
"`search_sequential` 放在傳給 [`Python::detach`](https://pyo3.rs/main/doc/"
"pyo3/marker/struct.Python.html#method.detach) 的閉包中，以實現真正的平行化："

#: src/parallelism.md:85
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""
"現在 Python 執行緒可使用多個 CPU 核心，解決了 Python 多執行緒通常只適合 I/O-"
"bound 任務的限制："

#: src/parallelism.md:103
msgid "Benchmark"
msgstr "基準測試"

#: src/parallelism.md:105
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr "讓我們對 `word-count` 範例做基準測試，確認 PyO3 確實解鎖了平行化。"

#: src/parallelism.md:107
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr "我們使用 `pytest-benchmark` 來測試四個字數統計函式："

#: src/parallelism.md:109
msgid "Pure Python version"
msgstr "純 Python 版本"

#: src/parallelism.md:110
msgid "Rust parallel version"
msgstr "Rust 平行版本"

#: src/parallelism.md:111
msgid "Rust sequential version"
msgstr "Rust 序列版本"

#: src/parallelism.md:112
msgid "Rust sequential version executed twice with two Python threads"
msgstr "Rust 序列版本在兩個 Python 執行緒中執行兩次"

#: src/parallelism.md:114
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `nox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""
"基準測試腳本在[這裡](https://github.com/PyO3/pyo3/blob/main/examples/word-"
"count/tests/test_word_count.py)，我們可在 `word-count` 資料夾中執行 `nox` 進"
"行測試。"

#: src/parallelism.md:116
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr "雖然基準測試結果會因機器而異，但相對結果應與下圖（2020 年中）相近："

#: src/parallelism.md:129
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""
"可以看到 Python 執行緒版本沒有比 Rust 序列版本慢太多，這代表相較於單一 CPU 核"
"心的執行，速度翻倍。"

#: src/parallelism.md:131
msgid "Sharing Python objects between Rust threads"
msgstr "在 Rust 執行緒間共享 Python 物件"

#: src/parallelism.md:133
msgid ""
"In the example above we made a Python interface to a low-level rust "
"function, and then leveraged the python `threading` module to run the low-"
"level function in parallel. It is also possible to spawn threads in Rust "
"that acquire the GIL and operate on Python objects. However, care must be "
"taken to avoid writing code that deadlocks with the GIL in these cases."
msgstr ""
"在上述範例中，我們為底層 Rust 函式建立了 Python 介面，並利用 Python 的 "
"`threading` 模組平行執行該函式。也可以在 Rust 中啟動執行緒，取得 GIL 並操作 "
"Python 物件。不過在這些情況下必須小心，避免寫出會與 GIL 死結的程式碼。"

#: src/parallelism.md:139
msgid ""
"Note: This example is meant to illustrate how to drop and re-acquire the GIL "
"to avoid creating deadlocks. Unless the spawned threads subsequently release "
"the GIL or you are using the free-threaded build of CPython, you will not "
"see any speedups due to multi-threaded parallelism using `rayon` to "
"parallelize code that acquires and holds the GIL for the entire execution of "
"the spawned thread."
msgstr ""
"注意：此範例用來示範如何釋放並重新取得 GIL 以避免死結。除非啟動的執行緒之後會"
"釋放 GIL，或你使用的是 CPython 的自由執行緒建置，否則用 `rayon` 平行化會在整"
"個執行期間取得並持有 GIL 的程式碼，並不會帶來多執行緒的速度提升。"

#: src/parallelism.md:146
msgid ""
"In the example below, we share a `Vec` of User ID objects defined using the "
"`pyclass` macro and spawn threads to process the collection of data into a "
"`Vec` of booleans based on a predicate using a `rayon` parallel iterator:"
msgstr ""
"在下方範例中，我們共享一個使用 `pyclass` 巨集定義的使用者 ID 物件 `Vec`，並啟"
"動執行緒，透過 `rayon` 的平行迭代器以判斷條件將資料集合處理成 `Vec` 的布林"
"值："

#: src/parallelism.md:152
msgid "// These traits let us use int_par_iter and map\n"
msgstr "// 這些特徵讓我們可以使用 int_par_iter 和 map\n"

#: src/parallelism.md:174
msgid ""
"It's important to note that there is an `outer_py` Python token as well as "
"an `inner_py` token. Sharing Python tokens between threads is not allowed "
"and threads must individually attach to the interpreter to access data "
"wrapped by a Python object."
msgstr ""
"請注意這裡同時有 `outer_py` 與 `inner_py` 兩個 Python token。在執行緒之間共"
"享 Python token 是不允許的，執行緒必須各自附加到直譯器，才能存取 Python 物件"
"包裹的資料。"

#: src/parallelism.md:179
msgid ""
"It's also important to see that this example uses [`Python::detach`](https://"
"pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.detach) to wrap the "
"code that spawns OS threads via `rayon`. If this example didn't use "
"`detach`, a `rayon` worker thread would block on acquiring the GIL while a "
"thread that owns the GIL spins forever waiting for the result of the `rayon` "
"thread. Calling `detach` allows the GIL to be released in the thread "
"collecting the results from the worker threads. You should always call "
"`detach` in situations that spawn worker threads, but especially so in cases "
"where worker threads need to acquire the GIL, to prevent deadlocks."
msgstr ""
"此外，此範例使用 [`Python::detach`](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#method.detach) 包裹透過 `rayon` 啟動 OS 執行緒的程式碼。若"
"未使用 `detach`，`rayon` 工作執行緒會在取得 GIL 時阻塞，而擁有 GIL 的執行緒會"
"無限等待 `rayon` 執行緒結果。呼叫 `detach` 可讓收集工作執行緒結果的執行緒釋"
"放 GIL。只要會啟動工作執行緒，就應呼叫 `detach`，尤其在工作執行緒需要取得 "
"GIL 的情況下，以避免死結。"
