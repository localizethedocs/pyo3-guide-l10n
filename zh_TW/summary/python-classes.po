msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class.md:1
msgid "Python Classes"
msgstr ""

#: src/class.md:3
msgid ""
"PyO3 exposes a group of attributes powered by Rust's proc macro system for "
"defining Python classes as Rust structs."
msgstr ""

#: src/class.md:5
msgid ""
"The main attribute is `#[pyclass]`, which is placed upon a Rust `struct` or "
"a fieldless `enum` (a.k.a. C-like enum) to generate a Python type for it. "
"They will usually also have _one_ `#[pymethods]`\\-annotated `impl` block "
"for the struct, which is used to define Python methods and constants for the "
"generated Python type. (If the [`multiple-pymethods`](features.md#multiple-"
"pymethods) feature is enabled each `#[pyclass]` is allowed to have multiple "
"`#[pymethods]` blocks.) `#[pymethods]` may also have implementations for "
"Python magic methods such as `__str__`."
msgstr ""

#: src/class.md:7
msgid ""
"This chapter will discuss the functionality and configuration these "
"attributes offer. Below is a list of links to the relevant section of this "
"chapter for each:"
msgstr ""

#: src/class.md:9
msgid "[`#[pyclass]`](#defining-a-new-class)"
msgstr ""

#: src/class.md:10
msgid "[`#[pyo3(get, set)]`](#object-properties-using-pyo3get-set)"
msgstr ""

#: src/class.md:11
msgid "[`#[pymethods]`](#instance-methods)"
msgstr "[`#[pymethods]`](#instance-methods)"

#: src/class.md:12
msgid "[`#[new]`](#constructor)"
msgstr "[`#[new]`](#constructor)"

#: src/class.md:13
msgid "[`#[getter]`](#object-properties-using-getter-and-setter)"
msgstr "[`#[getter]`](#object-properties-using-getter-and-setter)"

#: src/class.md:14
msgid "[`#[setter]`](#object-properties-using-getter-and-setter)"
msgstr "[`#[setter]`](#object-properties-using-getter-and-setter)"

#: src/class.md:15
msgid "[`#[staticmethod]`](#static-methods)"
msgstr "[`#[staticmethod]`](#static-methods)"

#: src/class.md:16
msgid "[`#[classmethod]`](#class-methods)"
msgstr "[`#[classmethod]`](#class-methods)"

#: src/class.md:17
msgid "[`#[classattr]`](#class-attributes)"
msgstr "[`#[classattr]`](#class-attributes)"

#: src/class.md:18
msgid "[`#[args]`](#method-arguments)"
msgstr "[`#[args]`](#method-arguments)"

#: src/class.md:19
msgid "[Magic methods and slots](class/protocols.html)"
msgstr ""

#: src/class.md:21
msgid "Defining a new class"
msgstr "定義新類別"

#: src/class.md:23
msgid ""
"To define a custom Python class, add the `#[pyclass]` attribute to a Rust "
"struct or a fieldless enum."
msgstr ""

#: src/class.md:32
msgid "// A \"tuple\" struct\n"
msgstr ""

#: src/class.md:36
msgid "// PyO3 supports custom discriminants in enums\n"
msgstr ""

#: src/class.md:43
msgid "// ...\n"
msgstr ""

#: src/class.md:49
msgid "// PyO3 supports custom discriminants.\n"
msgstr ""

#: src/class.md:53
msgid ""
"Because Python objects are freely shared between threads by the Python "
"interpreter, all types annotated with `#[pyclass]` must implement `Send` "
"(unless annotated with [`#[pyclass(unsendable)]`](#customizing-the-class))."
msgstr ""

#: src/class.md:55
msgid ""
"The above example generates implementations for [`PyTypeInfo`](https://pyo3."
"rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html), [`PyTypeObject`]"
"(https://pyo3.rs/main/doc/pyo3/type_object/trait.PyTypeObject.html), and "
"[`PyClass`](https://pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html) for "
"`MyClass` and `MyEnum`. To see these generated implementations, refer to the "
"[implementation details](#implementation-details) at the end of this chapter."
msgstr ""

#: src/class.md:57
msgid "Constructor"
msgstr ""

#: src/class.md:59
msgid ""
"By default it is not possible to create an instance of a custom class from "
"Python code. To declare a constructor, you need to define a method and "
"annotate it with the `#[new]` attribute. Only Python's `__new__` method can "
"be specified, `__init__` is not available."
msgstr ""

#: src/class.md:77
msgid ""
"Alternatively, if your `new` method may fail you can return `PyResult<Self>`."
msgstr ""

#: src/class.md:90
msgid "\"cannot be zero\""
msgstr ""

#: src/class.md:98
msgid ""
"As you can see, the Rust method name is not important here; this way you can "
"still use `new()` for a Rust-level constructor."
msgstr ""

#: src/class.md:101
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:104
msgid "For arguments, see the `Method arguments` section below."
msgstr ""

#: src/class.md:106
msgid "Adding the class to a module"
msgstr ""

#: src/class.md:108
msgid ""
"The next step is to create the module initializer and add our class to it"
msgstr ""

#: src/class.md:122
msgid "PyCell and interior mutability"
msgstr ""

#: src/class.md:124
msgid ""
"You sometimes need to convert your `pyclass` into a Python object and access "
"it from Rust code (e.g., for testing it). [`PyCell`](https://pyo3.rs/main/"
"doc/pyo3/pycell/struct.PyCell.html) is the primary interface for that."
msgstr ""

#: src/class.md:128
msgid ""
"`PyCell<T: PyClass>` is always allocated in the Python heap, so Rust doesn't "
"have ownership of it. In other words, Rust code can only extract a "
"`&PyCell<T>`, not a `PyCell<T>`."
msgstr ""

#: src/class.md:131
msgid ""
"Thus, to mutate data behind `&PyCell` safely, PyO3 employs the [Interior "
"Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-"
"mutability.html) like [`RefCell`](https://doc.rust-lang.org/std/cell/struct."
"RefCell.html)."
msgstr ""

#: src/class.md:135
msgid ""
"Users who are familiar with `RefCell` can use `PyCell` just like `RefCell`."
msgstr ""

#: src/class.md:137
msgid ""
"For users who are not very familiar with `RefCell`, here is a reminder of "
"Rust's rules of borrowing:"
msgstr ""

#: src/class.md:138
msgid ""
"At any given time, you can have either (but not both of) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/class.md:139
msgid "References must always be valid."
msgstr ""

#: src/class.md:141
msgid ""
"`PyCell`, like `RefCell`, ensures these borrowing rules by tracking "
"references at runtime."
msgstr ""

#: src/class.md:153
msgid "// Get PyRef\n"
msgstr ""

#: src/class.md:155
msgid "// You cannot get PyRefMut unless all PyRefs are dropped\n"
msgstr ""

#: src/class.md:159
msgid "// Get PyRefMut\n"
msgstr ""

#: src/class.md:161
msgid "// You cannot get any other refs until the PyRefMut is dropped\n"
msgstr ""

#: src/class.md:166
msgid "// You can convert `&PyCell` to a Python object\n"
msgstr ""

#: src/class.md:167
msgid "\"assert obj.num == 5\""
msgstr ""

#: src/class.md:171
msgid ""
"`&PyCell<T>` is bounded by the same lifetime as a [`GILGuard`](https://pyo3."
"rs/main/doc/pyo3/struct.GILGuard.html). To make the object longer lived (for "
"example, to store it in a struct on the Rust side), you can use `Py<T>`, "
"which stores an object longer than the GIL lifetime, and therefore needs a "
"`Python<'_>` token to access."
msgstr ""

#: src/class.md:190
msgid "// Py<MyClass>::as_ref returns &PyCell<MyClass>\n"
msgstr ""

#: src/class.md:191
msgid "// Get PyRef<T>\n"
msgstr ""

#: src/class.md:196
msgid "Customizing the class"
msgstr ""

#: src/class.md:198
msgid "`#[pyclass]` can be used with the following parameters:"
msgstr ""

#: src/class.md:200
msgid "Parameter"
msgstr ""

#: src/class.md:200
msgid "Description"
msgstr "說明"

#: src/class.md:202
msgid "<span style=\"white-space: pre\">`crate = \"some::path\"`</span>"
msgstr ""

#: src/class.md:202
msgid "Path to import the `pyo3` crate, if it's not accessible at `::pyo3`."
msgstr ""

#: src/class.md:203
msgid "`dict`"
msgstr ""

#: src/class.md:203
msgid ""
"Gives instances of this class an empty `__dict__` to store custom attributes."
msgstr ""

#: src/class.md:204
msgid "<span style=\"white-space: pre\">`extends = BaseType`</span>"
msgstr ""

#: src/class.md:204
msgid ""
"Use a custom baseclass. Defaults to [`PyAny`](https://pyo3.rs/main/doc/pyo3/"
"prelude/struct.PyAny.html)"
msgstr ""

#: src/class.md:205
msgid "<span style=\"white-space: pre\">`freelist = N`</span>"
msgstr ""

#: src/class.md:205
msgid ""
"Implements a [free list](https://en.wikipedia.org/wiki/Free_list) of size N. "
"This can improve performance for types that are often created and deleted in "
"quick succession. Profile your code to see whether `freelist` is right for "
"you."
msgstr ""

#: src/class.md:206
msgid "`mapping`"
msgstr ""

#: src/class.md:206
msgid ""
"Inform PyO3 that this class is a [`Mapping`](./class/protocols.md#mapping--"
"sequence-types), and so leave its implementation of sequence C-API slots "
"empty."
msgstr ""

#: src/class.md:207
msgid "<span style=\"white-space: pre\">`module = \"module_name\"`</span>"
msgstr ""

#: src/class.md:207
msgid ""
"Python code will see the class as being defined in this module. Defaults to "
"`builtins`."
msgstr ""

#: src/class.md:208
msgid "<span style=\"white-space: pre\">`name = \"python_name\"`</span>"
msgstr ""

#: src/class.md:208
msgid ""
"Sets the name that Python sees this class as. Defaults to the name of the "
"Rust struct."
msgstr ""

#: src/class.md:209
msgid ""
"<span style=\"white-space: pre\">`text_signature = \"(arg1, arg2, ...)\"`</"
"span>"
msgstr ""

#: src/class.md:209
msgid "Sets the text signature for the Python class' `__new__` method."
msgstr ""

#: src/class.md:210
msgid "`subclass`"
msgstr ""

#: src/class.md:210
msgid ""
"Allows other Python classes and `#[pyclass]` to inherit from this class. "
"Enums cannot be subclassed."
msgstr ""

#: src/class.md:211
msgid "`unsendable`"
msgstr ""

#: src/class.md:211
msgid ""
"Required if your struct is not [`Send`](https://doc.rust-lang.org/stable/std/"
"marker/trait.Send.html). Rather than using `unsendable`, consider "
"implementing your struct in a threadsafe way by e.g. substituting [`Rc`]"
"(https://doc.rust-lang.org/stable/std/rc/struct.Rc.html) with [`Arc`]"
"(https://doc.rust-lang.org/stable/std/sync/struct.Rc.html). By using "
"`unsendable`, your class will panic when accessed by another thread."
msgstr ""

#: src/class.md:212
msgid "`weakref`"
msgstr ""

#: src/class.md:212
msgid ""
"Allows this class to be [weakly referenceable](https://docs.python.org/3/"
"library/weakref.html)."
msgstr ""

#: src/class.md:214
msgid ""
"All of these parameters can either be passed directly on the "
"`#[pyclass(...)]` annotation, or as one or more accompanying `#[pyo3(...)]` "
"annotations, e.g.:"
msgstr ""

#: src/class.md:218
msgid "// Argument supplied directly to the `#[pyclass]` annotation.\n"
msgstr ""

#: src/class.md:219 src/class.md:224
msgid "\"SomeName\""
msgstr ""

#: src/class.md:221
msgid "// Argument supplied as a separate annotation.\n"
msgstr ""

#: src/class.md:236
msgid "These parameters are covered in various sections of this guide."
msgstr ""

#: src/class.md:238
msgid "Return type"
msgstr ""

#: src/class.md:240
msgid ""
"Generally, `#[new]` method have to return `T: "
"Into<PyClassInitializer<Self>>` or `PyResult<T> where T: "
"Into<PyClassInitializer<Self>>`."
msgstr ""

#: src/class.md:243
msgid ""
"For constructors that may fail, you should wrap the return type in a "
"PyResult as well. Consult the table below to determine which type your "
"constructor should return:"
msgstr ""

#: src/class.md:246
msgid "**Cannot fail**"
msgstr ""

#: src/class.md:246
msgid "**May fail**"
msgstr ""

#: src/class.md:248
msgid "**No inheritance**"
msgstr ""

#: src/class.md:248
msgid "`T`"
msgstr "`T`"

#: src/class.md:248
msgid "`PyResult<T>`"
msgstr ""

#: src/class.md:249
msgid "**Inheritance(T Inherits U)**"
msgstr ""

#: src/class.md:249
msgid "`(T, U)`"
msgstr "`(T, U)`"

#: src/class.md:249
msgid "`PyResult<(T, U)>`"
msgstr ""

#: src/class.md:250
msgid "**Inheritance(General Case)**"
msgstr ""

#: src/class.md:250
msgid ""
"[`PyClassInitializer<T>`](https://pyo3.rs/main/doc/pyo3/pyclass_init/struct."
"PyClassInitializer.html)"
msgstr ""

#: src/class.md:250
msgid "`PyResult<PyClassInitializer<T>>`"
msgstr ""

#: src/class.md:252
msgid "Inheritance"
msgstr ""

#: src/class.md:254
msgid ""
"By default, `PyAny` is used as the base class. To override this default, use "
"the `extends` parameter for `pyclass` with the full path to the base class."
msgstr ""

#: src/class.md:257
msgid ""
"For convenience, `(T, U)` implements `Into<PyClassInitializer<T>>` where `U` "
"is the baseclass of `T`. But for more deeply nested inheritance, you have to "
"return `PyClassInitializer<T>` explicitly."
msgstr ""

#: src/class.md:262
msgid ""
"To get a parent class from a child, use [`PyRef`](https://pyo3.rs/main/doc/"
"pyo3/pycell/struct.PyRef.html) instead of `&self` for methods, or "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html) "
"instead of `&mut self`. Then you can access a parent class by `self_."
"as_ref()` as `&Self::BaseClass`, or by `self_.into_super()` as `PyRef<Self::"
"BaseClass>`."
msgstr ""

#: src/class.md:300
msgid "// Get &BaseClass\n"
msgstr ""

#: src/class.md:320
msgid "// Get PyRef<'_, SubClass>\n"
msgstr ""

#: src/class.md:326
msgid "\"assert subsub.method3() == 3000\""
msgstr ""

#: src/class.md:330
msgid ""
"You can also inherit native types such as `PyDict`, if they implement "
"[`PySizedLayout`](https://pyo3.rs/main/doc/pyo3/type_object/trait."
"PySizedLayout.html). However, this is not supported when building for the "
"Python limited API (aka the `abi3` feature of PyO3)."
msgstr ""

#: src/class.md:333
msgid ""
"However, because of some technical problems, we don't currently provide safe "
"upcasting methods for types that inherit native types. Even in such cases, "
"you can unsafely get a base class by raw pointer conversion."
msgstr ""

#: src/class.md:364
msgid "\"cnt.set('abc', 10); assert cnt['abc'] == 10\""
msgstr ""

#: src/class.md:369
msgid ""
"If `SubClass` does not provide a baseclass initialization, the compilation "
"fails."
msgstr ""

#: src/class.md:392
msgid "Object properties"
msgstr ""

#: src/class.md:394
msgid "PyO3 supports two ways to add properties to your `#[pyclass]`:"
msgstr ""

#: src/class.md:395
msgid ""
"For simple struct fields with no side effects, a `#[pyo3(get, set)]` "
"attribute can be added directly to the field definition in the `#[pyclass]`."
msgstr ""

#: src/class.md:396
msgid ""
"For properties which require computation you can define `#[getter]` and "
"`#[setter]` functions in the [`#[pymethods]`](#instance-methods) block."
msgstr ""

#: src/class.md:398
msgid "We'll cover each of these in the following sections."
msgstr ""

#: src/class.md:400
msgid "Object properties using `#[pyo3(get, set)]`"
msgstr ""

#: src/class.md:402
msgid ""
"For simple cases where a member variable is just read and written with no "
"side effects, you can declare getters and setters in your `#[pyclass]` field "
"definition using the `pyo3` attribute, like in the example below:"
msgstr ""

#: src/class.md:413
msgid ""
"The above would make the `num` field available for reading and writing as a "
"`self.num` Python property. To expose the property with a different name to "
"the field, specify this alongside the rest of the options, e.g. `#[pyo3(get, "
"set, name = \"custom_name\")]`."
msgstr ""

#: src/class.md:415
msgid ""
"Properties can be readonly or writeonly by using just `#[pyo3(get)]` or "
"`#[pyo3(set)]` respectively."
msgstr ""

#: src/class.md:417
msgid ""
"To use these annotations, your field type must implement some conversion "
"traits:"
msgstr ""

#: src/class.md:418
msgid ""
"For `get` the field type must implement both `IntoPy<PyObject>` and `Clone`."
msgstr ""

#: src/class.md:419
msgid "For `set` the field type must implement `FromPyObject`."
msgstr ""

#: src/class.md:421
msgid "Object properties using `#[getter]` and `#[setter]`"
msgstr ""

#: src/class.md:423
msgid ""
"For cases which don't satisfy the `#[pyo3(get, set)]` trait requirements, or "
"need side effects, descriptor methods can be defined in a `#[pymethods]` "
"`impl` block."
msgstr ""

#: src/class.md:425
msgid ""
"This is done using the `#[getter]` and `#[setter]` attributes, like in the "
"example below:"
msgstr ""

#: src/class.md:443
msgid ""
"A getter or setter's function name is used as the property name by default. "
"There are several ways how to override the name."
msgstr ""

#: src/class.md:446
msgid ""
"If a function name starts with `get_` or `set_` for getter or setter "
"respectively, the descriptor name becomes the function name with this prefix "
"removed. This is also useful in case of Rust keywords like `type` ([raw "
"identifiers](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/"
"raw-identifiers.html) can be used since Rust 2018)."
msgstr ""

#: src/class.md:473
msgid ""
"In this case, a property `num` is defined and available from Python code as "
"`self.num`."
msgstr ""

#: src/class.md:475
msgid ""
"Both the `#[getter]` and `#[setter]` attributes accept one parameter. If "
"this parameter is specified, it is used as the property name, i.e."
msgstr ""

#: src/class.md:499
msgid ""
"In this case, the property `number` is defined and available from Python "
"code as `self.number`."
msgstr ""

#: src/class.md:501
msgid ""
"Attributes defined by `#[setter]` or `#[pyo3(set)]` will always raise "
"`AttributeError` on `del` operations. Support for defining custom `del` "
"behavior is tracked in [\\#1778](https://github.com/PyO3/pyo3/issues/1778)."
msgstr ""

#: src/class.md:505
msgid "Instance methods"
msgstr ""

#: src/class.md:507
msgid ""
"To define a Python compatible method, an `impl` block for your struct has to "
"be annotated with the `#[pymethods]` attribute. PyO3 generates Python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:511
msgid ""
"Since Rust allows any number of `impl` blocks, you can easily split methods "
"between those accessible to Python (and Rust) and those accessible only to "
"Rust. However to have multiple `#[pymethods]`\\-annotated `impl` blocks for "
"the same struct you must enable the [`multiple-pymethods`](features."
"md#multiple-pymethods) feature of PyO3."
msgstr ""

#: src/class.md:534
msgid ""
"Calls to these methods are protected by the GIL, so both `&self` and `&mut "
"self` can be used. The return type must be `PyResult<T>` or `T` for some `T` "
"that implements `IntoPy<PyObject>`; the latter is allowed if the method "
"cannot raise Python exceptions."
msgstr ""

#: src/class.md:538
msgid ""
"A `Python` parameter can be specified as part of method signature, in this "
"case the `py` argument gets injected by the method wrapper, e.g."
msgstr ""

#: src/class.md:556
msgid ""
"From the Python perspective, the `method2` in this example does not accept "
"any arguments."
msgstr ""

#: src/class.md:558
msgid "Class methods"
msgstr ""

#: src/class.md:560
msgid ""
"To create a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute. This is the equivalent of the "
"Python decorator `@classmethod`."
msgstr ""

#: src/class.md:581
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:583
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:585
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:586
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:587
msgid ""
"The return type must be `PyResult<T>` or `T` for some `T` that implements "
"`IntoPy<PyObject>`."
msgstr ""

#: src/class.md:589
msgid "Static methods"
msgstr ""

#: src/class.md:591
msgid ""
"To create a static method for a custom class, the method needs to be "
"annotated with the `#[staticmethod]` attribute. The return type must be `T` "
"or `PyResult<T>` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:611
msgid "Class attributes"
msgstr ""

#: src/class.md:613
msgid ""
"To create a class attribute (also called [class variable](https://docs."
"python.org/3/tutorial/classes.html#class-and-instance-variables)), a method "
"without any arguments can be annotated with the `#[classattr]` attribute. "
"The return type must be `T` for some `T` that implements `IntoPy<PyObject>`."
msgstr ""

#: src/class.md:625
msgid "\"hello\""
msgstr ""

#: src/class.md:631
msgid "\"assert my_class.my_attribute == 'hello'\""
msgstr ""

#: src/class.md:635
msgid ""
"Note that unlike class variables defined in Python code, class attributes "
"defined in Rust cannot be mutated at all:"
msgstr ""

#: src/class.md:638
msgid ""
"// Would raise a `TypeError: can't set attributes of built-in/extension type "
"'MyClass'`\n"
msgstr ""

#: src/class.md:639
msgid "\"my_class.my_attribute = 'foo'\""
msgstr ""

#: src/class.md:642
msgid ""
"If the class attribute is defined with `const` code only, one can also "
"annotate associated constants:"
msgstr ""

#: src/class.md:652
msgid "\"foobar\""
msgstr ""

#: src/class.md:656
msgid "Method arguments"
msgstr ""

#: src/class.md:658
msgid ""
"By default, PyO3 uses function signatures to determine which arguments are "
"required. Then it scans the incoming `args` and `kwargs` parameters. If it "
"can not find all required parameters, it raises a `TypeError` exception. It "
"is possible to override the default behavior with the `#[args(...)]` "
"attribute. This attribute accepts a comma separated list of parameters in "
"the form of `attr_name=\"default value\"`. Each parameter has to match the "
"method parameter by name."
msgstr ""

#: src/class.md:664
msgid "Each parameter can be one of the following types:"
msgstr ""

#: src/class.md:666
msgid ""
"`\"/\"`: positional-only arguments separator, each parameter defined before "
"`\"/\"` is a positional-only parameter. Corresponds to python's `def "
"meth(arg1, arg2, ..., /, argN..)`."
msgstr ""

#: src/class.md:669
msgid ""
"`\"*\"`: var arguments separator, each parameter defined after `\"*\"` is a "
"keyword-only parameter. Corresponds to python's `def meth(*, arg1.., "
"arg2=..)`."
msgstr ""

#: src/class.md:671
msgid ""
"`args=\"*\"`: \"args\" is var args, corresponds to Python's `def "
"meth(*args)`. Type of the `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:673
msgid ""
"`kwargs=\"**\"`: \"kwargs\" receives keyword arguments, corresponds to "
"Python's `def meth(**kwargs)`. The type of the `kwargs` parameter has to be "
"`Option<&PyDict>`."
msgstr ""

#: src/class.md:675
msgid ""
"`arg=\"Value\"`: arguments with default value. Corresponds to Python's `def "
"meth(arg=Value)`. If the `arg` argument is defined after var arguments, it "
"is treated as a keyword-only argument. Note that `Value` has to be valid "
"rust code, PyO3 just inserts it into the generated code unmodified."
msgstr ""

#: src/class.md:680
msgid "Example:"
msgstr ""

#: src/class.md:692
msgid "\"-1\""
msgstr ""

#: src/class.md:698
msgid "\"10\""
msgstr ""

#: src/class.md:699
msgid "\"*\""
msgstr ""

#: src/class.md:700
msgid "\"\\\"Hello\\\"\""
msgstr ""

#: src/class.md:701
msgid "\"**\""
msgstr ""

#: src/class.md:712
msgid "\"py_args={:?}, py_kwargs={:?}, name={}, num={}\""
msgstr ""

#: src/class.md:719
msgid "\"num={}\""
msgstr ""

#: src/class.md:723
msgid ""
"N.B. the position of the `\"/\"` and `\"*\"` arguments (if included) control "
"the system of handling positional and keyword arguments. In Python:"
msgstr ""

#: src/class.md:728 src/class.md:729
msgid "\"World\""
msgstr ""

#: src/class.md:732
msgid "Produces output:"
msgstr ""

#: src/class.md:740
msgid "Making class method signatures available to Python"
msgstr ""

#: src/class.md:742
msgid ""
"The [`text_signature = \"...\"`](./function.md#text_signature) option for "
"`#[pyfunction]` also works for classes and methods:"
msgstr ""

#: src/class.md:748
msgid "// it works even if the item is not documented:\n"
msgstr ""

#: src/class.md:750 src/class.md:793
msgid "\"(c, d, /)\""
msgstr ""

#: src/class.md:755
msgid ""
"// the signature for the constructor is attached\n"
"    // to the struct definition instead.\n"
msgstr ""

#: src/class.md:761
msgid "// the self argument should be written $self\n"
msgstr ""

#: src/class.md:762
msgid "\"($self, e, f)\""
msgstr ""

#: src/class.md:767 src/class.md:822
msgid "\"(cls, e, f)\""
msgstr ""

#: src/class.md:772 src/class.md:834
msgid "\"(e, f)\""
msgstr ""

#: src/class.md:780
msgid "\"inspect\""
msgstr ""

#: src/class.md:780
msgid "\"signature\""
msgstr ""

#: src/class.md:781
msgid "\"my_module\""
msgstr ""

#: src/class.md:783 src/class.md:981
msgid "\"MyClass\""
msgstr ""

#: src/class.md:786 src/class.md:795 src/class.md:804 src/class.md:816
#: src/class.md:828
msgid "\"__doc__\""
msgstr ""

#: src/class.md:787 src/class.md:796
msgid "\"\""
msgstr ""

#: src/class.md:791 src/class.md:808 src/class.md:820 src/class.md:832
msgid "\"__str__\""
msgstr ""

#: src/class.md:798
msgid ""
"\"`text_signature` on classes is not compatible with compilation in `abi3` "
"mode until Python 3.10 or greater\""
msgstr ""

#: src/class.md:802
msgid "\"my_method\""
msgstr ""

#: src/class.md:810
msgid "\"(self, /, e, f)\""
msgstr ""

#: src/class.md:814
msgid "\"my_class_method\""
msgstr ""

#: src/class.md:826
msgid "\"my_static_method\""
msgstr ""

#: src/class.md:842
msgid ""
"Note that `text_signature` on classes is not compatible with compilation in "
"`abi3` mode until Python 3.10 or greater."
msgstr ""

#: src/class.md:845
msgid "\\#\\[pyclass\\] enums"
msgstr ""

#: src/class.md:847
msgid ""
"Currently PyO3 only supports fieldless enums. PyO3 adds a class attribute "
"for each variant, so you can access them in Python without defining "
"`#[new]`. PyO3 also provides default implementations of `__richcmp__` and "
"`__int__`, so they can be compared using `==`:"
msgstr ""

#: src/class.md:861
msgid ""
"r#\"\n"
"        assert x == cls.Variant\n"
"        assert y == cls.OtherVariant\n"
"        assert x != y\n"
"    \"#"
msgstr ""

#: src/class.md:869
msgid "You can also convert your enums into `int`:"
msgstr ""

#: src/class.md:881
msgid "// The exact value is assigned by the compiler.\n"
msgstr ""

#: src/class.md:882
msgid ""
"r#\"\n"
"        assert int(cls.Variant) == x\n"
"        assert int(cls.OtherVariant) == 10\n"
"        assert cls.OtherVariant == 10  # You can also compare against int.\n"
"        assert 10 == cls.OtherVariant\n"
"    \"#"
msgstr ""

#: src/class.md:891
msgid "PyO3 also provides `__repr__` for enums:"
msgstr ""

#: src/class.md:904
msgid ""
"r#\"\n"
"        assert repr(x) == 'MyEnum.Variant'\n"
"        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'\n"
"    \"#"
msgstr ""

#: src/class.md:911
msgid ""
"All methods defined by PyO3 can be overriden. For example here's how you "
"override `__repr__`:"
msgstr ""

#: src/class.md:923
msgid "\"42\""
msgstr ""

#: src/class.md:929
msgid "\"assert repr(cls.Answer) == '42'\""
msgstr ""

#: src/class.md:933
msgid ""
"You may not use enums as a base class or let enums inherit from other "
"classes."
msgstr ""

#: src/class.md:955
msgid ""
"`#[pyclass]` enums are currently not interoperable with `IntEnum` in Python."
msgstr ""

#: src/class.md:957
msgid "Implementation details"
msgstr ""

#: src/class.md:959
msgid ""
"The `#[pyclass]` macros rely on a lot of conditional code generation: each "
"`#[pyclass]` can optionally have a `#[pymethods]` block."
msgstr ""

#: src/class.md:961
msgid ""
"To support this flexibility the `#[pyclass]` macro expands to a blob of "
"boilerplate code which sets up the structure for [\"dtolnay specialization\"]"
"(https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/"
"README.md). This implementation pattern enables the Rust compiler to use "
"`#[pymethods]` implementations when they are present, and fall back to "
"default (empty) definitions when they are not."
msgstr ""

#: src/class.md:963
msgid ""
"This simple technique works for the case when there is zero or one "
"implementations. To support multiple `#[pymethods]` for a `#[pyclass]` (in "
"the [`multiple-pymethods`](features.md#multiple-pymethods) feature), a "
"registry mechanism provided by the [`inventory`](https://github.com/dtolnay/"
"inventory) crate is used instead. This collects `impl`s at library load "
"time, but isn't supported on all platforms. See [inventory: how it works]"
"(https://github.com/dtolnay/inventory#how-it-works) for more details."
msgstr ""

#: src/class.md:965
msgid ""
"The `#[pyclass]` macro expands to roughly the code seen below. The "
"`PyClassImplCollector` is the type used internally by PyO3 for dtolnay "
"specialization:"
msgstr ""

#: src/class.md:968
msgid "\"multiple-pymethods\""
msgstr ""

#: src/class.md:969
msgid ""
"// Note: the implementation differs slightly with the `multiple-pymethods` "
"feature enabled.\n"
msgstr ""

#: src/class.md:971
msgid "/// Class for demonstration\n"
msgstr ""

#: src/class.md:1005
msgid "\"Class for demonstration\\u{0}\""
msgstr ""

#: src/class.md:1022
msgid "\"assert cls.__name__ == 'MyClass'\""
msgstr ""
