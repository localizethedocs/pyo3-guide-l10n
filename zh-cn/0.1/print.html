<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><a href="https://travis-ci.org/PyO3/pyo3"><img src="https://travis-ci.org/PyO3/pyo3.svg?branch=master" alt="Build Status" /></a> <a href="https://crates.io/crates/pyo3"><img src="https://img.shields.io/crates/v/pyo3.svg" alt="Latest Version" /></a> <a href="http://pyo3.github.io/pyo3/pyo3/"><img src="https://img.shields.io/badge/api-rustdoc-blue.svg" alt="Rust Documentation" /></a></p>
<p>PyO3 is a <a href="http://www.rust-lang.org/">Rust</a> bindings for the <a href="https://www.python.org/">Python</a> interpreter.</p>
<p>Supported Python versions:</p>
<ul>
<li>Python2.7, Python 3.5 and up</li>
</ul>
<p>Supported Rust version:</p>
<ul>
<li>Rust 1.20.0-nightly or later</li>
<li>On Windows, we require rustc 1.20.0-nightly</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use <code>pyo3</code>, add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = "0.1"
</code></pre>
<p>Example program displaying the value of <code>sys.version</code>:</p>
<pre><pre class="playground"><code class="language-rust">extern crate pyo3;

use pyo3::{Python, PyDict, PyResult};

fn main() {
    let gil = Python::acquire_gil();
    hello(gil.python()).unwrap();
}

fn hello(py: Python) -&gt; PyResult&lt;()&gt; {
    let sys = py.import("sys")?;
    let version: String = sys.get("version")?.extract()?;

    let locals = PyDict::new(py);
    locals.set_item("os", py.import("os")?)?;
    let user: String = py.eval("os.getenv('USER') or os.getenv('USERNAME')", None, Some(&amp;locals))?.extract()?;

    println!("Hello {}, I'm Python {}", user, version);
    Ok(())
}</code></pre></pre>
<p>Example library with python bindings:</p>
<p>The following two files will build with <code>cargo build</code>, and will generate a python-compatible library. On macOS, you will need to rename the output from *.dylib to *.so. On Windows, you will need to rename the output from *.dll to *.pyd.</p>
<p><strong><code>Cargo.toml</code>:</strong></p>
<pre><code class="language-toml">[lib]
name = "rust2py"
crate-type = ["cdylib"]

[dependencies.pyo3]
version = "0.1"
features = ["extension-module"]
</code></pre>
<p><strong><code>src/lib.rs</code></strong></p>
<pre><pre class="playground"><code class="language-rust">#![feature(proc_macro, specialization)]

extern crate pyo3;
use pyo3::{py, PyResult, Python, PyModule};

// add bindings to the generated python module
// N.B: names: "librust2py" must be the name of the `.so` or `.pyd` file
/// This module is implemented in Rust.
#[py::modinit(rust2py)]
fn init_mod(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m, "sum_as_string")]
    // pyo3 aware function. All of our python interface could be declared in a separate module.
    // Note that the `#[pyfn()]` annotation automatically converts the arguments from
    // Python objects to Rust values; and the Rust return value back into a Python object.
    fn sum_as_string_py(_: Python, a:i64, b:i64) -&gt; PyResult&lt;String&gt; {
       let out = sum_as_string(a, b);
       Ok(out)
    }

    Ok(())
}

// logic implemented as a normal rust function
fn sum_as_string(a:i64, b:i64) -&gt; String {
    format!("{}", a + b).to_string()
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>For <code>setup.py</code> integration, see <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a></p>
<h2 id="ownership-and-lifetimes"><a class="header" href="#ownership-and-lifetimes">Ownership and Lifetimes</a></h2>
<p>In Python, all objects are implicitly reference counted. In Rust, we will use the <a href="https://pyo3.github.io/pyo3/pyo3/struct.PyObject.html"><code>PyObject</code></a> type to represent a reference to a Python object.</p>
<p>Because all Python objects potentially have multiple owners, the concept of Rust mutability does not apply to Python objects. As a result, this API will <strong>allow mutating Python objects even if they are not stored in a mutable Rust variable</strong>.</p>
<p>The Python interpreter uses a global interpreter lock (GIL) to ensure thread-safety. This API uses a zero-sized <a href="https://pyo3.github.io/PyO3/pyo3/struct.Python.html"><code>struct Python&lt;'p&gt;</code></a> as a token to indicate that a function can assume that the GIL is held.</p>
<p>You obtain a <a href="https://pyo3.github.io/PyO3/pyo3/struct.Python.html"><code>Python</code></a> instance by acquiring the GIL, and have to pass it into some operations that call into the Python runtime.</p>
<p>PyO3 library provides wrappers for python native objects. Ownership of python objects are disallowed because any access to python runtime has to be protected by GIL. All apis are available through references. Lifetimes of python object's refereces are bound to GIL lifetime.</p>
<p>There are two types of pointers that could be stored on rust structs. Both implements <code>Send</code> and <code>Sync</code> traits and maintain python object's reference count.</p>
<ul>
<li>
<p><a href="https://pyo3.github.io/pyo3/pyo3/struct.PyObject.html"><code>PyObject</code></a> is general purpose type. It does not maintain type of the referenced object. It provides helper methods for extracing rust values and casting to specific python object type.</p>
</li>
<li>
<p><a href="https://pyo3.github.io/pyo3/pyo3/struct.Py.html"><code>Py&lt;T&gt;</code></a> represents a reference to a concrete python object <code>T</code>.</p>
</li>
</ul>
<p>To upgrade to a reference <a href="https://pyo3.github.io/pyo3/pyo3/trait.AsPyRef.html"><code>AsPyRef</code></a> trait can be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this tutorial, we will walk through the steps of building a simple Python extension called <code>TODO</code>.</p>
<h2 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h2>
<p>Before we begin, we need to install Rust using the <a href="https://www.rustup.rs/">rustup</a> installer:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>If you already have rustup installed, run this command to ensure you have the latest version of Rust:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p><code>PyO3</code> provides some handy traits to convert between Python types and Rust types.</p>
<h2 id="topyobject-and-intopyobject-trait"><a class="header" href="#topyobject-and-intopyobject-trait"><code>ToPyObject</code> and <code>IntoPyObject</code> trait</a></h2>
<p><a href="https://pyo3.github.io/PyO3/pyo3/trait.ToPyObject.html"><code>ToPyObject</code></a> trait is a conversion trait that allows various objects to be converted into <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyObject.html"><code>PyObject</code></a>. <a href="https://pyo3.github.io/PyO3/pyo3/trait.IntoPyObject.html"><code>IntoPyObject</code></a> serves the same purpose except it consumes <code>self</code>.</p>
<h2 id="intopytuple-trait"><a class="header" href="#intopytuple-trait"><code>IntoPyTuple</code> trait</a></h2>
<p><a href="https://pyo3.github.io/PyO3/pyo3/trait.IntoPyTuple.html"><code>IntoPyTuple</code></a> trait is a conversion trait that allows various objects to be converted into <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyTuple.html"><code>PyTuple</code></a> object.</p>
<p>For example, <a href="https://pyo3.github.io/PyO3/pyo3/trait.IntoPyTuple.html"><code>IntoPyTuple</code></a> trait is implemented for <code>()</code> so that you can convert it into a empty <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyTuple.html"><code>PyTuple</code></a></p>
<pre><pre class="playground"><code class="language-rust">extern crate pyo3;

use pyo3::{Python, IntoPyTuple};

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let py_tuple = ().into_tuple(py);
}</code></pre></pre>
<h2 id="frompyobject-and-reffrompyobject-trait"><a class="header" href="#frompyobject-and-reffrompyobject-trait"><code>FromPyObject</code> and <code>RefFromPyObject</code> trait</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-exception"><a class="header" href="#python-exception">Python Exception</a></h1>
<h2 id="define-a-new-exception"><a class="header" href="#define-a-new-exception">Define a new exception</a></h2>
<p>You can use the <code>py_exception!</code> macro to define a new excetpion type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>py_exception!(module, MyError);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use] extern crate pyo3;

use pyo3::{Python, PyDict};

py_exception!(mymodule, CustomError);

fn main() {
let gil = Python::acquire_gil();
    let py = gil.python();
    let ctx = PyDict::new(py);

    ctx.set_item(py, "CustomError", py.get_type::&lt;CustomError&gt;()).unwrap();

    py.run("assert str(CustomError) == \"&lt;class 'mymodule.CustomError'&gt;\"", None, Some(&amp;ctx)).unwrap();
    py.run("assert CustomError('oops').args == ('oops',)", None, Some(&amp;ctx)).unwrap();
}</code></pre></pre>
<h2 id="raise-an-exception"><a class="header" href="#raise-an-exception">Raise an exception</a></h2>
<p>To raise an exception, first you need to obtain an exception type and construct a new <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyErr.html"><code>PyErr</code></a>, then call <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyErr.html#method.restore"><code>PyErr::restore()</code></a> method to write the exception back to the Python interpreter's global state.</p>
<pre><pre class="playground"><code class="language-rust">extern crate pyo3;

use pyo3::{Python, PyErr, exc};

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    PyErr::new_lazy_init(py.get_type::&lt;exc::TypeError&gt;(), None).restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
}</code></pre></pre>
<p>If you already have a Python exception instance, you can simply call <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyErr.html#method.from_instance"><code>PyErr::from_instance()</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PyErr::from_instance(py, err).restore(py);
<span class="boring">}</span></code></pre></pre>
<h2 id="check-exception-type"><a class="header" href="#check-exception-type">Check exception type</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check object type, in <code>PyO3</code> there is a <a href="https://pyo3.github.io/PyO3/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance()</code></a> method which does the same thing.</p>
<pre><pre class="playground"><code class="language-rust">extern crate pyo3;

use pyo3::{Python, PyBool, PyList};

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    assert!(py.is_instance::&lt;PyBool&gt;(py.True().as_ref()).unwrap());
    let list = PyList::new(py, &amp;[1, 2, 3, 4]);
    assert!(!py.is_instance::&lt;PyBool&gt;(list.as_ref()).unwrap());
    assert!(py.is_instance::&lt;PyList&gt;(list.as_ref()).unwrap());
}</code></pre></pre>
<p><a href="https://pyo3.github.io/PyO3/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance()</code></a> calls the underlaying <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyType.html#method.is_instance"><code>PyType::is_instance</code></a> method to do the actual work.</p>
<p>To check the type of an exception, you can simply do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ret = py.is_instance::&lt;exc::TypeError&gt;(&amp;err.instance(py)).expect("Error calling is_instance");
<span class="boring">}</span></code></pre></pre>
<h2 id="handle-rust-error"><a class="header" href="#handle-rust-error">Handle Rust Error</a></h2>
<p>The vast majority of operations in this library will return <a href="https://pyo3.github.io/PyO3/pyo3/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>. This is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>A <a href="https://pyo3.github.io/PyO3/pyo3/struct.PyErr.html"><code>PyErr</code></a> represents a Python exception. Errors within the <code>PyO3</code> library are also exposed as Python exceptions.</p>
<p>The <a href="https://pyo3.github.io/PyO3/pyo3/trait.ToPyErr.html"><code>ToPyErr</code></a> trait provides a way to convert Rust errors to Python exceptions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToPyErr {
    fn to_pyerr(&amp;self, _: Python) -&gt; PyErr;
}
<span class="boring">}</span></code></pre></pre>
<p>It's implemented for most of the standard library's error types so that you use <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err()</code></a> to transform errors to Python exceptions as well as taking advantage of <code>try!</code> macro or <code>?</code> operator.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{PyResult, ToPyErr};

fn parse_int(py: Python, s: String) -&gt; PyResult&lt;usize&gt; {
    Ok(s.parse::&lt;usize&gt;().map_err(|e| e.to_pyerr(py))?)
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet above will raise <code>ValueError</code> in Python if <code>String::parse()</code> return an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-module"><a class="header" href="#python-module">Python Module</a></h1>
<p>Python module generation is powered by unstable <a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html">Procedural Macros</a> feature, so you need to turn on <code>proc_macro</code> feature:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(proc_macro)]

extern crate pyo3;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>You need to change your <code>crate-type</code> to <code>cdylib</code> to produce a Python compatible library:</p>
<pre><code class="language-toml">[lib]
name = "rust2py"
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.1", features = ["extension-module"] }
</code></pre>
<p>Now you can write your module, for example</p>
<pre><pre class="playground"><code class="language-rust">#![feature(proc_macro)]

extern crate pyo3;
use pyo3::{py, PyResult, Python, PyModule};

// add bindings to the generated python module
// N.B: names: "librust2py" must be the name of the `.so` or `.pyd` file
/// This module is implemented in Rust.
#[py::modinit(rust2py)]
fn init_mod(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    // pyo3 aware function. All of our python interface could be declared in a separate module.
    // Note that the `#[pyfn()]` annotation automatically converts the arguments from
    // Python objects to Rust values; and the Rust return value back into a Python object.
    #[pyfn(m, "sum_as_string")]
    fn sum_as_string_py(_: Python, a:i64, b:i64) -&gt; PyResult&lt;String&gt; {
       let out = sum_as_string(a, b);
       Ok(out)
    }

    Ok(())
}

// logic implemented as a normal rust function
fn sum_as_string(a:i64, b:i64) -&gt; String {
    format!("{}", a + b).to_string()
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <code>modinit</code> procedural macro attribute takes care of exporting the initialization function of your module to Python. It takes one argument as the name of your module, it must be the name of the <code>.so</code> or <code>.pyd</code> file.</p>
<p>The <a href="https://doc.rust-lang.org/stable/book/first-edition/comments.html">Rust doc comments</a> of the module initialization function will be applied automatically as the Python doc string of your module.</p>
<pre><code class="language-python">import rust2py

print(rust2py.__doc__)
</code></pre>
<p>Which means that the above Python code will print <code>This module is implemented in Rust.</code>.</p>
<blockquote>
<p>On macOS, you will need to rename the output from <code>*.dylib</code> to <code>*.so</code>.</p>
<p>On Windows, you will need to rename the output from <code>*.dll</code> to <code>*.pyd</code>.</p>
</blockquote>
<p>For <code>setup.py</code> integration, You can use <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>, learn more about it in <a href="./distribution.html">Distribution</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-function"><a class="header" href="#python-function">Python Function</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-class"><a class="header" href="#python-class">Python Class</a></h1>
<p>Python class generation is powered by unstable <a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html">Procedural Macros</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md">Specialization</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">Const fn</a> features, so you need to turn on <code>proc_macro</code> and <code>specialization</code> features:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(proc_macro, specialization, const_fn)]

<span class="boring">fn main() {
</span>extern crate pyo3;
<span class="boring">}</span></code></pre></pre>
<h2 id="define-new-class"><a class="header" href="#define-new-class">Define new class</a></h2>
<p>To define python custom class, rust struct needs to be annotated with <code>#[py::class]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::*;

#[py::class]
struct MyClass {
   num: i32,
   debug: bool,
   token: PyToken,
}
<span class="boring">}</span></code></pre></pre>
<p>The above example generates the following implementations for <code>MyClass</code> struct</p>
<pre><code class="language-rust ignore">impl PyTypeInfo for MyClass { ... }
impl PyTypeObject for MyClass { ... }
impl PyObjectWithToken for MyClass { ... }
impl ToPyObject for MyClass { ... }
impl IntoPyObject for MyClass { ... }
impl ToPyPointer for MyClass { ... }</code></pre>
<p>Following implementations <code>PyObjectWithToken</code>, <code>ToPyObject</code>, <code>IntoPyObject</code>, <code>ToPyPointer</code> are generated only if struct contains <code>PyToken</code> attribute.</p>
<p><code>PyToken</code> instance available only in <code>py.init</code> method.</p>
<p>TODO - continue</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>By default it is not possible to create instance of custom class from python code. To declare constructor, you need to define class method and annotate it with <code>#[new]</code> attribute. Only python <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::method]
impl MyClass {

     #[new]
     fn __new__(cls: &amp;PyType, ...) -&gt; PyResult&lt;Py&lt;MyClass&gt;&gt; {
         cls.py().init(|token| {
             MyClass {
                 num: 10,
                 debug: False,
                 token: token
             }
         })
     }
}
<span class="boring">}</span></code></pre></pre>
<p>Some rules of <code>new</code> method</p>
<ul>
<li>If no method marked with <code>#[new]</code> is declared, object instances can only be created from Rust, but not from Python.</li>
<li>The first parameter is the type object of the class to create. This may be the type object of a derived class declared in Python.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>. Usually, <code>T</code> will be <code>MyType</code>.</li>
</ul>
<h2 id="object-properties"><a class="header" href="#object-properties">Object properties</a></h2>
<p>Instance's <code>__dict__</code> attributes is not supported by pyo3 library. But it is possible to specify instance get/set descriptors. Descriptor methods can be defined in <code>#[methods]</code> <code>impl</code> block only and has to be annotated with <code>#[getter]</code> or <code>[setter]</code> attributes. i.e.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[getter]
     fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }
}
<span class="boring">}</span></code></pre></pre>
<p>Getter or setter function's name is used as property name by default. There are several ways how to override name.</p>
<p>If function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively. Descriptor name becomes function name with prefix removed. This is useful in case os rust's special keywords like <code>type</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[getter]
     fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }

     #[setter]
     fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
     }
}
<span class="boring">}</span></code></pre></pre>
<p>In this case property <code>num</code> is defined. And it is available from python code as <code>self.num</code>.</p>
<p>Also both <code>#[getter]</code> and <code>#[setter]</code> attributes accepts one parameter. If parameter is specified, it is used and property name. i.e.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[getter(number)]
     fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }

     #[setter(number)]
     fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
     }
}
<span class="boring">}</span></code></pre></pre>
<p>In this case property <code>number</code> is defined. And it is available from python code as <code>self.number</code>.</p>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p>To define python compatible method, <code>impl</code> block for struct has to be annotated with <code>#[py::methods]</code> attribute. <code>pyo3</code> library generates python compatible wrappers for all functions in this block with some variations, like descriptors, class method static methods, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }

     fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
        Ok(())
     }
}
<span class="boring">}</span></code></pre></pre>
<p>Calls to this methods protected by <code>GIL</code>, <code>&amp;self</code> or <code>&amp;mut self</code> can be used. The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</p>
<p><code>Python</code> parameter can be spefieid as part of method signature, in this case <code>py</code> argument get injected by method wrapper. i.e</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     fn method2(&amp;self, py: Python) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
<span class="boring">}</span></code></pre></pre>
<p>From python prespective <code>method2</code>, in above example, does not accept any arguments.</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>To specify class method for custom class, method needs to be annotated with<code>#[classmethod]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[classmethod]
     fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
<span class="boring">}</span></code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called. This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</li>
</ul>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>To specify class method for custom class, method needs to be annotated with <code>#[staticmethod]</code> attribute. The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[staticmethod]
     fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="callable-object"><a class="header" href="#callable-object">Callable object</a></h2>
<p>To specify custom <code>__call__</code> method for custom class, call method needs to be annotated with <code>#[call]</code> attribute. Arguments of the method are speficied same as for instance method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {

     #[call]
     #[args(args="*")]
     fn __call__(&amp;self, args: &amp;PyTuple) -&gt; PyResult&lt;i32&gt; {
        println!("MyCLS has been called");
        Ok(self.num)
     }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h2>
<p>By default pyo3 library uses function signature to determine which arguments are required. Then it scans incoming <code>args</code> parameter and then incoming <code>kwargs</code> parameter. If it can not find all required parameters, it raises <code>TypeError</code> exception. It is possible to override default bahavior with <code>#[args(...)]</code> attribute. <code>args</code> attribute accept comma separated list of parameters in form <code>attr_name="default value"</code>. Each parameter has to match method parameter by name.</p>
<p>Each parameter could one of following type:</p>
<ul>
<li>"*": var arguments separator, each parameter defined after "*" is keyword only paramters. coresponds to python's <code>def meth(*, arg1.., arg2=..)</code></li>
<li>args="*": "args" is var args, coresponds to python's <code>def meth(*args)</code>. Type of <code>args</code> parameter has to be <code>&amp;PyTuple</code>.</li>
<li>kwargs="**": "kwargs" is kwyword arguments, coresponds to python's <code>def meth(**kwargs)</code>. Type of <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li>arg="Value": arguments with default value. coresponds to python's <code>def meth(arg=Value)</code>. if <code>arg</code> argument is defined after var arguments it is treated as keyword argument. Note that <code>Value</code> has to be valid rust code, pyo3 just inserts it into generated code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[py::methods]
impl MyClass {
 
     #[args(arg1=true, args="*", arg2=10, kwargs="**")]
     fn method(&amp;self, arg1: bool, args: &amp;PyTuple, arg2: i32, kwargs: Option&lt;&amp;PyTuple&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(1)
     }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="class-customizations"><a class="header" href="#class-customizations">Class customizations</a></h2>
<p>Python object model defines several protocols for different object behavior, like sequence, mapping or number protocols. pyo3 library defines separate trait for each of them. To provide specific python object behavior you need to implement specific trait for your struct. Important note, each protocol implementation block has to be annotated with <code>#[py::proto]</code> attribute.</p>
<h3 id="basic-object-customization"><a class="header" href="#basic-object-customization">Basic object customization</a></h3>
<p><a href="https://pyo3.github.io/pyo3/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provide several basic customizations.</p>
<h4 id="attribute-access"><a class="header" href="#attribute-access">Attribute access</a></h4>
<p>To customize object attribute access define following methods:</p>
<ul>
<li><code>fn __getattr__(&amp;self, name: FromPyObject) -&gt; PyResult&lt;impl IntoPyObject&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: FromPyObject, value: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>Each methods coresponds to python's <code>self.attr</code>, <code>self.attr = value</code> and <code>del self.attr</code> code.</p>
<h4 id="string-conversions"><a class="header" href="#string-conversions">String Conversions</a></h4>
<ul>
<li>
<p><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
</li>
<li>
<p><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Possible return types for <code>__str__</code> and <code>__repr__</code> are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>. In Python 2.7, Unicode strings returned by <code>__str__</code> and <code>__repr__</code> will be converted to byte strings by the Python runtime, which results in an exception if the string contains non-ASCII characters.</p>
</li>
<li>
<p><code>fn __bytes__(&amp;self) -&gt; PyResult&lt;PyBytes&gt;</code></p>
<p>On Python 3.x, provides the conversion to <code>bytes</code>. On Python 2.7, <code>__bytes__</code> is allowed but has no effect.</p>
</li>
<li>
<p><code>fn __unicode__(&amp;self) -&gt; PyResult&lt;PyUnicode&gt;</code></p>
<p>On Python 2.7, provides the conversion to <code>unicode</code>. On Python 3.x, <code>__unicode__</code> is allowed but has no effect.</p>
</li>
<li>
<p><code>fn __format__(&amp;self, format_spec: &amp;str) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Special method that is used by the <code>format()</code> builtin and the <code>str.format()</code> method. Possible return types are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
</ul>
<h4 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison operators</a></h4>
<ul>
<li>
<p><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>). The <code>op</code> argument indicates the comparison operation being performed. The return type will normally be <code>PyResult&lt;bool&gt;</code>, but any Python object can be returned. If <code>other</code> is not of the type specified in the signature, the generated code will automatically <code>return NotImplemented</code>.</p>
</li>
<li>
<p><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></p>
<p>Objects that compare equal must have the same hash value. The return type must be <code>PyResult&lt;T&gt;</code> where <code>T</code> is one of Rust's primitive integer types.</p>
</li>
</ul>
<h4 id="other-methods"><a class="header" href="#other-methods">Other methods</a></h4>
<ul>
<li>
<p><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Determines the "truthyness" of the object. This method works for both python 3 and python 2, even on Python 2.7 where the Python spelling was <code>__nonzero__</code>.</p>
</li>
</ul>
<h3 id="garbage-collector-integration"><a class="header" href="#garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other python objects, you will need to integrate with Python's garbage collector so that the GC is aware of those references. To do this, implement <a href="https://pyo3.github.io/pyo3/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct. It includes two methods <code>__traverse__</code> and <code>__clear__</code>. These correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API. <code>__traverse__</code> must call <code>visit.call()</code> for each reference to another python object. <code>__clear__</code> must clear out any mutable references to other python objects (thus breaking reference cycles). Immutable references do not have to be cleared, as every cycle must contain at least one mutable reference. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(proc_macro, specialization)]
<span class="boring">fn main() {
</span>extern crate pyo3;

use pyo3::{py, PyObject, PyGCProtocol, PyVisit, PyTraverseError};

#[py::class]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}
    
#[py::proto]
impl PyGCProtocol for ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(ref obj) = self.obj {
            visit.call(obj)?
        }
        Ok(())
    }
    
    fn __clear__(&amp;mut self) {
        if let Some(obj) = self.obj.take() {
          // Release reference, this decrements ref counter.
          self.py().release(obj);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Special protocol trait implementation has to be annotated with <code>#[py::proto]</code> attribute.</p>
<h3 id="iterator-types"><a class="header" href="#iterator-types">Iterator Types</a></h3>
<p>Iterators can be defined using the <a href="https://pyo3.github.io/pyo3/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait. It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(&amp;mut self) -&gt; PyResult&lt;impl IntoPyObject&gt;</code></li>
<li><code>fn __next__(&amp;mut self) -&gt; PyResult&lt;Option&lt;impl IntoPyObject&gt;&gt;</code></li>
</ul>
<p>Returning <code>Ok(None)</code> from <code>__next__</code> indicates that that there are no further items.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(proc_macro, specialization)]
extern crate pyo3;

use pyo3::{py, PyObject, PyResult, PyIterProtocol};

#[py::class]
struct MyIterator {
    iter: Box&lt;Iterator&lt;Item=PyObject&gt; + Send&gt;
}

#[py::proto]
impl PyIterProtocol {

    fn __iter__(&amp;mut self) -&gt; PyResult&lt;PyObject&gt; {
        Ok(self.into())
    }
    fn __next__(&amp;mut self) -&gt; PyResult&lt;Option&lt;PyObject&gt;&gt; {
        Ok(self.iter.next())
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distribution"><a class="header" href="#distribution">Distribution</a></h1>
<h2 id="setuptools-rust-integration"><a class="header" href="#setuptools-rust-integration"><code>setuptools-rust</code> integration</a></h2>
<p><a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> is a setuptools helpers for Rust Python extensions. It supports <code>PyO3</code> by default.</p>
<p>For detailed usage, please refer to its <a href="https://github.com/PyO3/setuptools-rust/blob/master/README.rst">README</a></p>
<h2 id="source-distribution"><a class="header" href="#source-distribution">Source distribution</a></h2>
<p>To build a source code distribution, you need to add the following lines to your <code>MANIFEST.in</code> file to ensure it correctly packages Rust extension source code.</p>
<pre><code class="language-text">include Cargo.toml
recursive-include src *
</code></pre>
<p>Then you can build a source code distribution by (assuming you have already written a <code>setup.py</code>):</p>
<pre><code class="language-bash">python setup.py sdist
</code></pre>
<h2 id="binary-wheel-distribution"><a class="header" href="#binary-wheel-distribution">Binary wheel distribution</a></h2>
<p>To build a binary wheel, <a href="https://github.com/pypa/manylinux">manylinux</a> would be a natural choice for Linux.</p>
<p>TODO: an manylinux1 example, macOS wheel</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
