msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:53Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class.md:1
msgid "Python Class"
msgstr ""

#: src/class.md:3
msgid ""
"Python class generation is powered by unstable [Procedural Macros](https://"
"doc.rust-lang.org/book/first-edition/procedural-macros.html) and "
"[Specialization](https://github.com/rust-lang/rfcs/blob/master/text/1210-"
"impl-specialization.md) and [Const fn](https://github.com/rust-lang/rfcs/"
"blob/master/text/0911-const-fn.md) features, so you need to turn on "
"`proc_macro` and `specialization` features:"
msgstr ""

#: src/class.md:14
msgid "Define new class"
msgstr ""

#: src/class.md:16
msgid ""
"To define python custom class, rust struct needs to be annotated with `#[py::"
"class]` attribute."
msgstr ""

#: src/class.md:29
msgid ""
"The above example generates the following implementations for `MyClass` "
"struct"
msgstr ""

#: src/class.md:40
msgid ""
"Following implementations `PyObjectWithToken`, `ToPyObject`, `IntoPyObject`, "
"`ToPyPointer` are generated only if struct contains `PyToken` attribute."
msgstr ""

#: src/class.md:43
msgid "`PyToken` instance available only in `py.init` method."
msgstr ""

#: src/class.md:45
msgid "TODO - continue"
msgstr ""

#: src/class.md:47
msgid "py::class macro"
msgstr ""

#: src/class.md:49
msgid ""
"Python class generation is powered by [Procedural Macros](https://doc.rust-"
"lang.org/book/first-edition/procedural-macros.html). To define python custom "
"class, rust struct needs to be annotated with `#[py::class]` attribute. `py::"
"class` macro accepts following parameters:"
msgstr ""

#: src/class.md:53
msgid ""
"`name=XXX` - customize class name visible to python code. By default struct "
"name is used as a class name."
msgstr ""

#: src/class.md:55
msgid ""
"`freelist=XXX` - `freelist` parameter add support of free allocation list to "
"custom class. The performance improvement applies to types that are often "
"created and deleted in a row, so that they can benefit from a freelist. "
"`XXX` is a number of items for free list."
msgstr ""

#: src/class.md:58
msgid ""
"`gc` - adds support for python garbage collector. classes that build with "
"`gc` parameter participate in python garbage collector. If custom class "
"contains references to other python object that can be collector "
"`PyGCProtocol` trait has to be implemented."
msgstr ""

#: src/class.md:61
msgid "`weakref` - adds support for python weak references"
msgstr ""

#: src/class.md:62
msgid ""
"`base=BaseType` - use custom base class. BaseType is type which is "
"implements `PyTypeInfo` trait."
msgstr ""

#: src/class.md:64
msgid ""
"`subclass` - adds subclass support so that Python classes can inherit from "
"this class"
msgstr ""

#: src/class.md:65
msgid ""
"`dict` - adds `__dict__` support, the instances of this type have a "
"dictionary containing instance variables"
msgstr ""

#: src/class.md:68
msgid "Constructor"
msgstr ""

#: src/class.md:70
msgid ""
"By default it is not possible to create instance of custom class from python "
"code. To declare constructor, you need to define class method and annotate "
"it with `#[new]` attribute. Only python `__new__` method can be specified, "
"`__init__` is not available."
msgstr ""

#: src/class.md:91
msgid "Some rules of `new` method"
msgstr ""

#: src/class.md:93
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:95
msgid ""
"The first parameter is the raw object, custom `new` method must initialize "
"object with value of struct using `init` method. Type of the object may be "
"the type object of a derived class declared in Python."
msgstr ""

#: src/class.md:98
msgid "The first parameter implicitly has type `&PyRawObject`."
msgstr ""

#: src/class.md:99 src/class.md:291
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:100
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`. Usually, `T` will be `MyType`."
msgstr ""

#: src/class.md:104
msgid "Inheritance"
msgstr ""

#: src/class.md:106
msgid ""
"By default `PyObject` is used as default base class. To override default "
"base class `base` parameter for `py::class` needs to be used. Value is full "
"path to base class. `__new__` method accepts `PyRawObject` object. `obj` "
"instance must be initialized with value of custom class struct. Subclass "
"must call parent's `__new__` method."
msgstr ""

#: src/class.md:149
msgid ""
"`ObjectProtocol` trait provides `get_base()` method. It returns reference to "
"instance of base class."
msgstr ""

#: src/class.md:153
msgid "Object properties"
msgstr ""

#: src/class.md:155
msgid ""
"Descriptor methods can be defined in `#[py::methods]` `impl` block only and "
"has to be annotated with `#[getter]` or `[setter]` attributes. i.e."
msgstr ""

#: src/class.md:170
msgid ""
"Getter or setter function's name is used as property name by default. There "
"are several ways how to override name."
msgstr ""

#: src/class.md:173
msgid ""
"If function name starts with `get_` or `set_` for getter or setter "
"respectively. Descriptor name becomes function name with prefix removed. "
"This is useful in case os rust's special keywords like `type`."
msgstr ""

#: src/class.md:194
msgid ""
"In this case property `num` is defined. And it is available from python code "
"as `self.num`."
msgstr ""

#: src/class.md:196
msgid ""
"Also both `#[getter]` and `#[setter]` attributes accepts one parameter. If "
"parameter is specified, it is used and property name. i.e."
msgstr ""

#: src/class.md:216
msgid ""
"In this case property `number` is defined. And it is available from python "
"code as `self.number`."
msgstr ""

#: src/class.md:218
msgid ""
"For simple cases you can also define getters and setters in your Rust struct "
"field definition, for example:"
msgstr ""

#: src/class.md:228
msgid "Then it is available from Python code as `self.num`."
msgstr ""

#: src/class.md:230
msgid "Instance methods"
msgstr ""

#: src/class.md:232
msgid ""
"To define python compatible method, `impl` block for struct has to be "
"annotated with `#[py::methods]` attribute. `pyo3` library generates python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:252
msgid ""
"Calls to this methods protected by `GIL`, `&self` or `&mut self` can be "
"used. The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:255
msgid ""
"`Python` parameter can be specified as part of method signature, in this "
"case `py` argument get injected by method wrapper. i.e"
msgstr ""

#: src/class.md:268
msgid ""
"From python perspective `method2`, in above example, does not accept any "
"arguments."
msgstr ""

#: src/class.md:270
msgid "Class methods"
msgstr ""

#: src/class.md:272
msgid ""
"To specify class method for custom class, method needs to be annotated "
"with`#[classmethod]` attribute."
msgstr ""

#: src/class.md:286
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:288
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:290
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:292
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:294
msgid "Static methods"
msgstr ""

#: src/class.md:296
msgid ""
"To specify class method for custom class, method needs to be annotated with "
"`#[staticmethod]` attribute. The return type must be `PyResult<T>` for some "
"`T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:311
msgid "Callable object"
msgstr ""

#: src/class.md:313
msgid ""
"To specify custom `__call__` method for custom class, call method needs to "
"be annotated with `#[call]` attribute. Arguments of the method are specified "
"same as for instance method."
msgstr ""

#: src/class.md:321 src/class.md:356
msgid "\"*\""
msgstr ""

#: src/class.md:323
msgid "\"MyCLS has been called\""
msgstr ""

#: src/class.md:329
msgid "Method arguments"
msgstr ""

#: src/class.md:331
msgid ""
"By default pyo3 library uses function signature to determine which arguments "
"are required. Then it scans incoming `args` parameter and then incoming "
"`kwargs` parameter. If it can not find all required parameters, it raises "
"`TypeError` exception. It is possible to override default behavior with "
"`#[args(...)]` attribute. `args` attribute accept comma separated list of "
"parameters in form `attr_name=\"default value\"`. Each parameter has to "
"match method parameter by name."
msgstr ""

#: src/class.md:338
msgid "Each parameter could one of following type:"
msgstr ""

#: src/class.md:340
msgid ""
"\"\\*\": var arguments separator, each parameter defined after \"\\*\" is "
"keyword only parameters. corresponds to python's `def meth(*, arg1.., "
"arg2=..)`"
msgstr ""

#: src/class.md:342
msgid ""
"args=\"\\*\": \"args\" is var args, corresponds to python's `def "
"meth(*args)`. Type of `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:344
msgid ""
"kwargs=\"\\*\\*\": \"kwargs\" is keyword arguments, corresponds to python's "
"`def meth(**kwargs)`. Type of `kwargs` parameter has to be `Option<&PyDict>`."
msgstr ""

#: src/class.md:346
msgid ""
"arg=\"Value\": arguments with default value. corresponds to python's `def "
"meth(arg=Value)`. if `arg` argument is defined after var arguments it is "
"treated as keyword argument. Note that `Value` has to be valid rust code, "
"pyo3 just inserts it into generated code unmodified."
msgstr ""

#: src/class.md:351 src/class.md:491
msgid "Example:"
msgstr ""

#: src/class.md:356
msgid "\"**\""
msgstr ""

#: src/class.md:364
msgid "Class customizations"
msgstr ""

#: src/class.md:366
msgid ""
"Python object model defines several protocols for different object behavior, "
"like sequence, mapping or number protocols. pyo3 library defines separate "
"trait for each of them. To provide specific python object behavior you need "
"to implement specific trait for your struct. Important note, each protocol "
"implementation block has to be annotated with `#[py::proto]` attribute."
msgstr ""

#: src/class.md:372
msgid "Basic object customization"
msgstr ""

#: src/class.md:374
msgid ""
"[`PyObjectProtocol`](https://pyo3.github.io/pyo3/pyo3/class/basic/trait."
"PyObjectProtocol.html) trait provide several basic customizations."
msgstr ""

#: src/class.md:376
msgid "Attribute access"
msgstr ""

#: src/class.md:378
msgid "To customize object attribute access define following methods:"
msgstr ""

#: src/class.md:380
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:381
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:382
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:384
msgid ""
"Each methods corresponds to python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:386
msgid "String Conversions"
msgstr ""

#: src/class.md:388
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:389
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:391
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`. In Python 2.7, Unicode strings returned by `__str__` "
"and `__repr__` will be converted to byte strings by the Python runtime, "
"which results in an exception if the string contains non-ASCII characters."
msgstr ""

#: src/class.md:395
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:397
msgid ""
"On Python 3.x, provides the conversion to `bytes`. On Python 2.7, "
"`__bytes__` is allowed but has no effect."
msgstr ""

#: src/class.md:400
msgid "`fn __unicode__(&self) -> PyResult<PyUnicode>`"
msgstr ""

#: src/class.md:402
msgid ""
"On Python 2.7, provides the conversion to `unicode`. On Python 3.x, "
"`__unicode__` is allowed but has no effect."
msgstr ""

#: src/class.md:405
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:407
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:410
msgid "Comparison operators"
msgstr ""

#: src/class.md:412
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:414
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:420
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:422
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:425
msgid "Other methods"
msgstr ""

#: src/class.md:427
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:429
msgid ""
"Determines the \"truthyness\" of the object. This method works for both "
"python 3 and python 2, even on Python 2.7 where the Python spelling was "
"`__nonzero__`."
msgstr ""

#: src/class.md:433
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:435
msgid ""
"If your type owns references to other python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement [`PyGCProtocol`](https://pyo3.github.io/"
"pyo3/pyo3/class/gc/trait.PyGCProtocol.html) trait for your struct. It "
"includes two methods `__traverse__` and `__clear__`. These correspond to the "
"slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` must "
"call `visit.call()` for each reference to another python object. `__clear__` "
"must clear out any mutable references to other python objects (thus breaking "
"reference cycles). Immutable references do not have to be cleared, as every "
"cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:468
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:475
msgid ""
"Special protocol trait implementation has to be annotated with `#[py::"
"proto]` attribute."
msgstr ""

#: src/class.md:477
msgid ""
"It is also possible to enable gc for custom class using `gc` parameter for "
"`py::class` annotation. i.e. `#[py::class(gc)]`. In that case instances of "
"custom class participate in python garbage collector, and it is possible to "
"track them with `gc` module methods."
msgstr ""

#: src/class.md:481
msgid "Iterator Types"
msgstr ""

#: src/class.md:483
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://pyo3.github.io/"
"pyo3/pyo3/class/iter/trait.PyIterProtocol.html) trait. It includes two "
"methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:486
msgid "`fn __iter__(&mut self) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:487
msgid "`fn __next__(&mut self) -> PyResult<Option<impl IntoPyObject>>`"
msgstr ""

#: src/class.md:489
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""
