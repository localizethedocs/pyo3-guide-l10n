msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-29T08:25:31Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/async-await.md:1
msgid "Using `async` and `await`"
msgstr "使用 `async` 和 `await`"

#: src/async-await.md:3
msgid ""
"_This feature is still in active development. See [the related issue]"
"(https://github.com/PyO3/pyo3/issues/1632)._"
msgstr ""
"_此功能仍在積極開發中。請參考[相關議題](https://github.com/PyO3/pyo3/"
"issues/1632)。_"

#: src/async-await.md:5
msgid "`#[pyfunction]` and `#[pymethods]` attributes also support `async fn`."
msgstr "`#[pyfunction]` 與 `#[pymethods]` 屬性也支援 `async fn`。"

#: src/async-await.md:9 src/async-await.md:86
msgid "\"experimental-async\""
msgstr ""

#: src/async-await.md:28
msgid ""
"_Python awaitables instantiated with this method can only be awaited in "
"`asyncio` context. Other Python async runtime may be supported in the future."
"_"
msgstr ""
"_使用此方法建立的 Python awaitable 只能在 `asyncio` 上下文中被 await。未來可"
"能會支援其他 Python 非同步執行環境。_"

#: src/async-await.md:30
msgid "`Send + 'static` constraint"
msgstr "`Send + 'static` 限制"

#: src/async-await.md:32
msgid ""
"Resulting future of an `async fn` decorated by `#[pyfunction]` must be `Send "
"+ 'static` to be embedded in a Python object."
msgstr ""
"由 `#[pyfunction]` 修飾的 `async fn` 所產生的 future 必須是 `Send + "
"'static`，才能嵌入為 Python 物件。"

#: src/async-await.md:34
msgid ""
"As a consequence, `async fn` parameters and return types must also be `Send "
"+ 'static`, so it is not possible to have a signature like `async fn "
"does_not_compile<'py>(arg: Bound<'py, PyAny>) -> Bound<'py, PyAny>`."
msgstr ""
"因此，`async fn` 的參數與回傳型別也必須是 `Send + 'static`，所以無法使用像 "
"`async fn does_not_compile<'py>(arg: Bound<'py, PyAny>) -> Bound<'py, "
"PyAny>` 的簽名。"

#: src/async-await.md:36
msgid ""
"However, there is an exception for method receivers, so async methods can "
"accept `&self`/ `&mut self`. Note that this means that the class instance is "
"borrowed for as long as the returned future is not completed, even across "
"yield points and while waiting for I/O operations to complete. Hence, other "
"methods cannot obtain exclusive borrows while the future is still being "
"polled. This is the same as how async methods in Rust generally work but it "
"is more problematic for Rust code interfacing with Python code due to "
"pervasive shared mutability. This strongly suggests to prefer shared borrows "
"`&self` over exclusive ones `&mut self` to avoid racy borrow check failures "
"at runtime."
msgstr ""
"不過，方法接收者有例外，因此 async 方法可以接受 `&self`/`&mut self`。請注意，"
"這表示類別實例會在回傳的 future 完成前一直被借用，甚至跨越 yield 點與等待 I/"
"O 操作完成的期間。因此，在 future 仍被輪詢時，其他方法無法取得獨占借用。這與 "
"Rust 中 async 方法的一般行為相同，但由於普遍的共享可變性，對與 Python 互動的 "
"Rust 程式碼而言問題更大。強烈建議優先使用共享借用 `&self` 而非獨占借用 `&mut "
"self`，以避免執行期的競態借用檢查失敗。"

#: src/async-await.md:42
msgid "Implicitly attached to the interpreter"
msgstr "隱式附加到直譯器"

#: src/async-await.md:44
msgid ""
"Even if it is not possible to pass a `py: Python<'py>` token to an `async "
"fn`, we're still attached to the interpreter during the execution of the "
"future – the same as for a regular `fn` without `Python<'py>`/`Bound<'py, "
"PyAny>` parameter"
msgstr ""
"即使無法將 `py: Python<'py>` token 傳給 `async fn`，我們在 future 執行期間仍"
"會附加到直譯器——就像一般不帶 `Python<'py>`/`Bound<'py, PyAny>` 參數的 `fn` 一"
"樣。"

#: src/async-await.md:46
msgid ""
"It is still possible to get a `Python` marker using [`Python::attach`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.attach); "
"because `attach` is reentrant and optimized, the cost will be negligible."
msgstr ""
"仍可透過 [`Python::attach`](https://pyo3.rs/main/doc/pyo3/marker/struct."
"Python.html#method.attach) 取得 `Python` 標記；由於 `attach` 具備可重入性且已"
"最佳化，其成本可忽略不計。"

#: src/async-await.md:48
msgid "Detaching from the interpreter across `.await`"
msgstr "跨越 `.await` 時從直譯器分離"

#: src/async-await.md:50
msgid ""
"There is currently no simple way to detach from the interpreter when "
"awaiting a future, _but solutions are currently in development_."
msgstr "目前沒有簡單的方法在等待 future 時從直譯器分離，_但解法正在開發中_。"

#: src/async-await.md:52
msgid "Here is the advised workaround for now:"
msgstr "目前建議的替代作法如下："

#: src/async-await.md:80
msgid "Cancellation"
msgstr "取消"

#: src/async-await.md:82
msgid ""
"Cancellation on the Python side can be caught using [`CancelHandle`](https://"
"pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html) type, by "
"annotating a function parameter with `#[pyo3(cancel_handle)]`."
msgstr ""
"可透過 [`CancelHandle`](https://pyo3.rs/main/doc/pyo3/coroutine/struct."
"CancelHandle.html) 型別捕捉 Python 端的取消事件，方法是在函式參數上加註 "
"`#[pyo3(cancel_handle)]`。"

#: src/async-await.md:94
msgid "/* _ = ... => println!(\"done\"), */"
msgstr ""

#: src/async-await.md:95
msgid "\"cancelled\""
msgstr ""

#: src/async-await.md:101
msgid "The `Coroutine` type"
msgstr "`Coroutine` 型別"

#: src/async-await.md:103
msgid ""
"To make a Rust future awaitable in Python, PyO3 defines a [`Coroutine`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.Coroutine.html) type, which "
"implements the Python [coroutine protocol](https://docs.python.org/3/library/"
"collections.abc.html#collections.abc.Coroutine)."
msgstr ""
"為了讓 Rust future 能在 Python 中被 await，PyO3 定義了 [`Coroutine`](https://"
"pyo3.rs/main/doc/pyo3/coroutine/struct.Coroutine.html) 型別，並實作了 Python "
"的[協程協定](https://docs.python.org/3/library/collections.abc."
"html#collections.abc.Coroutine)。"

#: src/async-await.md:105
msgid ""
"Each `coroutine.send` call is translated to a `Future::poll` call. If a "
"[`CancelHandle`](https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle."
"html) parameter is declared, the exception passed to `coroutine.throw` call "
"is stored in it and can be retrieved with [`CancelHandle::cancelled`]"
"(https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle.html#method."
"cancelled); otherwise, it cancels the Rust future, and the exception is "
"reraised;"
msgstr ""
"每次 `coroutine.send` 呼叫都會被轉換為 `Future::poll` 呼叫。若宣告了 "
"[`CancelHandle`](https://pyo3.rs/main/doc/pyo3/coroutine/struct.CancelHandle."
"html) 參數，傳給 `coroutine.throw` 的例外會儲存在其中，並可透過 "
"[`CancelHandle::cancelled`](https://pyo3.rs/main/doc/pyo3/coroutine/struct."
"CancelHandle.html#method.cancelled) 取得；否則會取消 Rust future，並重新拋出"
"該例外；"

#: src/async-await.md:108
msgid ""
"_The type does not yet have a public constructor until the design is "
"finalized._"
msgstr ""
