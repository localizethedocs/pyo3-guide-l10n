msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:40:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/conversions/traits.md:1
msgid "Conversion traits"
msgstr ""

#: src/conversions/traits.md:3
msgid ""
"PyO3 provides some handy traits to convert between Python types and Rust "
"types."
msgstr ""

#: src/conversions/traits.md:5
msgid "`.extract()` and the `FromPyObject` trait"
msgstr ""

#: src/conversions/traits.md:7
msgid ""
"The easiest way to convert a Python object to a Rust value is using `."
"extract()`.  It returns a `PyResult` with a type error if the conversion "
"fails, so usually you will use something like"
msgstr ""

#: src/conversions/traits.md:15
msgid ""
"This method is available for many Python object types, and can produce a "
"wide variety of Rust types, which you can check out in the implementor list "
"of [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)."
msgstr ""

#: src/conversions/traits.md:19
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) is also implemented for your own Rust types wrapped as Python objects "
"(see [the chapter about classes](../class.md)).  There, in order to both be "
"able to operate on mutable references _and_ satisfy Rust's rules of non-"
"aliasing mutable references, you have to extract the PyO3 reference wrappers "
"[`PyRef`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html) and "
"[`PyRefMut`](https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html).  "
"They work like the reference wrappers of `std::cell::RefCell` and ensure (at "
"runtime) that Rust borrows are allowed."
msgstr ""

#: src/conversions/traits.md:26
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html)"
msgstr ""

#: src/conversions/traits.md:28
msgid ""
"[`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject."
"html) can be automatically derived for many kinds of structs and enums if "
"the member types themselves implement `FromPyObject`. This even includes "
"members with a generic type `T: FromPyObject`. Derivation for empty enums, "
"enum variants and structs is not supported."
msgstr ""

#: src/conversions/traits.md:33
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for structs"
msgstr ""

#: src/conversions/traits.md:35
msgid ""
"The derivation generates code that will attempt to access the attribute  "
"`my_string` on the Python object, i.e. `obj.getattr(\"my_string\")`, and "
"call `extract()` on the attribute."
msgstr ""

#: src/conversions/traits.md:38
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    my_string: String,\n"
"}\n"
"#\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let module = PyModule::from_code(\n"
"#             py,\n"
"#             \"class Foo:\n"
"#             def __init__(self):\n"
"#                 self.my_string = 'test'\",\n"
"#             \"\",\n"
"#             \"\",\n"
"#         )?;\n"
"# \n"
"#         let class = module.getattr(\"Foo\")?;\n"
"#         let instance = class.call0()?;\n"
"#         let rustystruct: RustyStruct = instance.extract()?;\n"
"#         assert_eq!(rustystruct.my_string, \"test\");\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:66
msgid ""
"By setting the `#[pyo3(item)]` attribute on the field, PyO3 will attempt to "
"extract the value by calling the `get_item` method on the Python object."
msgstr ""

#: src/conversions/traits.md:68
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    #[pyo3(item)]\n"
"    my_string: String,\n"
"}\n"
"#\n"
"# use pyo3::types::PyDict;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let dict = PyDict::new(py);\n"
"#         dict.set_item(\"my_string\", \"test\")?;\n"
"# \n"
"#         let rustystruct: RustyStruct = dict.extract()?;\n"
"#         assert_eq!(rustystruct.my_string, \"test\");\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:91
msgid "The argument passed to `getattr` and `get_item` can also be configured:"
msgstr ""

#: src/conversions/traits.md:93
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyStruct {\n"
"    #[pyo3(item(\"key\"))]\n"
"    string_in_mapping: String,\n"
"    #[pyo3(attribute(\"name\"))]\n"
"    string_attr: String,\n"
"}\n"
"# \n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let module = PyModule::from_code(\n"
"#             py,\n"
"#             \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.name = 'test'\n"
"#                 self['key'] = 'test2'\",\n"
"#             \"\",\n"
"#             \"\",\n"
"#         )?;\n"
"# \n"
"#         let class = module.getattr(\"Foo\")?;\n"
"#         let instance = class.call0()?;\n"
"#         let rustystruct: RustyStruct = instance.extract()?;\n"
"# \t\tassert_eq!(rustystruct.string_attr, \"test\");\n"
"#         assert_eq!(rustystruct.string_in_mapping, \"test2\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:127
msgid ""
"This tries to extract `string_attr` from the attribute `name` and "
"`string_in_mapping` from a mapping with the key `\"key\"`. The arguments for "
"`attribute` are restricted to non-empty string literals while `item` can "
"take any valid literal that implements `ToBorrowedObject`."
msgstr ""

#: src/conversions/traits.md:132
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for tuple structs"
msgstr ""

#: src/conversions/traits.md:134
msgid ""
"Tuple structs are also supported but do not allow customizing the "
"extraction. The input is always assumed to be a Python tuple with the same "
"length as the Rust type, the `n`th field is extracted from the `n`th item in "
"the Python tuple."
msgstr ""

#: src/conversions/traits.md:138
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTuple(String, String);\n"
"\n"
"# use pyo3::types::PyTuple;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let tuple = PyTuple::new(py, vec![\"test\", \"test2\"]);\n"
"# \n"
"#         let rustytuple: RustyTuple = tuple.extract()?;\n"
"#         assert_eq!(rustytuple.0, \"test\");\n"
"#         assert_eq!(rustytuple.1, \"test2\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:158
msgid ""
"Tuple structs with a single field are treated as wrapper types which are "
"described in the following section. To override this behaviour and ensure "
"that the input is in fact a tuple, specify the struct as"
msgstr ""

#: src/conversions/traits.md:161
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTuple((String,));\n"
"\n"
"# use pyo3::types::PyTuple;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let tuple = PyTuple::new(py, vec![\"test\"]);\n"
"# \n"
"#         let rustytuple: RustyTuple = tuple.extract()?;\n"
"#         assert_eq!((rustytuple.0).0, \"test\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:180
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for wrapper types"
msgstr ""

#: src/conversions/traits.md:182
msgid ""
"The `pyo3(transparent)` attribute can be used on structs with exactly one "
"field. This results in extracting directly from the input object, i.e. `obj."
"extract()`, rather than trying to access an item or attribute. This "
"behaviour is enabled per default for newtype structs and tuple-variants with "
"a single field."
msgstr ""

#: src/conversions/traits.md:187
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"struct RustyTransparentTupleStruct(String);\n"
"\n"
"#[derive(FromPyObject)]\n"
"#[pyo3(transparent)]\n"
"struct RustyTransparentStruct {\n"
"    inner: String,\n"
"}\n"
"\n"
"# use pyo3::types::PyString;\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         let s = PyString::new(py, \"test\");\n"
"# \n"
"#         let tup: RustyTransparentTupleStruct = s.extract()?;\n"
"#         assert_eq!(tup.0, \"test\");\n"
"# \n"
"#         let stru: RustyTransparentStruct = s.extract()?;\n"
"#         assert_eq!(stru.inner, \"test\");\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:215
msgid ""
"Deriving [`FromPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait."
"FromPyObject.html) for enums"
msgstr ""

#: src/conversions/traits.md:217
msgid ""
"The `FromPyObject` derivation for enums generates code that tries to extract "
"the variants in the order of the fields. As soon as a variant can be "
"extracted succesfully, that variant is returned. This makes it possible to "
"extract Python union types like `str | int`."
msgstr ""

#: src/conversions/traits.md:221
msgid ""
"The same customizations and restrictions described for struct derivations "
"apply to enum variants, i.e. a tuple variant assumes that the input is a "
"Python tuple, and a struct variant defaults to extracting fields as "
"attributes but can be configured in the same manner. The `transparent` "
"attribute can be applied to single-field-variants."
msgstr ""

#: src/conversions/traits.md:226
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"# #[derive(Debug)]\n"
"enum RustyEnum<'a> {\n"
"    Int(usize), // input is a positive int\n"
"    String(String), // input is a string\n"
"    IntTuple(usize, usize), // input is a 2-tuple with positive ints\n"
"    StringIntTuple(String, usize), // input is a 2-tuple with String and "
"int\n"
"    Coordinates3d { // needs to be in front of 2d\n"
"        x: usize,\n"
"        y: usize,\n"
"        z: usize,\n"
"    },\n"
"    Coordinates2d { // only gets checked if the input did not have `z`\n"
"        #[pyo3(attribute(\"x\"))]\n"
"        a: usize,\n"
"        #[pyo3(attribute(\"y\"))]\n"
"        b: usize,\n"
"    },\n"
"    #[pyo3(transparent)]\n"
"    CatchAll(&'a PyAny), // This extraction never fails\n"
"}\n"
"# \n"
"# use pyo3::types::{PyBytes, PyString};\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         {\n"
"#             let thing = 42_u8.to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 42,\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Int(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = PyString::new(py, \"text\");\n"
"#             let rust_thing: RustyEnum = thing.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 \"text\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::String(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = (32_u8, 73_u8).to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (32, 73),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::IntTuple(i, j) => (i, j),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let thing = (\"foo\", 73_u8).to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (String::from(\"foo\"), 73),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::StringIntTuple(i, j) => (i, j),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         {\n"
"#             let module = PyModule::from_code(\n"
"#                 py,\n"
"#                 \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 0\n"
"#                 self.y = 1\n"
"#                 self.z = 2\",\n"
"#                 \"\",\n"
"#                 \"\",\n"
"#             )?;\n"
"# \n"
"#             let class = module.getattr(\"Foo\")?;\n"
"#             let instance = class.call0()?;\n"
"#             let rust_thing: RustyEnum = instance.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (0, 1, 2),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Coordinates3d { x, y, z } => (x, y, z),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let module = PyModule::from_code(\n"
"#                 py,\n"
"#                 \"class Foo(dict):\n"
"#             def __init__(self):\n"
"#                 self.x = 3\n"
"#                 self.y = 4\",\n"
"#                 \"\",\n"
"#                 \"\",\n"
"#             )?;\n"
"# \n"
"#             let class = module.getattr(\"Foo\")?;\n"
"#             let instance = class.call0()?;\n"
"#             let rust_thing: RustyEnum = instance.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 (3, 4),\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Coordinates2d { a, b } => (a, b),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = PyBytes::new(py, b\"text\");\n"
"#             let rust_thing: RustyEnum = thing.extract()?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 b\"text\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::CatchAll(i) => i.downcast::<PyBytes>()?."
"as_bytes(),\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:368
msgid ""
"If none of the enum variants match, a `PyTypeError` containing the names of "
"the tested variants is returned. The names reported in the error message can "
"be customized through the `#[pyo3(annotation = \"name\")]` attribute, e.g. "
"to use conventional Python type names:"
msgstr ""

#: src/conversions/traits.md:373
msgid ""
"```\n"
"use pyo3::prelude::*;\n"
"\n"
"#[derive(FromPyObject)]\n"
"# #[derive(Debug)]\n"
"enum RustyEnum {\n"
"    #[pyo3(transparent, annotation = \"str\")]\n"
"    String(String),\n"
"    #[pyo3(transparent, annotation = \"int\")]\n"
"    Int(isize),\n"
"}\n"
"#\n"
"# fn main() -> PyResult<()> {\n"
"#     Python::with_gil(|py| -> PyResult<()> {\n"
"#         {\n"
"#             let thing = 42_u8.to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 42,\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::Int(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = \"foo\".to_object(py);\n"
"#             let rust_thing: RustyEnum = thing.extract(py)?;\n"
"# \n"
"#             assert_eq!(\n"
"#                 \"foo\",\n"
"#                 match rust_thing {\n"
"#                     RustyEnum::String(i) => i,\n"
"#                     other => unreachable!(\"Error extracting: {:?}\", "
"other),\n"
"#                 }\n"
"#             );\n"
"#         }\n"
"# \n"
"#         {\n"
"#             let thing = b\"foo\".to_object(py);\n"
"#             let error = thing.extract::<RustyEnum>(py).unwrap_err();\n"
"#             assert!(error.is_instance::<pyo3::exceptions::"
"PyTypeError>(py));\n"
"#         }\n"
"# \n"
"#         Ok(())\n"
"#     })\n"
"# }\n"
"```"
msgstr ""

#: src/conversions/traits.md:424
msgid ""
"If the input is neither a string nor an integer, the error message will be: "
"`\"'<INPUT_TYPE>' cannot be converted to 'str | int'\"`."
msgstr ""

#: src/conversions/traits.md:427
msgid "`#[derive(FromPyObject)]` Container Attributes"
msgstr ""

#: src/conversions/traits.md:428
msgid "`pyo3(transparent)`"
msgstr ""

#: src/conversions/traits.md:429
msgid ""
"extract the field directly from the object as `obj.extract()` instead of "
"`get_item()` or `getattr()`"
msgstr ""

#: src/conversions/traits.md:431
msgid ""
"Newtype structs and tuple-variants are treated as transparent per default."
msgstr ""

#: src/conversions/traits.md:432
msgid "only supported for single-field structs and enum variants"
msgstr ""

#: src/conversions/traits.md:433
msgid "`pyo3(annotation = \"name\")`"
msgstr ""

#: src/conversions/traits.md:434
msgid ""
"changes the name of the failed variant in the generated error message in "
"case of failure."
msgstr ""

#: src/conversions/traits.md:435
msgid "e.g. `pyo3(\"int\")` reports the variant's type as `int`."
msgstr ""

#: src/conversions/traits.md:436
msgid "only supported for enum variants"
msgstr ""

#: src/conversions/traits.md:438
msgid "`#[derive(FromPyObject)]` Field Attributes"
msgstr ""

#: src/conversions/traits.md:439
msgid "`pyo3(attribute)`, `pyo3(attribute(\"name\"))`"
msgstr ""

#: src/conversions/traits.md:440
msgid ""
"retrieve the field from an attribute, possibly with a custom name specified "
"as an argument"
msgstr ""

#: src/conversions/traits.md:441
msgid "argument must be a string-literal."
msgstr ""

#: src/conversions/traits.md:442
msgid "`pyo3(item)`, `pyo3(item(\"key\"))`"
msgstr ""

#: src/conversions/traits.md:443
msgid ""
"retrieve the field from a mapping, possibly with the custom key specified as "
"an argument."
msgstr ""

#: src/conversions/traits.md:444
msgid "can be any literal that implements `ToBorrowedObject`"
msgstr ""

#: src/conversions/traits.md:446
msgid "`IntoPy<T>`"
msgstr ""

#: src/conversions/traits.md:448
msgid ""
"This trait defines the to-python conversion for a Rust type. It is usually "
"implemented as `IntoPy<PyObject>`, which is the trait needed for returning a "
"value from `#[pyfunction]` and `#[pymethods]`."
msgstr ""

#: src/conversions/traits.md:452
msgid ""
"All types in PyO3 implement this trait, as does a `#[pyclass]` which doesn't "
"use `extends`."
msgstr ""

#: src/conversions/traits.md:454
msgid ""
"Occasionally you may choose to implement this for custom types which are "
"mapped to Python types _without_ having a unique python type."
msgstr ""

#: src/conversions/traits.md:469
msgid "The `ToPyObject` trait"
msgstr ""

#: src/conversions/traits.md:471
msgid ""
"[`ToPyObject`](https://pyo3.rs/main/doc/pyo3/conversion/trait.ToPyObject."
"html) is a conversion trait that allows various objects to be converted into "
"[`PyObject`](https://pyo3.rs/main/doc/pyo3/type.PyObject.html). "
"`IntoPy<PyObject>` serves the same purpose, except that it consumes `self`."
msgstr ""
