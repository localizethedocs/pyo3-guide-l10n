msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:40:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/exception.md:1
msgid "Python Exceptions"
msgstr ""

#: src/exception.md:3
msgid "Defining a new exception"
msgstr ""

#: src/exception.md:5
msgid ""
"You can use the [`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"create_exception.html) macro to define a new exception type:"
msgstr ""

#: src/exception.md:13
msgid "`module` is the name of the containing module."
msgstr ""

#: src/exception.md:14
msgid "`MyError` is the name of the new exception type."
msgstr ""

#: src/exception.md:16
msgid "For example:"
msgstr ""

#: src/exception.md:27 src/exception.md:43
msgid "\"CustomError\""
msgstr ""

#: src/exception.md:28
msgid "\"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\""
msgstr ""

#: src/exception.md:29
msgid "\"assert CustomError('oops').args == ('oops',)\""
msgstr ""

#: src/exception.md:33
msgid ""
"When using PyO3 to create an extension module, you can add the new exception "
"to the module like this, so that it is importable from Python:"
msgstr ""

#: src/exception.md:42
msgid "// ... other elements added to module ...\n"
msgstr ""

#: src/exception.md:50
msgid "Raising an exception"
msgstr ""

#: src/exception.md:52
msgid ""
"To raise an exception from `pyfunction`s and `pymethods`, you should return "
"an `Err(PyErr)`. If returned to Python code, this [`PyErr`](https://pyo3.rs/"
"main/doc/pyo3/struct.PyErr.html) will then be raised as a Python exception. "
"Many PyO3 APIs also return [`PyResult`](https://pyo3.rs/main/doc/pyo3/type."
"PyResult.html)."
msgstr ""

#: src/exception.md:55
msgid ""
"If a Rust type exists for the exception, then it is possible to use the "
"`new_err` method. For example, each standard exception defined in the `pyo3::"
"exceptions` module has a corresponding Rust type and exceptions defined by "
"[`create_exception!`](https://pyo3.rs/main/doc/pyo3/macro.create_exception."
"html) and [`import_exception!`](https://pyo3.rs/main/doc/pyo3/macro."
"import_exception.html) macro have Rust types as well."
msgstr ""

#: src/exception.md:67
msgid "\"division by zero\""
msgstr ""

#: src/exception.md:80
msgid ""
"You can also manually write and fetch errors in the Python interpreter's "
"global state:"
msgstr ""

#: src/exception.md:87
msgid "\"Error\""
msgstr ""

#: src/exception.md:93
msgid ""
"If you already have a Python exception instance, you can simply call "
"[`PyErr::from_instance`](https://pyo3.rs/main/doc/pyo3/struct.PyErr."
"html#method.from_instance)."
msgstr ""

#: src/exception.md:100
msgid "Checking exception types"
msgstr ""

#: src/exception.md:102
msgid ""
"Python has an [`isinstance`](https://docs.python.org/3/library/functions."
"html#isinstance) method to check an object's type. In PyO3 every native type "
"has access to the [`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/"
"struct.PyAny.html#method.is_instance) method which does the same thing."
msgstr ""

#: src/exception.md:116
msgid ""
"[`PyAny::is_instance`](https://pyo3.rs/main/doc/pyo3/struct.PyAny."
"html#method.is_instance) calls the underlying [`PyType::is_instance`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyType.html#method.is_instance) "
"method to do the actual work."
msgstr ""

#: src/exception.md:119
msgid "To check the type of an exception, you can similarly do:"
msgstr ""

#: src/exception.md:130
msgid "Handling Rust errors"
msgstr ""

#: src/exception.md:132
msgid ""
"The vast majority of operations in this library will return [`PyResult<T>`]"
"(https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html), which is an "
"alias for the type `Result<T, PyErr>`."
msgstr ""

#: src/exception.md:136
msgid ""
"A [`PyErr`](https://pyo3.rs/main/doc/pyo3/struct.PyErr.html) represents a "
"Python exception. Errors within the PyO3 library are also exposed as Python "
"exceptions."
msgstr ""

#: src/exception.md:139
msgid ""
"If your code has a custom error type, adding an implementation of `std::"
"convert::From<MyError> for PyErr` is usually enough. PyO3 will then "
"automatically convert your error to a Python exception when needed."
msgstr ""

#: src/exception.md:142
msgid ""
"The following code snippet defines a Rust error named `CustomIOError`. In "
"its `From<CustomIOError> for PyErr` implementation it returns a `PyErr` "
"representing Python's `OSError`."
msgstr ""

#: src/exception.md:157
msgid "\"Oh no!\""
msgstr ""

#: src/exception.md:167 src/exception.md:173
msgid "/* ... */"
msgstr ""

#: src/exception.md:170 src/exception.md:186
msgid "\"0.0.0.0\""
msgstr ""

#: src/exception.md:192
msgid ""
"This has been implemented for most of Rust's standard library errors, so "
"that you can use the `?` (\"try\") operator with them. The following code "
"snippet will raise a `ValueError` in Python if `String::parse()` returns an "
"error."
msgstr ""

#: src/exception.md:207
msgid "\"1\""
msgstr ""

#: src/exception.md:208
msgid "\"1337\""
msgstr ""

#: src/exception.md:210
msgid "\"-1\""
msgstr ""

#: src/exception.md:213
msgid "\"foo\""
msgstr ""

#: src/exception.md:216
msgid "\"13.37\""
msgstr ""

#: src/exception.md:223
msgid ""
"If lazy construction of the Python exception instance is desired, the "
"[`PyErrArguments`](https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html) "
"trait can be implemented. In that case, actual exception argument creation "
"is delayed until the `PyErr` is needed."
msgstr ""

#: src/exception.md:228
msgid "Using exceptions defined in Python code"
msgstr ""

#: src/exception.md:230
msgid ""
"It is possible to use an exception defined in Python code as a native Rust "
"type. The `import_exception!` macro allows importing a specific exception "
"class and defines a Rust type for that exception."
msgstr ""

#: src/exception.md:243
msgid "\"tell\""
msgstr ""

#: src/exception.md:244
msgid "\"not supported: tell\""
msgstr ""

#: src/exception.md:251
msgid ""
"[`pyo3::exceptions`](https://pyo3.rs/main/doc/pyo3/exceptions/index.html) "
"defines exceptions for several standard library modules."
msgstr ""
