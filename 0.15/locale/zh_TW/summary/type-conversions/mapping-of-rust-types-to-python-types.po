msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:40:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/conversions/tables.md:1
msgid "Mapping of Rust types to Python types"
msgstr "Rust 型別對應到 Python 型別"

#: src/conversions/tables.md:3
msgid ""
"When writing functions callable from Python (such as a `#[pyfunction]` or in "
"a `#[pymethods]` block), the trait `FromPyObject` is required for function "
"arguments, and `IntoPy<PyObject>` is required for function return values."
msgstr ""

#: src/conversions/tables.md:5
msgid ""
"Consult the tables in the following section to find the Rust types provided "
"by PyO3 which implement these traits."
msgstr "請參考下一節的表格，找出 PyO3 提供且實作這些特徵的 Rust 型別。"

#: src/conversions/tables.md:7
msgid "Argument Types"
msgstr "引數型別"

#: src/conversions/tables.md:9
msgid ""
"When accepting a function argument, it is possible to either use Rust "
"library types or PyO3's Python-native types. (See the next section for "
"discussion on when to use each.)"
msgstr ""
"接受函式引數時，可以使用 Rust 函式庫型別或 PyO3 的 Python 原生型別。（何時使"
"用哪種型別，請見下一節。）"

#: src/conversions/tables.md:11
msgid ""
"The table below contains the Python type and the corresponding function "
"argument types that will accept them:"
msgstr "下表列出 Python 型別及其對應可接受的函式引數型別："

#: src/conversions/tables.md:13
msgid "Python"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust"
msgstr ""

#: src/conversions/tables.md:13
msgid "Rust (Python-native)"
msgstr "Rust（Python 原生）"

#: src/conversions/tables.md:15
msgid "`object`"
msgstr ""

#: src/conversions/tables.md:15 src/conversions/tables.md:28
#: src/conversions/tables.md:29 src/conversions/tables.md:30
#: src/conversions/tables.md:31 src/conversions/tables.md:32
#: src/conversions/tables.md:33 src/conversions/tables.md:34
#: src/conversions/tables.md:35 src/conversions/tables.md:36
#: src/conversions/tables.md:39 src/conversions/tables.md:40
msgid "\\-"
msgstr ""

#: src/conversions/tables.md:15
msgid "`&PyAny`"
msgstr ""

#: src/conversions/tables.md:16 src/conversions/tables.md:79
#: src/conversions/tables.md:80
msgid "`str`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`String`, `Cow<str>`, `&str`, `OsString`, `PathBuf`"
msgstr ""

#: src/conversions/tables.md:16
msgid "`&PyUnicode`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`bytes`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`Vec<u8>`, `&[u8]`"
msgstr ""

#: src/conversions/tables.md:17
msgid "`&PyBytes`"
msgstr ""

#: src/conversions/tables.md:18 src/conversions/tables.md:81
msgid "`bool`"
msgstr ""

#: src/conversions/tables.md:18
msgid "`&PyBool`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "`int`"
msgstr ""

#: src/conversions/tables.md:19 src/conversions/tables.md:82
msgid "Any integer type (`i32`, `u32`, `usize`, etc)"
msgstr ""

#: src/conversions/tables.md:19
msgid "`&PyLong`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`float`"
msgstr ""

#: src/conversions/tables.md:20 src/conversions/tables.md:83
msgid "`f32`, `f64`"
msgstr ""

#: src/conversions/tables.md:20
msgid "`&PyFloat`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`complex`"
msgstr ""

#: src/conversions/tables.md:21
msgid "`num_complex::Complex`[^1]"
msgstr ""

#: src/conversions/tables.md:21
msgid "`&PyComplex`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`list[T]`"
msgstr ""

#: src/conversions/tables.md:22 src/conversions/tables.md:37
#: src/conversions/tables.md:86
msgid "`Vec<T>`"
msgstr ""

#: src/conversions/tables.md:22
msgid "`&PyList`"
msgstr ""

#: src/conversions/tables.md:23
msgid "`dict[K, V]`"
msgstr ""

#: src/conversions/tables.md:23 src/conversions/tables.md:38
msgid ""
"`HashMap<K, V>`, `BTreeMap<K, V>`, `hashbrown::HashMap<K, V>`[^2], "
"`indexmap::IndexMap<K, V>`[^3]"
msgstr ""

#: src/conversions/tables.md:23
msgid "`&PyDict`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`tuple[T, U]`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`(T, U)`, `Vec<T>`"
msgstr ""

#: src/conversions/tables.md:24
msgid "`&PyTuple`"
msgstr ""

#: src/conversions/tables.md:25
msgid "`set[T]`"
msgstr ""

#: src/conversions/tables.md:25 src/conversions/tables.md:26
msgid "`HashSet<T>`, `BTreeSet<T>`, `hashbrown::HashSet<T>`[^2]"
msgstr ""

#: src/conversions/tables.md:25
msgid "`&PySet`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`frozenset[T]`"
msgstr ""

#: src/conversions/tables.md:26
msgid "`&PyFrozenSet`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`bytearray`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`Vec<u8>`"
msgstr ""

#: src/conversions/tables.md:27
msgid "`&PyByteArray`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`slice`"
msgstr ""

#: src/conversions/tables.md:28
msgid "`&PySlice`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`type`"
msgstr ""

#: src/conversions/tables.md:29
msgid "`&PyType`"
msgstr ""

#: src/conversions/tables.md:30
msgid "`module`"
msgstr "`module`"

#: src/conversions/tables.md:30
msgid "`&PyModule`"
msgstr ""

#: src/conversions/tables.md:31
msgid "`datetime.datetime`"
msgstr "`datetime.datetime`"

#: src/conversions/tables.md:31
msgid "`&PyDateTime`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`datetime.date`"
msgstr ""

#: src/conversions/tables.md:32
msgid "`&PyDate`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`datetime.time`"
msgstr ""

#: src/conversions/tables.md:33
msgid "`&PyTime`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`datetime.tzinfo`"
msgstr ""

#: src/conversions/tables.md:34
msgid "`&PyTzInfo`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`datetime.timedelta`"
msgstr ""

#: src/conversions/tables.md:35
msgid "`&PyDelta`"
msgstr ""

#: src/conversions/tables.md:36
msgid "`typing.Optional[T]`"
msgstr ""

#: src/conversions/tables.md:36 src/conversions/tables.md:84
msgid "`Option<T>`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`typing.Sequence[T]`"
msgstr ""

#: src/conversions/tables.md:37
msgid "`&PySequence`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`typing.Mapping[K, V]`"
msgstr ""

#: src/conversions/tables.md:38
msgid "`&PyMapping`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`typing.Iterator[Any]`"
msgstr ""

#: src/conversions/tables.md:39
msgid "`&PyIterator`"
msgstr ""

#: src/conversions/tables.md:40
msgid "`typing.Union[...]`"
msgstr ""

#: src/conversions/tables.md:40
msgid ""
"See [`#[derive(FromPyObject)]`](traits.html#deriving-a-"
"hrefhttpsdocsrspyo3latestpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-"
"for-enums)"
msgstr ""

#: src/conversions/tables.md:42
msgid ""
"There are also a few special types related to the GIL and Rust-defined "
"`#[pyclass]`es which may come in useful:"
msgstr ""

#: src/conversions/tables.md:44
msgid "What"
msgstr "項目"

#: src/conversions/tables.md:44
msgid "Description"
msgstr "說明"

#: src/conversions/tables.md:46
msgid "`Python`"
msgstr ""

#: src/conversions/tables.md:46
msgid ""
"A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL"
msgstr ""

#: src/conversions/tables.md:47
msgid "`Py<T>`"
msgstr ""

#: src/conversions/tables.md:47
msgid ""
"A Python object isolated from the GIL lifetime. This can be sent to other "
"threads."
msgstr ""

#: src/conversions/tables.md:48
msgid "`PyObject`"
msgstr ""

#: src/conversions/tables.md:48
msgid "An alias for `Py<PyAny>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "`&PyCell<T>`"
msgstr ""

#: src/conversions/tables.md:49
msgid "A `#[pyclass]` value owned by Python."
msgstr ""

#: src/conversions/tables.md:50
msgid "`PyRef<T>`"
msgstr ""

#: src/conversions/tables.md:50
msgid "A `#[pyclass]` borrowed immutably."
msgstr "不可變借用的 `#[pyclass]`。"

#: src/conversions/tables.md:51
msgid "`PyRefMut<T>`"
msgstr ""

#: src/conversions/tables.md:51
msgid "A `#[pyclass]` borrowed mutably."
msgstr "可變借用的 `#[pyclass]`。"

#: src/conversions/tables.md:53
msgid ""
"For more detail on accepting `#[pyclass]` values as function arguments, see "
"[the section of this guide on Python Classes](../class.md)."
msgstr ""
"更多關於將 `#[pyclass]` 作為函式引數的細節，請見本指南的[Python 類別章節](../"
"class.md)。"

#: src/conversions/tables.md:55
msgid "Using Rust library types vs Python-native types"
msgstr "使用 Rust 函式庫型別 vs Python 原生型別"

#: src/conversions/tables.md:57
msgid ""
"Using Rust library types as function arguments will incur a conversion cost "
"compared to using the Python-native types. Using the Python-native types is "
"almost zero-cost (they just require a type check similar to the Python "
"builtin function `isinstance()`)."
msgstr ""
"使用 Rust 函式庫型別作為函式引數，相較於 Python 原生型別會產生轉換成本。使用 "
"Python 原生型別幾乎是零成本（只需進行類似 Python 內建函式 `isinstance()` 的型"
"別檢查）。"

#: src/conversions/tables.md:59
msgid ""
"However, once that conversion cost has been paid, the Rust standard library "
"types offer a number of benefits:"
msgstr "不過，一旦付出轉換成本，Rust 標準函式庫型別會帶來多項好處："

#: src/conversions/tables.md:60
msgid ""
"You can write functionality in native-speed Rust code (free of Python's "
"runtime costs)."
msgstr "你可以用原生速度的 Rust 程式碼實作功能（不受 Python 執行期成本影響）。"

#: src/conversions/tables.md:61
msgid "You get better interoperability with the rest of the Rust ecosystem."
msgstr "可與 Rust 生態系的其他元件有更好的互通性。"

#: src/conversions/tables.md:62
msgid ""
"You can use `Python::allow_threads` to release the Python GIL and let other "
"Python threads make progress while your Rust code is executing."
msgstr ""

#: src/conversions/tables.md:63
msgid ""
"You also benefit from stricter type checking. For example you can specify "
"`Vec<i32>`, which will only accept a Python `list` containing integers. The "
"Python-native equivalent, `&PyList`, would accept a Python `list` containing "
"Python objects of any type."
msgstr ""
"你也會受益於更嚴格的型別檢查。例如指定 `Vec<i32>`，只會接受包含整數的 Python "
"`list`。相對的 Python 原生等價型別 `&PyList` 會接受包含任何型別 Python 物件"
"的 `list`。"

#: src/conversions/tables.md:65
msgid ""
"For most PyO3 usage the conversion cost is worth paying to get these "
"benefits. As always, if you're not sure it's worth it in your case, "
"benchmark it!"
msgstr ""
"對於多數 PyO3 使用情境，付出轉換成本以換取上述好處是值得的。一如往常，若不確"
"定是否值得，請進行基準測試！"

#: src/conversions/tables.md:67
msgid "Returning Rust values to Python"
msgstr "將 Rust 值回傳給 Python"

#: src/conversions/tables.md:69
msgid ""
"When returning values from functions callable from Python, Python-native "
"types (`&PyAny`, `&PyDict` etc.) can be used with zero cost."
msgstr ""

#: src/conversions/tables.md:71
msgid ""
"Because these types are references, in some situations the Rust compiler may "
"ask for lifetime annotations. If this is the case, you should use "
"`Py<PyAny>`, `Py<PyDict>` etc. instead - which are also zero-cost. For all "
"of these Python-native types `T`, `Py<T>` can be created from `T` with an `."
"into()` conversion."
msgstr ""

#: src/conversions/tables.md:73
msgid ""
"If your function is fallible, it should return `PyResult<T>` or `Result<T, "
"E>` where `E` implements `From<E> for PyErr`. This will raise a `Python` "
"exception if the `Err` variant is returned."
msgstr ""
"若函式可能失敗，應回傳 `PyResult<T>` 或 `Result<T, E>`，其中 `E` 需實作 "
"`From<E> for PyErr`。若回傳 `Err` 變體，將拋出 `Python` 例外。"

#: src/conversions/tables.md:75
msgid ""
"Finally, the following Rust types are also able to convert to Python as "
"return values:"
msgstr "最後，以下 Rust 型別也可作為回傳值轉換為 Python："

#: src/conversions/tables.md:77
msgid "Rust type"
msgstr "Rust 型別"

#: src/conversions/tables.md:77
msgid "Resulting Python Type"
msgstr "對應的 Python 型別"

#: src/conversions/tables.md:79
msgid "`String`"
msgstr ""

#: src/conversions/tables.md:80
msgid "`&str`"
msgstr ""

#: src/conversions/tables.md:84
msgid "`Optional[T]`"
msgstr "`Optional[T]`"

#: src/conversions/tables.md:85
msgid "`(T, U)`"
msgstr "`(T, U)`"

#: src/conversions/tables.md:85
msgid "`Tuple[T, U]`"
msgstr "`Tuple[T, U]`"

#: src/conversions/tables.md:86
msgid "`List[T]`"
msgstr "`List[T]`"

#: src/conversions/tables.md:87
msgid "`HashMap<K, V>`"
msgstr "`HashMap<K, V>`"

#: src/conversions/tables.md:87 src/conversions/tables.md:88
msgid "`Dict[K, V]`"
msgstr "`Dict[K, V]`"

#: src/conversions/tables.md:88
msgid "`BTreeMap<K, V>`"
msgstr "`BTreeMap<K, V>`"

#: src/conversions/tables.md:89
msgid "`HashSet<T>`"
msgstr "`HashSet<T>`"

#: src/conversions/tables.md:89 src/conversions/tables.md:90
msgid "`Set[T]`"
msgstr "`Set[T]`"

#: src/conversions/tables.md:90
msgid "`BTreeSet<T>`"
msgstr "`BTreeSet<T>`"

#: src/conversions/tables.md:91
msgid "`&PyCell<T: PyClass>`"
msgstr ""

#: src/conversions/tables.md:91 src/conversions/tables.md:92
#: src/conversions/tables.md:93
msgid "`T`"
msgstr "`T`"

#: src/conversions/tables.md:92
msgid "`PyRef<T: PyClass>`"
msgstr "`PyRef<T: PyClass>`"

#: src/conversions/tables.md:93
msgid "`PyRefMut<T: PyClass>`"
msgstr "`PyRefMut<T: PyClass>`"

#: src/conversions/tables.md:95
msgid "Requires the `num-complex` optional feature."
msgstr "需要 `num-complex` 選用功能。"

#: src/conversions/tables.md:97
msgid "Requires the `hashbrown` optional feature."
msgstr "需要 `hashbrown` 選用功能。"

#: src/conversions/tables.md:99
msgid "Requires the `indexmap` optional feature."
msgstr "需要 `indexmap` 選用功能。"
