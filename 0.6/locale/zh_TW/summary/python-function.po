msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/function.md:1
msgid "Python Function"
msgstr ""

#: src/function.md:3
msgid ""
"PyO3 supports two ways to define a function in python. Both require "
"registering the function to a [module](./module.md)"
msgstr ""

#: src/function.md:6
msgid "One way is defining the function in the module definition."
msgstr ""

#: src/function.md:15
msgid ""
"// Note that the `#[pyfn()]` annotation automatically converts the arguments "
"from\n"
"    // Python objects to Rust values; and the Rust return value back into a "
"Python object.\n"
msgstr ""

#: src/function.md:17
msgid "\"sum_as_string\""
msgstr ""

#: src/function.md:19
msgid "\"{}\""
msgstr ""

#: src/function.md:28
msgid ""
"The other is annotating a function with `#[pyfunction]` and then adding it "
"to the module using the `add_wrapped_to_module!` macro, which takes the "
"module as first parameter, the function name as second and an instance of "
"`Python` as third."
msgstr ""

#: src/function.md:53
msgid "Making the function signature available to Python"
msgstr ""

#: src/function.md:55
msgid ""
"In order to make the function signature available to Python to be retrieved "
"via `inspect.signature`, simply make sure the first line of your doc-string "
"is formatted like in the example below. Please note that the new-line after "
"the `--` is mandatory. The `/` signifies the end of positional only "
"arguments. This is not a feature of this library in particular, but the "
"general format used by CPython for annotating signatures of built-in "
"functions. Function signatures for built-ins are new in Python 3 â€” in Python "
"2, it is simply considered to be part of the doc-string."
msgstr ""

#: src/function.md:67
msgid ""
"/// add(a, b, /)\n"
"/// --\n"
"///\n"
"/// This function adds two unsigned 64-bit integers.\n"
msgstr ""

#: src/function.md:78
msgid ""
"When annotated like this, signatures are also correctly displayed in IPython."
msgstr ""

#: src/function.md:86
msgid "Closures"
msgstr ""

#: src/function.md:88
msgid ""
"Currently, there are no conversions between `Fn`s in rust and callables in "
"python. This would definitely be possible and very useful, so contributions "
"are welcome. In the meantime, you can do the following:"
msgstr ""

#: src/function.md:90
msgid "Calling a python function in rust"
msgstr ""

#: src/function.md:92
msgid ""
"You can use `ObjectProtocol::is_callable` to check if you got a callable, "
"which is true for functions (including lambdas), methods and objects with a "
"`__call__` method. You can call the object with `ObjectProtocol::call` with "
"the args as first parameter and the kwargs (or `None`) as second parameter. "
"There are also `ObjectProtocol::call0` with no args and `ObjectProtocol::"
"call1` with only the args."
msgstr ""

#: src/function.md:94
msgid "Calling rust `Fn`s in python"
msgstr ""

#: src/function.md:96
msgid ""
"If you have a static function, you can expose it with `#[pyfunction]` and "
"use `wrap_pyfunction!` to get the corresponding `PyObject`. For dynamic "
"functions, e.g. lambda and functions that were passed as arguments, you must "
"put them in some kind of owned container, e.g. a box. (Long-Term a special "
"container similar to wasm-bindgen's `Closure` should take care of that). You "
"can than use a `#[pyclass]` struct with that container as field as a way to "
"pass the function over the ffi-barrier. You can even make that class "
"callable with `__call__` so it looks like a function in python code."
msgstr ""
