msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/class.md:1
msgid "Python Class"
msgstr ""

#: src/class.md:3
msgid "Define new class"
msgstr ""

#: src/class.md:5
msgid ""
"To define a custom python class, a rust struct needs to be annotated with "
"the `#[pyclass]` attribute."
msgstr ""

#: src/class.md:19
msgid ""
"The above example generates implementations for `PyTypeInfo` and "
"`PyTypeObject` for `MyClass`."
msgstr ""

#: src/class.md:21
msgid "Get Python objects from `pyclass`"
msgstr ""

#: src/class.md:22
msgid "You can use `pyclass`es like normal rust structs."
msgstr ""

#: src/class.md:24
msgid ""
"However, if instantiated normally, you can't treat `pyclass`es as Python "
"objects."
msgstr ""

#: src/class.md:26
msgid ""
"To get a Python object which includes `pyclass`, we have to use some special "
"methods."
msgstr ""

#: src/class.md:28
msgid "`PyRef`"
msgstr ""

#: src/class.md:29
msgid ""
"`PyRef` is a special reference, which ensures that the referred struct is a "
"part of a Python object, and you are also holding the GIL."
msgstr ""

#: src/class.md:32
msgid ""
"You can get an instance of `PyRef` by `PyRef::new`, which does 3 things:"
msgstr ""

#: src/class.md:33
msgid "Allocate a Python object in the Python heap"
msgstr ""

#: src/class.md:34
msgid "Copies the rust struct into the Python object"
msgstr ""

#: src/class.md:35
msgid "Returns a reference of it"
msgstr ""

#: src/class.md:37
msgid ""
"You can use `PyRef` just like `&T`, because it implements `Deref<Target=T>`."
msgstr ""

#: src/class.md:51
msgid "// You can treat a `PyRef` as a Python object\n"
msgstr ""

#: src/class.md:53
msgid "\"obj\""
msgstr ""

#: src/class.md:56
msgid "`PyRefMut`"
msgstr ""

#: src/class.md:57
msgid "`PyRefMut` is a mutable version of `PyRef`."
msgstr ""

#: src/class.md:72
msgid "`Py`"
msgstr ""

#: src/class.md:73
msgid ""
"`Py` is a object wrapper which stores an object longer than the GIL lifetime."
msgstr ""

#: src/class.md:75
msgid "You can use it to avoid lifetime problems."
msgstr ""

#: src/class.md:93
msgid "Customizing the class"
msgstr ""

#: src/class.md:95
msgid "The `#[pyclass]` macro accepts following parameters:"
msgstr ""

#: src/class.md:97
msgid ""
"`name=XXX` - Set the class name shown in python code. By default struct name "
"is used as a class name."
msgstr ""

#: src/class.md:98
msgid ""
"`freelist=XXX` - `freelist` parameter add support of free allocation list to "
"custom class. The performance improvement applies to types that are often "
"created and deleted in a row, so that they can benefit from a freelist. "
"`XXX` is a number of items for free list."
msgstr ""

#: src/class.md:101
msgid ""
"`gc` - Classes with the `gc` parameter participate in python garbage "
"collector. If a custom class contains references to other python object that "
"can be collected, the `PyGCProtocol` trait has to be implemented."
msgstr ""

#: src/class.md:104
msgid "`weakref` - adds support for python weak references"
msgstr ""

#: src/class.md:105
msgid ""
"`extends=BaseType` - use a custom base class. The base BaseType must "
"implement `PyTypeInfo`."
msgstr ""

#: src/class.md:106
msgid "`subclass` - Allows Python classes to inherit from this class"
msgstr ""

#: src/class.md:107
msgid ""
"`dict` - adds `__dict__` support, the instances of this type have a "
"dictionary containing instance variables."
msgstr ""

#: src/class.md:109
msgid "Constructor"
msgstr ""

#: src/class.md:111
msgid ""
"By default it is not possible to create an instance of a custom class from "
"python code. To declare a constructor, you need to define a class method and "
"annotate it with `#[new]` attribute. Only the python `__new__` method can be "
"specified, `__init__` is not available."
msgstr ""

#: src/class.md:138
msgid "Rules for the `new` method:"
msgstr ""

#: src/class.md:140
msgid ""
"If no method marked with `#[new]` is declared, object instances can only be "
"created from Rust, but not from Python."
msgstr ""

#: src/class.md:142
msgid ""
"The first parameter is the raw object and the custom `new` method must "
"initialize the object with an instance of the struct using `init` method. "
"The type of the object may be the type object of a derived class declared in "
"Python."
msgstr ""

#: src/class.md:145
msgid "The first parameter implicitly has type `&PyRawObject`."
msgstr ""

#: src/class.md:146 src/class.md:383
msgid ""
"For details on `parameter-list`, see the documentation of `Method arguments` "
"section."
msgstr ""

#: src/class.md:147
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`. Usually, `T` will be `MyType`."
msgstr ""

#: src/class.md:150
msgid "Inheritance"
msgstr ""

#: src/class.md:152
msgid ""
"By default `PyObject` is used as default base class. To override default "
"base class `base` parameter for `class` needs to be used. Value is full path "
"to base class. `new` method accepts `PyRawObject` object. `obj` instance "
"must be initialized with value of custom class struct. Subclass must call "
"parent's `new` method."
msgstr ""

#: src/class.md:197
msgid ""
"`ObjectProtocol` trait provides `get_base()` method. It returns reference to "
"instance of base class."
msgstr ""

#: src/class.md:201
msgid "Object properties"
msgstr ""

#: src/class.md:203
msgid ""
"Descriptor methods can be defined in `#[pymethods]` `impl` block only and "
"has to be annotated with `#[getter]` or `[setter]` attributes. i.e."
msgstr ""

#: src/class.md:225
msgid ""
"Getter or setter function's name is used as property name by default. There "
"are several ways how to override name."
msgstr ""

#: src/class.md:228
msgid ""
"If function name starts with `get_` or `set_` for getter or setter "
"respectively. Descriptor name becomes function name with prefix removed. "
"This is useful in case of rust's special keywords like `type`."
msgstr ""

#: src/class.md:256
msgid ""
"In this case property `num` is defined. And it is available from python code "
"as `self.num`."
msgstr ""

#: src/class.md:258
msgid ""
"Also both `#[getter]` and `#[setter]` attributes accepts one parameter. If "
"this parameter is specified, it is used as a property name. i.e."
msgstr ""

#: src/class.md:285
msgid ""
"In this case the property `number` is defined and is available from python "
"code as `self.number`."
msgstr ""

#: src/class.md:287
msgid ""
"For simple cases you can also define getters and setters in your Rust struct "
"field definition, for example:"
msgstr ""

#: src/class.md:299
msgid "Then it is available from Python code as `self.num`."
msgstr ""

#: src/class.md:301
msgid "Instance methods"
msgstr ""

#: src/class.md:303
msgid ""
"To define a python compatible method, `impl` block for struct has to be "
"annotated with the `#[pymethods]` attribute. PyO3 generates python "
"compatible wrappers for all functions in this block with some variations, "
"like descriptors, class method static methods, etc."
msgstr ""

#: src/class.md:329
msgid ""
"Calls to this methods protected by `GIL`, `&self` or `&mut self` can be "
"used. The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:332
msgid ""
"`Python` parameter can be specified as part of method signature, in this "
"case `py` argument get injected by method wrapper. i.e"
msgstr ""

#: src/class.md:352
msgid ""
"From python perspective `method2`, in above example, does not accept any "
"arguments."
msgstr ""

#: src/class.md:354
msgid "Class methods"
msgstr ""

#: src/class.md:356
msgid ""
"To specify a class method for a custom class, the method needs to be "
"annotated with the `#[classmethod]` attribute."
msgstr ""

#: src/class.md:378
msgid "Declares a class method callable from Python."
msgstr ""

#: src/class.md:380
msgid ""
"The first parameter is the type object of the class on which the method is "
"called. This may be the type object of a derived class."
msgstr ""

#: src/class.md:382
msgid "The first parameter implicitly has type `&PyType`."
msgstr ""

#: src/class.md:384
msgid ""
"The return type must be `PyResult<T>` for some `T` that implements "
"`IntoPyObject`."
msgstr ""

#: src/class.md:386
msgid "Static methods"
msgstr ""

#: src/class.md:388
msgid ""
"To specify a static method for a custom class, method needs to be annotated "
"with `#[staticmethod]` attribute. The return type must be `PyResult<T>` for "
"some `T` that implements `IntoPyObject`."
msgstr ""

#: src/class.md:410
msgid "Callable object"
msgstr ""

#: src/class.md:412
msgid ""
"To specify a custom `__call__` method for a custom class, call methods need "
"to be annotated with the `#[call]` attribute. Arguments of the method are "
"specified same as for instance method."
msgstr ""

#: src/class.md:428 src/class.md:471
msgid "\"*\""
msgstr ""

#: src/class.md:430
msgid "\"MyClass has been called\""
msgstr ""

#: src/class.md:436
msgid "Method arguments"
msgstr ""

#: src/class.md:438
msgid ""
"By default PyO3 uses function signatures to determine which arguments are "
"required. Then it scans incoming `args` parameter and then incoming `kwargs` "
"parameter. If it can not find all required parameters, it raises a "
"`TypeError` exception. It is possible to override the default behavior with "
"`#[args(...)]` attribute. `args` attribute accepts a comma separated list of "
"parameters in form of `attr_name=\"default value\"`. Each parameter has to "
"match the method parameter by name."
msgstr ""

#: src/class.md:444
msgid "Each parameter could be one of following type:"
msgstr ""

#: src/class.md:446
msgid ""
"\"\\*\": var arguments separator, each parameter defined after \"\\*\" is "
"keyword only parameters. corresponds to python's `def meth(*, arg1.., "
"arg2=..)`"
msgstr ""

#: src/class.md:448
msgid ""
"args=\"\\*\": \"args\" is var args, corresponds to python's `def "
"meth(*args)`. Type of `args` parameter has to be `&PyTuple`."
msgstr ""

#: src/class.md:450
msgid ""
"kwargs=\"\\*\\*\": \"kwargs\" is keyword arguments, corresponds to python's "
"`def meth(**kwargs)`. Type of `kwargs` parameter has to be `Option<&PyDict>`."
msgstr ""

#: src/class.md:452
msgid ""
"arg=\"Value\": arguments with default value. corresponds to python's `def "
"meth(arg=Value)`. if `arg` argument is defined after var arguments it is "
"treated as keyword argument. Note that `Value` has to be valid rust code, "
"PyO3 just inserts it into generated code unmodified."
msgstr ""

#: src/class.md:457 src/class.md:608
msgid "Example:"
msgstr ""

#: src/class.md:471
msgid "\"**\""
msgstr ""

#: src/class.md:479
msgid "Class customizations"
msgstr ""

#: src/class.md:481
msgid ""
"Python's object model defines several protocols for different object "
"behavior, like sequence, mapping or number protocols. PyO3 defines separate "
"traits for each of them. To provide specific python object behavior you need "
"to implement the specific trait for your struct. Important note, each "
"protocol implementation block has to be annotated with `#[pyproto]` "
"attribute."
msgstr ""

#: src/class.md:486
msgid "Basic object customization"
msgstr ""

#: src/class.md:488
msgid ""
"[`PyObjectProtocol`](https://docs.rs/pyo3/0.6.0-alpha.4/class/basic/trait."
"PyObjectProtocol.html) trait provide several basic customizations."
msgstr ""

#: src/class.md:490
msgid "Attribute access"
msgstr ""

#: src/class.md:492
msgid "To customize object attribute access define following methods:"
msgstr ""

#: src/class.md:494
msgid ""
"`fn __getattr__(&self, name: FromPyObject) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:495
msgid ""
"`fn __setattr__(&mut self, name: FromPyObject, value: FromPyObject) -> "
"PyResult<()>`"
msgstr ""

#: src/class.md:496
msgid "`fn __delattr__(&mut self, name: FromPyObject) -> PyResult<()>`"
msgstr ""

#: src/class.md:498
msgid ""
"Each methods corresponds to python's `self.attr`, `self.attr = value` and "
"`del self.attr` code."
msgstr ""

#: src/class.md:500
msgid "String Conversions"
msgstr ""

#: src/class.md:502
msgid "`fn __repr__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:503
msgid "`fn __str__(&self) -> PyResult<impl ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:505
msgid ""
"Possible return types for `__str__` and `__repr__` are `PyResult<String>` or "
"`PyResult<PyString>`. In Python 2.7, Unicode strings returned by `__str__` "
"and `__repr__` will be converted to byte strings by the Python runtime, "
"which results in an exception if the string contains non-ASCII characters."
msgstr ""

#: src/class.md:509
msgid "`fn __bytes__(&self) -> PyResult<PyBytes>`"
msgstr ""

#: src/class.md:511
msgid ""
"On Python 3.x, provides the conversion to `bytes`. On Python 2.7, "
"`__bytes__` is allowed but has no effect."
msgstr ""

#: src/class.md:514
msgid "`fn __unicode__(&self) -> PyResult<PyUnicode>`"
msgstr ""

#: src/class.md:516
msgid ""
"On Python 2.7, provides the conversion to `unicode`. On Python 3.x, "
"`__unicode__` is allowed but has no effect."
msgstr ""

#: src/class.md:519
msgid ""
"`fn __format__(&self, format_spec: &str) -> PyResult<impl "
"ToPyObject<ObjectType=PyString>>`"
msgstr ""

#: src/class.md:521
msgid ""
"Special method that is used by the `format()` builtin and the `str.format()` "
"method. Possible return types are `PyResult<String>` or `PyResult<PyString>`."
msgstr ""

#: src/class.md:524
msgid "Comparison operators"
msgstr ""

#: src/class.md:526
msgid ""
"`fn __richcmp__(&self, other: impl FromPyObject, op: CompareOp) -> "
"PyResult<impl ToPyObject>`"
msgstr ""

#: src/class.md:528
msgid ""
"Overloads Python comparison operations (`==`, `!=`, `<`, `<=`, `>`, and "
"`>=`). The `op` argument indicates the comparison operation being performed. "
"The return type will normally be `PyResult<bool>`, but any Python object can "
"be returned. If `other` is not of the type specified in the signature, the "
"generated code will automatically `return NotImplemented`."
msgstr ""

#: src/class.md:534
msgid "`fn __hash__(&self) -> PyResult<impl PrimInt>`"
msgstr ""

#: src/class.md:536
msgid ""
"Objects that compare equal must have the same hash value. The return type "
"must be `PyResult<T>` where `T` is one of Rust's primitive integer types."
msgstr ""

#: src/class.md:539
msgid "Other methods"
msgstr ""

#: src/class.md:541
msgid "`fn __bool__(&self) -> PyResult<bool>`"
msgstr ""

#: src/class.md:543
msgid ""
"Determines the \"truthiness\" of the object. This method works for both "
"python 3 and python 2, even on Python 2.7 where the Python spelling was "
"`__nonzero__`."
msgstr ""

#: src/class.md:547
msgid "Garbage Collector Integration"
msgstr ""

#: src/class.md:549
msgid ""
"If your type owns references to other python objects, you will need to "
"integrate with Python's garbage collector so that the GC is aware of those "
"references. To do this, implement [`PyGCProtocol`](https://docs.rs/"
"pyo3/0.6.0-alpha.4/class/gc/trait.PyGCProtocol.html) trait for your struct. "
"It includes two methods `__traverse__` and `__clear__`. These correspond to "
"the slots `tp_traverse` and `tp_clear` in the Python C API. `__traverse__` "
"must call `visit.call()` for each reference to another python object. "
"`__clear__` must clear out any mutable references to other python objects "
"(thus breaking reference cycles). Immutable references do not have to be "
"cleared, as every cycle must contain at least one mutable reference. Example:"
msgstr ""

#: src/class.md:583
msgid "// Release reference, this decrements ref counter.\n"
msgstr ""

#: src/class.md:592
msgid ""
"Special protocol trait implementations have to be annotated with the "
"`#[pyproto]` attribute."
msgstr ""

#: src/class.md:594
msgid ""
"It is also possible to enable GC for custom class using `gc` parameter for "
"`class` annotation. i.e. `#[pyclass(gc)]`. In that case instances of custom "
"class participate in python garbage collector, and it is possible to track "
"them with `gc` module methods."
msgstr ""

#: src/class.md:598
msgid "Iterator Types"
msgstr ""

#: src/class.md:600
msgid ""
"Iterators can be defined using the [`PyIterProtocol`](https://docs.rs/"
"pyo3/0.6.0-alpha.4/class/iter/trait.PyIterProtocol.html) trait. It includes "
"two methods `__iter__` and `__next__`:"
msgstr ""

#: src/class.md:603
msgid "`fn __iter__(slf: PyRefMut<Self>) -> PyResult<impl IntoPyObject>`"
msgstr ""

#: src/class.md:604
msgid ""
"`fn __next__(slf: PyRefMut<Self>) -> PyResult<Option<impl IntoPyObject>>`"
msgstr ""

#: src/class.md:606
msgid ""
"Returning `Ok(None)` from `__next__` indicates that that there are no "
"further items."
msgstr ""

#: src/class.md:632
msgid "Manually implementing pyclass"
msgstr ""

#: src/class.md:634
msgid ""
"TODO: Which traits to implement (basically `PyTypeCreate: PyObjectAlloc + "
"PyTypeInfo + PyMethodsProtocol + Sized`) and what they mean."
msgstr ""

#: src/class.md:636
msgid "How methods are implemented"
msgstr ""

#: src/class.md:638
msgid ""
"Users should be able to define a `#[pyclass]` with or without "
"`#[pymethods]`, while PyO3 needs a trait with a function that returns all "
"methods. Since it's impossible to make the code generation in pyclass "
"dependent on whether there is an impl block, we'd need to implement the "
"trait on `#[pyclass]` and override the implementation in `#[pymethods]`, "
"which is to the best of my knowledge only possible with the specialization "
"feature, which can't be used on stable."
msgstr ""

#: src/class.md:644
msgid ""
"To escape this we use [inventory](https://github.com/dtolnay/inventory), "
"which allows us to collect `impl`s from arbitrary source code by exploiting "
"some binary trick. See [inventory: how it works](https://github.com/dtolnay/"
"inventory#how-it-works) and `pyo3_derive_backend::py_class::impl_inventory` "
"for more details."
msgstr ""
