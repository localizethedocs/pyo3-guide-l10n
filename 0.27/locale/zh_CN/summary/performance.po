msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:41:54Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/performance.md:1
msgid "Performance"
msgstr ""

#: src/performance.md:3
msgid ""
"To achieve the best possible performance, it is useful to be aware of "
"several tricks and sharp edges concerning PyO3's API."
msgstr ""

#: src/performance.md:5
msgid "`extract` versus `cast`"
msgstr ""

#: src/performance.md:7
msgid ""
"Pythonic API implemented using PyO3 are often polymorphic, i.e. they will "
"accept `&Bound<'_, PyAny>` and try to turn this into multiple more concrete "
"types to which the requested operation is applied. This often leads to "
"chains of calls to `extract`, e.g."
msgstr ""

#: src/performance.md:29 src/performance.md:51
msgid "\"Cannot frobnicate that type.\""
msgstr ""

#: src/performance.md:34
msgid ""
"This suboptimal as the `FromPyObject<T>` trait requires `extract` to have a "
"`Result<T, PyErr>` return type. For native types like `PyList`, it faster to "
"use `cast` (which `extract` calls internally) when the error value is "
"ignored. This avoids the costly conversion of a `PyDowncastError` to a "
"`PyErr` required to fulfil the `FromPyObject` contract, i.e."
msgstr ""

#: src/performance.md:45
msgid ""
"// Use `cast` instead of `extract` as turning `PyDowncastError` into `PyErr` "
"is quite costly.\n"
msgstr ""

#: src/performance.md:56
msgid "Access to Bound implies access to Python token"
msgstr ""

#: src/performance.md:58
msgid ""
"Calling `Python::attach` is effectively a no-op when we're already attached "
"to the interpreter, but checking that this is the case still has a cost. If "
"an existing Python token can not be accessed, for example when implementing "
"a pre-existing trait, but a Python-bound reference is available, this cost "
"can be avoided by exploiting that access to Python-bound reference gives "
"zero-cost access to a Python token via `Bound::py`."
msgstr ""

#: src/performance.md:60
msgid "For example, instead of writing"
msgstr ""

#: src/performance.md:81
msgid "use the more efficient"
msgstr ""

#: src/performance.md:92
msgid "// Access to `&Bound<'py, PyAny>` implies access to `Python<'py>`.\n"
msgstr ""

#: src/performance.md:100
msgid "Calling Python callables (`__call__`)"
msgstr ""

#: src/performance.md:102
msgid ""
"CPython support multiple calling protocols: [`tp_call`](https://docs.python."
"org/3/c-api/call.html#the-tp-call-protocol) and [`vectorcall`](https://docs."
"python.org/3/c-api/call.html#the-vectorcall-protocol). [`vectorcall`]"
"(https://docs.python.org/3/c-api/call.html#the-vectorcall-protocol) is a "
"more efficient protocol unlocking faster calls. PyO3 will try to dispatch "
"Python `call`s using the [`vectorcall`](https://docs.python.org/3/c-api/call."
"html#the-vectorcall-protocol) calling convention to archive maximum "
"performance if possible and falling back to [`tp_call`](https://docs.python."
"org/3/c-api/call.html#the-tp-call-protocol) otherwise. This is implemented "
"using the (internal) `PyCallArgs` trait. It defines how Rust types can be "
"used as Python `call` arguments. This trait is currently implemented for"
msgstr ""

#: src/performance.md:106
msgid "Rust tuples, where each member implements `IntoPyObject`,"
msgstr ""

#: src/performance.md:107
msgid "`Bound<'_, PyTuple>`"
msgstr ""

#: src/performance.md:108
msgid "`Py<PyTuple>`"
msgstr ""

#: src/performance.md:110
msgid ""
"Rust tuples may make use of [`vectorcall`](https://docs.python.org/3/c-api/"
"call.html#the-vectorcall-protocol) where as `Bound<'_, PyTuple>` and "
"`Py<PyTuple>` can only use [`tp_call`](https://docs.python.org/3/c-api/call."
"html#the-tp-call-protocol). For maximum performance prefer using Rust tuples "
"as arguments."
msgstr ""

#: src/performance.md:115
msgid "Detach from the interpreter for long-running Rust-only work"
msgstr ""

#: src/performance.md:117
msgid ""
"When executing Rust code which does not need to interact with the Python "
"interpreter, use [`Python::detach`](https://pyo3.rs/main/doc/pyo3/marker/"
"struct.Python.html#method.detach) to allow the Python interpreter to proceed "
"without waiting for the current thread."
msgstr ""

#: src/performance.md:119
msgid ""
"On the GIL-enabled build, this is crucial for best performance as only a "
"single thread may ever be attached at a time."
msgstr ""

#: src/performance.md:121
msgid ""
"On the free-threaded build, this is still best practice as there are several "
"\"stop the world\" events (such as garbage collection) where all threads "
"attached to the Python interpreter are forced to wait."
msgstr ""

#: src/performance.md:123
msgid ""
"As a rule of thumb, attaching and detaching from the Python interpreter "
"takes less than a millisecond, so any work which is expected to take "
"multiple milliseconds can likely benefit from detaching from the interpreter."
msgstr ""

#: src/performance.md:127
msgid "Disable the global reference pool"
msgstr ""

#: src/performance.md:129
msgid ""
"PyO3 uses global mutable state to keep track of deferred reference count "
"updates implied by `impl<T> Drop for Py<T>` being called without being "
"attached to the interpreter. The necessary synchronization to obtain and "
"apply these reference count updates when PyO3-based code next attaches to "
"the interpreter is somewhat expensive and can become a significant part of "
"the cost of crossing the Python-Rust boundary."
msgstr ""

#: src/performance.md:131
msgid ""
"This functionality can be avoided by setting the "
"`pyo3_disable_reference_pool` conditional compilation flag. This removes the "
"global reference pool and the associated costs completely. However, it does "
"_not_ remove the `Drop` implementation for `Py<T>` which is necessary to "
"interoperate with existing Rust code written without PyO3-based code in "
"mind. To stay compatible with the wider Rust ecosystem in these cases, we "
"keep the implementation but abort when `Drop` is called without being "
"attached to the interpreter. If `pyo3_leak_on_drop_without_reference_pool` "
"is additionally enabled, objects dropped without being attached to Python "
"will be leaked instead which is always sound but might have determinal "
"effects like resource exhaustion in the long term."
msgstr ""

#: src/performance.md:133
msgid ""
"This limitation is important to keep in mind when this setting is used, "
"especially when embedding Python code into a Rust application as it is quite "
"easy to accidentally drop a `Py<T>` (or types containing it like `PyErr`, "
"`PyBackedStr` or `PyBackedBytes`) returned from `Python::attach` without "
"making sure to re-attach beforehand. For example, the following code"
msgstr ""

#: src/performance.md:149
msgid "will abort if the list not explicitly disposed via"
msgstr ""
