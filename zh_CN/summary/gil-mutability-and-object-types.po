msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:33:35Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/types.md:1
msgid "GIL lifetimes, mutability and Python object types"
msgstr ""

#: src/types.md:3
msgid ""
"On first glance, PyO3 provides a huge number of different types that can be "
"used to wrap or refer to Python objects.  This page delves into the details "
"and gives an overview of their intended meaning, with examples when each "
"type is best used."
msgstr ""

#: src/types.md:9
msgid "The Python GIL, mutability, and Rust types"
msgstr ""

#: src/types.md:11
msgid ""
"Since Python has no concept of ownership, and works solely with boxed "
"objects, any Python object can be referenced any number of times, and "
"mutation is allowed from any reference."
msgstr ""

#: src/types.md:15
msgid ""
"The situation is helped a little by the Global Interpreter Lock (GIL), which "
"ensures that only one thread can use the Python interpreter and its API at "
"the same time, while non-Python operations (system calls and extension code) "
"can unlock the GIL.  (See [the section on parallelism](parallelism.md) for "
"how to do that in PyO3.)"
msgstr ""

#: src/types.md:21
msgid ""
"In PyO3, holding the GIL is modeled by acquiring a token of the type "
"`Python<'py>`, which serves three purposes:"
msgstr ""

#: src/types.md:24
msgid ""
"It provides some global API for the Python interpreter, such as [`eval`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method.eval)."
msgstr ""

#: src/types.md:26
msgid ""
"It can be passed to functions that require a proof of holding the GIL, such "
"as [`Py::clone_ref`](https://pyo3.rs/main/doc/pyo3/struct.Py.html#method."
"clone_ref)."
msgstr ""

#: src/types.md:28
msgid ""
"Its lifetime can be used to create Rust references that implicitly guarantee "
"holding the GIL, such as [`&'py PyAny`](https://pyo3.rs/main/doc/pyo3/types/"
"struct.PyAny.html)."
msgstr ""

#: src/types.md:31
msgid ""
"The latter two points are the reason why some APIs in PyO3 require the `py: "
"Python` argument, while others don't."
msgstr ""

#: src/types.md:34
msgid ""
"The PyO3 API for Python objects is written such that instead of requiring a "
"mutable Rust reference for mutating operations such as [`PyList::append`]"
"(https://pyo3.rs/main/doc/pyo3/types/struct.PyList.html#method.append), a "
"shared reference (which, in turn, can only be created through `Python<'_>` "
"with a GIL lifetime) is sufficient."
msgstr ""

#: src/types.md:39
msgid ""
"However, Rust structs wrapped as Python objects (called `pyclass` types) "
"usually _do_ need `&mut` access.  Due to the GIL, PyO3 _can_ guarantee "
"thread-safe access to them, but it cannot statically guarantee uniqueness of "
"`&mut` references once an object's ownership has been passed to the Python "
"interpreter, ensuring references is done at runtime using `PyCell`, a scheme "
"very similar to `std::cell::RefCell`."
msgstr ""

#: src/types.md:46
msgid "Accessing the Python GIL"
msgstr ""

#: src/types.md:48
msgid ""
"To get hold of a `Python<'py>` token to prove the GIL is held, consult "
"[PyO3's documentation](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#obtaining-a-python-token)."
msgstr ""

#: src/types.md:50
msgid "Object types"
msgstr ""

#: src/types.md:52
msgid "[`PyAny`](https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html)"
msgstr ""

#: src/types.md:54
msgid ""
"**Represents:** a Python object of unspecified type, restricted to a GIL "
"lifetime.  Currently, `PyAny` can only ever occur as a reference, `&PyAny`."
msgstr ""

#: src/types.md:57
msgid ""
"**Used:** Whenever you want to refer to some Python object and will have the "
"GIL for the whole duration you need to access that object. For example, "
"intermediate values and arguments to `pyfunction`s or `pymethod`s "
"implemented in Rust where any type is allowed."
msgstr ""

#: src/types.md:62
msgid ""
"Many general methods for interacting with Python objects are on the `PyAny` "
"struct, such as `getattr`, `setattr`, and `.call`."
msgstr ""

#: src/types.md:65 src/types.md:130 src/types.md:168 src/types.md:235
msgid "**Conversions:**"
msgstr ""

#: src/types.md:67
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"Python-native type such as a list:"
msgstr ""

#: src/types.md:75
msgid "// To &PyList with PyAny::downcast\n"
msgstr ""

#: src/types.md:78 src/types.md:98 src/types.md:185
msgid "// To Py<PyAny> (aka PyObject) with .into()\n"
msgstr ""

#: src/types.md:81
msgid "// To Py<PyList> with PyAny::extract\n"
msgstr ""

#: src/types.md:88
msgid ""
"For a `&PyAny` object reference `any` where the underlying object is a "
"`#[pyclass]`:"
msgstr ""

#: src/types.md:95
msgid "// To &PyCell<MyClass> with PyAny::downcast\n"
msgstr ""

#: src/types.md:101
msgid "// To Py<MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:104
msgid "// To MyClass with PyAny::extract, if MyClass: Clone\n"
msgstr ""

#: src/types.md:107
msgid "// To PyRef<'_, MyClass> or PyRefMut<'_, MyClass> with PyAny::extract\n"
msgstr ""

#: src/types.md:115
msgid "`PyTuple`, `PyDict`, and many more"
msgstr ""

#: src/types.md:117
msgid ""
"**Represents:** a native Python object of known type, restricted to a GIL "
"lifetime just like `PyAny`."
msgstr ""

#: src/types.md:120
msgid ""
"**Used:** Whenever you want to operate with native Python types while "
"holding the GIL.  Like `PyAny`, this is the most convenient form to use for "
"function arguments and intermediate values."
msgstr ""

#: src/types.md:124
msgid ""
"These types all implement `Deref<Target = PyAny>`, so they all expose the "
"same methods which can be found on `PyAny`."
msgstr ""

#: src/types.md:127
msgid ""
"To see all Python types exposed by `PyO3` you should consult the [`pyo3::"
"types`](https://pyo3.rs/main/doc/pyo3/types/index.html) module."
msgstr ""

#: src/types.md:137
msgid ""
"// Use methods from PyAny on all Python types with Deref implementation\n"
msgstr ""

#: src/types.md:140 src/types.md:267
msgid "// To &PyAny automatically with Deref implementation\n"
msgstr ""

#: src/types.md:143 src/types.md:270
msgid "// To &PyAny explicitly with .as_ref()\n"
msgstr ""

#: src/types.md:146
msgid "// To Py<T> with .into() or Py::from()\n"
msgstr ""

#: src/types.md:149
msgid "// To PyObject with .into() or .to_object(py)\n"
msgstr ""

#: src/types.md:156
msgid "`Py<T>` and `PyObject`"
msgstr ""

#: src/types.md:158
msgid ""
"**Represents:** a GIL-independent reference to a Python object. This can be "
"a Python native type (like `PyTuple`), or a `pyclass` type implemented in "
"Rust. The most commonly-used variant, `Py<PyAny>`, is also known as "
"`PyObject`."
msgstr ""

#: src/types.md:162
msgid ""
"**Used:** Whenever you want to carry around references to a Python object "
"without caring about a GIL lifetime.  For example, storing Python object "
"references in a Rust struct that outlives the Python-Rust FFI boundary, or "
"returning objects from functions implemented in Rust back to Python."
msgstr ""

#: src/types.md:166
msgid "Can be cloned using Python reference counts with `.clone()`."
msgstr ""

#: src/types.md:170
msgid "For a `Py<PyList>`, the conversions are as below:"
msgstr ""

#: src/types.md:177
msgid "// To &PyList with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:181
msgid ""
"// Because `.into_ref()` will consume `list`.\n"
"// To &PyList with Py::into_ref() (moves the pointer into PyO3's object "
"storage)\n"
msgstr ""

#: src/types.md:191
msgid ""
"For a `#[pyclass] struct MyClass`, the conversions for `Py<MyClass>` are "
"below:"
msgstr ""

#: src/types.md:199
msgid "// To &PyCell<MyClass> with Py::as_ref() (borrows from the Py)\n"
msgstr ""

#: src/types.md:203
msgid ""
"// Because `.into_ref()` will consume `my_class`.\n"
"// To &PyCell<MyClass> with Py::into_ref() (moves the pointer into PyO3's "
"object storage)\n"
msgstr ""

#: src/types.md:207
msgid "// To Py<PyAny> (aka PyObject) with .into_py(py)\n"
msgstr ""

#: src/types.md:211
msgid "// To PyRef<'_, MyClass> with Py::borrow or Py::try_borrow\n"
msgstr ""

#: src/types.md:214
msgid "// To PyRefMut<'_, MyClass> with Py::borrow_mut or Py::try_borrow_mut\n"
msgstr ""

#: src/types.md:222
msgid "`PyCell<SomeType>`"
msgstr ""

#: src/types.md:224
msgid ""
"**Represents:** a reference to a Rust object (instance of `PyClass`) which "
"is wrapped in a Python object.  The cell part is an analog to stdlib's "
"[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) to allow "
"access to `&mut` references."
msgstr ""

#: src/types.md:228
msgid ""
"**Used:** for accessing pure-Rust API of the instance (members and functions "
"taking `&SomeType` or `&mut SomeType`) while maintaining the aliasing rules "
"of Rust references."
msgstr ""

#: src/types.md:232
msgid ""
"Like PyO3's Python native types, `PyCell<T>` implements `Deref<Target = "
"PyAny>`, so it also exposes all of the methods on `PyAny`."
msgstr ""

#: src/types.md:237
msgid ""
"`PyCell<T>` can be used to access `&T` and `&mut T` via `PyRef<T>` and "
"`PyRefMut<T>` respectively."
msgstr ""

#: src/types.md:244
msgid "// To PyRef<T> with .borrow() or .try_borrow()\n"
msgstr ""

#: src/types.md:249
msgid "// To PyRefMut<T> with .borrow_mut() or .try_borrow_mut()\n"
msgstr ""

#: src/types.md:257
msgid "`PyCell<T>` can also be accessed like a Python-native type."
msgstr ""

#: src/types.md:264
msgid "// Use methods from PyAny on PyCell<T> with Deref implementation\n"
msgstr ""

#: src/types.md:277
msgid "`PyRef<SomeType>` and `PyRefMut<SomeType>`"
msgstr ""

#: src/types.md:279
msgid ""
"**Represents:** reference wrapper types employed by `PyCell` to keep track "
"of borrows, analog to `Ref` and `RefMut` used by `RefCell`."
msgstr ""

#: src/types.md:282
msgid ""
"**Used:** while borrowing a `PyCell`.  They can also be used with `."
"extract()` on types like `Py<T>` and `PyAny` to get a reference quickly."
msgstr ""

#: src/types.md:286
msgid "Related traits and types"
msgstr ""

#: src/types.md:288
msgid "`PyClass`"
msgstr ""

#: src/types.md:290
msgid ""
"This trait marks structs defined in Rust that are also usable as Python "
"classes, usually defined using the `#[pyclass]` macro."
msgstr ""

#: src/types.md:293
msgid "`PyNativeType`"
msgstr ""

#: src/types.md:295
msgid ""
"This trait marks structs that mirror native Python types, such as `PyList`."
msgstr ""
