msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:34:09Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/parallelism.md:1
msgid "Parallelism"
msgstr "平行化"

#: src/parallelism.md:3
msgid ""
"CPython has the infamous [Global Interpreter Lock](https://docs.python.org/3/"
"glossary.html#term-global-interpreter-lock), which prevents several threads "
"from executing Python bytecode in parallel. This makes threading in Python a "
"bad fit for [CPU-bound](https://stackoverflow.com/questions/868568/) tasks "
"and often forces developers to accept the overhead of multiprocessing."
msgstr ""

#: src/parallelism.md:5
msgid ""
"In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a "
"look at our [word-count](https://github.com/PyO3/pyo3/blob/main/examples/"
"word-count/src/lib.rs) example, where we have a `search` function that "
"utilizes the [rayon](https://github.com/rayon-rs/rayon) crate to count words "
"in parallel."
msgstr ""

#: src/parallelism.md:9
msgid "// These traits let us use `par_lines` and `map`.\n"
msgstr "// 這些特徵讓我們可以使用 `par_lines` 和 `map`。\n"

#: src/parallelism.md:13
msgid "/// Count the occurrences of needle in line, case insensitive\n"
msgstr "/// 計算某行中 needle 出現次數，不區分大小寫\n"

#: src/parallelism.md:17 src/parallelism.md:39 src/parallelism.md:59
msgid "' '"
msgstr ""

#: src/parallelism.md:34
msgid ""
"But let's assume you have a long running Rust function which you would like "
"to execute several times in parallel. For the sake of example let's take a "
"sequential version of the word count:"
msgstr ""
"假設你有一個耗時的 Rust 函式，想要平行執行多次。以下以字數統計的序列版作為範"
"例："

#: src/parallelism.md:52
msgid ""
"To enable parallel execution of this function, the [`Python::allow_threads`]"
"(https://pyo3.rs/main/doc/pyo3/marker/struct.Python.html#method."
"allow_threads) method can be used to temporarily release the GIL, thus "
"allowing other Python threads to run. We then have a function exposed to the "
"Python runtime which calls `search_sequential` inside a closure passed to "
"[`Python::allow_threads`](https://pyo3.rs/main/doc/pyo3/marker/struct.Python."
"html#method.allow_threads) to enable true parallelism:"
msgstr ""

#: src/parallelism.md:76
msgid ""
"Now Python threads can use more than one CPU core, resolving the limitation "
"which usually makes multi-threading in Python only good for IO-bound tasks:"
msgstr ""
"現在 Python 執行緒可使用多個 CPU 核心，解決了 Python 多執行緒通常只適合 I/O-"
"bound 任務的限制："

#: src/parallelism.md:93
msgid "Benchmark"
msgstr "基準測試"

#: src/parallelism.md:95
msgid ""
"Let's benchmark the `word-count` example to verify that we really did unlock "
"parallelism with PyO3."
msgstr "讓我們對 `word-count` 範例做基準測試，確認 PyO3 確實解鎖了平行化。"

#: src/parallelism.md:97
msgid "We are using `pytest-benchmark` to benchmark four word count functions:"
msgstr "我們使用 `pytest-benchmark` 來測試四個字數統計函式："

#: src/parallelism.md:99
msgid "Pure Python version"
msgstr "純 Python 版本"

#: src/parallelism.md:100
msgid "Rust parallel version"
msgstr "Rust 平行版本"

#: src/parallelism.md:101
msgid "Rust sequential version"
msgstr "Rust 序列版本"

#: src/parallelism.md:102
msgid "Rust sequential version executed twice with two Python threads"
msgstr "Rust 序列版本在兩個 Python 執行緒中執行兩次"

#: src/parallelism.md:104
msgid ""
"The benchmark script can be found [here](https://github.com/PyO3/pyo3/blob/"
"main/examples/word-count/tests/test_word_count.py), and we can run `nox` in "
"the `word-count` folder to benchmark these functions."
msgstr ""
"基準測試腳本在[這裡](https://github.com/PyO3/pyo3/blob/main/examples/word-"
"count/tests/test_word_count.py)，我們可在 `word-count` 資料夾中執行 `nox` 進"
"行測試。"

#: src/parallelism.md:106
msgid ""
"While the results of the benchmark of course depend on your machine, the "
"relative results should be similar to this (mid 2020):"
msgstr "雖然基準測試結果會因機器而異，但相對結果應與下圖（2020 年中）相近："

#: src/parallelism.md:118
msgid ""
"You can see that the Python threaded version is not much slower than the "
"Rust sequential version, which means compared to an execution on a single "
"CPU core the speed has doubled."
msgstr ""
"可以看到 Python 執行緒版本沒有比 Rust 序列版本慢太多，這代表相較於單一 CPU 核"
"心的執行，速度翻倍。"
