msgid ""
msgstr ""
"Project-Id-Version: PyO3 user guide\n"
"POT-Creation-Date: 2025-12-16T11:34:09Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/python-from-rust/function-calls.md:1
msgid "Calling Python functions"
msgstr ""

#: src/python-from-rust/function-calls.md:3
msgid ""
"The `Bound<'py, T>` smart pointer (such as `Bound<'py, PyAny>`, `Bound<'py, "
"PyList>`, or `Bound<'py, MyClass>`) can be used to call Python functions."
msgstr ""

#: src/python-from-rust/function-calls.md:5
msgid "PyO3 offers two APIs to make function calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:7
msgid ""
"[`call`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call) - call any callable Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:8
msgid ""
"[`call_method`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call_method) - call a method on the Python object."
msgstr ""

#: src/python-from-rust/function-calls.md:10
msgid ""
"Both of these APIs take `args` and `kwargs` arguments (for positional and "
"keyword arguments respectively). There are variants for less complex calls:"
msgstr ""

#: src/python-from-rust/function-calls.md:12
msgid ""
"[`call1`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call1) and [`call_method1`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method1) to call only with "
"positional `args`."
msgstr ""

#: src/python-from-rust/function-calls.md:13
msgid ""
"[`call0`](https://pyo3.rs/main/doc/pyo3/types/trait.PyAnyMethods."
"html#tymethod.call0) and [`call_method0`](https://pyo3.rs/main/doc/pyo3/"
"types/trait.PyAnyMethods.html#tymethod.call_method0) to call with no "
"arguments."
msgstr ""

#: src/python-from-rust/function-calls.md:15
msgid ""
"For convenience the [`Py<T>`](../types.md#pyt-and-pyobject) smart pointer "
"also exposes these same six API methods, but needs a `Python` token as an "
"additional first argument to prove the GIL is held."
msgstr ""

#: src/python-from-rust/function-calls.md:17
msgid ""
"The example below calls a Python function behind a `PyObject` (aka "
"`Py<PyAny>`) reference:"
msgstr ""

#: src/python-from-rust/function-calls.md:24
msgid "\"arg1\""
msgstr ""

#: src/python-from-rust/function-calls.md:25
msgid "\"arg2\""
msgstr ""

#: src/python-from-rust/function-calls.md:26
msgid "\"arg3\""
msgstr ""

#: src/python-from-rust/function-calls.md:31
#: src/python-from-rust/function-calls.md:77
msgid ""
"\"def example(*args, **kwargs):\n"
"                if args != ():\n"
"                    print('called with args', args)\n"
"                if kwargs != {}:\n"
"                    print('called with kwargs', kwargs)\n"
"                if args == () and kwargs == {}:\n"
"                    print('called with no arguments')\""
msgstr ""

#: src/python-from-rust/function-calls.md:38
#: src/python-from-rust/function-calls.md:39
#: src/python-from-rust/function-calls.md:84
#: src/python-from-rust/function-calls.md:85
msgid "\"\""
msgstr ""

#: src/python-from-rust/function-calls.md:41
#: src/python-from-rust/function-calls.md:87
msgid "\"example\""
msgstr ""

#: src/python-from-rust/function-calls.md:44
msgid "// call object without any arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:47
msgid "// pass object with Rust tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:51
msgid "// call object with Python tuple of positional arguments\n"
msgstr ""

#: src/python-from-rust/function-calls.md:59
msgid "Creating keyword arguments"
msgstr ""

#: src/python-from-rust/function-calls.md:61
msgid ""
"For the `call` and `call_method` APIs, `kwargs` are `Option<&Bound<'py, "
"PyDict>>`, so can either be `None` or `Some(&dict)`. You can use the "
"[`IntoPyDict`](https://pyo3.rs/main/doc/pyo3/types/trait.IntoPyDict.html) "
"trait to convert other dict-like containers, e.g. `HashMap` or `BTreeMap`, "
"as well as tuples with up to 10 elements and `Vec`s where each element is a "
"two-element tuple."
msgstr ""

#: src/python-from-rust/function-calls.md:69
msgid "\"key1\""
msgstr ""

#: src/python-from-rust/function-calls.md:71
msgid "\"key2\""
msgstr ""

#: src/python-from-rust/function-calls.md:90
msgid "// call object with PyDict\n"
msgstr ""

#: src/python-from-rust/function-calls.md:94
msgid "// pass arguments as Vec\n"
msgstr ""

#: src/python-from-rust/function-calls.md:98
msgid "// pass arguments as HashMap\n"
msgstr ""

#: src/python-from-rust/function-calls.md:110
msgid ""
"During PyO3's [migration from \"GIL Refs\" to the `Bound<T>` smart pointer]"
"(../migration.md#migrating-from-the-gil-refs-api-to-boundt), [`Py<T>::call`]"
"(https://pyo3.rs/main/doc/pyo3/struct.Py.html#method.call) is temporarily "
"named `call_bound` (and `call_method` is temporarily `call_method_bound`)."
msgstr ""

#: src/python-from-rust/function-calls.md:112
msgid ""
"(This temporary naming is only the case for the `Py<T>` smart pointer. The "
"methods on the `&PyAny` GIL Ref such as `call` have not been given "
"replacements, and the methods on the `Bound<PyAny>` smart pointer such as "
"[`Bound<PyAny>::call`](https://pyo3.rs/main/doc/pyo3/types/trait."
"PyAnyMethods.html#tymethod.call) already use follow the newest API "
"conventions.)"
msgstr ""
